(()=>{var __webpack_modules__={473:module=>{eval("(function __HLS_WORKER_BUNDLE__(__IN_WORKER__){\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  function ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var o = Object.getOwnPropertySymbols(e);\n      r && (o = o.filter(function (r) {\n        return Object.getOwnPropertyDescriptor(e, r).enumerable;\n      })), t.push.apply(t, o);\n    }\n    return t;\n  }\n  function _objectSpread2(e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = null != arguments[r] ? arguments[r] : {};\n      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n        _defineProperty(e, r, t[r]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n      });\n    }\n    return e;\n  }\n  function _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n      var i = e.call(t, r || \"default\");\n      if (\"object\" != typeof i) return i;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n  }\n  function _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : String(i);\n  }\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n  }\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n      writable: false\n    });\n    return Constructor;\n  }\n  function _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n  }\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  function _construct(Parent, args, Class) {\n    if (_isNativeReflectConstruct()) {\n      _construct = Reflect.construct.bind();\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n    return _construct.apply(null, arguments);\n  }\n  function _isNativeFunction(fn) {\n    try {\n      return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n    } catch (e) {\n      return typeof fn === \"function\";\n    }\n  }\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n        _cache.set(Class, Wrapper);\n      }\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n      }\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf(Wrapper, Class);\n    };\n    return _wrapNativeSuper(Class);\n  }\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n  }\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n  function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function getDefaultExportFromCjs (x) {\n  \treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n  }\n\n  var urlToolkit = {exports: {}};\n\n  (function (module, exports) {\n  \t// see https://tools.ietf.org/html/rfc1808\n\n  \t(function (root) {\n  \t  var URL_REGEX =\n  \t    /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n  \t  var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n  \t  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n  \t  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n  \t  var URLToolkit = {\n  \t    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n  \t    // E.g\n  \t    // With opts.alwaysNormalize = false (default, spec compliant)\n  \t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n  \t    // With opts.alwaysNormalize = true (not spec compliant)\n  \t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n  \t    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n  \t      opts = opts || {};\n  \t      // remove any remaining space and CRLF\n  \t      baseURL = baseURL.trim();\n  \t      relativeURL = relativeURL.trim();\n  \t      if (!relativeURL) {\n  \t        // 2a) If the embedded URL is entirely empty, it inherits the\n  \t        // entire base URL (i.e., is set equal to the base URL)\n  \t        // and we are done.\n  \t        if (!opts.alwaysNormalize) {\n  \t          return baseURL;\n  \t        }\n  \t        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n  \t        if (!basePartsForNormalise) {\n  \t          throw new Error('Error trying to parse base URL.');\n  \t        }\n  \t        basePartsForNormalise.path = URLToolkit.normalizePath(\n  \t          basePartsForNormalise.path\n  \t        );\n  \t        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n  \t      }\n  \t      var relativeParts = URLToolkit.parseURL(relativeURL);\n  \t      if (!relativeParts) {\n  \t        throw new Error('Error trying to parse relative URL.');\n  \t      }\n  \t      if (relativeParts.scheme) {\n  \t        // 2b) If the embedded URL starts with a scheme name, it is\n  \t        // interpreted as an absolute URL and we are done.\n  \t        if (!opts.alwaysNormalize) {\n  \t          return relativeURL;\n  \t        }\n  \t        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n  \t        return URLToolkit.buildURLFromParts(relativeParts);\n  \t      }\n  \t      var baseParts = URLToolkit.parseURL(baseURL);\n  \t      if (!baseParts) {\n  \t        throw new Error('Error trying to parse base URL.');\n  \t      }\n  \t      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n  \t        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n  \t        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n  \t        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n  \t        baseParts.netLoc = pathParts[1];\n  \t        baseParts.path = pathParts[2];\n  \t      }\n  \t      if (baseParts.netLoc && !baseParts.path) {\n  \t        baseParts.path = '/';\n  \t      }\n  \t      var builtParts = {\n  \t        // 2c) Otherwise, the embedded URL inherits the scheme of\n  \t        // the base URL.\n  \t        scheme: baseParts.scheme,\n  \t        netLoc: relativeParts.netLoc,\n  \t        path: null,\n  \t        params: relativeParts.params,\n  \t        query: relativeParts.query,\n  \t        fragment: relativeParts.fragment,\n  \t      };\n  \t      if (!relativeParts.netLoc) {\n  \t        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n  \t        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n  \t        // (if any) of the base URL.\n  \t        builtParts.netLoc = baseParts.netLoc;\n  \t        // 4) If the embedded URL path is preceded by a slash \"/\", the\n  \t        // path is not relative and we skip to Step 7.\n  \t        if (relativeParts.path[0] !== '/') {\n  \t          if (!relativeParts.path) {\n  \t            // 5) If the embedded URL path is empty (and not preceded by a\n  \t            // slash), then the embedded URL inherits the base URL path\n  \t            builtParts.path = baseParts.path;\n  \t            // 5a) if the embedded URL's <params> is non-empty, we skip to\n  \t            // step 7; otherwise, it inherits the <params> of the base\n  \t            // URL (if any) and\n  \t            if (!relativeParts.params) {\n  \t              builtParts.params = baseParts.params;\n  \t              // 5b) if the embedded URL's <query> is non-empty, we skip to\n  \t              // step 7; otherwise, it inherits the <query> of the base\n  \t              // URL (if any) and we skip to step 7.\n  \t              if (!relativeParts.query) {\n  \t                builtParts.query = baseParts.query;\n  \t              }\n  \t            }\n  \t          } else {\n  \t            // 6) The last segment of the base URL's path (anything\n  \t            // following the rightmost slash \"/\", or the entire path if no\n  \t            // slash is present) is removed and the embedded URL's path is\n  \t            // appended in its place.\n  \t            var baseURLPath = baseParts.path;\n  \t            var newPath =\n  \t              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n  \t              relativeParts.path;\n  \t            builtParts.path = URLToolkit.normalizePath(newPath);\n  \t          }\n  \t        }\n  \t      }\n  \t      if (builtParts.path === null) {\n  \t        builtParts.path = opts.alwaysNormalize\n  \t          ? URLToolkit.normalizePath(relativeParts.path)\n  \t          : relativeParts.path;\n  \t      }\n  \t      return URLToolkit.buildURLFromParts(builtParts);\n  \t    },\n  \t    parseURL: function (url) {\n  \t      var parts = URL_REGEX.exec(url);\n  \t      if (!parts) {\n  \t        return null;\n  \t      }\n  \t      return {\n  \t        scheme: parts[1] || '',\n  \t        netLoc: parts[2] || '',\n  \t        path: parts[3] || '',\n  \t        params: parts[4] || '',\n  \t        query: parts[5] || '',\n  \t        fragment: parts[6] || '',\n  \t      };\n  \t    },\n  \t    normalizePath: function (path) {\n  \t      // The following operations are\n  \t      // then applied, in order, to the new path:\n  \t      // 6a) All occurrences of \"./\", where \".\" is a complete path\n  \t      // segment, are removed.\n  \t      // 6b) If the path ends with \".\" as a complete path segment,\n  \t      // that \".\" is removed.\n  \t      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n  \t      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n  \t      // complete path segment not equal to \"..\", are removed.\n  \t      // Removal of these path segments is performed iteratively,\n  \t      // removing the leftmost matching pattern on each iteration,\n  \t      // until no matching pattern remains.\n  \t      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n  \t      // complete path segment not equal to \"..\", that\n  \t      // \"<segment>/..\" is removed.\n  \t      while (\n  \t        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n  \t      ) {}\n  \t      return path.split('').reverse().join('');\n  \t    },\n  \t    buildURLFromParts: function (parts) {\n  \t      return (\n  \t        parts.scheme +\n  \t        parts.netLoc +\n  \t        parts.path +\n  \t        parts.params +\n  \t        parts.query +\n  \t        parts.fragment\n  \t      );\n  \t    },\n  \t  };\n\n  \t  module.exports = URLToolkit;\n  \t})(); \n  } (urlToolkit));\n\n  var urlToolkitExports = urlToolkit.exports;\n\n  // https://caniuse.com/mdn-javascript_builtins_number_isfinite\n  var isFiniteNumber = Number.isFinite || function (value) {\n    return typeof value === 'number' && isFinite(value);\n  };\n\n  // https://caniuse.com/mdn-javascript_builtins_number_issafeinteger\n  var isSafeInteger = Number.isSafeInteger || function (value) {\n    return typeof value === 'number' && Math.abs(value) <= MAX_SAFE_INTEGER;\n  };\n  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n  var Events = /*#__PURE__*/function (Events) {\n    Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n    Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n    Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n    Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n    Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n    Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n    Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n    Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n    Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n    Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n    Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n    Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n    Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n    Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n    Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n    Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n    Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n    Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n    Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n    Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n    Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n    Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n    Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n    Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n    Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n    Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n    Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n    Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n    Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n    Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n    Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n    Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n    Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n    Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n    Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n    Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n    Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n    Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n    Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n    Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n    Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n    Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n    Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n    Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n    Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n    Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n    Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n    Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n    Events[\"MAX_AUTO_LEVEL_UPDATED\"] = \"hlsMaxAutoLevelUpdated\";\n    Events[\"ERROR\"] = \"hlsError\";\n    Events[\"DESTROYING\"] = \"hlsDestroying\";\n    Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n    Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n    Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n    Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n    Events[\"STEERING_MANIFEST_LOADED\"] = \"hlsSteeringManifestLoaded\";\n    return Events;\n  }({});\n\n  /**\n   * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n   */\n\n  var ErrorTypes = /*#__PURE__*/function (ErrorTypes) {\n    ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n    ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n    ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n    ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n    ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n    return ErrorTypes;\n  }({});\n  var ErrorDetails = /*#__PURE__*/function (ErrorDetails) {\n    ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n    ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n    ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n    ErrorDetails[\"KEY_SYSTEM_NO_CONFIGURED_LICENSE\"] = \"keySystemNoConfiguredLicense\";\n    ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n    ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED\"] = \"keySystemServerCertificateRequestFailed\";\n    ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED\"] = \"keySystemServerCertificateUpdateFailed\";\n    ErrorDetails[\"KEY_SYSTEM_SESSION_UPDATE_FAILED\"] = \"keySystemSessionUpdateFailed\";\n    ErrorDetails[\"KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED\"] = \"keySystemStatusOutputRestricted\";\n    ErrorDetails[\"KEY_SYSTEM_STATUS_INTERNAL_ERROR\"] = \"keySystemStatusInternalError\";\n    ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n    ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n    ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n    ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n    ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n    ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n    ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n    ErrorDetails[\"LEVEL_PARSING_ERROR\"] = \"levelParsingError\";\n    ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n    ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n    ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n    ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n    ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n    ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n    ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n    ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n    ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n    ErrorDetails[\"FRAG_GAP\"] = \"fragGap\";\n    ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n    ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n    ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n    ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n    ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n    ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n    ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n    ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n    ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n    ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n    ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n    ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n    ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n    ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n    return ErrorDetails;\n  }({});\n\n  var noop = function noop() {};\n  var fakeLogger = {\n    trace: noop,\n    debug: noop,\n    log: noop,\n    warn: noop,\n    info: noop,\n    error: noop\n  };\n  var exportedLogger = fakeLogger;\n\n  // let lastCallTime;\n  // function formatMsgWithTimeInfo(type, msg) {\n  //   const now = Date.now();\n  //   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n  //   lastCallTime = now;\n  //   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n  //   return msg;\n  // }\n\n  function consolePrintFn(type) {\n    var func = self.console[type];\n    if (func) {\n      return func.bind(self.console, \"[\" + type + \"] >\");\n    }\n    return noop;\n  }\n  function exportLoggerFunctions(debugConfig) {\n    for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      functions[_key - 1] = arguments[_key];\n    }\n    functions.forEach(function (type) {\n      exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n    });\n  }\n  function enableLogs(debugConfig, id) {\n    // check that console is available\n    if (typeof console === 'object' && debugConfig === true || typeof debugConfig === 'object') {\n      exportLoggerFunctions(debugConfig,\n      // Remove out from list here to hard-disable a log-level\n      // 'trace',\n      'debug', 'log', 'info', 'warn', 'error');\n      // Some browsers don't allow to use bind on console object anyway\n      // fallback to default if needed\n      try {\n        exportedLogger.log(\"Debug logs enabled for \\\"\" + id + \"\\\" in hls.js version \" + \"1.5.17\");\n      } catch (e) {\n        exportedLogger = fakeLogger;\n      }\n    } else {\n      exportedLogger = fakeLogger;\n    }\n  }\n  var logger = exportedLogger;\n\n  var DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\n  var ATTR_LIST_REGEX = /(.+?)=(\".*?\"|.*?)(?:,|$)/g;\n\n  // adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\n  var AttrList = /*#__PURE__*/function () {\n    function AttrList(attrs) {\n      if (typeof attrs === 'string') {\n        attrs = AttrList.parseAttrList(attrs);\n      }\n      _extends(this, attrs);\n    }\n    var _proto = AttrList.prototype;\n    _proto.decimalInteger = function decimalInteger(attrName) {\n      var intValue = parseInt(this[attrName], 10);\n      if (intValue > Number.MAX_SAFE_INTEGER) {\n        return Infinity;\n      }\n      return intValue;\n    };\n    _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {\n      if (this[attrName]) {\n        var stringValue = (this[attrName] || '0x').slice(2);\n        stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n        var value = new Uint8Array(stringValue.length / 2);\n        for (var i = 0; i < stringValue.length / 2; i++) {\n          value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n        }\n        return value;\n      } else {\n        return null;\n      }\n    };\n    _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {\n      var intValue = parseInt(this[attrName], 16);\n      if (intValue > Number.MAX_SAFE_INTEGER) {\n        return Infinity;\n      }\n      return intValue;\n    };\n    _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {\n      return parseFloat(this[attrName]);\n    };\n    _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {\n      var value = this[attrName];\n      return value ? parseFloat(value) : defaultValue;\n    };\n    _proto.enumeratedString = function enumeratedString(attrName) {\n      return this[attrName];\n    };\n    _proto.bool = function bool(attrName) {\n      return this[attrName] === 'YES';\n    };\n    _proto.decimalResolution = function decimalResolution(attrName) {\n      var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n      if (res === null) {\n        return undefined;\n      }\n      return {\n        width: parseInt(res[1], 10),\n        height: parseInt(res[2], 10)\n      };\n    };\n    AttrList.parseAttrList = function parseAttrList(input) {\n      var match;\n      var attrs = {};\n      var quote = '\"';\n      ATTR_LIST_REGEX.lastIndex = 0;\n      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n        var value = match[2];\n        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n          value = value.slice(1, -1);\n        }\n        var name = match[1].trim();\n        attrs[name] = value;\n      }\n      return attrs;\n    };\n    _createClass(AttrList, [{\n      key: \"clientAttrs\",\n      get: function get() {\n        return Object.keys(this).filter(function (attr) {\n          return attr.substring(0, 2) === 'X-';\n        });\n      }\n    }]);\n    return AttrList;\n  }();\n\n  // Avoid exporting const enum so that these values can be inlined\n\n  function isDateRangeCueAttribute(attrName) {\n    return attrName !== \"ID\" && attrName !== \"CLASS\" && attrName !== \"START-DATE\" && attrName !== \"DURATION\" && attrName !== \"END-DATE\" && attrName !== \"END-ON-NEXT\";\n  }\n  function isSCTE35Attribute(attrName) {\n    return attrName === \"SCTE35-OUT\" || attrName === \"SCTE35-IN\";\n  }\n  var DateRange = /*#__PURE__*/function () {\n    function DateRange(dateRangeAttr, dateRangeWithSameId) {\n      this.attr = void 0;\n      this._startDate = void 0;\n      this._endDate = void 0;\n      this._badValueForSameId = void 0;\n      if (dateRangeWithSameId) {\n        var previousAttr = dateRangeWithSameId.attr;\n        for (var key in previousAttr) {\n          if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n            logger.warn(\"DATERANGE tag attribute: \\\"\" + key + \"\\\" does not match for tags with ID: \\\"\" + dateRangeAttr.ID + \"\\\"\");\n            this._badValueForSameId = key;\n            break;\n          }\n        }\n        // Merge DateRange tags with the same ID\n        dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);\n      }\n      this.attr = dateRangeAttr;\n      this._startDate = new Date(dateRangeAttr[\"START-DATE\"]);\n      if (\"END-DATE\" in this.attr) {\n        var endDate = new Date(this.attr[\"END-DATE\"]);\n        if (isFiniteNumber(endDate.getTime())) {\n          this._endDate = endDate;\n        }\n      }\n    }\n    _createClass(DateRange, [{\n      key: \"id\",\n      get: function get() {\n        return this.attr.ID;\n      }\n    }, {\n      key: \"class\",\n      get: function get() {\n        return this.attr.CLASS;\n      }\n    }, {\n      key: \"startDate\",\n      get: function get() {\n        return this._startDate;\n      }\n    }, {\n      key: \"endDate\",\n      get: function get() {\n        if (this._endDate) {\n          return this._endDate;\n        }\n        var duration = this.duration;\n        if (duration !== null) {\n          return new Date(this._startDate.getTime() + duration * 1000);\n        }\n        return null;\n      }\n    }, {\n      key: \"duration\",\n      get: function get() {\n        if (\"DURATION\" in this.attr) {\n          var duration = this.attr.decimalFloatingPoint(\"DURATION\");\n          if (isFiniteNumber(duration)) {\n            return duration;\n          }\n        } else if (this._endDate) {\n          return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n        }\n        return null;\n      }\n    }, {\n      key: \"plannedDuration\",\n      get: function get() {\n        if (\"PLANNED-DURATION\" in this.attr) {\n          return this.attr.decimalFloatingPoint(\"PLANNED-DURATION\");\n        }\n        return null;\n      }\n    }, {\n      key: \"endOnNext\",\n      get: function get() {\n        return this.attr.bool(\"END-ON-NEXT\");\n      }\n    }, {\n      key: \"isValid\",\n      get: function get() {\n        return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);\n      }\n    }]);\n    return DateRange;\n  }();\n\n  var LoadStats = function LoadStats() {\n    this.aborted = false;\n    this.loaded = 0;\n    this.retry = 0;\n    this.total = 0;\n    this.chunkCount = 0;\n    this.bwEstimate = 0;\n    this.loading = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n    this.parsing = {\n      start: 0,\n      end: 0\n    };\n    this.buffering = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n  };\n\n  var ElementaryStreamTypes = {\n    AUDIO: \"audio\",\n    VIDEO: \"video\",\n    AUDIOVIDEO: \"audiovideo\"\n  };\n  var BaseSegment = /*#__PURE__*/function () {\n    function BaseSegment(baseurl) {\n      var _this$elementaryStrea;\n      this._byteRange = null;\n      this._url = null;\n      // baseurl is the URL to the playlist\n      this.baseurl = void 0;\n      // relurl is the portion of the URL that comes from inside the playlist.\n      this.relurl = void 0;\n      // Holds the types of data this fragment supports\n      this.elementaryStreams = (_this$elementaryStrea = {}, _this$elementaryStrea[ElementaryStreamTypes.AUDIO] = null, _this$elementaryStrea[ElementaryStreamTypes.VIDEO] = null, _this$elementaryStrea[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$elementaryStrea);\n      this.baseurl = baseurl;\n    }\n\n    // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n    var _proto = BaseSegment.prototype;\n    _proto.setByteRange = function setByteRange(value, previous) {\n      var params = value.split('@', 2);\n      var start;\n      if (params.length === 1) {\n        start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;\n      } else {\n        start = parseInt(params[1]);\n      }\n      this._byteRange = [start, parseInt(params[0]) + start];\n    };\n    _createClass(BaseSegment, [{\n      key: \"byteRange\",\n      get: function get() {\n        if (!this._byteRange) {\n          return [];\n        }\n        return this._byteRange;\n      }\n    }, {\n      key: \"byteRangeStartOffset\",\n      get: function get() {\n        return this.byteRange[0];\n      }\n    }, {\n      key: \"byteRangeEndOffset\",\n      get: function get() {\n        return this.byteRange[1];\n      }\n    }, {\n      key: \"url\",\n      get: function get() {\n        if (!this._url && this.baseurl && this.relurl) {\n          this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {\n            alwaysNormalize: true\n          });\n        }\n        return this._url || '';\n      },\n      set: function set(value) {\n        this._url = value;\n      }\n    }]);\n    return BaseSegment;\n  }();\n\n  /**\n   * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\n   */\n  var Fragment = /*#__PURE__*/function (_BaseSegment) {\n    _inheritsLoose(Fragment, _BaseSegment);\n    function Fragment(type, baseurl) {\n      var _this;\n      _this = _BaseSegment.call(this, baseurl) || this;\n      _this._decryptdata = null;\n      _this.rawProgramDateTime = null;\n      _this.programDateTime = null;\n      _this.tagList = [];\n      // EXTINF has to be present for a m3u8 to be considered valid\n      _this.duration = 0;\n      // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n      _this.sn = 0;\n      // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n      // core difference from the private field _decryptdata is the lack of the initialized IV\n      // _decryptdata will set the IV for this segment based on the segment number in the fragment\n      _this.levelkeys = void 0;\n      // A string representing the fragment type\n      _this.type = void 0;\n      // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n      _this.loader = null;\n      // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n      _this.keyLoader = null;\n      // The level/track index to which the fragment belongs\n      _this.level = -1;\n      // The continuity counter of the fragment\n      _this.cc = 0;\n      // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n      _this.startPTS = void 0;\n      // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n      _this.endPTS = void 0;\n      // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n      _this.startDTS = void 0;\n      // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n      _this.endDTS = void 0;\n      // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n      _this.start = 0;\n      // Set by `updateFragPTSDTS` in level-helper\n      _this.deltaPTS = void 0;\n      // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n      _this.maxStartPTS = void 0;\n      // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n      _this.minEndPTS = void 0;\n      // Load/parse timing information\n      _this.stats = new LoadStats();\n      // Init Segment bytes (unset for media segments)\n      _this.data = void 0;\n      // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n      _this.bitrateTest = false;\n      // #EXTINF  segment title\n      _this.title = null;\n      // The Media Initialization Section for this segment\n      _this.initSegment = null;\n      // Fragment is the last fragment in the media playlist\n      _this.endList = void 0;\n      // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\n      _this.gap = void 0;\n      // Deprecated\n      _this.urlId = 0;\n      _this.type = type;\n      return _this;\n    }\n    var _proto2 = Fragment.prototype;\n    _proto2.setKeyFormat = function setKeyFormat(keyFormat) {\n      if (this.levelkeys) {\n        var _key = this.levelkeys[keyFormat];\n        if (_key && !this._decryptdata) {\n          this._decryptdata = _key.getDecryptData(this.sn);\n        }\n      }\n    };\n    _proto2.abortRequests = function abortRequests() {\n      var _this$loader, _this$keyLoader;\n      (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();\n      (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();\n    };\n    _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {\n      if (partial === void 0) {\n        partial = false;\n      }\n      var elementaryStreams = this.elementaryStreams;\n      var info = elementaryStreams[type];\n      if (!info) {\n        elementaryStreams[type] = {\n          startPTS: startPTS,\n          endPTS: endPTS,\n          startDTS: startDTS,\n          endDTS: endDTS,\n          partial: partial\n        };\n        return;\n      }\n      info.startPTS = Math.min(info.startPTS, startPTS);\n      info.endPTS = Math.max(info.endPTS, endPTS);\n      info.startDTS = Math.min(info.startDTS, startDTS);\n      info.endDTS = Math.max(info.endDTS, endDTS);\n    };\n    _proto2.clearElementaryStreamInfo = function clearElementaryStreamInfo() {\n      var elementaryStreams = this.elementaryStreams;\n      elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n      elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n      elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n    };\n    _createClass(Fragment, [{\n      key: \"decryptdata\",\n      get: function get() {\n        var levelkeys = this.levelkeys;\n        if (!levelkeys && !this._decryptdata) {\n          return null;\n        }\n        if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\n          var _key2 = this.levelkeys.identity;\n          if (_key2) {\n            this._decryptdata = _key2.getDecryptData(this.sn);\n          } else {\n            var keyFormats = Object.keys(this.levelkeys);\n            if (keyFormats.length === 1) {\n              return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);\n            }\n          }\n        }\n        return this._decryptdata;\n      }\n    }, {\n      key: \"end\",\n      get: function get() {\n        return this.start + this.duration;\n      }\n    }, {\n      key: \"endProgramDateTime\",\n      get: function get() {\n        if (this.programDateTime === null) {\n          return null;\n        }\n        if (!isFiniteNumber(this.programDateTime)) {\n          return null;\n        }\n        var duration = !isFiniteNumber(this.duration) ? 0 : this.duration;\n        return this.programDateTime + duration * 1000;\n      }\n    }, {\n      key: \"encrypted\",\n      get: function get() {\n        var _this$_decryptdata;\n        // At the m3u8-parser level we need to add support for manifest signalled keyformats\n        // when we want the fragment to start reporting that it is encrypted.\n        // Currently, keyFormat will only be set for identity keys\n        if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {\n          return true;\n        } else if (this.levelkeys) {\n          var keyFormats = Object.keys(this.levelkeys);\n          var len = keyFormats.length;\n          if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }]);\n    return Fragment;\n  }(BaseSegment);\n\n  /**\n   * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\n   */\n  var Part = /*#__PURE__*/function (_BaseSegment2) {\n    _inheritsLoose(Part, _BaseSegment2);\n    function Part(partAttrs, frag, baseurl, index, previous) {\n      var _this2;\n      _this2 = _BaseSegment2.call(this, baseurl) || this;\n      _this2.fragOffset = 0;\n      _this2.duration = 0;\n      _this2.gap = false;\n      _this2.independent = false;\n      _this2.relurl = void 0;\n      _this2.fragment = void 0;\n      _this2.index = void 0;\n      _this2.stats = new LoadStats();\n      _this2.duration = partAttrs.decimalFloatingPoint('DURATION');\n      _this2.gap = partAttrs.bool('GAP');\n      _this2.independent = partAttrs.bool('INDEPENDENT');\n      _this2.relurl = partAttrs.enumeratedString('URI');\n      _this2.fragment = frag;\n      _this2.index = index;\n      var byteRange = partAttrs.enumeratedString('BYTERANGE');\n      if (byteRange) {\n        _this2.setByteRange(byteRange, previous);\n      }\n      if (previous) {\n        _this2.fragOffset = previous.fragOffset + previous.duration;\n      }\n      return _this2;\n    }\n    _createClass(Part, [{\n      key: \"start\",\n      get: function get() {\n        return this.fragment.start + this.fragOffset;\n      }\n    }, {\n      key: \"end\",\n      get: function get() {\n        return this.start + this.duration;\n      }\n    }, {\n      key: \"loaded\",\n      get: function get() {\n        var elementaryStreams = this.elementaryStreams;\n        return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n      }\n    }]);\n    return Part;\n  }(BaseSegment);\n\n  var DEFAULT_TARGET_DURATION = 10;\n\n  /**\n   * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.\n   */\n  var LevelDetails = /*#__PURE__*/function () {\n    function LevelDetails(baseUrl) {\n      this.PTSKnown = false;\n      this.alignedSliding = false;\n      this.averagetargetduration = void 0;\n      this.endCC = 0;\n      this.endSN = 0;\n      this.fragments = void 0;\n      this.fragmentHint = void 0;\n      this.partList = null;\n      this.dateRanges = void 0;\n      this.live = true;\n      this.ageHeader = 0;\n      this.advancedDateTime = void 0;\n      this.updated = true;\n      this.advanced = true;\n      this.availabilityDelay = void 0;\n      // Manifest reload synchronization\n      this.misses = 0;\n      this.startCC = 0;\n      this.startSN = 0;\n      this.startTimeOffset = null;\n      this.targetduration = 0;\n      this.totalduration = 0;\n      this.type = null;\n      this.url = void 0;\n      this.m3u8 = '';\n      this.version = null;\n      this.canBlockReload = false;\n      this.canSkipUntil = 0;\n      this.canSkipDateRanges = false;\n      this.skippedSegments = 0;\n      this.recentlyRemovedDateranges = void 0;\n      this.partHoldBack = 0;\n      this.holdBack = 0;\n      this.partTarget = 0;\n      this.preloadHint = void 0;\n      this.renditionReports = void 0;\n      this.tuneInGoal = 0;\n      this.deltaUpdateFailed = void 0;\n      this.driftStartTime = 0;\n      this.driftEndTime = 0;\n      this.driftStart = 0;\n      this.driftEnd = 0;\n      this.encryptedFragments = void 0;\n      this.playlistParsingError = null;\n      this.variableList = null;\n      this.hasVariableRefs = false;\n      this.fragments = [];\n      this.encryptedFragments = [];\n      this.dateRanges = {};\n      this.url = baseUrl;\n    }\n    var _proto = LevelDetails.prototype;\n    _proto.reloaded = function reloaded(previous) {\n      if (!previous) {\n        this.advanced = true;\n        this.updated = true;\n        return;\n      }\n      var partSnDiff = this.lastPartSn - previous.lastPartSn;\n      var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n      this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;\n      this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n      if (this.updated || this.advanced) {\n        this.misses = Math.floor(previous.misses * 0.6);\n      } else {\n        this.misses = previous.misses + 1;\n      }\n      this.availabilityDelay = previous.availabilityDelay;\n    };\n    _createClass(LevelDetails, [{\n      key: \"hasProgramDateTime\",\n      get: function get() {\n        if (this.fragments.length) {\n          return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);\n        }\n        return false;\n      }\n    }, {\n      key: \"levelTargetDuration\",\n      get: function get() {\n        return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n      }\n    }, {\n      key: \"drift\",\n      get: function get() {\n        var runTime = this.driftEndTime - this.driftStartTime;\n        if (runTime > 0) {\n          var runDuration = this.driftEnd - this.driftStart;\n          return runDuration * 1000 / runTime;\n        }\n        return 1;\n      }\n    }, {\n      key: \"edge\",\n      get: function get() {\n        return this.partEnd || this.fragmentEnd;\n      }\n    }, {\n      key: \"partEnd\",\n      get: function get() {\n        var _this$partList;\n        if ((_this$partList = this.partList) != null && _this$partList.length) {\n          return this.partList[this.partList.length - 1].end;\n        }\n        return this.fragmentEnd;\n      }\n    }, {\n      key: \"fragmentEnd\",\n      get: function get() {\n        var _this$fragments;\n        if ((_this$fragments = this.fragments) != null && _this$fragments.length) {\n          return this.fragments[this.fragments.length - 1].end;\n        }\n        return 0;\n      }\n    }, {\n      key: \"age\",\n      get: function get() {\n        if (this.advancedDateTime) {\n          return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n        }\n        return 0;\n      }\n    }, {\n      key: \"lastPartIndex\",\n      get: function get() {\n        var _this$partList2;\n        if ((_this$partList2 = this.partList) != null && _this$partList2.length) {\n          return this.partList[this.partList.length - 1].index;\n        }\n        return -1;\n      }\n    }, {\n      key: \"lastPartSn\",\n      get: function get() {\n        var _this$partList3;\n        if ((_this$partList3 = this.partList) != null && _this$partList3.length) {\n          return this.partList[this.partList.length - 1].fragment.sn;\n        }\n        return this.endSN;\n      }\n    }]);\n    return LevelDetails;\n  }();\n\n  function base64Decode(base64encodedStr) {\n    return Uint8Array.from(atob(base64encodedStr), function (c) {\n      return c.charCodeAt(0);\n    });\n  }\n\n  function getKeyIdBytes(str) {\n    var keyIdbytes = strToUtf8array(str).subarray(0, 16);\n    var paddedkeyIdbytes = new Uint8Array(16);\n    paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);\n    return paddedkeyIdbytes;\n  }\n  function changeEndianness(keyId) {\n    var swap = function swap(array, from, to) {\n      var cur = array[from];\n      array[from] = array[to];\n      array[to] = cur;\n    };\n    swap(keyId, 0, 3);\n    swap(keyId, 1, 2);\n    swap(keyId, 4, 5);\n    swap(keyId, 6, 7);\n  }\n  function convertDataUriToArrayBytes(uri) {\n    // data:[<media type][;attribute=value][;base64],<data>\n    var colonsplit = uri.split(':');\n    var keydata = null;\n    if (colonsplit[0] === 'data' && colonsplit.length === 2) {\n      var semicolonsplit = colonsplit[1].split(';');\n      var commasplit = semicolonsplit[semicolonsplit.length - 1].split(',');\n      if (commasplit.length === 2) {\n        var isbase64 = commasplit[0] === 'base64';\n        var data = commasplit[1];\n        if (isbase64) {\n          semicolonsplit.splice(-1, 1); // remove from processing\n          keydata = base64Decode(data);\n        } else {\n          keydata = getKeyIdBytes(data);\n        }\n      }\n    }\n    return keydata;\n  }\n  function strToUtf8array(str) {\n    return Uint8Array.from(unescape(encodeURIComponent(str)), function (c) {\n      return c.charCodeAt(0);\n    });\n  }\n\n  /** returns `undefined` is `self` is missing, e.g. in node */\n  var optionalSelf = typeof self !== 'undefined' ? self : undefined;\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess\n   */\n  var KeySystems = {\n    CLEARKEY: \"org.w3.clearkey\",\n    FAIRPLAY: \"com.apple.fps\",\n    PLAYREADY: \"com.microsoft.playready\",\n    WIDEVINE: \"com.widevine.alpha\"\n  };\n\n  // Playlist #EXT-X-KEY KEYFORMAT values\n  var KeySystemFormats = {\n    CLEARKEY: \"org.w3.clearkey\",\n    FAIRPLAY: \"com.apple.streamingkeydelivery\",\n    PLAYREADY: \"com.microsoft.playready\",\n    WIDEVINE: \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\"\n  };\n  function keySystemFormatToKeySystemDomain(format) {\n    switch (format) {\n      case KeySystemFormats.FAIRPLAY:\n        return KeySystems.FAIRPLAY;\n      case KeySystemFormats.PLAYREADY:\n        return KeySystems.PLAYREADY;\n      case KeySystemFormats.WIDEVINE:\n        return KeySystems.WIDEVINE;\n      case KeySystemFormats.CLEARKEY:\n        return KeySystems.CLEARKEY;\n    }\n  }\n\n  // System IDs for which we can extract a key ID from \"encrypted\" event PSSH\n  var KeySystemIds = {\n    CENC: \"1077efecc0b24d02ace33c1e52e2fb4b\",\n    CLEARKEY: \"e2719d58a985b3c9781ab030af78d30e\",\n    FAIRPLAY: \"94ce86fb07ff4f43adb893d2fa968ca2\",\n    PLAYREADY: \"9a04f07998404286ab92e65be0885f95\",\n    WIDEVINE: \"edef8ba979d64acea3c827dcd51d21ed\"\n  };\n  function keySystemIdToKeySystemDomain(systemId) {\n    if (systemId === KeySystemIds.WIDEVINE) {\n      return KeySystems.WIDEVINE;\n    } else if (systemId === KeySystemIds.PLAYREADY) {\n      return KeySystems.PLAYREADY;\n    } else if (systemId === KeySystemIds.CENC || systemId === KeySystemIds.CLEARKEY) {\n      return KeySystems.CLEARKEY;\n    }\n  }\n  function keySystemDomainToKeySystemFormat(keySystem) {\n    switch (keySystem) {\n      case KeySystems.FAIRPLAY:\n        return KeySystemFormats.FAIRPLAY;\n      case KeySystems.PLAYREADY:\n        return KeySystemFormats.PLAYREADY;\n      case KeySystems.WIDEVINE:\n        return KeySystemFormats.WIDEVINE;\n      case KeySystems.CLEARKEY:\n        return KeySystemFormats.CLEARKEY;\n    }\n  }\n  function getKeySystemsForConfig(config) {\n    var drmSystems = config.drmSystems,\n      widevineLicenseUrl = config.widevineLicenseUrl;\n    var keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter(function (keySystem) {\n      return !!drmSystems[keySystem];\n    }) : [];\n    if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {\n      keySystemsToAttempt.push(KeySystems.WIDEVINE);\n    }\n    return keySystemsToAttempt;\n  }\n  var requestMediaKeySystemAccess = function (_optionalSelf$navigat) {\n    if (optionalSelf != null && (_optionalSelf$navigat = optionalSelf.navigator) != null && _optionalSelf$navigat.requestMediaKeySystemAccess) {\n      return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);\n    } else {\n      return null;\n    }\n  }();\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration\n   */\n  function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {\n    var initDataTypes;\n    switch (keySystem) {\n      case KeySystems.FAIRPLAY:\n        initDataTypes = ['cenc', 'sinf'];\n        break;\n      case KeySystems.WIDEVINE:\n      case KeySystems.PLAYREADY:\n        initDataTypes = ['cenc'];\n        break;\n      case KeySystems.CLEARKEY:\n        initDataTypes = ['cenc', 'keyids'];\n        break;\n      default:\n        throw new Error(\"Unknown key-system: \" + keySystem);\n    }\n    return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);\n  }\n  function createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {\n    var baseConfig = {\n      initDataTypes: initDataTypes,\n      persistentState: drmSystemOptions.persistentState || 'optional',\n      distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || 'optional',\n      sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || 'temporary'],\n      audioCapabilities: audioCodecs.map(function (codec) {\n        return {\n          contentType: \"audio/mp4; codecs=\\\"\" + codec + \"\\\"\",\n          robustness: drmSystemOptions.audioRobustness || '',\n          encryptionScheme: drmSystemOptions.audioEncryptionScheme || null\n        };\n      }),\n      videoCapabilities: videoCodecs.map(function (codec) {\n        return {\n          contentType: \"video/mp4; codecs=\\\"\" + codec + \"\\\"\",\n          robustness: drmSystemOptions.videoRobustness || '',\n          encryptionScheme: drmSystemOptions.videoEncryptionScheme || null\n        };\n      })\n    };\n    return [baseConfig];\n  }\n\n  function sliceUint8(array, start, end) {\n    // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\n    // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\n    return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));\n  }\n\n  // breaking up those two types in order to clarify what is happening in the decoding path.\n\n  /**\n   * Returns true if an ID3 header can be found at offset in data\n   * @param data - The data to search\n   * @param offset - The offset at which to start searching\n   */\n  var isHeader$2 = function isHeader(data, offset) {\n    /*\n     * http://id3.org/id3v2.3.0\n     * [0]     = 'I'\n     * [1]     = 'D'\n     * [2]     = '3'\n     * [3,4]   = {Version}\n     * [5]     = {Flags}\n     * [6-9]   = {ID3 Size}\n     *\n     * An ID3v2 tag can be detected with the following pattern:\n     *  $49 44 33 yy yy xx zz zz zz zz\n     * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n     */\n    if (offset + 10 <= data.length) {\n      // look for 'ID3' identifier\n      if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n        // check version is within range\n        if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n          // check size is within range\n          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Returns true if an ID3 footer can be found at offset in data\n   * @param data - The data to search\n   * @param offset - The offset at which to start searching\n   */\n  var isFooter = function isFooter(data, offset) {\n    /*\n     * The footer is a copy of the header, but with a different identifier\n     */\n    if (offset + 10 <= data.length) {\n      // look for '3DI' identifier\n      if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n        // check version is within range\n        if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n          // check size is within range\n          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n   * @param data - The data to search in\n   * @param offset - The offset at which to start searching\n   * @returns the block of data containing any ID3 tags found\n   * or *undefined* if no header is found at the starting offset\n   */\n  var getID3Data = function getID3Data(data, offset) {\n    var front = offset;\n    var length = 0;\n    while (isHeader$2(data, offset)) {\n      // ID3 header is 10 bytes\n      length += 10;\n      var size = readSize(data, offset + 6);\n      length += size;\n      if (isFooter(data, offset + 10)) {\n        // ID3 footer is 10 bytes\n        length += 10;\n      }\n      offset += length;\n    }\n    if (length > 0) {\n      return data.subarray(front, front + length);\n    }\n    return undefined;\n  };\n  var readSize = function readSize(data, offset) {\n    var size = 0;\n    size = (data[offset] & 0x7f) << 21;\n    size |= (data[offset + 1] & 0x7f) << 14;\n    size |= (data[offset + 2] & 0x7f) << 7;\n    size |= data[offset + 3] & 0x7f;\n    return size;\n  };\n  var canParse$2 = function canParse(data, offset) {\n    return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;\n  };\n\n  /**\n   * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n   * @param data - Block of data containing one or more ID3 tags\n   */\n  var getTimeStamp = function getTimeStamp(data) {\n    var frames = getID3Frames(data);\n    for (var i = 0; i < frames.length; i++) {\n      var frame = frames[i];\n      if (isTimeStampFrame(frame)) {\n        return readTimeStamp(frame);\n      }\n    }\n    return undefined;\n  };\n\n  /**\n   * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n   */\n  var isTimeStampFrame = function isTimeStampFrame(frame) {\n    return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';\n  };\n  var getFrameData = function getFrameData(data) {\n    /*\n    Frame ID       $xx xx xx xx (four characters)\n    Size           $xx xx xx xx\n    Flags          $xx xx\n    */\n    var type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n    var size = readSize(data, 4);\n\n    // skip frame id, size, and flags\n    var offset = 10;\n    return {\n      type: type,\n      size: size,\n      data: data.subarray(offset, offset + size)\n    };\n  };\n\n  /**\n   * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n   * @param id3Data - The ID3 data containing one or more ID3 tags\n   */\n  var getID3Frames = function getID3Frames(id3Data) {\n    var offset = 0;\n    var frames = [];\n    while (isHeader$2(id3Data, offset)) {\n      var size = readSize(id3Data, offset + 6);\n      // skip past ID3 header\n      offset += 10;\n      var end = offset + size;\n      // loop through frames in the ID3 tag\n      while (offset + 8 < end) {\n        var frameData = getFrameData(id3Data.subarray(offset));\n        var frame = decodeFrame(frameData);\n        if (frame) {\n          frames.push(frame);\n        }\n\n        // skip frame header and frame data\n        offset += frameData.size + 10;\n      }\n      if (isFooter(id3Data, offset)) {\n        offset += 10;\n      }\n    }\n    return frames;\n  };\n  var decodeFrame = function decodeFrame(frame) {\n    if (frame.type === 'PRIV') {\n      return decodePrivFrame(frame);\n    } else if (frame.type[0] === 'W') {\n      return decodeURLFrame(frame);\n    }\n    return decodeTextFrame(frame);\n  };\n  var decodePrivFrame = function decodePrivFrame(frame) {\n    /*\n    Format: <text string>\\0<binary data>\n    */\n    if (frame.size < 2) {\n      return undefined;\n    }\n    var owner = utf8ArrayToStr(frame.data, true);\n    var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n    return {\n      key: frame.type,\n      info: owner,\n      data: privateData.buffer\n    };\n  };\n  var decodeTextFrame = function decodeTextFrame(frame) {\n    if (frame.size < 2) {\n      return undefined;\n    }\n    if (frame.type === 'TXXX') {\n      /*\n      Format:\n      [0]   = {Text Encoding}\n      [1-?] = {Description}\\0{Value}\n      */\n      var index = 1;\n      var description = utf8ArrayToStr(frame.data.subarray(index), true);\n      index += description.length + 1;\n      var value = utf8ArrayToStr(frame.data.subarray(index));\n      return {\n        key: frame.type,\n        info: description,\n        data: value\n      };\n    }\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Value}\n    */\n    var text = utf8ArrayToStr(frame.data.subarray(1));\n    return {\n      key: frame.type,\n      data: text\n    };\n  };\n  var decodeURLFrame = function decodeURLFrame(frame) {\n    if (frame.type === 'WXXX') {\n      /*\n      Format:\n      [0]   = {Text Encoding}\n      [1-?] = {Description}\\0{URL}\n      */\n      if (frame.size < 2) {\n        return undefined;\n      }\n      var index = 1;\n      var description = utf8ArrayToStr(frame.data.subarray(index), true);\n      index += description.length + 1;\n      var value = utf8ArrayToStr(frame.data.subarray(index));\n      return {\n        key: frame.type,\n        info: description,\n        data: value\n      };\n    }\n    /*\n    Format:\n    [0-?] = {URL}\n    */\n    var url = utf8ArrayToStr(frame.data);\n    return {\n      key: frame.type,\n      data: url\n    };\n  };\n  var readTimeStamp = function readTimeStamp(timeStampFrame) {\n    if (timeStampFrame.data.byteLength === 8) {\n      var data = new Uint8Array(timeStampFrame.data);\n      // timestamp is 33 bit expressed as a big-endian eight-octet number,\n      // with the upper 31 bits set to zero.\n      var pts33Bit = data[3] & 0x1;\n      var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n      timestamp /= 45;\n      if (pts33Bit) {\n        timestamp += 47721858.84;\n      } // 2^32 / 90\n\n      return Math.round(timestamp);\n    }\n    return undefined;\n  };\n\n  // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n  // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n  /* utf.js - UTF-8 <=> UTF-16 convertion\n   *\n   * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n   * Version: 1.0\n   * LastModified: Dec 25 1999\n   * This library is free.  You can redistribute it and/or modify it.\n   */\n  var utf8ArrayToStr = function utf8ArrayToStr(array, exitOnNull) {\n    if (exitOnNull === void 0) {\n      exitOnNull = false;\n    }\n    var decoder = getTextDecoder();\n    if (decoder) {\n      var decoded = decoder.decode(array);\n      if (exitOnNull) {\n        // grab up to the first null\n        var idx = decoded.indexOf('\\0');\n        return idx !== -1 ? decoded.substring(0, idx) : decoded;\n      }\n\n      // remove any null characters\n      return decoded.replace(/\\0/g, '');\n    }\n    var len = array.length;\n    var c;\n    var char2;\n    var char3;\n    var out = '';\n    var i = 0;\n    while (i < len) {\n      c = array[i++];\n      if (c === 0x00 && exitOnNull) {\n        return out;\n      } else if (c === 0x00 || c === 0x03) {\n        // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n        continue;\n      }\n      switch (c >> 4) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n          // 0xxxxxxx\n          out += String.fromCharCode(c);\n          break;\n        case 12:\n        case 13:\n          // 110x xxxx   10xx xxxx\n          char2 = array[i++];\n          out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n          break;\n        case 14:\n          // 1110 xxxx  10xx xxxx  10xx xxxx\n          char2 = array[i++];\n          char3 = array[i++];\n          out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n          break;\n      }\n    }\n    return out;\n  };\n  var decoder;\n  function getTextDecoder() {\n    // On Play Station 4, TextDecoder is defined but partially implemented.\n    // Manual decoding option is preferable\n    if (navigator.userAgent.includes('PlayStation 4')) {\n      return;\n    }\n    if (!decoder && typeof self.TextDecoder !== 'undefined') {\n      decoder = new self.TextDecoder('utf-8');\n    }\n    return decoder;\n  }\n\n  /**\n   *  hex dump helper class\n   */\n\n  var Hex = {\n    hexDump: function hexDump(array) {\n      var str = '';\n      for (var i = 0; i < array.length; i++) {\n        var h = array[i].toString(16);\n        if (h.length < 2) {\n          h = '0' + h;\n        }\n        str += h;\n      }\n      return str;\n    }\n  };\n\n  var UINT32_MAX$1 = Math.pow(2, 32) - 1;\n  var push = [].push;\n\n  // We are using fixed track IDs for driving the MP4 remuxer\n  // instead of following the TS PIDs.\n  // There is no reason not to do this and some browsers/SourceBuffer-demuxers\n  // may not like if there are TrackID \"switches\"\n  // See https://github.com/video-dev/hls.js/issues/1331\n  // Here we are mapping our internal track types to constant MP4 track IDs\n  // With MSE currently one can only have one track of each, and we are muxing\n  // whatever video/audio rendition in them.\n  var RemuxerTrackIdConfig = {\n    video: 1,\n    audio: 2,\n    id3: 3,\n    text: 4\n  };\n  function bin2str(data) {\n    return String.fromCharCode.apply(null, data);\n  }\n  function readUint16(buffer, offset) {\n    var val = buffer[offset] << 8 | buffer[offset + 1];\n    return val < 0 ? 65536 + val : val;\n  }\n  function readUint32(buffer, offset) {\n    var val = readSint32(buffer, offset);\n    return val < 0 ? 4294967296 + val : val;\n  }\n  function readUint64(buffer, offset) {\n    var result = readUint32(buffer, offset);\n    result *= Math.pow(2, 32);\n    result += readUint32(buffer, offset + 4);\n    return result;\n  }\n  function readSint32(buffer, offset) {\n    return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n  }\n  function writeUint32(buffer, offset, value) {\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = value >> 16 & 0xff;\n    buffer[offset + 2] = value >> 8 & 0xff;\n    buffer[offset + 3] = value & 0xff;\n  }\n\n  // Find \"moof\" box\n  function hasMoofData(data) {\n    var end = data.byteLength;\n    for (var i = 0; i < end;) {\n      var size = readUint32(data, i);\n      if (size > 8 && data[i + 4] === 0x6d && data[i + 5] === 0x6f && data[i + 6] === 0x6f && data[i + 7] === 0x66) {\n        return true;\n      }\n      i = size > 1 ? i + size : end;\n    }\n    return false;\n  }\n\n  // Find the data for a box specified by its path\n  function findBox(data, path) {\n    var results = [];\n    if (!path.length) {\n      // short-circuit the search for empty paths\n      return results;\n    }\n    var end = data.byteLength;\n    for (var i = 0; i < end;) {\n      var size = readUint32(data, i);\n      var type = bin2str(data.subarray(i + 4, i + 8));\n      var endbox = size > 1 ? i + size : end;\n      if (type === path[0]) {\n        if (path.length === 1) {\n          // this is the end of the path and we've found the box we were\n          // looking for\n          results.push(data.subarray(i + 8, endbox));\n        } else {\n          // recursively search for the next box along the path\n          var subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n          if (subresults.length) {\n            push.apply(results, subresults);\n          }\n        }\n      }\n      i = endbox;\n    }\n\n    // we've finished searching all of data\n    return results;\n  }\n  function parseSegmentIndex(sidx) {\n    var references = [];\n    var version = sidx[0];\n\n    // set initial offset, we skip the reference ID (not needed)\n    var index = 8;\n    var timescale = readUint32(sidx, index);\n    index += 4;\n    var earliestPresentationTime = 0;\n    var firstOffset = 0;\n    if (version === 0) {\n      earliestPresentationTime = readUint32(sidx, index);\n      firstOffset = readUint32(sidx, index + 4);\n      index += 8;\n    } else {\n      earliestPresentationTime = readUint64(sidx, index);\n      firstOffset = readUint64(sidx, index + 8);\n      index += 16;\n    }\n\n    // skip reserved\n    index += 2;\n    var startByte = sidx.length + firstOffset;\n    var referencesCount = readUint16(sidx, index);\n    index += 2;\n    for (var i = 0; i < referencesCount; i++) {\n      var referenceIndex = index;\n      var referenceInfo = readUint32(sidx, referenceIndex);\n      referenceIndex += 4;\n      var referenceSize = referenceInfo & 0x7fffffff;\n      var referenceType = (referenceInfo & 0x80000000) >>> 31;\n      if (referenceType === 1) {\n        logger.warn('SIDX has hierarchical references (not supported)');\n        return null;\n      }\n      var subsegmentDuration = readUint32(sidx, referenceIndex);\n      referenceIndex += 4;\n      references.push({\n        referenceSize: referenceSize,\n        subsegmentDuration: subsegmentDuration,\n        // unscaled\n        info: {\n          duration: subsegmentDuration / timescale,\n          start: startByte,\n          end: startByte + referenceSize - 1\n        }\n      });\n      startByte += referenceSize;\n\n      // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n      // for |sapDelta|.\n      referenceIndex += 4;\n\n      // skip to next ref\n      index = referenceIndex;\n    }\n    return {\n      earliestPresentationTime: earliestPresentationTime,\n      timescale: timescale,\n      version: version,\n      referencesCount: referencesCount,\n      references: references\n    };\n  }\n\n  /**\n   * Parses an MP4 initialization segment and extracts stream type and\n   * timescale values for any declared tracks. Timescale values indicate the\n   * number of clock ticks per second to assume for time-based values\n   * elsewhere in the MP4.\n   *\n   * To determine the start time of an MP4, you need two pieces of\n   * information: the timescale unit and the earliest base media decode\n   * time. Multiple timescales can be specified within an MP4 but the\n   * base media decode time is always expressed in the timescale from\n   * the media header box for the track:\n   * ```\n   * moov > trak > mdia > mdhd.timescale\n   * moov > trak > mdia > hdlr\n   * ```\n   * @param initSegment the bytes of the init segment\n   * @returns a hash of track type to timescale values or null if\n   * the init segment is malformed.\n   */\n\n  function parseInitSegment(initSegment) {\n    var result = [];\n    var traks = findBox(initSegment, ['moov', 'trak']);\n    for (var i = 0; i < traks.length; i++) {\n      var trak = traks[i];\n      var tkhd = findBox(trak, ['tkhd'])[0];\n      if (tkhd) {\n        var version = tkhd[0];\n        var trackId = readUint32(tkhd, version === 0 ? 12 : 20);\n        var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n        if (mdhd) {\n          version = mdhd[0];\n          var timescale = readUint32(mdhd, version === 0 ? 12 : 20);\n          var hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n          if (hdlr) {\n            var hdlrType = bin2str(hdlr.subarray(8, 12));\n            var type = {\n              soun: ElementaryStreamTypes.AUDIO,\n              vide: ElementaryStreamTypes.VIDEO\n            }[hdlrType];\n            if (type) {\n              // Parse codec details\n              var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n              var stsdData = parseStsd(stsd);\n              result[trackId] = {\n                timescale: timescale,\n                type: type\n              };\n              result[type] = _objectSpread2({\n                timescale: timescale,\n                id: trackId\n              }, stsdData);\n            }\n          }\n        }\n      }\n    }\n    var trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n    trex.forEach(function (trex) {\n      var trackId = readUint32(trex, 4);\n      var track = result[trackId];\n      if (track) {\n        track.default = {\n          duration: readUint32(trex, 12),\n          flags: readUint32(trex, 20)\n        };\n      }\n    });\n    return result;\n  }\n  function parseStsd(stsd) {\n    var sampleEntries = stsd.subarray(8);\n    var sampleEntriesEnd = sampleEntries.subarray(8 + 78);\n    var fourCC = bin2str(sampleEntries.subarray(4, 8));\n    var codec = fourCC;\n    var encrypted = fourCC === 'enca' || fourCC === 'encv';\n    if (encrypted) {\n      var encBox = findBox(sampleEntries, [fourCC])[0];\n      var encBoxChildren = encBox.subarray(fourCC === 'enca' ? 28 : 78);\n      var sinfs = findBox(encBoxChildren, ['sinf']);\n      sinfs.forEach(function (sinf) {\n        var schm = findBox(sinf, ['schm'])[0];\n        if (schm) {\n          var scheme = bin2str(schm.subarray(4, 8));\n          if (scheme === 'cbcs' || scheme === 'cenc') {\n            var frma = findBox(sinf, ['frma'])[0];\n            if (frma) {\n              // for encrypted content codec fourCC will be in frma\n              codec = bin2str(frma);\n            }\n          }\n        }\n      });\n    }\n    switch (codec) {\n      case 'avc1':\n      case 'avc2':\n      case 'avc3':\n      case 'avc4':\n        {\n          // extract profile + compatibility + level out of avcC box\n          var avcCBox = findBox(sampleEntriesEnd, ['avcC'])[0];\n          codec += '.' + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);\n          break;\n        }\n      case 'mp4a':\n        {\n          var codecBox = findBox(sampleEntries, [fourCC])[0];\n          var esdsBox = findBox(codecBox.subarray(28), ['esds'])[0];\n          if (esdsBox && esdsBox.length > 12) {\n            var i = 4;\n            // ES Descriptor tag\n            if (esdsBox[i++] !== 0x03) {\n              break;\n            }\n            i = skipBERInteger(esdsBox, i);\n            i += 2; // skip es_id;\n            var flags = esdsBox[i++];\n            if (flags & 0x80) {\n              i += 2; // skip dependency es_id\n            }\n            if (flags & 0x40) {\n              i += esdsBox[i++]; // skip URL\n            }\n            // Decoder config descriptor\n            if (esdsBox[i++] !== 0x04) {\n              break;\n            }\n            i = skipBERInteger(esdsBox, i);\n            var objectType = esdsBox[i++];\n            if (objectType === 0x40) {\n              codec += '.' + toHex(objectType);\n            } else {\n              break;\n            }\n            i += 12;\n            // Decoder specific info\n            if (esdsBox[i++] !== 0x05) {\n              break;\n            }\n            i = skipBERInteger(esdsBox, i);\n            var firstByte = esdsBox[i++];\n            var audioObjectType = (firstByte & 0xf8) >> 3;\n            if (audioObjectType === 31) {\n              audioObjectType += 1 + ((firstByte & 0x7) << 3) + ((esdsBox[i] & 0xe0) >> 5);\n            }\n            codec += '.' + audioObjectType;\n          }\n          break;\n        }\n      case 'hvc1':\n      case 'hev1':\n        {\n          var hvcCBox = findBox(sampleEntriesEnd, ['hvcC'])[0];\n          var profileByte = hvcCBox[1];\n          var profileSpace = ['', 'A', 'B', 'C'][profileByte >> 6];\n          var generalProfileIdc = profileByte & 0x1f;\n          var profileCompat = readUint32(hvcCBox, 2);\n          var tierFlag = (profileByte & 0x20) >> 5 ? 'H' : 'L';\n          var levelIDC = hvcCBox[12];\n          var constraintIndicator = hvcCBox.subarray(6, 12);\n          codec += '.' + profileSpace + generalProfileIdc;\n          codec += '.' + profileCompat.toString(16).toUpperCase();\n          codec += '.' + tierFlag + levelIDC;\n          var constraintString = '';\n          for (var _i = constraintIndicator.length; _i--;) {\n            var _byte = constraintIndicator[_i];\n            if (_byte || constraintString) {\n              var encodedByte = _byte.toString(16).toUpperCase();\n              constraintString = '.' + encodedByte + constraintString;\n            }\n          }\n          codec += constraintString;\n          break;\n        }\n      case 'dvh1':\n      case 'dvhe':\n        {\n          var dvcCBox = findBox(sampleEntriesEnd, ['dvcC'])[0];\n          var profile = dvcCBox[2] >> 1 & 0x7f;\n          var level = dvcCBox[2] << 5 & 0x20 | dvcCBox[3] >> 3 & 0x1f;\n          codec += '.' + addLeadingZero(profile) + '.' + addLeadingZero(level);\n          break;\n        }\n      case 'vp09':\n        {\n          var vpcCBox = findBox(sampleEntriesEnd, ['vpcC'])[0];\n          var _profile = vpcCBox[4];\n          var _level = vpcCBox[5];\n          var bitDepth = vpcCBox[6] >> 4 & 0x0f;\n          codec += '.' + addLeadingZero(_profile) + '.' + addLeadingZero(_level) + '.' + addLeadingZero(bitDepth);\n          break;\n        }\n      case 'av01':\n        {\n          var av1CBox = findBox(sampleEntriesEnd, ['av1C'])[0];\n          var _profile2 = av1CBox[1] >>> 5;\n          var _level2 = av1CBox[1] & 0x1f;\n          var _tierFlag = av1CBox[2] >>> 7 ? 'H' : 'M';\n          var highBitDepth = (av1CBox[2] & 0x40) >> 6;\n          var twelveBit = (av1CBox[2] & 0x20) >> 5;\n          var _bitDepth = _profile2 === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;\n          var monochrome = (av1CBox[2] & 0x10) >> 4;\n          var chromaSubsamplingX = (av1CBox[2] & 0x08) >> 3;\n          var chromaSubsamplingY = (av1CBox[2] & 0x04) >> 2;\n          var chromaSamplePosition = av1CBox[2] & 0x03;\n          // TODO: parse color_description_present_flag\n          // default it to BT.709/limited range for now\n          // more info https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\n          var colorPrimaries = 1;\n          var transferCharacteristics = 1;\n          var matrixCoefficients = 1;\n          var videoFullRangeFlag = 0;\n          codec += '.' + _profile2 + '.' + addLeadingZero(_level2) + _tierFlag + '.' + addLeadingZero(_bitDepth) + '.' + monochrome + '.' + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + '.' + addLeadingZero(colorPrimaries) + '.' + addLeadingZero(transferCharacteristics) + '.' + addLeadingZero(matrixCoefficients) + '.' + videoFullRangeFlag;\n          break;\n        }\n    }\n    return {\n      codec: codec,\n      encrypted: encrypted\n    };\n  }\n  function skipBERInteger(bytes, i) {\n    var limit = i + 5;\n    while (bytes[i++] & 0x80 && i < limit) {}\n    return i;\n  }\n  function toHex(x) {\n    return ('0' + x.toString(16).toUpperCase()).slice(-2);\n  }\n  function addLeadingZero(num) {\n    return (num < 10 ? '0' : '') + num;\n  }\n  function patchEncyptionData(initSegment, decryptdata) {\n    if (!initSegment || !decryptdata) {\n      return initSegment;\n    }\n    var keyId = decryptdata.keyId;\n    if (keyId && decryptdata.isCommonEncryption) {\n      var traks = findBox(initSegment, ['moov', 'trak']);\n      traks.forEach(function (trak) {\n        var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n        // skip the sample entry count\n        var sampleEntries = stsd.subarray(8);\n        var encBoxes = findBox(sampleEntries, ['enca']);\n        var isAudio = encBoxes.length > 0;\n        if (!isAudio) {\n          encBoxes = findBox(sampleEntries, ['encv']);\n        }\n        encBoxes.forEach(function (enc) {\n          var encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n          var sinfBoxes = findBox(encBoxChildren, ['sinf']);\n          sinfBoxes.forEach(function (sinf) {\n            var tenc = parseSinf(sinf);\n            if (tenc) {\n              // Look for default key id (keyID offset is always 8 within the tenc box):\n              var tencKeyId = tenc.subarray(8, 24);\n              if (!tencKeyId.some(function (b) {\n                return b !== 0;\n              })) {\n                logger.log(\"[eme] Patching keyId in 'enc\" + (isAudio ? 'a' : 'v') + \">sinf>>tenc' box: \" + Hex.hexDump(tencKeyId) + \" -> \" + Hex.hexDump(keyId));\n                tenc.set(keyId, 8);\n              }\n            }\n          });\n        });\n      });\n    }\n    return initSegment;\n  }\n  function parseSinf(sinf) {\n    var schm = findBox(sinf, ['schm'])[0];\n    if (schm) {\n      var scheme = bin2str(schm.subarray(4, 8));\n      if (scheme === 'cbcs' || scheme === 'cenc') {\n        return findBox(sinf, ['schi', 'tenc'])[0];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Determine the base media decode start time, in seconds, for an MP4\n   * fragment. If multiple fragments are specified, the earliest time is\n   * returned.\n   *\n   * The base media decode time can be parsed from track fragment\n   * metadata:\n   * ```\n   * moof > traf > tfdt.baseMediaDecodeTime\n   * ```\n   * It requires the timescale value from the mdhd to interpret.\n   *\n   * @param initData - a hash of track type to timescale values\n   * @param fmp4 - the bytes of the mp4 fragment\n   * @returns the earliest base media decode start time for the\n   * fragment, in seconds\n   */\n  function getStartDTS(initData, fmp4) {\n    // we need info from two children of each track fragment box\n    return findBox(fmp4, ['moof', 'traf']).reduce(function (result, traf) {\n      var tfdt = findBox(traf, ['tfdt'])[0];\n      var version = tfdt[0];\n      var start = findBox(traf, ['tfhd']).reduce(function (result, tfhd) {\n        // get the track id from the tfhd\n        var id = readUint32(tfhd, 4);\n        var track = initData[id];\n        if (track) {\n          var baseTime = readUint32(tfdt, 4);\n          if (version === 1) {\n            // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n            // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n            // https://github.com/video-dev/hls.js/issues/5303\n            if (baseTime === UINT32_MAX$1) {\n              logger.warn(\"[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time\");\n              return result;\n            }\n            baseTime *= UINT32_MAX$1 + 1;\n            baseTime += readUint32(tfdt, 8);\n          }\n          // assume a 90kHz clock if no timescale was specified\n          var scale = track.timescale || 90e3;\n          // convert base time to seconds\n          var startTime = baseTime / scale;\n          if (isFiniteNumber(startTime) && (result === null || startTime < result)) {\n            return startTime;\n          }\n        }\n        return result;\n      }, null);\n      if (start !== null && isFiniteNumber(start) && (result === null || start < result)) {\n        return start;\n      }\n      return result;\n    }, null);\n  }\n\n  /*\n    For Reference:\n    aligned(8) class TrackFragmentHeaderBox\n             extends FullBox(tfhd, 0, tf_flags){\n       unsigned int(32)  track_ID;\n       // all the following are optional fields\n       unsigned int(64)  base_data_offset;\n       unsigned int(32)  sample_description_index;\n       unsigned int(32)  default_sample_duration;\n       unsigned int(32)  default_sample_size;\n       unsigned int(32)  default_sample_flags\n    }\n   */\n  function getDuration(data, initData) {\n    var rawDuration = 0;\n    var videoDuration = 0;\n    var audioDuration = 0;\n    var trafs = findBox(data, ['moof', 'traf']);\n    for (var i = 0; i < trafs.length; i++) {\n      var traf = trafs[i];\n      // There is only one tfhd & trun per traf\n      // This is true for CMAF style content, and we should perhaps check the ftyp\n      // and only look for a single trun then, but for ISOBMFF we should check\n      // for multiple track runs.\n      var tfhd = findBox(traf, ['tfhd'])[0];\n      // get the track id from the tfhd\n      var id = readUint32(tfhd, 4);\n      var track = initData[id];\n      if (!track) {\n        continue;\n      }\n      var trackDefault = track.default;\n      var tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);\n      var sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;\n      if (tfhdFlags & 0x000008) {\n        // 0x000008 indicates the presence of the default_sample_duration field\n        if (tfhdFlags & 0x000002) {\n          // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n          // If present, the default_sample_duration exists at byte offset 12\n          sampleDuration = readUint32(tfhd, 12);\n        } else {\n          // Otherwise, the duration is at byte offset 8\n          sampleDuration = readUint32(tfhd, 8);\n        }\n      }\n      // assume a 90kHz clock if no timescale was specified\n      var timescale = track.timescale || 90e3;\n      var truns = findBox(traf, ['trun']);\n      for (var j = 0; j < truns.length; j++) {\n        rawDuration = computeRawDurationFromSamples(truns[j]);\n        if (!rawDuration && sampleDuration) {\n          var sampleCount = readUint32(truns[j], 4);\n          rawDuration = sampleDuration * sampleCount;\n        }\n        if (track.type === ElementaryStreamTypes.VIDEO) {\n          videoDuration += rawDuration / timescale;\n        } else if (track.type === ElementaryStreamTypes.AUDIO) {\n          audioDuration += rawDuration / timescale;\n        }\n      }\n    }\n    if (videoDuration === 0 && audioDuration === 0) {\n      // If duration samples are not available in the traf use sidx subsegment_duration\n      var sidxMinStart = Infinity;\n      var sidxMaxEnd = 0;\n      var sidxDuration = 0;\n      var sidxs = findBox(data, ['sidx']);\n      for (var _i2 = 0; _i2 < sidxs.length; _i2++) {\n        var sidx = parseSegmentIndex(sidxs[_i2]);\n        if (sidx != null && sidx.references) {\n          sidxMinStart = Math.min(sidxMinStart, sidx.earliestPresentationTime / sidx.timescale);\n          var subSegmentDuration = sidx.references.reduce(function (dur, ref) {\n            return dur + ref.info.duration || 0;\n          }, 0);\n          sidxMaxEnd = Math.max(sidxMaxEnd, subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale);\n          sidxDuration = sidxMaxEnd - sidxMinStart;\n        }\n      }\n      if (sidxDuration && isFiniteNumber(sidxDuration)) {\n        return sidxDuration;\n      }\n    }\n    if (videoDuration) {\n      return videoDuration;\n    }\n    return audioDuration;\n  }\n\n  /*\n    For Reference:\n    aligned(8) class TrackRunBox\n             extends FullBox(trun, version, tr_flags) {\n       unsigned int(32)  sample_count;\n       // the following are optional fields\n       signed int(32) data_offset;\n       unsigned int(32)  first_sample_flags;\n       // all fields in the following array are optional\n       {\n          unsigned int(32)  sample_duration;\n          unsigned int(32)  sample_size;\n          unsigned int(32)  sample_flags\n          if (version == 0)\n             { unsigned int(32)\n          else\n             { signed int(32)\n       }[ sample_count ]\n    }\n   */\n  function computeRawDurationFromSamples(trun) {\n    var flags = readUint32(trun, 0);\n    // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\n    // Each field is an int32, which is 4 bytes\n    var offset = 8;\n    // data-offset-present flag\n    if (flags & 0x000001) {\n      offset += 4;\n    }\n    // first-sample-flags-present flag\n    if (flags & 0x000004) {\n      offset += 4;\n    }\n    var duration = 0;\n    var sampleCount = readUint32(trun, 4);\n    for (var i = 0; i < sampleCount; i++) {\n      // sample-duration-present flag\n      if (flags & 0x000100) {\n        var sampleDuration = readUint32(trun, offset);\n        duration += sampleDuration;\n        offset += 4;\n      }\n      // sample-size-present flag\n      if (flags & 0x000200) {\n        offset += 4;\n      }\n      // sample-flags-present flag\n      if (flags & 0x000400) {\n        offset += 4;\n      }\n      // sample-composition-time-offsets-present flag\n      if (flags & 0x000800) {\n        offset += 4;\n      }\n    }\n    return duration;\n  }\n  function offsetStartDTS(initData, fmp4, timeOffset) {\n    findBox(fmp4, ['moof', 'traf']).forEach(function (traf) {\n      findBox(traf, ['tfhd']).forEach(function (tfhd) {\n        // get the track id from the tfhd\n        var id = readUint32(tfhd, 4);\n        var track = initData[id];\n        if (!track) {\n          return;\n        }\n        // assume a 90kHz clock if no timescale was specified\n        var timescale = track.timescale || 90e3;\n        // get the base media decode time from the tfdt\n        findBox(traf, ['tfdt']).forEach(function (tfdt) {\n          var version = tfdt[0];\n          var offset = timeOffset * timescale;\n          if (offset) {\n            var baseMediaDecodeTime = readUint32(tfdt, 4);\n            if (version === 0) {\n              baseMediaDecodeTime -= offset;\n              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n              writeUint32(tfdt, 4, baseMediaDecodeTime);\n            } else {\n              baseMediaDecodeTime *= Math.pow(2, 32);\n              baseMediaDecodeTime += readUint32(tfdt, 8);\n              baseMediaDecodeTime -= offset;\n              baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n              var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));\n              var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));\n              writeUint32(tfdt, 4, upper);\n              writeUint32(tfdt, 8, lower);\n            }\n          }\n        });\n      });\n    });\n  }\n\n  // TODO: Check if the last moof+mdat pair is part of the valid range\n  function segmentValidRange(data) {\n    var segmentedRange = {\n      valid: null,\n      remainder: null\n    };\n    var moofs = findBox(data, ['moof']);\n    if (moofs.length < 2) {\n      segmentedRange.remainder = data;\n      return segmentedRange;\n    }\n    var last = moofs[moofs.length - 1];\n    // Offset by 8 bytes; findBox offsets the start by as much\n    segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);\n    segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);\n    return segmentedRange;\n  }\n  function appendUint8Array(data1, data2) {\n    var temp = new Uint8Array(data1.length + data2.length);\n    temp.set(data1);\n    temp.set(data2, data1.length);\n    return temp;\n  }\n  function parseSamples(timeOffset, track) {\n    var seiSamples = [];\n    var videoData = track.samples;\n    var timescale = track.timescale;\n    var trackId = track.id;\n    var isHEVCFlavor = false;\n    var moofs = findBox(videoData, ['moof']);\n    moofs.map(function (moof) {\n      var moofOffset = moof.byteOffset - 8;\n      var trafs = findBox(moof, ['traf']);\n      trafs.map(function (traf) {\n        // get the base media decode time from the tfdt\n        var baseTime = findBox(traf, ['tfdt']).map(function (tfdt) {\n          var version = tfdt[0];\n          var result = readUint32(tfdt, 4);\n          if (version === 1) {\n            result *= Math.pow(2, 32);\n            result += readUint32(tfdt, 8);\n          }\n          return result / timescale;\n        })[0];\n        if (baseTime !== undefined) {\n          timeOffset = baseTime;\n        }\n        return findBox(traf, ['tfhd']).map(function (tfhd) {\n          var id = readUint32(tfhd, 4);\n          var tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n          var baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n          var sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n          var defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n          var defaultSampleDuration = 0;\n          var defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n          var defaultSampleSize = 0;\n          var defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n          var tfhdOffset = 8;\n          if (id === trackId) {\n            if (baseDataOffsetPresent) {\n              tfhdOffset += 8;\n            }\n            if (sampleDescriptionIndexPresent) {\n              tfhdOffset += 4;\n            }\n            if (defaultSampleDurationPresent) {\n              defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n              tfhdOffset += 4;\n            }\n            if (defaultSampleSizePresent) {\n              defaultSampleSize = readUint32(tfhd, tfhdOffset);\n              tfhdOffset += 4;\n            }\n            if (defaultSampleFlagsPresent) {\n              tfhdOffset += 4;\n            }\n            if (track.type === 'video') {\n              isHEVCFlavor = isHEVC(track.codec);\n            }\n            findBox(traf, ['trun']).map(function (trun) {\n              var version = trun[0];\n              var flags = readUint32(trun, 0) & 0xffffff;\n              var dataOffsetPresent = (flags & 0x000001) !== 0;\n              var dataOffset = 0;\n              var firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n              var sampleDurationPresent = (flags & 0x000100) !== 0;\n              var sampleDuration = 0;\n              var sampleSizePresent = (flags & 0x000200) !== 0;\n              var sampleSize = 0;\n              var sampleFlagsPresent = (flags & 0x000400) !== 0;\n              var sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n              var compositionOffset = 0;\n              var sampleCount = readUint32(trun, 4);\n              var trunOffset = 8; // past version, flags, and sample count\n\n              if (dataOffsetPresent) {\n                dataOffset = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              }\n              if (firstSampleFlagsPresent) {\n                trunOffset += 4;\n              }\n              var sampleOffset = dataOffset + moofOffset;\n              for (var ix = 0; ix < sampleCount; ix++) {\n                if (sampleDurationPresent) {\n                  sampleDuration = readUint32(trun, trunOffset);\n                  trunOffset += 4;\n                } else {\n                  sampleDuration = defaultSampleDuration;\n                }\n                if (sampleSizePresent) {\n                  sampleSize = readUint32(trun, trunOffset);\n                  trunOffset += 4;\n                } else {\n                  sampleSize = defaultSampleSize;\n                }\n                if (sampleFlagsPresent) {\n                  trunOffset += 4;\n                }\n                if (sampleCompositionOffsetsPresent) {\n                  if (version === 0) {\n                    compositionOffset = readUint32(trun, trunOffset);\n                  } else {\n                    compositionOffset = readSint32(trun, trunOffset);\n                  }\n                  trunOffset += 4;\n                }\n                if (track.type === ElementaryStreamTypes.VIDEO) {\n                  var naluTotalSize = 0;\n                  while (naluTotalSize < sampleSize) {\n                    var naluSize = readUint32(videoData, sampleOffset);\n                    sampleOffset += 4;\n                    if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                      var data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                      parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);\n                    }\n                    sampleOffset += naluSize;\n                    naluTotalSize += naluSize + 4;\n                  }\n                }\n                timeOffset += sampleDuration / timescale;\n              }\n            });\n          }\n        });\n      });\n    });\n    return seiSamples;\n  }\n  function isHEVC(codec) {\n    if (!codec) {\n      return false;\n    }\n    var delimit = codec.indexOf('.');\n    var baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);\n    return baseCodec === 'hvc1' || baseCodec === 'hev1' ||\n    // Dolby Vision\n    baseCodec === 'dvh1' || baseCodec === 'dvhe';\n  }\n  function isSEIMessage(isHEVCFlavor, naluHeader) {\n    if (isHEVCFlavor) {\n      var naluType = naluHeader >> 1 & 0x3f;\n      return naluType === 39 || naluType === 40;\n    } else {\n      var _naluType = naluHeader & 0x1f;\n      return _naluType === 6;\n    }\n  }\n  function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {\n    var data = discardEPB(unescapedData);\n    var seiPtr = 0;\n    // skip nal header\n    seiPtr += headerSize;\n    var payloadType = 0;\n    var payloadSize = 0;\n    var b = 0;\n    while (seiPtr < data.length) {\n      payloadType = 0;\n      do {\n        if (seiPtr >= data.length) {\n          break;\n        }\n        b = data[seiPtr++];\n        payloadType += b;\n      } while (b === 0xff);\n\n      // Parse payload size.\n      payloadSize = 0;\n      do {\n        if (seiPtr >= data.length) {\n          break;\n        }\n        b = data[seiPtr++];\n        payloadSize += b;\n      } while (b === 0xff);\n      var leftOver = data.length - seiPtr;\n      // Create a variable to process the payload\n      var payPtr = seiPtr;\n\n      // Increment the seiPtr to the end of the payload\n      if (payloadSize < leftOver) {\n        seiPtr += payloadSize;\n      } else if (payloadSize > leftOver) {\n        // Some type of corruption has happened?\n        logger.error(\"Malformed SEI payload. \" + payloadSize + \" is too small, only \" + leftOver + \" bytes left to parse.\");\n        // We might be able to parse some data, but let's be safe and ignore it.\n        break;\n      }\n      if (payloadType === 4) {\n        var countryCode = data[payPtr++];\n        if (countryCode === 181) {\n          var providerCode = readUint16(data, payPtr);\n          payPtr += 2;\n          if (providerCode === 49) {\n            var userStructure = readUint32(data, payPtr);\n            payPtr += 4;\n            if (userStructure === 0x47413934) {\n              var userDataType = data[payPtr++];\n\n              // Raw CEA-608 bytes wrapped in CEA-708 packet\n              if (userDataType === 3) {\n                var firstByte = data[payPtr++];\n                var totalCCs = 0x1f & firstByte;\n                var enabled = 0x40 & firstByte;\n                var totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n                var byteArray = new Uint8Array(totalBytes);\n                if (enabled) {\n                  byteArray[0] = firstByte;\n                  for (var i = 1; i < totalBytes; i++) {\n                    byteArray[i] = data[payPtr++];\n                  }\n                }\n                samples.push({\n                  type: userDataType,\n                  payloadType: payloadType,\n                  pts: pts,\n                  bytes: byteArray\n                });\n              }\n            }\n          }\n        }\n      } else if (payloadType === 5) {\n        if (payloadSize > 16) {\n          var uuidStrArray = [];\n          for (var _i3 = 0; _i3 < 16; _i3++) {\n            var _b = data[payPtr++].toString(16);\n            uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);\n            if (_i3 === 3 || _i3 === 5 || _i3 === 7 || _i3 === 9) {\n              uuidStrArray.push('-');\n            }\n          }\n          var length = payloadSize - 16;\n          var userDataBytes = new Uint8Array(length);\n          for (var _i4 = 0; _i4 < length; _i4++) {\n            userDataBytes[_i4] = data[payPtr++];\n          }\n          samples.push({\n            payloadType: payloadType,\n            pts: pts,\n            uuid: uuidStrArray.join(''),\n            userData: utf8ArrayToStr(userDataBytes),\n            userDataBytes: userDataBytes\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * remove Emulation Prevention bytes from a RBSP\n   */\n  function discardEPB(data) {\n    var length = data.byteLength;\n    var EPBPositions = [];\n    var i = 1;\n\n    // Find all `Emulation Prevention Bytes`\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        EPBPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    }\n\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (EPBPositions.length === 0) {\n      return data;\n    }\n\n    // Create a new array to hold the NAL unit data\n    var newLength = length - EPBPositions.length;\n    var newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === EPBPositions[0]) {\n        // Skip this byte\n        sourceIndex++;\n        // Remove this position index\n        EPBPositions.shift();\n      }\n      newData[i] = data[sourceIndex];\n    }\n    return newData;\n  }\n  function parseEmsg(data) {\n    var version = data[0];\n    var schemeIdUri = '';\n    var value = '';\n    var timeScale = 0;\n    var presentationTimeDelta = 0;\n    var presentationTime = 0;\n    var eventDuration = 0;\n    var id = 0;\n    var offset = 0;\n    if (version === 0) {\n      while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n        schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n      }\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n      while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n        value += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n      }\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n      timeScale = readUint32(data, 12);\n      presentationTimeDelta = readUint32(data, 16);\n      eventDuration = readUint32(data, 20);\n      id = readUint32(data, 24);\n      offset = 28;\n    } else if (version === 1) {\n      offset += 4;\n      timeScale = readUint32(data, offset);\n      offset += 4;\n      var leftPresentationTime = readUint32(data, offset);\n      offset += 4;\n      var rightPresentationTime = readUint32(data, offset);\n      offset += 4;\n      presentationTime = Math.pow(2, 32) * leftPresentationTime + rightPresentationTime;\n      if (!isSafeInteger(presentationTime)) {\n        presentationTime = Number.MAX_SAFE_INTEGER;\n        logger.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');\n      }\n      eventDuration = readUint32(data, offset);\n      offset += 4;\n      id = readUint32(data, offset);\n      offset += 4;\n      while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n        schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n      }\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n      while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n        value += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n      }\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    var payload = data.subarray(offset, data.byteLength);\n    return {\n      schemeIdUri: schemeIdUri,\n      value: value,\n      timeScale: timeScale,\n      presentationTime: presentationTime,\n      presentationTimeDelta: presentationTimeDelta,\n      eventDuration: eventDuration,\n      id: id,\n      payload: payload\n    };\n  }\n  function mp4Box(type) {\n    for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      payload[_key - 1] = arguments[_key];\n    }\n    var len = payload.length;\n    var size = 8;\n    var i = len;\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n    var result = new Uint8Array(size);\n    result[0] = size >> 24 & 0xff;\n    result[1] = size >> 16 & 0xff;\n    result[2] = size >> 8 & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    for (i = 0, size = 8; i < len; i++) {\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n    return result;\n  }\n  function mp4pssh(systemId, keyids, data) {\n    if (systemId.byteLength !== 16) {\n      throw new RangeError('Invalid system id');\n    }\n    var version;\n    var kids;\n    if (keyids) {\n      version = 1;\n      kids = new Uint8Array(keyids.length * 16);\n      for (var ix = 0; ix < keyids.length; ix++) {\n        var k = keyids[ix]; // uint8array\n        if (k.byteLength !== 16) {\n          throw new RangeError('Invalid key');\n        }\n        kids.set(k, ix * 16);\n      }\n    } else {\n      version = 0;\n      kids = new Uint8Array();\n    }\n    var kidCount;\n    if (version > 0) {\n      kidCount = new Uint8Array(4);\n      if (keyids.length > 0) {\n        new DataView(kidCount.buffer).setUint32(0, keyids.length, false);\n      }\n    } else {\n      kidCount = new Uint8Array();\n    }\n    var dataSize = new Uint8Array(4);\n    if (data && data.byteLength > 0) {\n      new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);\n    }\n    return mp4Box([112, 115, 115, 104], new Uint8Array([version, 0x00, 0x00, 0x00 // Flags\n    ]), systemId,\n    // 16 bytes\n    kidCount, kids, dataSize, data || new Uint8Array());\n  }\n  function parseMultiPssh(initData) {\n    var results = [];\n    if (initData instanceof ArrayBuffer) {\n      var length = initData.byteLength;\n      var offset = 0;\n      while (offset + 32 < length) {\n        var view = new DataView(initData, offset);\n        var pssh = parsePssh(view);\n        results.push(pssh);\n        offset += pssh.size;\n      }\n    }\n    return results;\n  }\n  function parsePssh(view) {\n    var size = view.getUint32(0);\n    var offset = view.byteOffset;\n    var length = view.byteLength;\n    if (length < size) {\n      return {\n        offset: offset,\n        size: length\n      };\n    }\n    var type = view.getUint32(4);\n    if (type !== 0x70737368) {\n      return {\n        offset: offset,\n        size: size\n      };\n    }\n    var version = view.getUint32(8) >>> 24;\n    if (version !== 0 && version !== 1) {\n      return {\n        offset: offset,\n        size: size\n      };\n    }\n    var buffer = view.buffer;\n    var systemId = Hex.hexDump(new Uint8Array(buffer, offset + 12, 16));\n    var dataSizeOrKidCount = view.getUint32(28);\n    var kids = null;\n    var data = null;\n    if (version === 0) {\n      if (size - 32 < dataSizeOrKidCount || dataSizeOrKidCount < 22) {\n        return {\n          offset: offset,\n          size: size\n        };\n      }\n      data = new Uint8Array(buffer, offset + 32, dataSizeOrKidCount);\n    } else if (version === 1) {\n      if (!dataSizeOrKidCount || length < offset + 32 + dataSizeOrKidCount * 16 + 16) {\n        return {\n          offset: offset,\n          size: size\n        };\n      }\n      kids = [];\n      for (var i = 0; i < dataSizeOrKidCount; i++) {\n        kids.push(new Uint8Array(buffer, offset + 32 + i * 16, 16));\n      }\n    }\n    return {\n      version: version,\n      systemId: systemId,\n      kids: kids,\n      data: data,\n      offset: offset,\n      size: size\n    };\n  }\n\n  var keyUriToKeyIdMap = {};\n  var LevelKey = /*#__PURE__*/function () {\n    LevelKey.clearKeyUriToKeyIdMap = function clearKeyUriToKeyIdMap() {\n      keyUriToKeyIdMap = {};\n    };\n    function LevelKey(method, uri, format, formatversions, iv) {\n      if (formatversions === void 0) {\n        formatversions = [1];\n      }\n      if (iv === void 0) {\n        iv = null;\n      }\n      this.uri = void 0;\n      this.method = void 0;\n      this.keyFormat = void 0;\n      this.keyFormatVersions = void 0;\n      this.encrypted = void 0;\n      this.isCommonEncryption = void 0;\n      this.iv = null;\n      this.key = null;\n      this.keyId = null;\n      this.pssh = null;\n      this.method = method;\n      this.uri = uri;\n      this.keyFormat = format;\n      this.keyFormatVersions = formatversions;\n      this.iv = iv;\n      this.encrypted = method ? method !== 'NONE' : false;\n      this.isCommonEncryption = this.encrypted && method !== 'AES-128';\n    }\n    var _proto = LevelKey.prototype;\n    _proto.isSupported = function isSupported() {\n      // If it's Segment encryption or No encryption, just select that key system\n      if (this.method) {\n        if (this.method === 'AES-128' || this.method === 'NONE') {\n          return true;\n        }\n        if (this.keyFormat === 'identity') {\n          // Maintain support for clear SAMPLE-AES with MPEG-3 TS\n          return this.method === 'SAMPLE-AES';\n        } else {\n          switch (this.keyFormat) {\n            case KeySystemFormats.FAIRPLAY:\n            case KeySystemFormats.WIDEVINE:\n            case KeySystemFormats.PLAYREADY:\n            case KeySystemFormats.CLEARKEY:\n              return ['ISO-23001-7', 'SAMPLE-AES', 'SAMPLE-AES-CENC', 'SAMPLE-AES-CTR'].indexOf(this.method) !== -1;\n          }\n        }\n      }\n      return false;\n    };\n    _proto.getDecryptData = function getDecryptData(sn) {\n      if (!this.encrypted || !this.uri) {\n        return null;\n      }\n      if (this.method === 'AES-128' && this.uri && !this.iv) {\n        if (typeof sn !== 'number') {\n          // We are fetching decryption data for a initialization segment\n          // If the segment was encrypted with AES-128\n          // It must have an IV defined. We cannot substitute the Segment Number in.\n          if (this.method === 'AES-128' && !this.iv) {\n            logger.warn(\"missing IV for initialization segment with method=\\\"\" + this.method + \"\\\" - compliance issue\");\n          }\n          // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n          sn = 0;\n        }\n        var iv = createInitializationVector(sn);\n        var decryptdata = new LevelKey(this.method, this.uri, 'identity', this.keyFormatVersions, iv);\n        return decryptdata;\n      }\n\n      // Initialize keyId if possible\n      var keyBytes = convertDataUriToArrayBytes(this.uri);\n      if (keyBytes) {\n        switch (this.keyFormat) {\n          case KeySystemFormats.WIDEVINE:\n            this.pssh = keyBytes;\n            // In case of widevine keyID is embedded in PSSH box. Read Key ID.\n            if (keyBytes.length >= 22) {\n              this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);\n            }\n            break;\n          case KeySystemFormats.PLAYREADY:\n            {\n              var PlayReadyKeySystemUUID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]);\n              this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);\n              var keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);\n              var keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));\n\n              // Parse Playready WRMHeader XML\n              var xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf('<'), keyByteStr.length);\n              var parser = new DOMParser();\n              var xmlDoc = parser.parseFromString(xmlKeyBytes, 'text/xml');\n              var keyData = xmlDoc.getElementsByTagName('KID')[0];\n              if (keyData) {\n                var keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute('VALUE');\n                if (keyId) {\n                  var keyIdArray = base64Decode(keyId).subarray(0, 16);\n                  // KID value in PRO is a base64-encoded little endian GUID interpretation of UUID\n                  // KID value in tenc is a big endian UUID GUID interpretation of UUID\n                  changeEndianness(keyIdArray);\n                  this.keyId = keyIdArray;\n                }\n              }\n              break;\n            }\n          default:\n            {\n              var keydata = keyBytes.subarray(0, 16);\n              if (keydata.length !== 16) {\n                var padded = new Uint8Array(16);\n                padded.set(keydata, 16 - keydata.length);\n                keydata = padded;\n              }\n              this.keyId = keydata;\n              break;\n            }\n        }\n      }\n\n      // Default behavior: assign a new keyId for each uri\n      if (!this.keyId || this.keyId.byteLength !== 16) {\n        var _keyId = keyUriToKeyIdMap[this.uri];\n        if (!_keyId) {\n          var val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;\n          _keyId = new Uint8Array(16);\n          var dv = new DataView(_keyId.buffer, 12, 4); // Just set the last 4 bytes\n          dv.setUint32(0, val);\n          keyUriToKeyIdMap[this.uri] = _keyId;\n        }\n        this.keyId = _keyId;\n      }\n      return this;\n    };\n    return LevelKey;\n  }();\n  function createInitializationVector(segmentNumber) {\n    var uint8View = new Uint8Array(16);\n    for (var i = 12; i < 16; i++) {\n      uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n    }\n    return uint8View;\n  }\n\n  var VARIABLE_REPLACEMENT_REGEX = /\\{\\$([a-zA-Z0-9-_]+)\\}/g;\n  function hasVariableReferences(str) {\n    return VARIABLE_REPLACEMENT_REGEX.test(str);\n  }\n  function substituteVariablesInAttributes(parsed, attr, attributeNames) {\n    if (parsed.variableList !== null || parsed.hasVariableRefs) {\n      for (var i = attributeNames.length; i--;) {\n        var name = attributeNames[i];\n        var value = attr[name];\n        if (value) {\n          attr[name] = substituteVariables(parsed, value);\n        }\n      }\n    }\n  }\n  function substituteVariables(parsed, value) {\n    if (parsed.variableList !== null || parsed.hasVariableRefs) {\n      var variableList = parsed.variableList;\n      return value.replace(VARIABLE_REPLACEMENT_REGEX, function (variableReference) {\n        var variableName = variableReference.substring(2, variableReference.length - 1);\n        var variableValue = variableList == null ? void 0 : variableList[variableName];\n        if (variableValue === undefined) {\n          parsed.playlistParsingError || (parsed.playlistParsingError = new Error(\"Missing preceding EXT-X-DEFINE tag for Variable Reference: \\\"\" + variableName + \"\\\"\"));\n          return variableReference;\n        }\n        return variableValue;\n      });\n    }\n    return value;\n  }\n  function addVariableDefinition(parsed, attr, parentUrl) {\n    var variableList = parsed.variableList;\n    if (!variableList) {\n      parsed.variableList = variableList = {};\n    }\n    var NAME;\n    var VALUE;\n    if ('QUERYPARAM' in attr) {\n      NAME = attr.QUERYPARAM;\n      try {\n        var searchParams = new self.URL(parentUrl).searchParams;\n        if (searchParams.has(NAME)) {\n          VALUE = searchParams.get(NAME);\n        } else {\n          throw new Error(\"\\\"\" + NAME + \"\\\" does not match any query parameter in URI: \\\"\" + parentUrl + \"\\\"\");\n        }\n      } catch (error) {\n        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(\"EXT-X-DEFINE QUERYPARAM: \" + error.message));\n      }\n    } else {\n      NAME = attr.NAME;\n      VALUE = attr.VALUE;\n    }\n    if (NAME in variableList) {\n      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(\"EXT-X-DEFINE duplicate Variable Name declarations: \\\"\" + NAME + \"\\\"\"));\n    } else {\n      variableList[NAME] = VALUE || '';\n    }\n  }\n  function importVariableDefinition(parsed, attr, sourceVariableList) {\n    var IMPORT = attr.IMPORT;\n    if (sourceVariableList && IMPORT in sourceVariableList) {\n      var variableList = parsed.variableList;\n      if (!variableList) {\n        parsed.variableList = variableList = {};\n      }\n      variableList[IMPORT] = sourceVariableList[IMPORT];\n    } else {\n      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(\"EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: \\\"\" + IMPORT + \"\\\"\"));\n    }\n  }\n\n  /**\n   * MediaSource helper\n   */\n\n  function getMediaSource(preferManagedMediaSource) {\n    if (preferManagedMediaSource === void 0) {\n      preferManagedMediaSource = true;\n    }\n    if (typeof self === 'undefined') return undefined;\n    var mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;\n    return mms || self.MediaSource || self.WebKitMediaSource;\n  }\n  function isManagedMediaSource(source) {\n    return typeof self !== 'undefined' && source === self.ManagedMediaSource;\n  }\n\n  // from http://mp4ra.org/codecs.html\n  // values indicate codec selection preference (lower is higher priority)\n  var sampleEntryCodesISO = {\n    audio: {\n      a3ds: 1,\n      'ac-3': 0.95,\n      'ac-4': 1,\n      alac: 0.9,\n      alaw: 1,\n      dra1: 1,\n      'dts+': 1,\n      'dts-': 1,\n      dtsc: 1,\n      dtse: 1,\n      dtsh: 1,\n      'ec-3': 0.9,\n      enca: 1,\n      fLaC: 0.9,\n      // MP4-RA listed codec entry for FLAC\n      flac: 0.9,\n      // legacy browser codec name for FLAC\n      FLAC: 0.9,\n      // some manifests may list \"FLAC\" with Apple's tools\n      g719: 1,\n      g726: 1,\n      m4ae: 1,\n      mha1: 1,\n      mha2: 1,\n      mhm1: 1,\n      mhm2: 1,\n      mlpa: 1,\n      mp4a: 1,\n      'raw ': 1,\n      Opus: 1,\n      opus: 1,\n      // browsers expect this to be lowercase despite MP4RA says 'Opus'\n      samr: 1,\n      sawb: 1,\n      sawp: 1,\n      sevc: 1,\n      sqcp: 1,\n      ssmv: 1,\n      twos: 1,\n      ulaw: 1\n    },\n    video: {\n      avc1: 1,\n      avc2: 1,\n      avc3: 1,\n      avc4: 1,\n      avcp: 1,\n      av01: 0.8,\n      drac: 1,\n      dva1: 1,\n      dvav: 1,\n      dvh1: 0.7,\n      dvhe: 0.7,\n      encv: 1,\n      hev1: 0.75,\n      hvc1: 0.75,\n      mjp2: 1,\n      mp4v: 1,\n      mvc1: 1,\n      mvc2: 1,\n      mvc3: 1,\n      mvc4: 1,\n      resv: 1,\n      rv60: 1,\n      s263: 1,\n      svc1: 1,\n      svc2: 1,\n      'vc-1': 1,\n      vp08: 1,\n      vp09: 0.9\n    },\n    text: {\n      stpp: 1,\n      wvtt: 1\n    }\n  };\n  function isCodecType(codec, type) {\n    var typeCodes = sampleEntryCodesISO[type];\n    return !!typeCodes && !!typeCodes[codec.slice(0, 4)];\n  }\n  function areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource) {\n    if (preferManagedMediaSource === void 0) {\n      preferManagedMediaSource = true;\n    }\n    return !codecs.split(',').some(function (codec) {\n      return !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource);\n    });\n  }\n  function isCodecMediaSourceSupported(codec, type, preferManagedMediaSource) {\n    var _MediaSource$isTypeSu;\n    if (preferManagedMediaSource === void 0) {\n      preferManagedMediaSource = true;\n    }\n    var MediaSource = getMediaSource(preferManagedMediaSource);\n    return (_MediaSource$isTypeSu = MediaSource == null ? void 0 : MediaSource.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;\n  }\n  function mimeTypeForCodec(codec, type) {\n    return type + \"/mp4;codecs=\\\"\" + codec + \"\\\"\";\n  }\n  function videoCodecPreferenceValue(videoCodec) {\n    if (videoCodec) {\n      var fourCC = videoCodec.substring(0, 4);\n      return sampleEntryCodesISO.video[fourCC];\n    }\n    return 2;\n  }\n  function codecsSetSelectionPreferenceValue(codecSet) {\n    return codecSet.split(',').reduce(function (num, fourCC) {\n      var preferenceValue = sampleEntryCodesISO.video[fourCC];\n      if (preferenceValue) {\n        return (preferenceValue * 2 + num) / (num ? 3 : 2);\n      }\n      return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);\n    }, 0);\n  }\n  var CODEC_COMPATIBLE_NAMES = {};\n  function getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource) {\n    if (preferManagedMediaSource === void 0) {\n      preferManagedMediaSource = true;\n    }\n    if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {\n      return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];\n    }\n\n    // Idealy fLaC and Opus would be first (spec-compliant) but\n    // some browsers will report that fLaC is supported then fail.\n    // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728\n    var codecsToCheck = {\n      flac: ['flac', 'fLaC', 'FLAC'],\n      opus: ['opus', 'Opus']\n    }[lowerCaseCodec];\n    for (var i = 0; i < codecsToCheck.length; i++) {\n      if (isCodecMediaSourceSupported(codecsToCheck[i], 'audio', preferManagedMediaSource)) {\n        CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];\n        return codecsToCheck[i];\n      }\n    }\n    return lowerCaseCodec;\n  }\n  var AUDIO_CODEC_REGEXP = /flac|opus/i;\n  function getCodecCompatibleName(codec, preferManagedMediaSource) {\n    if (preferManagedMediaSource === void 0) {\n      preferManagedMediaSource = true;\n    }\n    return codec.replace(AUDIO_CODEC_REGEXP, function (m) {\n      return getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource);\n    });\n  }\n  function pickMostCompleteCodecName(parsedCodec, levelCodec) {\n    // Parsing of mp4a codecs strings in mp4-tools from media is incomplete as of d8c6c7a\n    // so use level codec is parsed codec is unavailable or incomplete\n    if (parsedCodec && parsedCodec !== 'mp4a') {\n      return parsedCodec;\n    }\n    return levelCodec ? levelCodec.split(',')[0] : levelCodec;\n  }\n  function convertAVC1ToAVCOTI(codec) {\n    // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n    // Examples: avc1.66.30 to avc1.42001e and avc1.77.30,avc1.66.30 to avc1.4d001e,avc1.42001e.\n    var codecs = codec.split(',');\n    for (var i = 0; i < codecs.length; i++) {\n      var avcdata = codecs[i].split('.');\n      if (avcdata.length > 2) {\n        var result = avcdata.shift() + '.';\n        result += parseInt(avcdata.shift()).toString(16);\n        result += ('000' + parseInt(avcdata.shift()).toString(16)).slice(-4);\n        codecs[i] = result;\n      }\n    }\n    return codecs.join(',');\n  }\n\n  var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g;\n  var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\n  var IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)\n\n  var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n  // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n  /(?!#) *(\\S[^\\r\\n]*)/.source,\n  // segment URI, group 3 => the URI (note newline is not eaten)\n  /#EXT-X-BYTERANGE:*(.+)/.source,\n  // next segment's byterange, group 4 => range spec (x@y)\n  /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,\n  // next segment's program date/time group 5 => the datetime spec\n  /#.*/.source // All other non-segment oriented tags will match with all groups empty\n  ].join('|'), 'g');\n  var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join('|'));\n  var M3U8Parser = /*#__PURE__*/function () {\n    function M3U8Parser() {}\n    M3U8Parser.findGroup = function findGroup(groups, mediaGroupId) {\n      for (var i = 0; i < groups.length; i++) {\n        var group = groups[i];\n        if (group.id === mediaGroupId) {\n          return group;\n        }\n      }\n    };\n    M3U8Parser.resolve = function resolve(url, baseUrl) {\n      return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {\n        alwaysNormalize: true\n      });\n    };\n    M3U8Parser.isMediaPlaylist = function isMediaPlaylist(str) {\n      return IS_MEDIA_PLAYLIST.test(str);\n    };\n    M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {\n      var hasVariableRefs = hasVariableReferences(string) ;\n      var parsed = {\n        contentSteering: null,\n        levels: [],\n        playlistParsingError: null,\n        sessionData: null,\n        sessionKeys: null,\n        startTimeOffset: null,\n        variableList: null,\n        hasVariableRefs: hasVariableRefs\n      };\n      var levelsWithKnownCodecs = [];\n      MASTER_PLAYLIST_REGEX.lastIndex = 0;\n      var result;\n      while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n        if (result[1]) {\n          var _level$unknownCodecs;\n          // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n          var attrs = new AttrList(result[1]);\n          {\n            substituteVariablesInAttributes(parsed, attrs, ['CODECS', 'SUPPLEMENTAL-CODECS', 'ALLOWED-CPC', 'PATHWAY-ID', 'STABLE-VARIANT-ID', 'AUDIO', 'VIDEO', 'SUBTITLES', 'CLOSED-CAPTIONS', 'NAME']);\n          }\n          var uri = substituteVariables(parsed, result[2]) ;\n          var level = {\n            attrs: attrs,\n            bitrate: attrs.decimalInteger('BANDWIDTH') || attrs.decimalInteger('AVERAGE-BANDWIDTH'),\n            name: attrs.NAME,\n            url: M3U8Parser.resolve(uri, baseurl)\n          };\n          var resolution = attrs.decimalResolution('RESOLUTION');\n          if (resolution) {\n            level.width = resolution.width;\n            level.height = resolution.height;\n          }\n          setCodecs(attrs.CODECS, level);\n          if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {\n            levelsWithKnownCodecs.push(level);\n          }\n          parsed.levels.push(level);\n        } else if (result[3]) {\n          var tag = result[3];\n          var attributes = result[4];\n          switch (tag) {\n            case 'SESSION-DATA':\n              {\n                // #EXT-X-SESSION-DATA\n                var sessionAttrs = new AttrList(attributes);\n                {\n                  substituteVariablesInAttributes(parsed, sessionAttrs, ['DATA-ID', 'LANGUAGE', 'VALUE', 'URI']);\n                }\n                var dataId = sessionAttrs['DATA-ID'];\n                if (dataId) {\n                  if (parsed.sessionData === null) {\n                    parsed.sessionData = {};\n                  }\n                  parsed.sessionData[dataId] = sessionAttrs;\n                }\n                break;\n              }\n            case 'SESSION-KEY':\n              {\n                // #EXT-X-SESSION-KEY\n                var sessionKey = parseKey(attributes, baseurl, parsed);\n                if (sessionKey.encrypted && sessionKey.isSupported()) {\n                  if (parsed.sessionKeys === null) {\n                    parsed.sessionKeys = [];\n                  }\n                  parsed.sessionKeys.push(sessionKey);\n                } else {\n                  logger.warn(\"[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \\\"\" + attributes + \"\\\"\");\n                }\n                break;\n              }\n            case 'DEFINE':\n              {\n                // #EXT-X-DEFINE\n                {\n                  var variableAttributes = new AttrList(attributes);\n                  substituteVariablesInAttributes(parsed, variableAttributes, ['NAME', 'VALUE', 'QUERYPARAM']);\n                  addVariableDefinition(parsed, variableAttributes, baseurl);\n                }\n                break;\n              }\n            case 'CONTENT-STEERING':\n              {\n                // #EXT-X-CONTENT-STEERING\n                var contentSteeringAttributes = new AttrList(attributes);\n                {\n                  substituteVariablesInAttributes(parsed, contentSteeringAttributes, ['SERVER-URI', 'PATHWAY-ID']);\n                }\n                parsed.contentSteering = {\n                  uri: M3U8Parser.resolve(contentSteeringAttributes['SERVER-URI'], baseurl),\n                  pathwayId: contentSteeringAttributes['PATHWAY-ID'] || '.'\n                };\n                break;\n              }\n            case 'START':\n              {\n                // #EXT-X-START\n                parsed.startTimeOffset = parseStartTimeOffset(attributes);\n                break;\n              }\n          }\n        }\n      }\n      // Filter out levels with unknown codecs if it does not remove all levels\n      var stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;\n      parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;\n      if (parsed.levels.length === 0) {\n        parsed.playlistParsingError = new Error('no levels found in manifest');\n      }\n      return parsed;\n    };\n    M3U8Parser.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, parsed) {\n      var result;\n      var results = {};\n      var levels = parsed.levels;\n      var groupsByType = {\n        AUDIO: levels.map(function (level) {\n          return {\n            id: level.attrs.AUDIO,\n            audioCodec: level.audioCodec\n          };\n        }),\n        SUBTITLES: levels.map(function (level) {\n          return {\n            id: level.attrs.SUBTITLES,\n            textCodec: level.textCodec\n          };\n        }),\n        'CLOSED-CAPTIONS': []\n      };\n      var id = 0;\n      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n        var attrs = new AttrList(result[1]);\n        var type = attrs.TYPE;\n        if (type) {\n          var groups = groupsByType[type];\n          var medias = results[type] || [];\n          results[type] = medias;\n          {\n            substituteVariablesInAttributes(parsed, attrs, ['URI', 'GROUP-ID', 'LANGUAGE', 'ASSOC-LANGUAGE', 'STABLE-RENDITION-ID', 'NAME', 'INSTREAM-ID', 'CHARACTERISTICS', 'CHANNELS']);\n          }\n          var lang = attrs.LANGUAGE;\n          var assocLang = attrs['ASSOC-LANGUAGE'];\n          var channels = attrs.CHANNELS;\n          var characteristics = attrs.CHARACTERISTICS;\n          var instreamId = attrs['INSTREAM-ID'];\n          var media = {\n            attrs: attrs,\n            bitrate: 0,\n            id: id++,\n            groupId: attrs['GROUP-ID'] || '',\n            name: attrs.NAME || lang || '',\n            type: type,\n            default: attrs.bool('DEFAULT'),\n            autoselect: attrs.bool('AUTOSELECT'),\n            forced: attrs.bool('FORCED'),\n            lang: lang,\n            url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''\n          };\n          if (assocLang) {\n            media.assocLang = assocLang;\n          }\n          if (channels) {\n            media.channels = channels;\n          }\n          if (characteristics) {\n            media.characteristics = characteristics;\n          }\n          if (instreamId) {\n            media.instreamId = instreamId;\n          }\n          if (groups != null && groups.length) {\n            // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n            // If we don't find the track signalled, lets use the first audio groups codec we have\n            // Acting as a best guess\n            var groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n            assignCodec(media, groupCodec, 'audioCodec');\n            assignCodec(media, groupCodec, 'textCodec');\n          }\n          medias.push(media);\n        }\n      }\n      return results;\n    };\n    M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {\n      var level = new LevelDetails(baseurl);\n      var fragments = level.fragments;\n      // The most recent init segment seen (applies to all subsequent segments)\n      var currentInitSegment = null;\n      var currentSN = 0;\n      var currentPart = 0;\n      var totalduration = 0;\n      var discontinuityCounter = 0;\n      var prevFrag = null;\n      var frag = new Fragment(type, baseurl);\n      var result;\n      var i;\n      var levelkeys;\n      var firstPdtIndex = -1;\n      var createNextFrag = false;\n      var nextByteRange = null;\n      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n      level.m3u8 = string;\n      level.hasVariableRefs = hasVariableReferences(string) ;\n      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n        if (createNextFrag) {\n          createNextFrag = false;\n          frag = new Fragment(type, baseurl);\n          // setup the next fragment for part loading\n          frag.start = totalduration;\n          frag.sn = currentSN;\n          frag.cc = discontinuityCounter;\n          frag.level = id;\n          if (currentInitSegment) {\n            frag.initSegment = currentInitSegment;\n            frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n            currentInitSegment.rawProgramDateTime = null;\n            if (nextByteRange) {\n              frag.setByteRange(nextByteRange);\n              nextByteRange = null;\n            }\n          }\n        }\n        var duration = result[1];\n        if (duration) {\n          // INF\n          frag.duration = parseFloat(duration);\n          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n          var title = (' ' + result[2]).slice(1);\n          frag.title = title || null;\n          frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n        } else if (result[3]) {\n          // url\n          if (isFiniteNumber(frag.duration)) {\n            frag.start = totalduration;\n            if (levelkeys) {\n              setFragLevelKeys(frag, levelkeys, level);\n            }\n            frag.sn = currentSN;\n            frag.level = id;\n            frag.cc = discontinuityCounter;\n            fragments.push(frag);\n            // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n            var uri = (' ' + result[3]).slice(1);\n            frag.relurl = substituteVariables(level, uri) ;\n            assignProgramDateTime(frag, prevFrag);\n            prevFrag = frag;\n            totalduration += frag.duration;\n            currentSN++;\n            currentPart = 0;\n            createNextFrag = true;\n          }\n        } else if (result[4]) {\n          // X-BYTERANGE\n          var data = (' ' + result[4]).slice(1);\n          if (prevFrag) {\n            frag.setByteRange(data, prevFrag);\n          } else {\n            frag.setByteRange(data);\n          }\n        } else if (result[5]) {\n          // PROGRAM-DATE-TIME\n          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n          frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n          frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n          if (firstPdtIndex === -1) {\n            firstPdtIndex = fragments.length;\n          }\n        } else {\n          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n          if (!result) {\n            logger.warn('No matches on slow regex match for level playlist!');\n            continue;\n          }\n          for (i = 1; i < result.length; i++) {\n            if (typeof result[i] !== 'undefined') {\n              break;\n            }\n          }\n\n          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n          var tag = (' ' + result[i]).slice(1);\n          var value1 = (' ' + result[i + 1]).slice(1);\n          var value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : '';\n          switch (tag) {\n            case 'PLAYLIST-TYPE':\n              level.type = value1.toUpperCase();\n              break;\n            case 'MEDIA-SEQUENCE':\n              currentSN = level.startSN = parseInt(value1);\n              break;\n            case 'SKIP':\n              {\n                var skipAttrs = new AttrList(value1);\n                {\n                  substituteVariablesInAttributes(level, skipAttrs, ['RECENTLY-REMOVED-DATERANGES']);\n                }\n                var skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');\n                if (isFiniteNumber(skippedSegments)) {\n                  level.skippedSegments = skippedSegments;\n                  // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n                  for (var _i = skippedSegments; _i--;) {\n                    fragments.unshift(null);\n                  }\n                  currentSN += skippedSegments;\n                }\n                var recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');\n                if (recentlyRemovedDateranges) {\n                  level.recentlyRemovedDateranges = recentlyRemovedDateranges.split('\\t');\n                }\n                break;\n              }\n            case 'TARGETDURATION':\n              level.targetduration = Math.max(parseInt(value1), 1);\n              break;\n            case 'VERSION':\n              level.version = parseInt(value1);\n              break;\n            case 'INDEPENDENT-SEGMENTS':\n            case 'EXTM3U':\n              break;\n            case 'ENDLIST':\n              level.live = false;\n              break;\n            case '#':\n              if (value1 || value2) {\n                frag.tagList.push(value2 ? [value1, value2] : [value1]);\n              }\n              break;\n            case 'DISCONTINUITY':\n              discontinuityCounter++;\n              frag.tagList.push(['DIS']);\n              break;\n            case 'GAP':\n              frag.gap = true;\n              frag.tagList.push([tag]);\n              break;\n            case 'BITRATE':\n              frag.tagList.push([tag, value1]);\n              break;\n            case 'DATERANGE':\n              {\n                var dateRangeAttr = new AttrList(value1);\n                {\n                  substituteVariablesInAttributes(level, dateRangeAttr, ['ID', 'CLASS', 'START-DATE', 'END-DATE', 'SCTE35-CMD', 'SCTE35-OUT', 'SCTE35-IN']);\n                  substituteVariablesInAttributes(level, dateRangeAttr, dateRangeAttr.clientAttrs);\n                }\n                var dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);\n                if (dateRange.isValid || level.skippedSegments) {\n                  level.dateRanges[dateRange.id] = dateRange;\n                } else {\n                  logger.warn(\"Ignoring invalid DATERANGE tag: \\\"\" + value1 + \"\\\"\");\n                }\n                // Add to fragment tag list for backwards compatibility (< v1.2.0)\n                frag.tagList.push(['EXT-X-DATERANGE', value1]);\n                break;\n              }\n            case 'DEFINE':\n              {\n                {\n                  var variableAttributes = new AttrList(value1);\n                  substituteVariablesInAttributes(level, variableAttributes, ['NAME', 'VALUE', 'IMPORT', 'QUERYPARAM']);\n                  if ('IMPORT' in variableAttributes) {\n                    importVariableDefinition(level, variableAttributes, multivariantVariableList);\n                  } else {\n                    addVariableDefinition(level, variableAttributes, baseurl);\n                  }\n                }\n                break;\n              }\n            case 'DISCONTINUITY-SEQUENCE':\n              discontinuityCounter = parseInt(value1);\n              break;\n            case 'KEY':\n              {\n                var levelKey = parseKey(value1, baseurl, level);\n                if (levelKey.isSupported()) {\n                  if (levelKey.method === 'NONE') {\n                    levelkeys = undefined;\n                    break;\n                  }\n                  if (!levelkeys) {\n                    levelkeys = {};\n                  }\n                  if (levelkeys[levelKey.keyFormat]) {\n                    levelkeys = _extends({}, levelkeys);\n                  }\n                  levelkeys[levelKey.keyFormat] = levelKey;\n                } else {\n                  logger.warn(\"[Keys] Ignoring invalid EXT-X-KEY tag: \\\"\" + value1 + \"\\\"\");\n                }\n                break;\n              }\n            case 'START':\n              level.startTimeOffset = parseStartTimeOffset(value1);\n              break;\n            case 'MAP':\n              {\n                var mapAttrs = new AttrList(value1);\n                {\n                  substituteVariablesInAttributes(level, mapAttrs, ['BYTERANGE', 'URI']);\n                }\n                if (frag.duration) {\n                  // Initial segment tag is after segment duration tag.\n                  //   #EXTINF: 6.0\n                  //   #EXT-X-MAP:URI=\"init.mp4\n                  var init = new Fragment(type, baseurl);\n                  setInitSegment(init, mapAttrs, id, levelkeys);\n                  currentInitSegment = init;\n                  frag.initSegment = currentInitSegment;\n                  if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                    frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                  }\n                } else {\n                  // Initial segment tag is before segment duration tag\n                  // Handle case where EXT-X-MAP is declared after EXT-X-BYTERANGE\n                  var end = frag.byteRangeEndOffset;\n                  if (end) {\n                    var start = frag.byteRangeStartOffset;\n                    nextByteRange = end - start + \"@\" + start;\n                  } else {\n                    nextByteRange = null;\n                  }\n                  setInitSegment(frag, mapAttrs, id, levelkeys);\n                  currentInitSegment = frag;\n                  createNextFrag = true;\n                }\n                break;\n              }\n            case 'SERVER-CONTROL':\n              {\n                var serverControlAttrs = new AttrList(value1);\n                level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');\n                level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);\n                level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');\n                level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);\n                level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);\n                break;\n              }\n            case 'PART-INF':\n              {\n                var partInfAttrs = new AttrList(value1);\n                level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');\n                break;\n              }\n            case 'PART':\n              {\n                var partList = level.partList;\n                if (!partList) {\n                  partList = level.partList = [];\n                }\n                var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n                var index = currentPart++;\n                var partAttrs = new AttrList(value1);\n                {\n                  substituteVariablesInAttributes(level, partAttrs, ['BYTERANGE', 'URI']);\n                }\n                var part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);\n                partList.push(part);\n                frag.duration += part.duration;\n                break;\n              }\n            case 'PRELOAD-HINT':\n              {\n                var preloadHintAttrs = new AttrList(value1);\n                {\n                  substituteVariablesInAttributes(level, preloadHintAttrs, ['URI']);\n                }\n                level.preloadHint = preloadHintAttrs;\n                break;\n              }\n            case 'RENDITION-REPORT':\n              {\n                var renditionReportAttrs = new AttrList(value1);\n                {\n                  substituteVariablesInAttributes(level, renditionReportAttrs, ['URI']);\n                }\n                level.renditionReports = level.renditionReports || [];\n                level.renditionReports.push(renditionReportAttrs);\n                break;\n              }\n            default:\n              logger.warn(\"line parsed but not handled: \" + result);\n              break;\n          }\n        }\n      }\n      if (prevFrag && !prevFrag.relurl) {\n        fragments.pop();\n        totalduration -= prevFrag.duration;\n        if (level.partList) {\n          level.fragmentHint = prevFrag;\n        }\n      } else if (level.partList) {\n        assignProgramDateTime(frag, prevFrag);\n        frag.cc = discontinuityCounter;\n        level.fragmentHint = frag;\n        if (levelkeys) {\n          setFragLevelKeys(frag, levelkeys, level);\n        }\n      }\n      var fragmentLength = fragments.length;\n      var firstFragment = fragments[0];\n      var lastFragment = fragments[fragmentLength - 1];\n      totalduration += level.skippedSegments * level.targetduration;\n      if (totalduration > 0 && fragmentLength && lastFragment) {\n        level.averagetargetduration = totalduration / fragmentLength;\n        var lastSn = lastFragment.sn;\n        level.endSN = lastSn !== 'initSegment' ? lastSn : 0;\n        if (!level.live) {\n          lastFragment.endList = true;\n        }\n        if (firstFragment) {\n          level.startCC = firstFragment.cc;\n        }\n      } else {\n        level.endSN = 0;\n        level.startCC = 0;\n      }\n      if (level.fragmentHint) {\n        totalduration += level.fragmentHint.duration;\n      }\n      level.totalduration = totalduration;\n      level.endCC = discontinuityCounter;\n\n      /**\n       * Backfill any missing PDT values\n       * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n       * one or more Media Segment URIs, the client SHOULD extrapolate\n       * backward from that tag (using EXTINF durations and/or media\n       * timestamps) to associate dates with those segments.\"\n       * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n       * computed.\n       */\n      if (firstPdtIndex > 0) {\n        backfillProgramDateTimes(fragments, firstPdtIndex);\n      }\n      return level;\n    };\n    return M3U8Parser;\n  }();\n  function parseKey(keyTagAttributes, baseurl, parsed) {\n    var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;\n    // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n    var keyAttrs = new AttrList(keyTagAttributes);\n    {\n      substituteVariablesInAttributes(parsed, keyAttrs, ['KEYFORMAT', 'KEYFORMATVERSIONS', 'URI', 'IV', 'URI']);\n    }\n    var decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : '';\n    var decrypturi = keyAttrs.URI;\n    var decryptiv = keyAttrs.hexadecimalInteger('IV');\n    var decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;\n    // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n    var decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : 'identity';\n    if (decrypturi && keyAttrs.IV && !decryptiv) {\n      logger.error(\"Invalid IV: \" + keyAttrs.IV);\n    }\n    // If decrypturi is a URI with a scheme, then baseurl will be ignored\n    // No uri is allowed when METHOD is NONE\n    var resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : '';\n    var keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : '1').split('/').map(Number).filter(Number.isFinite);\n    return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);\n  }\n  function parseStartTimeOffset(startAttributes) {\n    var startAttrs = new AttrList(startAttributes);\n    var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n    if (isFiniteNumber(startTimeOffset)) {\n      return startTimeOffset;\n    }\n    return null;\n  }\n  function setCodecs(codecsAttributeValue, level) {\n    var codecs = (codecsAttributeValue || '').split(/[ ,]+/).filter(function (c) {\n      return c;\n    });\n    ['video', 'audio', 'text'].forEach(function (type) {\n      var filtered = codecs.filter(function (codec) {\n        return isCodecType(codec, type);\n      });\n      if (filtered.length) {\n        // Comma separated list of all codecs for type\n        level[type + \"Codec\"] = filtered.join(',');\n        // Remove known codecs so that only unknownCodecs are left after iterating through each type\n        codecs = codecs.filter(function (codec) {\n          return filtered.indexOf(codec) === -1;\n        });\n      }\n    });\n    level.unknownCodecs = codecs;\n  }\n  function assignCodec(media, groupItem, codecProperty) {\n    var codecValue = groupItem[codecProperty];\n    if (codecValue) {\n      media[codecProperty] = codecValue;\n    }\n  }\n  function backfillProgramDateTimes(fragments, firstPdtIndex) {\n    var fragPrev = fragments[firstPdtIndex];\n    for (var i = firstPdtIndex; i--;) {\n      var frag = fragments[i];\n      // Exit on delta-playlist skipped segments\n      if (!frag) {\n        return;\n      }\n      frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n      fragPrev = frag;\n    }\n  }\n  function assignProgramDateTime(frag, prevFrag) {\n    if (frag.rawProgramDateTime) {\n      frag.programDateTime = Date.parse(frag.rawProgramDateTime);\n    } else if (prevFrag != null && prevFrag.programDateTime) {\n      frag.programDateTime = prevFrag.endProgramDateTime;\n    }\n    if (!isFiniteNumber(frag.programDateTime)) {\n      frag.programDateTime = null;\n      frag.rawProgramDateTime = null;\n    }\n  }\n  function setInitSegment(frag, mapAttrs, id, levelkeys) {\n    frag.relurl = mapAttrs.URI;\n    if (mapAttrs.BYTERANGE) {\n      frag.setByteRange(mapAttrs.BYTERANGE);\n    }\n    frag.level = id;\n    frag.sn = 'initSegment';\n    if (levelkeys) {\n      frag.levelkeys = levelkeys;\n    }\n    frag.initSegment = null;\n  }\n  function setFragLevelKeys(frag, levelkeys, level) {\n    frag.levelkeys = levelkeys;\n    var encryptedFragments = level.encryptedFragments;\n    if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(function (format) {\n      return levelkeys[format].isCommonEncryption;\n    })) {\n      encryptedFragments.push(frag);\n    }\n  }\n\n  var PlaylistContextType = {\n    MANIFEST: \"manifest\",\n    LEVEL: \"level\",\n    AUDIO_TRACK: \"audioTrack\",\n    SUBTITLE_TRACK: \"subtitleTrack\"\n  };\n  var PlaylistLevelType = {\n    MAIN: \"main\",\n    AUDIO: \"audio\",\n    SUBTITLE: \"subtitle\"\n  };\n\n  function mapContextToLevelType(context) {\n    var type = context.type;\n    switch (type) {\n      case PlaylistContextType.AUDIO_TRACK:\n        return PlaylistLevelType.AUDIO;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        return PlaylistLevelType.SUBTITLE;\n      default:\n        return PlaylistLevelType.MAIN;\n    }\n  }\n  function getResponseUrl(response, context) {\n    var url = response.url;\n    // responseURL not supported on some browsers (it is used to detect URL redirection)\n    // data-uri mode also not supported (but no need to detect redirection)\n    if (url === undefined || url.indexOf('data:') === 0) {\n      // fallback to initial URL\n      url = context.url;\n    }\n    return url;\n  }\n  var PlaylistLoader = /*#__PURE__*/function () {\n    function PlaylistLoader(hls) {\n      this.hls = void 0;\n      this.loaders = Object.create(null);\n      this.variableList = null;\n      this.hls = hls;\n      this.registerListeners();\n    }\n    var _proto = PlaylistLoader.prototype;\n    _proto.startLoad = function startLoad(startPosition) {};\n    _proto.stopLoad = function stopLoad() {\n      this.destroyInternalLoaders();\n    };\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n      hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n      hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n    }\n\n    /**\n     * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n     */;\n    _proto.createInternalLoader = function createInternalLoader(context) {\n      var config = this.hls.config;\n      var PLoader = config.pLoader;\n      var Loader = config.loader;\n      var InternalLoader = PLoader || Loader;\n      var loader = new InternalLoader(config);\n      this.loaders[context.type] = loader;\n      return loader;\n    };\n    _proto.getInternalLoader = function getInternalLoader(context) {\n      return this.loaders[context.type];\n    };\n    _proto.resetInternalLoader = function resetInternalLoader(contextType) {\n      if (this.loaders[contextType]) {\n        delete this.loaders[contextType];\n      }\n    }\n\n    /**\n     * Call `destroy` on all internal loader instances mapped (one per context type)\n     */;\n    _proto.destroyInternalLoaders = function destroyInternalLoaders() {\n      for (var contextType in this.loaders) {\n        var loader = this.loaders[contextType];\n        if (loader) {\n          loader.destroy();\n        }\n        this.resetInternalLoader(contextType);\n      }\n    };\n    _proto.destroy = function destroy() {\n      this.variableList = null;\n      this.unregisterListeners();\n      this.destroyInternalLoaders();\n    };\n    _proto.onManifestLoading = function onManifestLoading(event, data) {\n      var url = data.url;\n      this.variableList = null;\n      this.load({\n        id: null,\n        level: 0,\n        responseType: 'text',\n        type: PlaylistContextType.MANIFEST,\n        url: url,\n        deliveryDirectives: null\n      });\n    };\n    _proto.onLevelLoading = function onLevelLoading(event, data) {\n      var id = data.id,\n        level = data.level,\n        pathwayId = data.pathwayId,\n        url = data.url,\n        deliveryDirectives = data.deliveryDirectives;\n      this.load({\n        id: id,\n        level: level,\n        pathwayId: pathwayId,\n        responseType: 'text',\n        type: PlaylistContextType.LEVEL,\n        url: url,\n        deliveryDirectives: deliveryDirectives\n      });\n    };\n    _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {\n      var id = data.id,\n        groupId = data.groupId,\n        url = data.url,\n        deliveryDirectives = data.deliveryDirectives;\n      this.load({\n        id: id,\n        groupId: groupId,\n        level: null,\n        responseType: 'text',\n        type: PlaylistContextType.AUDIO_TRACK,\n        url: url,\n        deliveryDirectives: deliveryDirectives\n      });\n    };\n    _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {\n      var id = data.id,\n        groupId = data.groupId,\n        url = data.url,\n        deliveryDirectives = data.deliveryDirectives;\n      this.load({\n        id: id,\n        groupId: groupId,\n        level: null,\n        responseType: 'text',\n        type: PlaylistContextType.SUBTITLE_TRACK,\n        url: url,\n        deliveryDirectives: deliveryDirectives\n      });\n    };\n    _proto.load = function load(context) {\n      var _context$deliveryDire,\n        _this = this;\n      var config = this.hls.config;\n\n      // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n\n      // Check if a loader for this context already exists\n      var loader = this.getInternalLoader(context);\n      if (loader) {\n        var loaderContext = loader.context;\n        if (loaderContext && loaderContext.url === context.url && loaderContext.level === context.level) {\n          // same URL can't overlap\n          logger.trace('[playlist-loader]: playlist request ongoing');\n          return;\n        }\n        logger.log(\"[playlist-loader]: aborting previous loader for type: \" + context.type);\n        loader.abort();\n      }\n\n      // apply different configs for retries depending on\n      // context (manifest, level, audio/subs playlist)\n      var loadPolicy;\n      if (context.type === PlaylistContextType.MANIFEST) {\n        loadPolicy = config.manifestLoadPolicy.default;\n      } else {\n        loadPolicy = _extends({}, config.playlistLoadPolicy.default, {\n          timeoutRetry: null,\n          errorRetry: null\n        });\n      }\n      loader = this.createInternalLoader(context);\n\n      // Override level/track timeout for LL-HLS requests\n      // (the default of 10000ms is counter productive to blocking playlist reload requests)\n      if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? void 0 : _context$deliveryDire.part)) {\n        var levelDetails;\n        if (context.type === PlaylistContextType.LEVEL && context.level !== null) {\n          levelDetails = this.hls.levels[context.level].details;\n        } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {\n          levelDetails = this.hls.audioTracks[context.id].details;\n        } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {\n          levelDetails = this.hls.subtitleTracks[context.id].details;\n        }\n        if (levelDetails) {\n          var partTarget = levelDetails.partTarget;\n          var targetDuration = levelDetails.targetduration;\n          if (partTarget && targetDuration) {\n            var maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;\n            loadPolicy = _extends({}, loadPolicy, {\n              maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),\n              maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)\n            });\n          }\n        }\n      }\n      var legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n      var loaderConfig = {\n        loadPolicy: loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n        retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n        maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n      };\n      var loaderCallbacks = {\n        onSuccess: function onSuccess(response, stats, context, networkDetails) {\n          var loader = _this.getInternalLoader(context);\n          _this.resetInternalLoader(context.type);\n          var string = response.data;\n\n          // Validate if it is an M3U8 at all\n          if (string.indexOf('#EXTM3U') !== 0) {\n            _this.handleManifestParsingError(response, context, new Error('no EXTM3U delimiter'), networkDetails || null, stats);\n            return;\n          }\n          stats.parsing.start = performance.now();\n          if (M3U8Parser.isMediaPlaylist(string)) {\n            _this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);\n          } else {\n            _this.handleMasterPlaylist(response, stats, context, networkDetails);\n          }\n        },\n        onError: function onError(response, context, networkDetails, stats) {\n          _this.handleNetworkError(context, networkDetails, false, response, stats);\n        },\n        onTimeout: function onTimeout(stats, context, networkDetails) {\n          _this.handleNetworkError(context, networkDetails, true, undefined, stats);\n        }\n      };\n\n      // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n\n      loader.load(context, loaderConfig, loaderCallbacks);\n    };\n    _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {\n      var hls = this.hls;\n      var string = response.data;\n      var url = getResponseUrl(response, context);\n      var parsedResult = M3U8Parser.parseMasterPlaylist(string, url);\n      if (parsedResult.playlistParsingError) {\n        this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);\n        return;\n      }\n      var contentSteering = parsedResult.contentSteering,\n        levels = parsedResult.levels,\n        sessionData = parsedResult.sessionData,\n        sessionKeys = parsedResult.sessionKeys,\n        startTimeOffset = parsedResult.startTimeOffset,\n        variableList = parsedResult.variableList;\n      this.variableList = variableList;\n      var _M3U8Parser$parseMast = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult),\n        _M3U8Parser$parseMast2 = _M3U8Parser$parseMast.AUDIO,\n        audioTracks = _M3U8Parser$parseMast2 === void 0 ? [] : _M3U8Parser$parseMast2,\n        subtitles = _M3U8Parser$parseMast.SUBTITLES,\n        captions = _M3U8Parser$parseMast['CLOSED-CAPTIONS'];\n      if (audioTracks.length) {\n        // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n        var embeddedAudioFound = audioTracks.some(function (audioTrack) {\n          return !audioTrack.url;\n        });\n\n        // if no embedded audio track defined, but audio codec signaled in quality level,\n        // we need to signal this main audio track this could happen with playlists with\n        // alt audio rendition in which quality levels (main)\n        // contains both audio+video. but with mixed audio track not signaled\n        if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n          logger.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');\n          audioTracks.unshift({\n            type: 'main',\n            name: 'main',\n            groupId: 'main',\n            default: false,\n            autoselect: false,\n            forced: false,\n            id: -1,\n            attrs: new AttrList({}),\n            bitrate: 0,\n            url: ''\n          });\n        }\n      }\n      hls.trigger(Events.MANIFEST_LOADED, {\n        levels: levels,\n        audioTracks: audioTracks,\n        subtitles: subtitles,\n        captions: captions,\n        contentSteering: contentSteering,\n        url: url,\n        stats: stats,\n        networkDetails: networkDetails,\n        sessionData: sessionData,\n        sessionKeys: sessionKeys,\n        startTimeOffset: startTimeOffset,\n        variableList: variableList\n      });\n    };\n    _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {\n      var hls = this.hls;\n      var id = context.id,\n        level = context.level,\n        type = context.type;\n      var url = getResponseUrl(response, context);\n      var levelUrlId = 0;\n      var levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;\n      var levelType = mapContextToLevelType(context);\n      var levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);\n\n      // We have done our first request (Manifest-type) and receive\n      // not a master playlist but a chunk-list (track/level)\n      // We fire the manifest-loaded event anyway with the parsed level-details\n      // by creating a single-level structure for it.\n      if (type === PlaylistContextType.MANIFEST) {\n        var singleLevel = {\n          attrs: new AttrList({}),\n          bitrate: 0,\n          details: levelDetails,\n          name: '',\n          url: url\n        };\n        hls.trigger(Events.MANIFEST_LOADED, {\n          levels: [singleLevel],\n          audioTracks: [],\n          url: url,\n          stats: stats,\n          networkDetails: networkDetails,\n          sessionData: null,\n          sessionKeys: null,\n          contentSteering: null,\n          startTimeOffset: null,\n          variableList: null\n        });\n      }\n\n      // save parsing time\n      stats.parsing.end = performance.now();\n\n      // extend the context with the new levelDetails property\n      context.levelDetails = levelDetails;\n      this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);\n    };\n    _proto.handleManifestParsingError = function handleManifestParsingError(response, context, error, networkDetails, stats) {\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.MANIFEST_PARSING_ERROR,\n        fatal: context.type === PlaylistContextType.MANIFEST,\n        url: response.url,\n        err: error,\n        error: error,\n        reason: error.message,\n        response: response,\n        context: context,\n        networkDetails: networkDetails,\n        stats: stats\n      });\n    };\n    _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response, stats) {\n      if (timeout === void 0) {\n        timeout = false;\n      }\n      var message = \"A network \" + (timeout ? 'timeout' : 'error' + (response ? ' (status ' + response.code + ')' : '')) + \" occurred while loading \" + context.type;\n      if (context.type === PlaylistContextType.LEVEL) {\n        message += \": \" + context.level + \" id: \" + context.id;\n      } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {\n        message += \" id: \" + context.id + \" group-id: \\\"\" + context.groupId + \"\\\"\";\n      }\n      var error = new Error(message);\n      logger.warn(\"[playlist-loader]: \" + message);\n      var details = ErrorDetails.UNKNOWN;\n      var fatal = false;\n      var loader = this.getInternalLoader(context);\n      switch (context.type) {\n        case PlaylistContextType.MANIFEST:\n          details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;\n          fatal = true;\n          break;\n        case PlaylistContextType.LEVEL:\n          details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;\n          fatal = false;\n          break;\n        case PlaylistContextType.AUDIO_TRACK:\n          details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n          fatal = false;\n          break;\n        case PlaylistContextType.SUBTITLE_TRACK:\n          details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;\n          fatal = false;\n          break;\n      }\n      if (loader) {\n        this.resetInternalLoader(context.type);\n      }\n      var errorData = {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: details,\n        fatal: fatal,\n        url: context.url,\n        loader: loader,\n        context: context,\n        error: error,\n        networkDetails: networkDetails,\n        stats: stats\n      };\n      if (response) {\n        var url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;\n        errorData.response = _objectSpread2({\n          url: url,\n          data: undefined\n        }, response);\n      }\n      this.hls.trigger(Events.ERROR, errorData);\n    };\n    _proto.handlePlaylistLoaded = function handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {\n      var hls = this.hls;\n      var type = context.type,\n        level = context.level,\n        id = context.id,\n        groupId = context.groupId,\n        deliveryDirectives = context.deliveryDirectives;\n      var url = getResponseUrl(response, context);\n      var parent = mapContextToLevelType(context);\n      var levelIndex = typeof context.level === 'number' && parent === PlaylistLevelType.MAIN ? level : undefined;\n      if (!levelDetails.fragments.length) {\n        var _error = new Error('No Segments found in Playlist');\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.NETWORK_ERROR,\n          details: ErrorDetails.LEVEL_EMPTY_ERROR,\n          fatal: false,\n          url: url,\n          error: _error,\n          reason: _error.message,\n          response: response,\n          context: context,\n          level: levelIndex,\n          parent: parent,\n          networkDetails: networkDetails,\n          stats: stats\n        });\n        return;\n      }\n      if (!levelDetails.targetduration) {\n        levelDetails.playlistParsingError = new Error('Missing Target Duration');\n      }\n      var error = levelDetails.playlistParsingError;\n      if (error) {\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.NETWORK_ERROR,\n          details: ErrorDetails.LEVEL_PARSING_ERROR,\n          fatal: false,\n          url: url,\n          error: error,\n          reason: error.message,\n          response: response,\n          context: context,\n          level: levelIndex,\n          parent: parent,\n          networkDetails: networkDetails,\n          stats: stats\n        });\n        return;\n      }\n      if (levelDetails.live && loader) {\n        if (loader.getCacheAge) {\n          levelDetails.ageHeader = loader.getCacheAge() || 0;\n        }\n        if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n          levelDetails.ageHeader = 0;\n        }\n      }\n      switch (type) {\n        case PlaylistContextType.MANIFEST:\n        case PlaylistContextType.LEVEL:\n          hls.trigger(Events.LEVEL_LOADED, {\n            details: levelDetails,\n            level: levelIndex || 0,\n            id: id || 0,\n            stats: stats,\n            networkDetails: networkDetails,\n            deliveryDirectives: deliveryDirectives\n          });\n          break;\n        case PlaylistContextType.AUDIO_TRACK:\n          hls.trigger(Events.AUDIO_TRACK_LOADED, {\n            details: levelDetails,\n            id: id || 0,\n            groupId: groupId || '',\n            stats: stats,\n            networkDetails: networkDetails,\n            deliveryDirectives: deliveryDirectives\n          });\n          break;\n        case PlaylistContextType.SUBTITLE_TRACK:\n          hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n            details: levelDetails,\n            id: id || 0,\n            groupId: groupId || '',\n            stats: stats,\n            networkDetails: networkDetails,\n            deliveryDirectives: deliveryDirectives\n          });\n          break;\n      }\n    };\n    return PlaylistLoader;\n  }();\n\n  function sendAddTrackEvent(track, videoEl) {\n    var event;\n    try {\n      event = new Event('addtrack');\n    } catch (err) {\n      // for IE11\n      event = document.createEvent('Event');\n      event.initEvent('addtrack', false, false);\n    }\n    event.track = track;\n    videoEl.dispatchEvent(event);\n  }\n  function addCueToTrack(track, cue) {\n    // Sometimes there are cue overlaps on segmented vtts so the same\n    // cue can appear more than once in different vtt files.\n    // This avoid showing duplicated cues with same timecode and text.\n    var mode = track.mode;\n    if (mode === 'disabled') {\n      track.mode = 'hidden';\n    }\n    if (track.cues && !track.cues.getCueById(cue.id)) {\n      try {\n        track.addCue(cue);\n        if (!track.cues.getCueById(cue.id)) {\n          throw new Error(\"addCue is failed for: \" + cue);\n        }\n      } catch (err) {\n        logger.debug(\"[texttrack-utils]: \" + err);\n        try {\n          var textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);\n          textTrackCue.id = cue.id;\n          track.addCue(textTrackCue);\n        } catch (err2) {\n          logger.debug(\"[texttrack-utils]: Legacy TextTrackCue fallback failed: \" + err2);\n        }\n      }\n    }\n    if (mode === 'disabled') {\n      track.mode = mode;\n    }\n  }\n  function clearCurrentCues(track) {\n    // When track.mode is disabled, track.cues will be null.\n    // To guarantee the removal of cues, we need to temporarily\n    // change the mode to hidden\n    var mode = track.mode;\n    if (mode === 'disabled') {\n      track.mode = 'hidden';\n    }\n    if (track.cues) {\n      for (var i = track.cues.length; i--;) {\n        track.removeCue(track.cues[i]);\n      }\n    }\n    if (mode === 'disabled') {\n      track.mode = mode;\n    }\n  }\n  function removeCuesInRange(track, start, end, predicate) {\n    var mode = track.mode;\n    if (mode === 'disabled') {\n      track.mode = 'hidden';\n    }\n    if (track.cues && track.cues.length > 0) {\n      var cues = getCuesInRange(track.cues, start, end);\n      for (var i = 0; i < cues.length; i++) {\n        if (!predicate || predicate(cues[i])) {\n          track.removeCue(cues[i]);\n        }\n      }\n    }\n    if (mode === 'disabled') {\n      track.mode = mode;\n    }\n  }\n\n  // Find first cue starting after given time.\n  // Modified version of binary search O(log(n)).\n  function getFirstCueIndexAfterTime(cues, time) {\n    // If first cue starts after time, start there\n    if (time < cues[0].startTime) {\n      return 0;\n    }\n    // If the last cue ends before time there is no overlap\n    var len = cues.length - 1;\n    if (time > cues[len].endTime) {\n      return -1;\n    }\n    var left = 0;\n    var right = len;\n    while (left <= right) {\n      var mid = Math.floor((right + left) / 2);\n      if (time < cues[mid].startTime) {\n        right = mid - 1;\n      } else if (time > cues[mid].startTime && left < len) {\n        left = mid + 1;\n      } else {\n        // If it's not lower or higher, it must be equal.\n        return mid;\n      }\n    }\n    // At this point, left and right have swapped.\n    // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n    return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n  }\n  function getCuesInRange(cues, start, end) {\n    var cuesFound = [];\n    var firstCueInRange = getFirstCueIndexAfterTime(cues, start);\n    if (firstCueInRange > -1) {\n      for (var i = firstCueInRange, len = cues.length; i < len; i++) {\n        var _cue = cues[i];\n        if (_cue.startTime >= start && _cue.endTime <= end) {\n          cuesFound.push(_cue);\n        } else if (_cue.startTime > end) {\n          return cuesFound;\n        }\n      }\n    }\n    return cuesFound;\n  }\n  function filterSubtitleTracks(textTrackList) {\n    var tracks = [];\n    for (var i = 0; i < textTrackList.length; i++) {\n      var track = textTrackList[i];\n      // Edge adds a track without a label; we don't want to use it\n      if ((track.kind === 'subtitles' || track.kind === 'captions') && track.label) {\n        tracks.push(textTrackList[i]);\n      }\n    }\n    return tracks;\n  }\n\n  var MetadataSchema = {\n    audioId3: \"org.id3\",\n    dateRange: \"com.apple.quicktime.HLS\",\n    emsg: \"https://aomedia.org/emsg/ID3\"\n  };\n\n  var MIN_CUE_DURATION = 0.25;\n  function getCueClass() {\n    if (typeof self === 'undefined') return undefined;\n    return self.VTTCue || self.TextTrackCue;\n  }\n  function createCueWithDataFields(Cue, startTime, endTime, data, type) {\n    var cue = new Cue(startTime, endTime, '');\n    try {\n      cue.value = data;\n      if (type) {\n        cue.type = type;\n      }\n    } catch (e) {\n      cue = new Cue(startTime, endTime, JSON.stringify(type ? _objectSpread2({\n        type: type\n      }, data) : data));\n    }\n    return cue;\n  }\n\n  // VTTCue latest draft allows an infinite duration, fallback\n  // to MAX_VALUE if necessary\n  var MAX_CUE_ENDTIME = function () {\n    var Cue = getCueClass();\n    try {\n      Cue && new Cue(0, Number.POSITIVE_INFINITY, '');\n    } catch (e) {\n      return Number.MAX_VALUE;\n    }\n    return Number.POSITIVE_INFINITY;\n  }();\n  function dateRangeDateToTimelineSeconds(date, offset) {\n    return date.getTime() / 1000 - offset;\n  }\n  function hexToArrayBuffer(str) {\n    return Uint8Array.from(str.replace(/^0x/, '').replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;\n  }\n  var ID3TrackController = /*#__PURE__*/function () {\n    function ID3TrackController(hls) {\n      this.hls = void 0;\n      this.id3Track = null;\n      this.media = null;\n      this.dateRangeCuesAppended = {};\n      this.hls = hls;\n      this._registerListeners();\n    }\n    var _proto = ID3TrackController.prototype;\n    _proto.destroy = function destroy() {\n      this._unregisterListeners();\n      this.id3Track = null;\n      this.media = null;\n      this.dateRangeCuesAppended = {};\n      // @ts-ignore\n      this.hls = null;\n    };\n    _proto._registerListeners = function _registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    };\n    _proto._unregisterListeners = function _unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    }\n\n    // Add ID3 metatadata text track.\n    ;\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      this.media = data.media;\n    };\n    _proto.onMediaDetaching = function onMediaDetaching() {\n      if (!this.id3Track) {\n        return;\n      }\n      clearCurrentCues(this.id3Track);\n      this.id3Track = null;\n      this.media = null;\n      this.dateRangeCuesAppended = {};\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.dateRangeCuesAppended = {};\n    };\n    _proto.createTrack = function createTrack(media) {\n      var track = this.getID3Track(media.textTracks);\n      track.mode = 'hidden';\n      return track;\n    };\n    _proto.getID3Track = function getID3Track(textTracks) {\n      if (!this.media) {\n        return;\n      }\n      for (var i = 0; i < textTracks.length; i++) {\n        var textTrack = textTracks[i];\n        if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {\n          // send 'addtrack' when reusing the textTrack for metadata,\n          // same as what we do for captions\n          sendAddTrackEvent(textTrack, this.media);\n          return textTrack;\n        }\n      }\n      return this.media.addTextTrack('metadata', 'id3');\n    };\n    _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {\n      if (!this.media) {\n        return;\n      }\n      var _this$hls$config = this.hls.config,\n        enableEmsgMetadataCues = _this$hls$config.enableEmsgMetadataCues,\n        enableID3MetadataCues = _this$hls$config.enableID3MetadataCues;\n      if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n        return;\n      }\n      var samples = data.samples;\n\n      // create track dynamically\n      if (!this.id3Track) {\n        this.id3Track = this.createTrack(this.media);\n      }\n      var Cue = getCueClass();\n      if (!Cue) {\n        return;\n      }\n      for (var i = 0; i < samples.length; i++) {\n        var type = samples[i].type;\n        if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n          continue;\n        }\n        var frames = getID3Frames(samples[i].data);\n        if (frames) {\n          var startTime = samples[i].pts;\n          var endTime = startTime + samples[i].duration;\n          if (endTime > MAX_CUE_ENDTIME) {\n            endTime = MAX_CUE_ENDTIME;\n          }\n          var timeDiff = endTime - startTime;\n          if (timeDiff <= 0) {\n            endTime = startTime + MIN_CUE_DURATION;\n          }\n          for (var j = 0; j < frames.length; j++) {\n            var frame = frames[j];\n            // Safari doesn't put the timestamp frame in the TextTrack\n            if (!isTimeStampFrame(frame)) {\n              // add a bounds to any unbounded cues\n              this.updateId3CueEnds(startTime, type);\n              var cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);\n              if (cue) {\n                this.id3Track.addCue(cue);\n              }\n            }\n          }\n        }\n      }\n    };\n    _proto.updateId3CueEnds = function updateId3CueEnds(startTime, type) {\n      var _this$id3Track;\n      var cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;\n      if (cues) {\n        for (var i = cues.length; i--;) {\n          var cue = cues[i];\n          if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {\n            cue.endTime = startTime;\n          }\n        }\n      }\n    };\n    _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {\n      var startOffset = _ref.startOffset,\n        endOffset = _ref.endOffset,\n        type = _ref.type;\n      var id3Track = this.id3Track,\n        hls = this.hls;\n      if (!hls) {\n        return;\n      }\n      var _hls$config = hls.config,\n        enableEmsgMetadataCues = _hls$config.enableEmsgMetadataCues,\n        enableID3MetadataCues = _hls$config.enableID3MetadataCues;\n      if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n        var predicate;\n        if (type === 'audio') {\n          predicate = function predicate(cue) {\n            return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;\n          };\n        } else if (type === 'video') {\n          predicate = function predicate(cue) {\n            return cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n          };\n        } else {\n          predicate = function predicate(cue) {\n            return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n          };\n        }\n        removeCuesInRange(id3Track, startOffset, endOffset, predicate);\n      }\n    };\n    _proto.onLevelUpdated = function onLevelUpdated(event, _ref2) {\n      var _this = this;\n      var details = _ref2.details;\n      if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {\n        return;\n      }\n      var dateRangeCuesAppended = this.dateRangeCuesAppended,\n        id3Track = this.id3Track;\n      var dateRanges = details.dateRanges;\n      var ids = Object.keys(dateRanges);\n      // Remove cues from track not found in details.dateRanges\n      if (id3Track) {\n        var idsToRemove = Object.keys(dateRangeCuesAppended).filter(function (id) {\n          return !ids.includes(id);\n        });\n        var _loop = function _loop() {\n          var id = idsToRemove[i];\n          Object.keys(dateRangeCuesAppended[id].cues).forEach(function (key) {\n            id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);\n          });\n          delete dateRangeCuesAppended[id];\n        };\n        for (var i = idsToRemove.length; i--;) {\n          _loop();\n        }\n      }\n      // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n      var lastFragment = details.fragments[details.fragments.length - 1];\n      if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {\n        return;\n      }\n      if (!this.id3Track) {\n        this.id3Track = this.createTrack(this.media);\n      }\n      var dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;\n      var Cue = getCueClass();\n      var _loop2 = function _loop2() {\n        var id = ids[_i];\n        var dateRange = dateRanges[id];\n        var startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);\n\n        // Process DateRanges to determine end-time (known DURATION, END-DATE, or END-ON-NEXT)\n        var appendedDateRangeCues = dateRangeCuesAppended[id];\n        var cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};\n        var durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;\n        var endTime = MAX_CUE_ENDTIME;\n        var endDate = dateRange.endDate;\n        if (endDate) {\n          endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);\n          durationKnown = true;\n        } else if (dateRange.endOnNext && !durationKnown) {\n          var nextDateRangeWithSameClass = ids.reduce(function (candidateDateRange, id) {\n            if (id !== dateRange.id) {\n              var otherDateRange = dateRanges[id];\n              if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {\n                return otherDateRange;\n              }\n            }\n            return candidateDateRange;\n          }, null);\n          if (nextDateRangeWithSameClass) {\n            endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);\n            durationKnown = true;\n          }\n        }\n\n        // Create TextTrack Cues for each MetadataGroup Item (select DateRange attribute)\n        // This is to emulate Safari HLS playback handling of DateRange tags\n        var attributes = Object.keys(dateRange.attr);\n        for (var j = 0; j < attributes.length; j++) {\n          var key = attributes[j];\n          if (!isDateRangeCueAttribute(key)) {\n            continue;\n          }\n          var cue = cues[key];\n          if (cue) {\n            if (durationKnown && !appendedDateRangeCues.durationKnown) {\n              cue.endTime = endTime;\n            }\n          } else if (Cue) {\n            var data = dateRange.attr[key];\n            if (isSCTE35Attribute(key)) {\n              data = hexToArrayBuffer(data);\n            }\n            var _cue = createCueWithDataFields(Cue, startTime, endTime, {\n              key: key,\n              data: data\n            }, MetadataSchema.dateRange);\n            if (_cue) {\n              _cue.id = id;\n              _this.id3Track.addCue(_cue);\n              cues[key] = _cue;\n            }\n          }\n        }\n\n        // Keep track of processed DateRanges by ID for updating cues with new DateRange tag attributes\n        dateRangeCuesAppended[id] = {\n          cues: cues,\n          dateRange: dateRange,\n          durationKnown: durationKnown\n        };\n      };\n      for (var _i = 0; _i < ids.length; _i++) {\n        _loop2();\n      }\n    };\n    return ID3TrackController;\n  }();\n\n  var LatencyController = /*#__PURE__*/function () {\n    function LatencyController(hls) {\n      var _this = this;\n      this.hls = void 0;\n      this.config = void 0;\n      this.media = null;\n      this.levelDetails = null;\n      this.currentTime = 0;\n      this.stallCount = 0;\n      this._latency = null;\n      this.timeupdateHandler = function () {\n        return _this.timeupdate();\n      };\n      this.hls = hls;\n      this.config = hls.config;\n      this.registerListeners();\n    }\n    var _proto = LatencyController.prototype;\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.onMediaDetaching();\n      this.levelDetails = null;\n      // @ts-ignore\n      this.hls = this.timeupdateHandler = null;\n    };\n    _proto.registerListeners = function registerListeners() {\n      this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      this.hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      this.hls.off(Events.ERROR, this.onError, this);\n    };\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      this.media = data.media;\n      this.media.addEventListener('timeupdate', this.timeupdateHandler);\n    };\n    _proto.onMediaDetaching = function onMediaDetaching() {\n      if (this.media) {\n        this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n        this.media = null;\n      }\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.levelDetails = null;\n      this._latency = null;\n      this.stallCount = 0;\n    };\n    _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {\n      var details = _ref.details;\n      this.levelDetails = details;\n      if (details.advanced) {\n        this.timeupdate();\n      }\n      if (!details.live && this.media) {\n        this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n      }\n    };\n    _proto.onError = function onError(event, data) {\n      var _this$levelDetails;\n      if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {\n        return;\n      }\n      this.stallCount++;\n      if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {\n        logger.warn('[playback-rate-controller]: Stall detected, adjusting target latency');\n      }\n    };\n    _proto.timeupdate = function timeupdate() {\n      var media = this.media,\n        levelDetails = this.levelDetails;\n      if (!media || !levelDetails) {\n        return;\n      }\n      this.currentTime = media.currentTime;\n      var latency = this.computeLatency();\n      if (latency === null) {\n        return;\n      }\n      this._latency = latency;\n\n      // Adapt playbackRate to meet target latency in low-latency mode\n      var _this$config = this.config,\n        lowLatencyMode = _this$config.lowLatencyMode,\n        maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;\n      if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {\n        return;\n      }\n      var targetLatency = this.targetLatency;\n      if (targetLatency === null) {\n        return;\n      }\n      var distanceFromTarget = latency - targetLatency;\n      // Only adjust playbackRate when within one target duration of targetLatency\n      // and more than one second from under-buffering.\n      // Playback further than one target duration from target can be considered DVR playback.\n      var liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n      var inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n      if (inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n        var max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n        var rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n        media.playbackRate = Math.min(max, Math.max(1, rate));\n      } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n        media.playbackRate = 1;\n      }\n    };\n    _proto.estimateLiveEdge = function estimateLiveEdge() {\n      var levelDetails = this.levelDetails;\n      if (levelDetails === null) {\n        return null;\n      }\n      return levelDetails.edge + levelDetails.age;\n    };\n    _proto.computeLatency = function computeLatency() {\n      var liveEdge = this.estimateLiveEdge();\n      if (liveEdge === null) {\n        return null;\n      }\n      return liveEdge - this.currentTime;\n    };\n    _createClass(LatencyController, [{\n      key: \"latency\",\n      get: function get() {\n        return this._latency || 0;\n      }\n    }, {\n      key: \"maxLatency\",\n      get: function get() {\n        var config = this.config,\n          levelDetails = this.levelDetails;\n        if (config.liveMaxLatencyDuration !== undefined) {\n          return config.liveMaxLatencyDuration;\n        }\n        return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n      }\n    }, {\n      key: \"targetLatency\",\n      get: function get() {\n        var levelDetails = this.levelDetails;\n        if (levelDetails === null) {\n          return null;\n        }\n        var holdBack = levelDetails.holdBack,\n          partHoldBack = levelDetails.partHoldBack,\n          targetduration = levelDetails.targetduration;\n        var _this$config2 = this.config,\n          liveSyncDuration = _this$config2.liveSyncDuration,\n          liveSyncDurationCount = _this$config2.liveSyncDurationCount,\n          lowLatencyMode = _this$config2.lowLatencyMode;\n        var userConfig = this.hls.userConfig;\n        var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n        if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n          targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n        }\n        var maxLiveSyncOnStallIncrease = targetduration;\n        var liveSyncOnStallIncrease = 1.0;\n        return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n      }\n    }, {\n      key: \"liveSyncPosition\",\n      get: function get() {\n        var liveEdge = this.estimateLiveEdge();\n        var targetLatency = this.targetLatency;\n        var levelDetails = this.levelDetails;\n        if (liveEdge === null || targetLatency === null || levelDetails === null) {\n          return null;\n        }\n        var edge = levelDetails.edge;\n        var syncPosition = liveEdge - targetLatency - this.edgeStalled;\n        var min = edge - levelDetails.totalduration;\n        var max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n        return Math.min(Math.max(min, syncPosition), max);\n      }\n    }, {\n      key: \"drift\",\n      get: function get() {\n        var levelDetails = this.levelDetails;\n        if (levelDetails === null) {\n          return 1;\n        }\n        return levelDetails.drift;\n      }\n    }, {\n      key: \"edgeStalled\",\n      get: function get() {\n        var levelDetails = this.levelDetails;\n        if (levelDetails === null) {\n          return 0;\n        }\n        var maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n        return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n      }\n    }, {\n      key: \"forwardBufferLength\",\n      get: function get() {\n        var media = this.media,\n          levelDetails = this.levelDetails;\n        if (!media || !levelDetails) {\n          return 0;\n        }\n        var bufferedRanges = media.buffered.length;\n        return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n      }\n    }]);\n    return LatencyController;\n  }();\n\n  var HdcpLevels = ['NONE', 'TYPE-0', 'TYPE-1', null];\n  function isHdcpLevel(value) {\n    return HdcpLevels.indexOf(value) > -1;\n  }\n  var VideoRangeValues = ['SDR', 'PQ', 'HLG'];\n  function isVideoRange(value) {\n    return !!value && VideoRangeValues.indexOf(value) > -1;\n  }\n  var HlsSkip = {\n    No: \"\",\n    Yes: \"YES\",\n    v2: \"v2\"\n  };\n  function getSkipValue(details) {\n    var canSkipUntil = details.canSkipUntil,\n      canSkipDateRanges = details.canSkipDateRanges,\n      age = details.age;\n    // A Client SHOULD NOT request a Playlist Delta Update unless it already\n    // has a version of the Playlist that is no older than one-half of the Skip Boundary.\n    // @see: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-6.3.7\n    var playlistRecentEnough = age < canSkipUntil / 2;\n    if (canSkipUntil && playlistRecentEnough) {\n      if (canSkipDateRanges) {\n        return HlsSkip.v2;\n      }\n      return HlsSkip.Yes;\n    }\n    return HlsSkip.No;\n  }\n  var HlsUrlParameters = /*#__PURE__*/function () {\n    function HlsUrlParameters(msn, part, skip) {\n      this.msn = void 0;\n      this.part = void 0;\n      this.skip = void 0;\n      this.msn = msn;\n      this.part = part;\n      this.skip = skip;\n    }\n    var _proto = HlsUrlParameters.prototype;\n    _proto.addDirectives = function addDirectives(uri) {\n      var url = new self.URL(uri);\n      if (this.msn !== undefined) {\n        url.searchParams.set('_HLS_msn', this.msn.toString());\n      }\n      if (this.part !== undefined) {\n        url.searchParams.set('_HLS_part', this.part.toString());\n      }\n      if (this.skip) {\n        url.searchParams.set('_HLS_skip', this.skip);\n      }\n      return url.href;\n    };\n    return HlsUrlParameters;\n  }();\n  var Level = /*#__PURE__*/function () {\n    function Level(data) {\n      this._attrs = void 0;\n      this.audioCodec = void 0;\n      this.bitrate = void 0;\n      this.codecSet = void 0;\n      this.url = void 0;\n      this.frameRate = void 0;\n      this.height = void 0;\n      this.id = void 0;\n      this.name = void 0;\n      this.videoCodec = void 0;\n      this.width = void 0;\n      this.details = void 0;\n      this.fragmentError = 0;\n      this.loadError = 0;\n      this.loaded = void 0;\n      this.realBitrate = 0;\n      this.supportedPromise = void 0;\n      this.supportedResult = void 0;\n      this._avgBitrate = 0;\n      this._audioGroups = void 0;\n      this._subtitleGroups = void 0;\n      // Deprecated (retained for backwards compatibility)\n      this._urlId = 0;\n      this.url = [data.url];\n      this._attrs = [data.attrs];\n      this.bitrate = data.bitrate;\n      if (data.details) {\n        this.details = data.details;\n      }\n      this.id = data.id || 0;\n      this.name = data.name;\n      this.width = data.width || 0;\n      this.height = data.height || 0;\n      this.frameRate = data.attrs.optionalFloat('FRAME-RATE', 0);\n      this._avgBitrate = data.attrs.decimalInteger('AVERAGE-BANDWIDTH');\n      this.audioCodec = data.audioCodec;\n      this.videoCodec = data.videoCodec;\n      this.codecSet = [data.videoCodec, data.audioCodec].filter(function (c) {\n        return !!c;\n      }).map(function (s) {\n        return s.substring(0, 4);\n      }).join(',');\n      this.addGroupId('audio', data.attrs.AUDIO);\n      this.addGroupId('text', data.attrs.SUBTITLES);\n    }\n    var _proto2 = Level.prototype;\n    _proto2.hasAudioGroup = function hasAudioGroup(groupId) {\n      return hasGroup(this._audioGroups, groupId);\n    };\n    _proto2.hasSubtitleGroup = function hasSubtitleGroup(groupId) {\n      return hasGroup(this._subtitleGroups, groupId);\n    };\n    _proto2.addGroupId = function addGroupId(type, groupId) {\n      if (!groupId) {\n        return;\n      }\n      if (type === 'audio') {\n        var audioGroups = this._audioGroups;\n        if (!audioGroups) {\n          audioGroups = this._audioGroups = [];\n        }\n        if (audioGroups.indexOf(groupId) === -1) {\n          audioGroups.push(groupId);\n        }\n      } else if (type === 'text') {\n        var subtitleGroups = this._subtitleGroups;\n        if (!subtitleGroups) {\n          subtitleGroups = this._subtitleGroups = [];\n        }\n        if (subtitleGroups.indexOf(groupId) === -1) {\n          subtitleGroups.push(groupId);\n        }\n      }\n    }\n\n    // Deprecated methods (retained for backwards compatibility)\n    ;\n    _proto2.addFallback = function addFallback() {};\n    _createClass(Level, [{\n      key: \"maxBitrate\",\n      get: function get() {\n        return Math.max(this.realBitrate, this.bitrate);\n      }\n    }, {\n      key: \"averageBitrate\",\n      get: function get() {\n        return this._avgBitrate || this.realBitrate || this.bitrate;\n      }\n    }, {\n      key: \"attrs\",\n      get: function get() {\n        return this._attrs[0];\n      }\n    }, {\n      key: \"codecs\",\n      get: function get() {\n        return this.attrs.CODECS || '';\n      }\n    }, {\n      key: \"pathwayId\",\n      get: function get() {\n        return this.attrs['PATHWAY-ID'] || '.';\n      }\n    }, {\n      key: \"videoRange\",\n      get: function get() {\n        return this.attrs['VIDEO-RANGE'] || 'SDR';\n      }\n    }, {\n      key: \"score\",\n      get: function get() {\n        return this.attrs.optionalFloat('SCORE', 0);\n      }\n    }, {\n      key: \"uri\",\n      get: function get() {\n        return this.url[0] || '';\n      }\n    }, {\n      key: \"audioGroups\",\n      get: function get() {\n        return this._audioGroups;\n      }\n    }, {\n      key: \"subtitleGroups\",\n      get: function get() {\n        return this._subtitleGroups;\n      }\n    }, {\n      key: \"urlId\",\n      get: function get() {\n        return 0;\n      },\n      set: function set(value) {}\n    }, {\n      key: \"audioGroupIds\",\n      get: function get() {\n        return this.audioGroups ? [this.audioGroupId] : undefined;\n      }\n    }, {\n      key: \"textGroupIds\",\n      get: function get() {\n        return this.subtitleGroups ? [this.textGroupId] : undefined;\n      }\n    }, {\n      key: \"audioGroupId\",\n      get: function get() {\n        var _this$audioGroups;\n        return (_this$audioGroups = this.audioGroups) == null ? void 0 : _this$audioGroups[0];\n      }\n    }, {\n      key: \"textGroupId\",\n      get: function get() {\n        var _this$subtitleGroups;\n        return (_this$subtitleGroups = this.subtitleGroups) == null ? void 0 : _this$subtitleGroups[0];\n      }\n    }]);\n    return Level;\n  }();\n  function hasGroup(groups, groupId) {\n    if (!groupId || !groups) {\n      return false;\n    }\n    return groups.indexOf(groupId) !== -1;\n  }\n\n  function updateFromToPTS(fragFrom, fragTo) {\n    var fragToPTS = fragTo.startPTS;\n    // if we know startPTS[toIdx]\n    if (isFiniteNumber(fragToPTS)) {\n      // update fragment duration.\n      // it helps to fix drifts between playlist reported duration and fragment real duration\n      var duration = 0;\n      var frag;\n      if (fragTo.sn > fragFrom.sn) {\n        duration = fragToPTS - fragFrom.start;\n        frag = fragFrom;\n      } else {\n        duration = fragFrom.start - fragToPTS;\n        frag = fragTo;\n      }\n      if (frag.duration !== duration) {\n        frag.duration = duration;\n      }\n      // we dont know startPTS[toIdx]\n    } else if (fragTo.sn > fragFrom.sn) {\n      var contiguous = fragFrom.cc === fragTo.cc;\n      // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n      if (contiguous && fragFrom.minEndPTS) {\n        fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);\n      } else {\n        fragTo.start = fragFrom.start + fragFrom.duration;\n      }\n    } else {\n      fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);\n    }\n  }\n  function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n    var parsedMediaDuration = endPTS - startPTS;\n    if (parsedMediaDuration <= 0) {\n      logger.warn('Fragment should have a positive duration', frag);\n      endPTS = startPTS + frag.duration;\n      endDTS = startDTS + frag.duration;\n    }\n    var maxStartPTS = startPTS;\n    var minEndPTS = endPTS;\n    var fragStartPts = frag.startPTS;\n    var fragEndPts = frag.endPTS;\n    if (isFiniteNumber(fragStartPts)) {\n      // delta PTS between audio and video\n      var deltaPTS = Math.abs(fragStartPts - startPTS);\n      if (!isFiniteNumber(frag.deltaPTS)) {\n        frag.deltaPTS = deltaPTS;\n      } else {\n        frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n      }\n      maxStartPTS = Math.max(startPTS, fragStartPts);\n      startPTS = Math.min(startPTS, fragStartPts);\n      startDTS = Math.min(startDTS, frag.startDTS);\n      minEndPTS = Math.min(endPTS, fragEndPts);\n      endPTS = Math.max(endPTS, fragEndPts);\n      endDTS = Math.max(endDTS, frag.endDTS);\n    }\n    var drift = startPTS - frag.start;\n    if (frag.start !== 0) {\n      frag.start = startPTS;\n    }\n    frag.duration = endPTS - frag.start;\n    frag.startPTS = startPTS;\n    frag.maxStartPTS = maxStartPTS;\n    frag.startDTS = startDTS;\n    frag.endPTS = endPTS;\n    frag.minEndPTS = minEndPTS;\n    frag.endDTS = endDTS;\n    var sn = frag.sn; // 'initSegment'\n    // exit if sn out of range\n    if (!details || sn < details.startSN || sn > details.endSN) {\n      return 0;\n    }\n    var i;\n    var fragIdx = sn - details.startSN;\n    var fragments = details.fragments;\n    // update frag reference in fragments array\n    // rationale is that fragments array might not contain this frag object.\n    // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n    // if we don't update frag, we won't be able to propagate PTS info on the playlist\n    // resulting in invalid sliding computation\n    fragments[fragIdx] = frag;\n    // adjust fragment PTS/duration from seqnum-1 to frag 0\n    for (i = fragIdx; i > 0; i--) {\n      updateFromToPTS(fragments[i], fragments[i - 1]);\n    }\n\n    // adjust fragment PTS/duration from seqnum to last frag\n    for (i = fragIdx; i < fragments.length - 1; i++) {\n      updateFromToPTS(fragments[i], fragments[i + 1]);\n    }\n    if (details.fragmentHint) {\n      updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n    }\n    details.PTSKnown = details.alignedSliding = true;\n    return drift;\n  }\n  function mergeDetails(oldDetails, newDetails) {\n    // Track the last initSegment processed. Initialize it to the last one on the timeline.\n    var currentInitSegment = null;\n    var oldFragments = oldDetails.fragments;\n    for (var i = oldFragments.length - 1; i >= 0; i--) {\n      var oldInit = oldFragments[i].initSegment;\n      if (oldInit) {\n        currentInitSegment = oldInit;\n        break;\n      }\n    }\n    if (oldDetails.fragmentHint) {\n      // prevent PTS and duration from being adjusted on the next hint\n      delete oldDetails.fragmentHint.endPTS;\n    }\n    // check if old/new playlists have fragments in common\n    // loop through overlapping SN and update startPTS , cc, and duration if any found\n    var ccOffset = 0;\n    var PTSFrag;\n    mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag) {\n      if (oldFrag.relurl) {\n        // Do not compare CC if the old fragment has no url. This is a level.fragmentHint used by LL-HLS parts.\n        // It maybe be off by 1 if it was created before any parts or discontinuity tags were appended to the end\n        // of the playlist.\n        ccOffset = oldFrag.cc - newFrag.cc;\n      }\n      if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {\n        newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n        newFrag.startDTS = oldFrag.startDTS;\n        newFrag.maxStartPTS = oldFrag.maxStartPTS;\n        newFrag.endPTS = oldFrag.endPTS;\n        newFrag.endDTS = oldFrag.endDTS;\n        newFrag.minEndPTS = oldFrag.minEndPTS;\n        newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;\n        if (newFrag.duration) {\n          PTSFrag = newFrag;\n        }\n\n        // PTS is known when any segment has startPTS and endPTS\n        newDetails.PTSKnown = newDetails.alignedSliding = true;\n      }\n      newFrag.elementaryStreams = oldFrag.elementaryStreams;\n      newFrag.loader = oldFrag.loader;\n      newFrag.stats = oldFrag.stats;\n      if (oldFrag.initSegment) {\n        newFrag.initSegment = oldFrag.initSegment;\n        currentInitSegment = oldFrag.initSegment;\n      }\n    });\n    if (currentInitSegment) {\n      var fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n      fragmentsToCheck.forEach(function (frag) {\n        var _currentInitSegment;\n        if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl))) {\n          frag.initSegment = currentInitSegment;\n        }\n      });\n    }\n    if (newDetails.skippedSegments) {\n      newDetails.deltaUpdateFailed = newDetails.fragments.some(function (frag) {\n        return !frag;\n      });\n      if (newDetails.deltaUpdateFailed) {\n        logger.warn('[level-helper] Previous playlist missing segments skipped in delta playlist');\n        for (var _i = newDetails.skippedSegments; _i--;) {\n          newDetails.fragments.shift();\n        }\n        newDetails.startSN = newDetails.fragments[0].sn;\n        newDetails.startCC = newDetails.fragments[0].cc;\n      } else if (newDetails.canSkipDateRanges) {\n        newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);\n      }\n    }\n    var newFragments = newDetails.fragments;\n    if (ccOffset) {\n      logger.warn('discontinuity sliding from playlist, take drift into account');\n      for (var _i2 = 0; _i2 < newFragments.length; _i2++) {\n        newFragments[_i2].cc += ccOffset;\n      }\n    }\n    if (newDetails.skippedSegments) {\n      newDetails.startCC = newDetails.fragments[0].cc;\n    }\n\n    // Merge parts\n    mapPartIntersection(oldDetails.partList, newDetails.partList, function (oldPart, newPart) {\n      newPart.elementaryStreams = oldPart.elementaryStreams;\n      newPart.stats = oldPart.stats;\n    });\n\n    // if at least one fragment contains PTS info, recompute PTS information for all fragments\n    if (PTSFrag) {\n      updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n    } else {\n      // ensure that delta is within oldFragments range\n      // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n      // in that case we also need to adjust start offset of all fragments\n      adjustSliding(oldDetails, newDetails);\n    }\n    if (newFragments.length) {\n      newDetails.totalduration = newDetails.edge - newFragments[0].start;\n    }\n    newDetails.driftStartTime = oldDetails.driftStartTime;\n    newDetails.driftStart = oldDetails.driftStart;\n    var advancedDateTime = newDetails.advancedDateTime;\n    if (newDetails.advanced && advancedDateTime) {\n      var edge = newDetails.edge;\n      if (!newDetails.driftStart) {\n        newDetails.driftStartTime = advancedDateTime;\n        newDetails.driftStart = edge;\n      }\n      newDetails.driftEndTime = advancedDateTime;\n      newDetails.driftEnd = edge;\n    } else {\n      newDetails.driftEndTime = oldDetails.driftEndTime;\n      newDetails.driftEnd = oldDetails.driftEnd;\n      newDetails.advancedDateTime = oldDetails.advancedDateTime;\n    }\n  }\n  function mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {\n    var dateRanges = _extends({}, oldDateRanges);\n    if (recentlyRemovedDateranges) {\n      recentlyRemovedDateranges.forEach(function (id) {\n        delete dateRanges[id];\n      });\n    }\n    Object.keys(deltaDateRanges).forEach(function (id) {\n      var dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);\n      if (dateRange.isValid) {\n        dateRanges[id] = dateRange;\n      } else {\n        logger.warn(\"Ignoring invalid Playlist Delta Update DATERANGE tag: \\\"\" + JSON.stringify(deltaDateRanges[id].attr) + \"\\\"\");\n      }\n    });\n    return dateRanges;\n  }\n  function mapPartIntersection(oldParts, newParts, intersectionFn) {\n    if (oldParts && newParts) {\n      var delta = 0;\n      for (var i = 0, len = oldParts.length; i <= len; i++) {\n        var _oldPart = oldParts[i];\n        var _newPart = newParts[i + delta];\n        if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {\n          intersectionFn(_oldPart, _newPart);\n        } else {\n          delta--;\n        }\n      }\n    }\n  }\n  function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n    var skippedSegments = newDetails.skippedSegments;\n    var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n    var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n    var delta = newDetails.startSN - oldDetails.startSN;\n    var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n    var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n    for (var i = start; i <= end; i++) {\n      var _oldFrag = oldFrags[delta + i];\n      var _newFrag = newFrags[i];\n      if (skippedSegments && !_newFrag && i < skippedSegments) {\n        // Fill in skipped segments in delta playlist\n        _newFrag = newDetails.fragments[i] = _oldFrag;\n      }\n      if (_oldFrag && _newFrag) {\n        intersectionFn(_oldFrag, _newFrag);\n      }\n    }\n  }\n  function adjustSliding(oldDetails, newDetails) {\n    var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n    var oldFragments = oldDetails.fragments;\n    if (delta < 0 || delta >= oldFragments.length) {\n      return;\n    }\n    addSliding(newDetails, oldFragments[delta].start);\n  }\n  function addSliding(details, start) {\n    if (start) {\n      var fragments = details.fragments;\n      for (var i = details.skippedSegments; i < fragments.length; i++) {\n        fragments[i].start += start;\n      }\n      if (details.fragmentHint) {\n        details.fragmentHint.start += start;\n      }\n    }\n  }\n  function computeReloadInterval(newDetails, distanceToLiveEdgeMs) {\n    if (distanceToLiveEdgeMs === void 0) {\n      distanceToLiveEdgeMs = Infinity;\n    }\n    var reloadInterval = 1000 * newDetails.targetduration;\n    if (newDetails.updated) {\n      // Use last segment duration when shorter than target duration and near live edge\n      var fragments = newDetails.fragments;\n      var liveEdgeMaxTargetDurations = 4;\n      if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {\n        var lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;\n        if (lastSegmentDuration < reloadInterval) {\n          reloadInterval = lastSegmentDuration;\n        }\n      }\n    } else {\n      // estimate = 'miss half average';\n      // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n      // changed then it MUST wait for a period of one-half the target\n      // duration before retrying.\n      reloadInterval /= 2;\n    }\n    return Math.round(reloadInterval);\n  }\n  function getFragmentWithSN(level, sn, fragCurrent) {\n    if (!(level != null && level.details)) {\n      return null;\n    }\n    var levelDetails = level.details;\n    var fragment = levelDetails.fragments[sn - levelDetails.startSN];\n    if (fragment) {\n      return fragment;\n    }\n    fragment = levelDetails.fragmentHint;\n    if (fragment && fragment.sn === sn) {\n      return fragment;\n    }\n    if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {\n      return fragCurrent;\n    }\n    return null;\n  }\n  function getPartWith(level, sn, partIndex) {\n    var _level$details;\n    if (!(level != null && level.details)) {\n      return null;\n    }\n    return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn, partIndex);\n  }\n  function findPart(partList, sn, partIndex) {\n    if (partList) {\n      for (var i = partList.length; i--;) {\n        var part = partList[i];\n        if (part.index === partIndex && part.fragment.sn === sn) {\n          return part;\n        }\n      }\n    }\n    return null;\n  }\n  function reassignFragmentLevelIndexes(levels) {\n    levels.forEach(function (level, index) {\n      var details = level.details;\n      if (details != null && details.fragments) {\n        details.fragments.forEach(function (fragment) {\n          fragment.level = index;\n        });\n      }\n    });\n  }\n\n  function isTimeoutError(error) {\n    switch (error.details) {\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n      case ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n        return true;\n    }\n    return false;\n  }\n  function getRetryConfig(loadPolicy, error) {\n    var isTimeout = isTimeoutError(error);\n    return loadPolicy.default[(isTimeout ? 'timeout' : 'error') + \"Retry\"];\n  }\n  function getRetryDelay(retryConfig, retryCount) {\n    // exponential backoff capped to max retry delay\n    var backoffFactor = retryConfig.backoff === 'linear' ? 1 : Math.pow(2, retryCount);\n    return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);\n  }\n  function getLoaderConfigWithoutReties(loderConfig) {\n    return _objectSpread2(_objectSpread2({}, loderConfig), {\n      errorRetry: null,\n      timeoutRetry: null\n    });\n  }\n  function shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {\n    if (!retryConfig) {\n      return false;\n    }\n    var httpStatus = loaderResponse == null ? void 0 : loaderResponse.code;\n    var retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);\n    return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;\n  }\n  function retryForHttpStatus(httpStatus) {\n    // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)\n    return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);\n  }\n\n  var BinarySearch = {\n    /**\n     * Searches for an item in an array which matches a certain condition.\n     * This requires the condition to only match one item in the array,\n     * and for the array to be ordered.\n     *\n     * @param list The array to search.\n     * @param comparisonFn\n     *      Called and provided a candidate item as the first argument.\n     *      Should return:\n     *          > -1 if the item should be located at a lower index than the provided item.\n     *          > 1 if the item should be located at a higher index than the provided item.\n     *          > 0 if the item is the item you're looking for.\n     *\n     * @returns the object if found, otherwise returns null\n     */\n    search: function search(list, comparisonFn) {\n      var minIndex = 0;\n      var maxIndex = list.length - 1;\n      var currentIndex = null;\n      var currentElement = null;\n      while (minIndex <= maxIndex) {\n        currentIndex = (minIndex + maxIndex) / 2 | 0;\n        currentElement = list[currentIndex];\n        var comparisonResult = comparisonFn(currentElement);\n        if (comparisonResult > 0) {\n          minIndex = currentIndex + 1;\n        } else if (comparisonResult < 0) {\n          maxIndex = currentIndex - 1;\n        } else {\n          return currentElement;\n        }\n      }\n      return null;\n    }\n  };\n\n  /**\n   * Returns first fragment whose endPdt value exceeds the given PDT, or null.\n   * @param fragments - The array of candidate fragments\n   * @param PDTValue - The PDT value which must be exceeded\n   * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n   */\n  function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n    if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {\n      return null;\n    }\n\n    // if less than start\n    var startPDT = fragments[0].programDateTime;\n    if (PDTValue < (startPDT || 0)) {\n      return null;\n    }\n    var endPDT = fragments[fragments.length - 1].endProgramDateTime;\n    if (PDTValue >= (endPDT || 0)) {\n      return null;\n    }\n    maxFragLookUpTolerance = maxFragLookUpTolerance || 0;\n    for (var seg = 0; seg < fragments.length; ++seg) {\n      var frag = fragments[seg];\n      if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n        return frag;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n   * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n   * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n   * @param fragPrevious - The last frag successfully appended\n   * @param fragments - The array of candidate fragments\n   * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within\n   * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n   * @returns a matching fragment or null\n   */\n  function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance, nextFragLookupTolerance) {\n    if (bufferEnd === void 0) {\n      bufferEnd = 0;\n    }\n    if (maxFragLookUpTolerance === void 0) {\n      maxFragLookUpTolerance = 0;\n    }\n    if (nextFragLookupTolerance === void 0) {\n      nextFragLookupTolerance = 0.005;\n    }\n    var fragNext = null;\n    if (fragPrevious) {\n      fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;\n      // check for buffer-end rounding error\n      var bufferEdgeError = fragPrevious.endDTS - bufferEnd;\n      if (bufferEdgeError > 0 && bufferEdgeError < 0.0000015) {\n        bufferEnd += 0.0000015;\n      }\n    } else if (bufferEnd === 0 && fragments[0].start === 0) {\n      fragNext = fragments[0];\n    }\n    // Prefer the next fragment if it's within tolerance\n    if (fragNext && ((!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0 || fragmentWithinFastStartSwitch(fragNext, fragPrevious, Math.min(nextFragLookupTolerance, maxFragLookUpTolerance)))) {\n      return fragNext;\n    }\n    // We might be seeking past the tolerance so find the best match\n    var foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n    if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {\n      return foundFragment;\n    }\n    // If no match was found return the next fragment after fragPrevious, or null\n    return fragNext;\n  }\n  function fragmentWithinFastStartSwitch(fragNext, fragPrevious, nextFragLookupTolerance) {\n    if (fragPrevious && fragPrevious.start === 0 && fragPrevious.level < fragNext.level && (fragPrevious.endPTS || 0) > 0) {\n      var firstDuration = fragPrevious.tagList.reduce(function (duration, tag) {\n        if (tag[0] === 'INF') {\n          duration += parseFloat(tag[1]);\n        }\n        return duration;\n      }, nextFragLookupTolerance);\n      return fragNext.start <= firstDuration;\n    }\n    return false;\n  }\n\n  /**\n   * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n   * @param candidate - The fragment to test\n   * @param bufferEnd - The end of the current buffered range the playhead is currently within\n   * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n   * @returns 0 if it matches, 1 if too low, -1 if too high\n   */\n  function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {\n    if (bufferEnd === void 0) {\n      bufferEnd = 0;\n    }\n    if (maxFragLookUpTolerance === void 0) {\n      maxFragLookUpTolerance = 0;\n    }\n    // eagerly accept an accurate match (no tolerance)\n    if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {\n      return 0;\n    }\n    // offset should be within fragment boundary - config.maxFragLookUpTolerance\n    // this is to cope with situations like\n    // bufferEnd = 9.991\n    // frag[] : [0,10]\n    // frag[1] : [10,20]\n    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n    //              frag start               frag start+duration\n    //                  |-----------------------------|\n    //              <---\x3e                         <---\x3e\n    //  ...--------\x3e<-----------------------------\x3e<---------....\n    // previous frag         matching fragment         next frag\n    //  return -1             return 0                 return 1\n    // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n    // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n    if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n      return 1;\n    } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n      // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n   * This function tests the candidate's program date time values, as represented in Unix time\n   * @param candidate - The fragment to test\n   * @param pdtBufferEnd - The Unix time representing the end of the current buffered range\n   * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n   * @returns true if contiguous, false otherwise\n   */\n  function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;\n\n    // endProgramDateTime can be null, default to zero\n    var endProgramDateTime = candidate.endProgramDateTime || 0;\n    return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n  }\n  function findFragWithCC(fragments, cc) {\n    return BinarySearch.search(fragments, function (candidate) {\n      if (candidate.cc < cc) {\n        return 1;\n      } else if (candidate.cc > cc) {\n        return -1;\n      } else {\n        return 0;\n      }\n    });\n  }\n\n  var NetworkErrorAction = {\n    DoNothing: 0,\n    SendEndCallback: 1,\n    SendAlternateToPenaltyBox: 2,\n    RemoveAlternatePermanently: 3,\n    InsertDiscontinuity: 4,\n    RetryRequest: 5\n  };\n  var ErrorActionFlags = {\n    None: 0,\n    MoveAllAlternatesMatchingHost: 1,\n    MoveAllAlternatesMatchingHDCP: 2,\n    SwitchToSDR: 4\n  }; // Reserved for future use\n  var ErrorController = /*#__PURE__*/function () {\n    function ErrorController(hls) {\n      this.hls = void 0;\n      this.playlistError = 0;\n      this.penalizedRenditions = {};\n      this.log = void 0;\n      this.warn = void 0;\n      this.error = void 0;\n      this.hls = hls;\n      this.log = logger.log.bind(logger, \"[info]:\");\n      this.warn = logger.warn.bind(logger, \"[warning]:\");\n      this.error = logger.error.bind(logger, \"[error]:\");\n      this.registerListeners();\n    }\n    var _proto = ErrorController.prototype;\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.ERROR, this.onError, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      if (!hls) {\n        return;\n      }\n      hls.off(Events.ERROR, this.onError, this);\n      hls.off(Events.ERROR, this.onErrorOut, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    };\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      // @ts-ignore\n      this.hls = null;\n      this.penalizedRenditions = {};\n    };\n    _proto.startLoad = function startLoad(startPosition) {};\n    _proto.stopLoad = function stopLoad() {\n      this.playlistError = 0;\n    };\n    _proto.getVariantLevelIndex = function getVariantLevelIndex(frag) {\n      return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.playlistError = 0;\n      this.penalizedRenditions = {};\n    };\n    _proto.onLevelUpdated = function onLevelUpdated() {\n      this.playlistError = 0;\n    };\n    _proto.onError = function onError(event, data) {\n      var _data$frag, _data$level;\n      if (data.fatal) {\n        return;\n      }\n      var hls = this.hls;\n      var context = data.context;\n      switch (data.details) {\n        case ErrorDetails.FRAG_LOAD_ERROR:\n        case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case ErrorDetails.KEY_LOAD_ERROR:\n        case ErrorDetails.KEY_LOAD_TIMEOUT:\n          data.errorAction = this.getFragRetryOrSwitchAction(data);\n          return;\n        case ErrorDetails.FRAG_PARSING_ERROR:\n          // ignore empty segment errors marked as gap\n          if ((_data$frag = data.frag) != null && _data$frag.gap) {\n            data.errorAction = {\n              action: NetworkErrorAction.DoNothing,\n              flags: ErrorActionFlags.None\n            };\n            return;\n          }\n        // falls through\n        case ErrorDetails.FRAG_GAP:\n        case ErrorDetails.FRAG_DECRYPT_ERROR:\n          {\n            // Switch level if possible, otherwise allow retry count to reach max error retries\n            data.errorAction = this.getFragRetryOrSwitchAction(data);\n            data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n            return;\n          }\n        case ErrorDetails.LEVEL_EMPTY_ERROR:\n        case ErrorDetails.LEVEL_PARSING_ERROR:\n          {\n            var _data$context, _data$context$levelDe;\n            // Only retry when empty and live\n            var levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n            if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {\n              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);\n            } else {\n              // Escalate to fatal if not retrying or switching\n              data.levelRetry = false;\n              data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n            }\n          }\n          return;\n        case ErrorDetails.LEVEL_LOAD_ERROR:\n        case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n          if (typeof (context == null ? void 0 : context.level) === 'number') {\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);\n          }\n          return;\n        case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n        case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n        case ErrorDetails.SUBTITLE_LOAD_ERROR:\n        case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:\n          if (context) {\n            var level = hls.levels[hls.loadLevel];\n            if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {\n              // Perform Pathway switch or Redundant failover if possible for fastest recovery\n              // otherwise allow playlist retry count to reach max error retries\n              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);\n              data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n              data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;\n              return;\n            }\n          }\n          return;\n        case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n          {\n            var _level = hls.levels[hls.loadLevel];\n            var restrictedHdcpLevel = _level == null ? void 0 : _level.attrs['HDCP-LEVEL'];\n            if (restrictedHdcpLevel) {\n              data.errorAction = {\n                action: NetworkErrorAction.SendAlternateToPenaltyBox,\n                flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,\n                hdcpLevel: restrictedHdcpLevel\n              };\n            } else {\n              this.keySystemError(data);\n            }\n          }\n          return;\n        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n        case ErrorDetails.REMUX_ALLOC_ERROR:\n        case ErrorDetails.BUFFER_APPEND_ERROR:\n          data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);\n          return;\n        case ErrorDetails.INTERNAL_EXCEPTION:\n        case ErrorDetails.BUFFER_APPENDING_ERROR:\n        case ErrorDetails.BUFFER_FULL_ERROR:\n        case ErrorDetails.LEVEL_SWITCH_ERROR:\n        case ErrorDetails.BUFFER_STALLED_ERROR:\n        case ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n        case ErrorDetails.BUFFER_NUDGE_ON_STALL:\n          data.errorAction = {\n            action: NetworkErrorAction.DoNothing,\n            flags: ErrorActionFlags.None\n          };\n          return;\n      }\n      if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {\n        this.keySystemError(data);\n      }\n    };\n    _proto.keySystemError = function keySystemError(data) {\n      var levelIndex = this.getVariantLevelIndex(data.frag);\n      // Do not retry level. Escalate to fatal if switching levels fails.\n      data.levelRetry = false;\n      data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n    };\n    _proto.getPlaylistRetryOrSwitchAction = function getPlaylistRetryOrSwitchAction(data, levelIndex) {\n      var hls = this.hls;\n      var retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);\n      var retryCount = this.playlistError++;\n      var retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);\n      if (retry) {\n        return {\n          action: NetworkErrorAction.RetryRequest,\n          flags: ErrorActionFlags.None,\n          retryConfig: retryConfig,\n          retryCount: retryCount\n        };\n      }\n      var errorAction = this.getLevelSwitchAction(data, levelIndex);\n      if (retryConfig) {\n        errorAction.retryConfig = retryConfig;\n        errorAction.retryCount = retryCount;\n      }\n      return errorAction;\n    };\n    _proto.getFragRetryOrSwitchAction = function getFragRetryOrSwitchAction(data) {\n      var hls = this.hls;\n      // Share fragment error count accross media options (main, audio, subs)\n      // This allows for level based rendition switching when media option assets fail\n      var variantLevelIndex = this.getVariantLevelIndex(data.frag);\n      var level = hls.levels[variantLevelIndex];\n      var _hls$config = hls.config,\n        fragLoadPolicy = _hls$config.fragLoadPolicy,\n        keyLoadPolicy = _hls$config.keyLoadPolicy;\n      var retryConfig = getRetryConfig(data.details.startsWith('key') ? keyLoadPolicy : fragLoadPolicy, data);\n      var fragmentErrors = hls.levels.reduce(function (acc, level) {\n        return acc + level.fragmentError;\n      }, 0);\n      // Switch levels when out of retried or level index out of bounds\n      if (level) {\n        if (data.details !== ErrorDetails.FRAG_GAP) {\n          level.fragmentError++;\n        }\n        var retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);\n        if (retry) {\n          return {\n            action: NetworkErrorAction.RetryRequest,\n            flags: ErrorActionFlags.None,\n            retryConfig: retryConfig,\n            retryCount: fragmentErrors\n          };\n        }\n      }\n      // Reach max retry count, or Missing level reference\n      // Switch to valid index\n      var errorAction = this.getLevelSwitchAction(data, variantLevelIndex);\n      // Add retry details to allow skipping of FRAG_PARSING_ERROR\n      if (retryConfig) {\n        errorAction.retryConfig = retryConfig;\n        errorAction.retryCount = fragmentErrors;\n      }\n      return errorAction;\n    };\n    _proto.getLevelSwitchAction = function getLevelSwitchAction(data, levelIndex) {\n      var hls = this.hls;\n      if (levelIndex === null || levelIndex === undefined) {\n        levelIndex = hls.loadLevel;\n      }\n      var level = this.hls.levels[levelIndex];\n      if (level) {\n        var _data$frag2, _data$context2;\n        var errorDetails = data.details;\n        level.loadError++;\n        if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {\n          level.fragmentError++;\n        }\n        // Search for next level to retry\n        var nextLevel = -1;\n        var levels = hls.levels,\n          loadLevel = hls.loadLevel,\n          minAutoLevel = hls.minAutoLevel,\n          maxAutoLevel = hls.maxAutoLevel;\n        if (!hls.autoLevelEnabled) {\n          hls.loadLevel = -1;\n        }\n        var fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;\n        // Find alternate audio codec if available on audio codec error\n        var isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === 'audio' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n        var findAudioCodecAlternate = isAudioCodecError && levels.some(function (_ref) {\n          var audioCodec = _ref.audioCodec;\n          return level.audioCodec !== audioCodec;\n        });\n        // Find alternate video codec if available on video codec error\n        var isVideoCodecError = data.sourceBufferName === 'video' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n        var findVideoCodecAlternate = isVideoCodecError && levels.some(function (_ref2) {\n          var codecSet = _ref2.codecSet,\n            audioCodec = _ref2.audioCodec;\n          return level.codecSet !== codecSet && level.audioCodec === audioCodec;\n        });\n        var _ref3 = (_data$context2 = data.context) != null ? _data$context2 : {},\n          playlistErrorType = _ref3.type,\n          playlistErrorGroupId = _ref3.groupId;\n        var _loop = function _loop() {\n            var candidate = (i + loadLevel) % levels.length;\n            if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {\n              var _level$audioGroups, _level$subtitleGroups;\n              var levelCandidate = levels[candidate];\n              // Skip level switch if GAP tag is found in next level at same position\n              if (errorDetails === ErrorDetails.FRAG_GAP && fragErrorType === PlaylistLevelType.MAIN && data.frag) {\n                var levelDetails = levels[candidate].details;\n                if (levelDetails) {\n                  var fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);\n                  if (fragCandidate != null && fragCandidate.gap) {\n                    return 0; // continue\n                  }\n                }\n              } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {\n                // For audio/subs playlist errors find another group ID or fallthrough to redundant fail-over\n                return 0; // continue\n              } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some(function (groupId) {\n                return levelCandidate.hasAudioGroup(groupId);\n              }) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some(function (groupId) {\n                return levelCandidate.hasSubtitleGroup(groupId);\n              }) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || !findAudioCodecAlternate && level.audioCodec !== levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet) {\n                // For video/audio/subs frag errors find another group ID or fallthrough to redundant fail-over\n                return 0; // continue\n              }\n              nextLevel = candidate;\n              return 1; // break\n            }\n          },\n          _ret;\n        for (var i = levels.length; i--;) {\n          _ret = _loop();\n          if (_ret === 0) continue;\n          if (_ret === 1) break;\n        }\n        if (nextLevel > -1 && hls.loadLevel !== nextLevel) {\n          data.levelRetry = true;\n          this.playlistError = 0;\n          return {\n            action: NetworkErrorAction.SendAlternateToPenaltyBox,\n            flags: ErrorActionFlags.None,\n            nextAutoLevel: nextLevel\n          };\n        }\n      }\n      // No levels to switch / Manual level selection / Level not found\n      // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level\n      return {\n        action: NetworkErrorAction.SendAlternateToPenaltyBox,\n        flags: ErrorActionFlags.MoveAllAlternatesMatchingHost\n      };\n    };\n    _proto.onErrorOut = function onErrorOut(event, data) {\n      var _data$errorAction;\n      switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {\n        case NetworkErrorAction.DoNothing:\n          break;\n        case NetworkErrorAction.SendAlternateToPenaltyBox:\n          this.sendAlternateToPenaltyBox(data);\n          if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {\n            data.fatal = true;\n          } else if (/MediaSource readyState: ended/.test(data.error.message)) {\n            this.warn(\"MediaSource ended after \\\"\" + data.sourceBufferName + \"\\\" sourceBuffer append error. Attempting to recover from media error.\");\n            this.hls.recoverMediaError();\n          }\n          break;\n      }\n      if (data.fatal) {\n        this.hls.stopLoad();\n        return;\n      }\n    };\n    _proto.sendAlternateToPenaltyBox = function sendAlternateToPenaltyBox(data) {\n      var hls = this.hls;\n      var errorAction = data.errorAction;\n      if (!errorAction) {\n        return;\n      }\n      var flags = errorAction.flags,\n        hdcpLevel = errorAction.hdcpLevel,\n        nextAutoLevel = errorAction.nextAutoLevel;\n      switch (flags) {\n        case ErrorActionFlags.None:\n          this.switchLevel(data, nextAutoLevel);\n          break;\n        case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:\n          if (hdcpLevel) {\n            hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];\n            errorAction.resolved = true;\n          }\n          this.warn(\"Restricting playback to HDCP-LEVEL of \\\"\" + hls.maxHdcpLevel + \"\\\" or lower\");\n          break;\n      }\n      // If not resolved by previous actions try to switch to next level\n      if (!errorAction.resolved) {\n        this.switchLevel(data, nextAutoLevel);\n      }\n    };\n    _proto.switchLevel = function switchLevel(data, levelIndex) {\n      if (levelIndex !== undefined && data.errorAction) {\n        this.warn(\"switching to level \" + levelIndex + \" after \" + data.details);\n        this.hls.nextAutoLevel = levelIndex;\n        data.errorAction.resolved = true;\n        // Stream controller is responsible for this but won't switch on false start\n        this.hls.nextLoadLevel = this.hls.nextAutoLevel;\n      }\n    };\n    return ErrorController;\n  }();\n\n  var BasePlaylistController = /*#__PURE__*/function () {\n    function BasePlaylistController(hls, logPrefix) {\n      this.hls = void 0;\n      this.timer = -1;\n      this.requestScheduled = -1;\n      this.canLoad = false;\n      this.log = void 0;\n      this.warn = void 0;\n      this.log = logger.log.bind(logger, logPrefix + \":\");\n      this.warn = logger.warn.bind(logger, logPrefix + \":\");\n      this.hls = hls;\n    }\n    var _proto = BasePlaylistController.prototype;\n    _proto.destroy = function destroy() {\n      this.clearTimer();\n      // @ts-ignore\n      this.hls = this.log = this.warn = null;\n    };\n    _proto.clearTimer = function clearTimer() {\n      if (this.timer !== -1) {\n        self.clearTimeout(this.timer);\n        this.timer = -1;\n      }\n    };\n    _proto.startLoad = function startLoad() {\n      this.canLoad = true;\n      this.requestScheduled = -1;\n      this.loadPlaylist();\n    };\n    _proto.stopLoad = function stopLoad() {\n      this.canLoad = false;\n      this.clearTimer();\n    };\n    _proto.switchParams = function switchParams(playlistUri, previous, current) {\n      var renditionReports = previous == null ? void 0 : previous.renditionReports;\n      if (renditionReports) {\n        var foundIndex = -1;\n        for (var i = 0; i < renditionReports.length; i++) {\n          var attr = renditionReports[i];\n          var uri = void 0;\n          try {\n            uri = new self.URL(attr.URI, previous.url).href;\n          } catch (error) {\n            logger.warn(\"Could not construct new URL for Rendition Report: \" + error);\n            uri = attr.URI || '';\n          }\n          // Use exact match. Otherwise, the last partial match, if any, will be used\n          // (Playlist URI includes a query string that the Rendition Report does not)\n          if (uri === playlistUri) {\n            foundIndex = i;\n            break;\n          } else if (uri === playlistUri.substring(0, uri.length)) {\n            foundIndex = i;\n          }\n        }\n        if (foundIndex !== -1) {\n          var _attr = renditionReports[foundIndex];\n          var msn = parseInt(_attr['LAST-MSN']) || (previous == null ? void 0 : previous.lastPartSn);\n          var part = parseInt(_attr['LAST-PART']) || (previous == null ? void 0 : previous.lastPartIndex);\n          if (this.hls.config.lowLatencyMode) {\n            var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n            if (part >= 0 && currentGoal > previous.partTarget) {\n              part += 1;\n            }\n          }\n          var skip = current && getSkipValue(current);\n          return new HlsUrlParameters(msn, part >= 0 ? part : undefined, skip);\n        }\n      }\n    };\n    _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n      if (this.requestScheduled === -1) {\n        this.requestScheduled = self.performance.now();\n      }\n      // Loading is handled by the subclasses\n    };\n    _proto.shouldLoadPlaylist = function shouldLoadPlaylist(playlist) {\n      return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);\n    };\n    _proto.shouldReloadPlaylist = function shouldReloadPlaylist(playlist) {\n      return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);\n    };\n    _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {\n      var _this = this;\n      var details = data.details,\n        stats = data.stats;\n\n      // Set last updated date-time\n      var now = self.performance.now();\n      var elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;\n      details.advancedDateTime = Date.now() - elapsed;\n\n      // if current playlist is a live playlist, arm a timer to reload it\n      if (details.live || previousDetails != null && previousDetails.live) {\n        details.reloaded(previousDetails);\n        if (previousDetails) {\n          this.log(\"live playlist \" + index + \" \" + (details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : details.updated ? 'UPDATED' : 'MISSED'));\n        }\n        // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n        if (previousDetails && details.fragments.length > 0) {\n          mergeDetails(previousDetails, details);\n        }\n        if (!this.canLoad || !details.live) {\n          return;\n        }\n        var deliveryDirectives;\n        var msn = undefined;\n        var part = undefined;\n        if (details.canBlockReload && details.endSN && details.advanced) {\n          // Load level with LL-HLS delivery directives\n          var lowLatencyMode = this.hls.config.lowLatencyMode;\n          var lastPartSn = details.lastPartSn;\n          var endSn = details.endSN;\n          var lastPartIndex = details.lastPartIndex;\n          var hasParts = lastPartIndex !== -1;\n          var lastPart = lastPartSn === endSn;\n          // When low latency mode is disabled, we'll skip part requests once the last part index is found\n          var nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;\n          if (hasParts) {\n            msn = lastPart ? endSn + 1 : lastPartSn;\n            part = lastPart ? nextSnStartIndex : lastPartIndex + 1;\n          } else {\n            msn = endSn + 1;\n          }\n          // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n          // Update directives to obtain the Playlist that has the estimated additional duration of media\n          var lastAdvanced = details.age;\n          var cdnAge = lastAdvanced + details.ageHeader;\n          var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n          if (currentGoal > 0) {\n            if (previousDetails && currentGoal > previousDetails.tuneInGoal) {\n              // If we attempted to get the next or latest playlist update, but currentGoal increased,\n              // then we either can't catchup, or the \"age\" header cannot be trusted.\n              this.warn(\"CDN Tune-in goal increased from: \" + previousDetails.tuneInGoal + \" to: \" + currentGoal + \" with playlist age: \" + details.age);\n              currentGoal = 0;\n            } else {\n              var segments = Math.floor(currentGoal / details.targetduration);\n              msn += segments;\n              if (part !== undefined) {\n                var parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n                part += parts;\n              }\n              this.log(\"CDN Tune-in age: \" + details.ageHeader + \"s last advanced \" + lastAdvanced.toFixed(2) + \"s goal: \" + currentGoal + \" skip sn \" + segments + \" to part \" + part);\n            }\n            details.tuneInGoal = currentGoal;\n          }\n          deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n          if (lowLatencyMode || !lastPart) {\n            this.loadPlaylist(deliveryDirectives);\n            return;\n          }\n        } else if (details.canBlockReload || details.canSkipUntil) {\n          deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n        }\n        var bufferInfo = this.hls.mainForwardBufferInfo;\n        var position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;\n        var distanceToLiveEdgeMs = (details.edge - position) * 1000;\n        var reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);\n        if (details.updated && now > this.requestScheduled + reloadInterval) {\n          this.requestScheduled = stats.loading.start;\n        }\n        if (msn !== undefined && details.canBlockReload) {\n          this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);\n        } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now) {\n          this.requestScheduled = now;\n        } else if (this.requestScheduled - now <= 0) {\n          this.requestScheduled += reloadInterval;\n        }\n        var estimatedTimeUntilUpdate = this.requestScheduled - now;\n        estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);\n        this.log(\"reload live playlist \" + index + \" in \" + Math.round(estimatedTimeUntilUpdate) + \" ms\");\n        // this.log(\n        //   `live reload ${details.updated ? 'REFRESHED' : 'MISSED'}\n        // reload in ${estimatedTimeUntilUpdate / 1000}\n        // round trip ${(stats.loading.end - stats.loading.start) / 1000}\n        // diff ${\n        //   (reloadInterval -\n        //     (estimatedTimeUntilUpdate +\n        //       stats.loading.end -\n        //       stats.loading.start)) /\n        //   1000\n        // }\n        // reload interval ${reloadInterval / 1000}\n        // target duration ${details.targetduration}\n        // distance to edge ${distanceToLiveEdgeMs / 1000}`\n        // );\n\n        this.timer = self.setTimeout(function () {\n          return _this.loadPlaylist(deliveryDirectives);\n        }, estimatedTimeUntilUpdate);\n      } else {\n        this.clearTimer();\n      }\n    };\n    _proto.getDeliveryDirectives = function getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n      var skip = getSkipValue(details);\n      if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n        msn = previousDeliveryDirectives.msn;\n        part = previousDeliveryDirectives.part;\n        skip = HlsSkip.No;\n      }\n      return new HlsUrlParameters(msn, part, skip);\n    };\n    _proto.checkRetry = function checkRetry(errorEvent) {\n      var _this2 = this;\n      var errorDetails = errorEvent.details;\n      var isTimeout = isTimeoutError(errorEvent);\n      var errorAction = errorEvent.errorAction;\n      var _ref = errorAction || {},\n        action = _ref.action,\n        _ref$retryCount = _ref.retryCount,\n        retryCount = _ref$retryCount === void 0 ? 0 : _ref$retryCount,\n        retryConfig = _ref.retryConfig;\n      var retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);\n      if (retry) {\n        var _errorEvent$context;\n        this.requestScheduled = -1;\n        if (retryCount >= retryConfig.maxNumRetry) {\n          return false;\n        }\n        if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {\n          // The LL-HLS request already timed out so retry immediately\n          this.warn(\"Retrying playlist loading \" + (retryCount + 1) + \"/\" + retryConfig.maxNumRetry + \" after \\\"\" + errorDetails + \"\\\" without delivery-directives\");\n          this.loadPlaylist();\n        } else {\n          var delay = getRetryDelay(retryConfig, retryCount);\n          // Schedule level/track reload\n          this.timer = self.setTimeout(function () {\n            return _this2.loadPlaylist();\n          }, delay);\n          this.warn(\"Retrying playlist loading \" + (retryCount + 1) + \"/\" + retryConfig.maxNumRetry + \" after \\\"\" + errorDetails + \"\\\" in \" + delay + \"ms\");\n        }\n        // `levelRetry = true` used to inform other controllers that a retry is happening\n        errorEvent.levelRetry = true;\n        errorAction.resolved = true;\n      }\n      return retry;\n    };\n    return BasePlaylistController;\n  }();\n\n  /*\n   * compute an Exponential Weighted moving average\n   * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n   *  - heavily inspired from shaka-player\n   */\n  var EWMA = /*#__PURE__*/function () {\n    //  About half of the estimated value will be from the last |halfLife| samples by weight.\n    function EWMA(halfLife, estimate, weight) {\n      if (estimate === void 0) {\n        estimate = 0;\n      }\n      if (weight === void 0) {\n        weight = 0;\n      }\n      this.halfLife = void 0;\n      this.alpha_ = void 0;\n      this.estimate_ = void 0;\n      this.totalWeight_ = void 0;\n      this.halfLife = halfLife;\n      // Larger values of alpha expire historical data more slowly.\n      this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n      this.estimate_ = estimate;\n      this.totalWeight_ = weight;\n    }\n    var _proto = EWMA.prototype;\n    _proto.sample = function sample(weight, value) {\n      var adjAlpha = Math.pow(this.alpha_, weight);\n      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n      this.totalWeight_ += weight;\n    };\n    _proto.getTotalWeight = function getTotalWeight() {\n      return this.totalWeight_;\n    };\n    _proto.getEstimate = function getEstimate() {\n      if (this.alpha_) {\n        var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n        if (zeroFactor) {\n          return this.estimate_ / zeroFactor;\n        }\n      }\n      return this.estimate_;\n    };\n    return EWMA;\n  }();\n\n  /*\n   * EWMA Bandwidth Estimator\n   *  - heavily inspired from shaka-player\n   * Tracks bandwidth samples and estimates available bandwidth.\n   * Based on the minimum of two exponentially-weighted moving averages with\n   * different half-lives.\n   */\n\n  var EwmaBandWidthEstimator = /*#__PURE__*/function () {\n    function EwmaBandWidthEstimator(slow, fast, defaultEstimate, defaultTTFB) {\n      if (defaultTTFB === void 0) {\n        defaultTTFB = 100;\n      }\n      this.defaultEstimate_ = void 0;\n      this.minWeight_ = void 0;\n      this.minDelayMs_ = void 0;\n      this.slow_ = void 0;\n      this.fast_ = void 0;\n      this.defaultTTFB_ = void 0;\n      this.ttfb_ = void 0;\n      this.defaultEstimate_ = defaultEstimate;\n      this.minWeight_ = 0.001;\n      this.minDelayMs_ = 50;\n      this.slow_ = new EWMA(slow);\n      this.fast_ = new EWMA(fast);\n      this.defaultTTFB_ = defaultTTFB;\n      this.ttfb_ = new EWMA(slow);\n    }\n    var _proto = EwmaBandWidthEstimator.prototype;\n    _proto.update = function update(slow, fast) {\n      var slow_ = this.slow_,\n        fast_ = this.fast_,\n        ttfb_ = this.ttfb_;\n      if (slow_.halfLife !== slow) {\n        this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());\n      }\n      if (fast_.halfLife !== fast) {\n        this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());\n      }\n      if (ttfb_.halfLife !== slow) {\n        this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());\n      }\n    };\n    _proto.sample = function sample(durationMs, numBytes) {\n      durationMs = Math.max(durationMs, this.minDelayMs_);\n      var numBits = 8 * numBytes;\n      // weight is duration in seconds\n      var durationS = durationMs / 1000;\n      // value is bandwidth in bits/s\n      var bandwidthInBps = numBits / durationS;\n      this.fast_.sample(durationS, bandwidthInBps);\n      this.slow_.sample(durationS, bandwidthInBps);\n    };\n    _proto.sampleTTFB = function sampleTTFB(ttfb) {\n      // weight is frequency curve applied to TTFB in seconds\n      // (longer times have less weight with expected input under 1 second)\n      var seconds = ttfb / 1000;\n      var weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);\n      this.ttfb_.sample(weight, Math.max(ttfb, 5));\n    };\n    _proto.canEstimate = function canEstimate() {\n      return this.fast_.getTotalWeight() >= this.minWeight_;\n    };\n    _proto.getEstimate = function getEstimate() {\n      if (this.canEstimate()) {\n        // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n        // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n        // Take the minimum of these two estimates.  This should have the effect of\n        // adapting down quickly, but up more slowly.\n        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n      } else {\n        return this.defaultEstimate_;\n      }\n    };\n    _proto.getEstimateTTFB = function getEstimateTTFB() {\n      if (this.ttfb_.getTotalWeight() >= this.minWeight_) {\n        return this.ttfb_.getEstimate();\n      } else {\n        return this.defaultTTFB_;\n      }\n    };\n    _proto.destroy = function destroy() {};\n    return EwmaBandWidthEstimator;\n  }();\n\n  var SUPPORTED_INFO_DEFAULT = {\n    supported: true,\n    configurations: [],\n    decodingInfoResults: [{\n      supported: true,\n      powerEfficient: true,\n      smooth: true\n    }]\n  };\n  var SUPPORTED_INFO_CACHE = {};\n  function requiresMediaCapabilitiesDecodingInfo(level, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference) {\n    // Only test support when configuration is exceeds minimum options\n    var audioGroups = level.audioCodec ? level.audioGroups : null;\n    var audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n    var channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n    var maxChannels = channelsPreference ? parseInt(channelsPreference) : audioCodecPreference ? Infinity : 2;\n    var audioChannels = null;\n    if (audioGroups != null && audioGroups.length) {\n      try {\n        if (audioGroups.length === 1 && audioGroups[0]) {\n          audioChannels = audioTracksByGroup.groups[audioGroups[0]].channels;\n        } else {\n          audioChannels = audioGroups.reduce(function (acc, groupId) {\n            if (groupId) {\n              var audioTrackGroup = audioTracksByGroup.groups[groupId];\n              if (!audioTrackGroup) {\n                throw new Error(\"Audio track group \" + groupId + \" not found\");\n              }\n              // Sum all channel key values\n              Object.keys(audioTrackGroup.channels).forEach(function (key) {\n                acc[key] = (acc[key] || 0) + audioTrackGroup.channels[key];\n              });\n            }\n            return acc;\n          }, {\n            2: 0\n          });\n        }\n      } catch (error) {\n        return true;\n      }\n    }\n    return level.videoCodec !== undefined && (level.width > 1920 && level.height > 1088 || level.height > 1920 && level.width > 1088 || level.frameRate > Math.max(currentFrameRate, 30) || level.videoRange !== 'SDR' && level.videoRange !== currentVideoRange || level.bitrate > Math.max(currentBw, 8e6)) || !!audioChannels && isFiniteNumber(maxChannels) && Object.keys(audioChannels).some(function (channels) {\n      return parseInt(channels) > maxChannels;\n    });\n  }\n  function getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities) {\n    var videoCodecs = level.videoCodec;\n    var audioCodecs = level.audioCodec;\n    if (!videoCodecs || !audioCodecs || !mediaCapabilities) {\n      return Promise.resolve(SUPPORTED_INFO_DEFAULT);\n    }\n    var baseVideoConfiguration = {\n      width: level.width,\n      height: level.height,\n      bitrate: Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate)),\n      // Assume a framerate of 30fps since MediaCapabilities will not accept Level default of 0.\n      framerate: level.frameRate || 30\n    };\n    var videoRange = level.videoRange;\n    if (videoRange !== 'SDR') {\n      baseVideoConfiguration.transferFunction = videoRange.toLowerCase();\n    }\n    var configurations = videoCodecs.split(',').map(function (videoCodec) {\n      return {\n        type: 'media-source',\n        video: _objectSpread2(_objectSpread2({}, baseVideoConfiguration), {}, {\n          contentType: mimeTypeForCodec(videoCodec, 'video')\n        })\n      };\n    });\n    if (audioCodecs && level.audioGroups) {\n      level.audioGroups.forEach(function (audioGroupId) {\n        var _audioTracksByGroup$g;\n        if (!audioGroupId) {\n          return;\n        }\n        (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null ? void 0 : _audioTracksByGroup$g.tracks.forEach(function (audioTrack) {\n          if (audioTrack.groupId === audioGroupId) {\n            var channels = audioTrack.channels || '';\n            var channelsNumber = parseFloat(channels);\n            if (isFiniteNumber(channelsNumber) && channelsNumber > 2) {\n              configurations.push.apply(configurations, audioCodecs.split(',').map(function (audioCodec) {\n                return {\n                  type: 'media-source',\n                  audio: {\n                    contentType: mimeTypeForCodec(audioCodec, 'audio'),\n                    channels: '' + channelsNumber\n                    // spatialRendering:\n                    //   audioCodec === 'ec-3' && channels.indexOf('JOC'),\n                  }\n                };\n              }));\n            }\n          }\n        });\n      });\n    }\n    return Promise.all(configurations.map(function (configuration) {\n      // Cache MediaCapabilities promises\n      var decodingInfoKey = getMediaDecodingInfoKey(configuration);\n      return SUPPORTED_INFO_CACHE[decodingInfoKey] || (SUPPORTED_INFO_CACHE[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));\n    })).then(function (decodingInfoResults) {\n      return {\n        supported: !decodingInfoResults.some(function (info) {\n          return !info.supported;\n        }),\n        configurations: configurations,\n        decodingInfoResults: decodingInfoResults\n      };\n    }).catch(function (error) {\n      return {\n        supported: false,\n        configurations: configurations,\n        decodingInfoResults: [],\n        error: error\n      };\n    });\n  }\n  function getMediaDecodingInfoKey(config) {\n    var audio = config.audio,\n      video = config.video;\n    var mediaConfig = video || audio;\n    if (mediaConfig) {\n      var codec = mediaConfig.contentType.split('\"')[1];\n      if (video) {\n        return \"r\" + video.height + \"x\" + video.width + \"f\" + Math.ceil(video.framerate) + (video.transferFunction || 'sd') + \"_\" + codec + \"_\" + Math.ceil(video.bitrate / 1e5);\n      }\n      if (audio) {\n        return \"c\" + audio.channels + (audio.spatialRendering ? 's' : 'n') + \"_\" + codec;\n      }\n    }\n    return '';\n  }\n\n  /**\n   * @returns Whether we can detect and validate HDR capability within the window context\n   */\n  function isHdrSupported() {\n    if (typeof matchMedia === 'function') {\n      var mediaQueryList = matchMedia('(dynamic-range: high)');\n      var badQuery = matchMedia('bad query');\n      if (mediaQueryList.media !== badQuery.media) {\n        return mediaQueryList.matches === true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Sanitizes inputs to return the active video selection options for HDR/SDR.\n   * When both inputs are null:\n   *\n   *    `{ preferHDR: false, allowedVideoRanges: [] }`\n   *\n   * When `currentVideoRange` non-null, maintain the active range:\n   *\n   *    `{ preferHDR: currentVideoRange !== 'SDR', allowedVideoRanges: [currentVideoRange] }`\n   *\n   * When VideoSelectionOption non-null:\n   *\n   *  - Allow all video ranges if `allowedVideoRanges` unspecified.\n   *  - If `preferHDR` is non-null use the value to filter `allowedVideoRanges`.\n   *  - Else check window for HDR support and set `preferHDR` to the result.\n   *\n   * @param currentVideoRange\n   * @param videoPreference\n   */\n  function getVideoSelectionOptions(currentVideoRange, videoPreference) {\n    var preferHDR = false;\n    var allowedVideoRanges = [];\n    if (currentVideoRange) {\n      preferHDR = currentVideoRange !== 'SDR';\n      allowedVideoRanges = [currentVideoRange];\n    }\n    if (videoPreference) {\n      allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);\n      preferHDR = videoPreference.preferHDR !== undefined ? videoPreference.preferHDR : isHdrSupported();\n      if (preferHDR) {\n        allowedVideoRanges = allowedVideoRanges.filter(function (range) {\n          return range !== 'SDR';\n        });\n      } else {\n        allowedVideoRanges = ['SDR'];\n      }\n    }\n    return {\n      preferHDR: preferHDR,\n      allowedVideoRanges: allowedVideoRanges\n    };\n  }\n\n  function getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {\n    var codecSets = Object.keys(codecTiers);\n    var channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n    var audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n    var preferStereo = channelsPreference && parseInt(channelsPreference) === 2;\n    // Use first level set to determine stereo, and minimum resolution and framerate\n    var hasStereo = true;\n    var hasCurrentVideoRange = false;\n    var minHeight = Infinity;\n    var minFramerate = Infinity;\n    var minBitrate = Infinity;\n    var selectedScore = 0;\n    var videoRanges = [];\n    var _getVideoSelectionOpt = getVideoSelectionOptions(currentVideoRange, videoPreference),\n      preferHDR = _getVideoSelectionOpt.preferHDR,\n      allowedVideoRanges = _getVideoSelectionOpt.allowedVideoRanges;\n    var _loop = function _loop() {\n      var tier = codecTiers[codecSets[i]];\n      hasStereo = tier.channels[2] > 0;\n      minHeight = Math.min(minHeight, tier.minHeight);\n      minFramerate = Math.min(minFramerate, tier.minFramerate);\n      minBitrate = Math.min(minBitrate, tier.minBitrate);\n      var matchingVideoRanges = allowedVideoRanges.filter(function (range) {\n        return tier.videoRanges[range] > 0;\n      });\n      if (matchingVideoRanges.length > 0) {\n        hasCurrentVideoRange = true;\n        videoRanges = matchingVideoRanges;\n      }\n    };\n    for (var i = codecSets.length; i--;) {\n      _loop();\n    }\n    minHeight = isFiniteNumber(minHeight) ? minHeight : 0;\n    minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;\n    var maxHeight = Math.max(1080, minHeight);\n    var maxFramerate = Math.max(30, minFramerate);\n    minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;\n    currentBw = Math.max(minBitrate, currentBw);\n    // If there are no variants with matching preference, set currentVideoRange to undefined\n    if (!hasCurrentVideoRange) {\n      currentVideoRange = undefined;\n      videoRanges = [];\n    }\n    var codecSet = codecSets.reduce(function (selected, candidate) {\n      // Remove candiates which do not meet bitrate, default audio, stereo or channels preference, 1080p or lower, 30fps or lower, or SDR/HDR selection if present\n      var candidateTier = codecTiers[candidate];\n      if (candidate === selected) {\n        return selected;\n      }\n      if (candidateTier.minBitrate > currentBw) {\n        logStartCodecCandidateIgnored(candidate, \"min bitrate of \" + candidateTier.minBitrate + \" > current estimate of \" + currentBw);\n        return selected;\n      }\n      if (!candidateTier.hasDefaultAudio) {\n        logStartCodecCandidateIgnored(candidate, \"no renditions with default or auto-select sound found\");\n        return selected;\n      }\n      if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {\n        logStartCodecCandidateIgnored(candidate, \"audio codec preference \\\"\" + audioCodecPreference + \"\\\" not found\");\n        return selected;\n      }\n      if (channelsPreference && !preferStereo) {\n        if (!candidateTier.channels[channelsPreference]) {\n          logStartCodecCandidateIgnored(candidate, \"no renditions with \" + channelsPreference + \" channel sound found (channels options: \" + Object.keys(candidateTier.channels) + \")\");\n          return selected;\n        }\n      } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels['2'] === 0) {\n        logStartCodecCandidateIgnored(candidate, \"no renditions with stereo sound found\");\n        return selected;\n      }\n      if (candidateTier.minHeight > maxHeight) {\n        logStartCodecCandidateIgnored(candidate, \"min resolution of \" + candidateTier.minHeight + \" > maximum of \" + maxHeight);\n        return selected;\n      }\n      if (candidateTier.minFramerate > maxFramerate) {\n        logStartCodecCandidateIgnored(candidate, \"min framerate of \" + candidateTier.minFramerate + \" > maximum of \" + maxFramerate);\n        return selected;\n      }\n      if (!videoRanges.some(function (range) {\n        return candidateTier.videoRanges[range] > 0;\n      })) {\n        logStartCodecCandidateIgnored(candidate, \"no variants with VIDEO-RANGE of \" + JSON.stringify(videoRanges) + \" found\");\n        return selected;\n      }\n      if (candidateTier.maxScore < selectedScore) {\n        logStartCodecCandidateIgnored(candidate, \"max score of \" + candidateTier.maxScore + \" < selected max of \" + selectedScore);\n        return selected;\n      }\n      // Remove candiates with less preferred codecs or more errors\n      if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {\n        return selected;\n      }\n      selectedScore = candidateTier.maxScore;\n      return candidate;\n    }, undefined);\n    return {\n      codecSet: codecSet,\n      videoRanges: videoRanges,\n      preferHDR: preferHDR,\n      minFramerate: minFramerate,\n      minBitrate: minBitrate\n    };\n  }\n  function logStartCodecCandidateIgnored(codeSet, reason) {\n    logger.log(\"[abr] start candidates with \\\"\" + codeSet + \"\\\" ignored because \" + reason);\n  }\n  function getAudioTracksByGroup(allAudioTracks) {\n    return allAudioTracks.reduce(function (audioTracksByGroup, track) {\n      var trackGroup = audioTracksByGroup.groups[track.groupId];\n      if (!trackGroup) {\n        trackGroup = audioTracksByGroup.groups[track.groupId] = {\n          tracks: [],\n          channels: {\n            2: 0\n          },\n          hasDefault: false,\n          hasAutoSelect: false\n        };\n      }\n      trackGroup.tracks.push(track);\n      var channelsKey = track.channels || '2';\n      trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;\n      trackGroup.hasDefault = trackGroup.hasDefault || track.default;\n      trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;\n      if (trackGroup.hasDefault) {\n        audioTracksByGroup.hasDefaultAudio = true;\n      }\n      if (trackGroup.hasAutoSelect) {\n        audioTracksByGroup.hasAutoSelectAudio = true;\n      }\n      return audioTracksByGroup;\n    }, {\n      hasDefaultAudio: false,\n      hasAutoSelectAudio: false,\n      groups: {}\n    });\n  }\n  function getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {\n    return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce(function (tiers, level) {\n      if (!level.codecSet) {\n        return tiers;\n      }\n      var audioGroups = level.audioGroups;\n      var tier = tiers[level.codecSet];\n      if (!tier) {\n        tiers[level.codecSet] = tier = {\n          minBitrate: Infinity,\n          minHeight: Infinity,\n          minFramerate: Infinity,\n          maxScore: 0,\n          videoRanges: {\n            SDR: 0\n          },\n          channels: {\n            '2': 0\n          },\n          hasDefaultAudio: !audioGroups,\n          fragmentError: 0\n        };\n      }\n      tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);\n      var lesserWidthOrHeight = Math.min(level.height, level.width);\n      tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);\n      tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);\n      tier.maxScore = Math.max(tier.maxScore, level.score);\n      tier.fragmentError += level.fragmentError;\n      tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;\n      if (audioGroups) {\n        audioGroups.forEach(function (audioGroupId) {\n          if (!audioGroupId) {\n            return;\n          }\n          var audioGroup = audioTracksByGroup.groups[audioGroupId];\n          if (!audioGroup) {\n            return;\n          }\n          // Default audio is any group with DEFAULT=YES, or if missing then any group with AUTOSELECT=YES, or all variants\n          tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;\n          Object.keys(audioGroup.channels).forEach(function (channels) {\n            tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];\n          });\n        });\n      }\n      return tiers;\n    }, {});\n  }\n  function findMatchingOption(option, tracks, matchPredicate) {\n    if ('attrs' in option) {\n      var index = tracks.indexOf(option);\n      if (index !== -1) {\n        return index;\n      }\n    }\n    for (var i = 0; i < tracks.length; i++) {\n      var _track = tracks[i];\n      if (matchesOption(option, _track, matchPredicate)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  function matchesOption(option, track, matchPredicate) {\n    var groupId = option.groupId,\n      name = option.name,\n      lang = option.lang,\n      assocLang = option.assocLang,\n      characteristics = option.characteristics,\n      isDefault = option.default;\n    var forced = option.forced;\n    return (groupId === undefined || track.groupId === groupId) && (name === undefined || track.name === name) && (lang === undefined || track.lang === lang) && (lang === undefined || track.assocLang === assocLang) && (isDefault === undefined || track.default === isDefault) && (forced === undefined || track.forced === forced) && (characteristics === undefined || characteristicsMatch(characteristics, track.characteristics)) && (matchPredicate === undefined || matchPredicate(option, track));\n  }\n  function characteristicsMatch(characteristicsA, characteristicsB) {\n    if (characteristicsB === void 0) {\n      characteristicsB = '';\n    }\n    var arrA = characteristicsA.split(',');\n    var arrB = characteristicsB.split(',');\n    // Expects each item to be unique:\n    return arrA.length === arrB.length && !arrA.some(function (el) {\n      return arrB.indexOf(el) === -1;\n    });\n  }\n  function audioMatchPredicate(option, track) {\n    var audioCodec = option.audioCodec,\n      channels = option.channels;\n    return (audioCodec === undefined || (track.audioCodec || '').substring(0, 4) === audioCodec.substring(0, 4)) && (channels === undefined || channels === (track.channels || '2'));\n  }\n  function findClosestLevelWithAudioGroup(option, levels, allAudioTracks, searchIndex, matchPredicate) {\n    var currentLevel = levels[searchIndex];\n    // Are there variants with same URI as current level?\n    // If so, find a match that does not require any level URI change\n    var variants = levels.reduce(function (variantMap, level, index) {\n      var uri = level.uri;\n      var renditions = variantMap[uri] || (variantMap[uri] = []);\n      renditions.push(index);\n      return variantMap;\n    }, {});\n    var renditions = variants[currentLevel.uri];\n    if (renditions.length > 1) {\n      searchIndex = Math.max.apply(Math, renditions);\n    }\n    // Find best match\n    var currentVideoRange = currentLevel.videoRange;\n    var currentFrameRate = currentLevel.frameRate;\n    var currentVideoCodec = currentLevel.codecSet.substring(0, 4);\n    var matchingVideo = searchDownAndUpList(levels, searchIndex, function (level) {\n      if (level.videoRange !== currentVideoRange || level.frameRate !== currentFrameRate || level.codecSet.substring(0, 4) !== currentVideoCodec) {\n        return false;\n      }\n      var audioGroups = level.audioGroups;\n      var tracks = allAudioTracks.filter(function (track) {\n        return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;\n      });\n      return findMatchingOption(option, tracks, matchPredicate) > -1;\n    });\n    if (matchingVideo > -1) {\n      return matchingVideo;\n    }\n    return searchDownAndUpList(levels, searchIndex, function (level) {\n      var audioGroups = level.audioGroups;\n      var tracks = allAudioTracks.filter(function (track) {\n        return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;\n      });\n      return findMatchingOption(option, tracks, matchPredicate) > -1;\n    });\n  }\n  function searchDownAndUpList(arr, searchIndex, predicate) {\n    for (var i = searchIndex; i > -1; i--) {\n      if (predicate(arr[i])) {\n        return i;\n      }\n    }\n    for (var _i = searchIndex + 1; _i < arr.length; _i++) {\n      if (predicate(arr[_i])) {\n        return _i;\n      }\n    }\n    return -1;\n  }\n\n  var AbrController = /*#__PURE__*/function () {\n    function AbrController(_hls) {\n      var _this = this;\n      this.hls = void 0;\n      this.lastLevelLoadSec = 0;\n      this.lastLoadedFragLevel = -1;\n      this.firstSelection = -1;\n      this._nextAutoLevel = -1;\n      this.nextAutoLevelKey = '';\n      this.audioTracksByGroup = null;\n      this.codecTiers = null;\n      this.timer = -1;\n      this.fragCurrent = null;\n      this.partCurrent = null;\n      this.bitrateTestDelay = 0;\n      this.bwEstimator = void 0;\n      /*\n          This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n          quickly enough to prevent underbuffering\n        */\n      this._abandonRulesCheck = function () {\n        var frag = _this.fragCurrent,\n          part = _this.partCurrent,\n          hls = _this.hls;\n        var autoLevelEnabled = hls.autoLevelEnabled,\n          media = hls.media;\n        if (!frag || !media) {\n          return;\n        }\n        var now = performance.now();\n        var stats = part ? part.stats : frag.stats;\n        var duration = part ? part.duration : frag.duration;\n        var timeLoading = now - stats.loading.start;\n        var minAutoLevel = hls.minAutoLevel;\n        // If frag loading is aborted, complete, or from lowest level, stop timer and return\n        if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level <= minAutoLevel) {\n          _this.clearTimer();\n          // reset forced auto level value so that next level will be selected\n          _this._nextAutoLevel = -1;\n          return;\n        }\n\n        // This check only runs if we're in ABR mode and actually playing\n        if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {\n          return;\n        }\n        var bufferInfo = hls.mainForwardBufferInfo;\n        if (bufferInfo === null) {\n          return;\n        }\n        var ttfbEstimate = _this.bwEstimator.getEstimateTTFB();\n        var playbackRate = Math.abs(media.playbackRate);\n        // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed\n        if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {\n          return;\n        }\n\n        // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n        var bufferStarvationDelay = bufferInfo.len / playbackRate;\n        var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n        var loadedFirstByte = stats.loaded && ttfb > -1;\n        var bwEstimate = _this.getBwEstimate();\n        var levels = hls.levels;\n        var level = levels[frag.level];\n        var expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.averageBitrate / 8));\n        var timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;\n        if (timeStreaming < 1 && loadedFirstByte) {\n          timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);\n        }\n        var loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;\n        // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment\n        var fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1000;\n        // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left\n        if (fragLoadedDelay <= bufferStarvationDelay) {\n          return;\n        }\n        var bwe = loadRate ? loadRate * 8 : bwEstimate;\n        var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n        var nextLoadLevel;\n        // Iterate through lower level and try to find the largest one that avoids rebuffering\n        for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n          // compute time to load next fragment at lower level\n          // 8 = bits per byte (bps/Bps)\n          var levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n          fragLevelNextLoadedDelay = _this.getTimeToLoadFrag(ttfbEstimate / 1000, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);\n          if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n            break;\n          }\n        }\n        // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n        // to load the current one\n        if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n          return;\n        }\n\n        // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down\n        if (fragLevelNextLoadedDelay > duration * 10) {\n          return;\n        }\n        hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;\n        if (loadedFirstByte) {\n          // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time\n          _this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n        } else {\n          // If there has been no loading progress, sample TTFB\n          _this.bwEstimator.sampleTTFB(timeLoading);\n        }\n        var nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;\n        if (_this.getBwEstimate() * _this.hls.config.abrBandWidthUpFactor > nextLoadLevelBitrate) {\n          _this.resetEstimator(nextLoadLevelBitrate);\n        }\n        _this.clearTimer();\n        logger.warn(\"[abr] Fragment \" + frag.sn + (part ? ' part ' + part.index : '') + \" of level \" + frag.level + \" is loading too slowly;\\n      Time to underbuffer: \" + bufferStarvationDelay.toFixed(3) + \" s\\n      Estimated load time for current fragment: \" + fragLoadedDelay.toFixed(3) + \" s\\n      Estimated load time for down switch fragment: \" + fragLevelNextLoadedDelay.toFixed(3) + \" s\\n      TTFB estimate: \" + (ttfb | 0) + \" ms\\n      Current BW estimate: \" + (isFiniteNumber(bwEstimate) ? bwEstimate | 0 : 'Unknown') + \" bps\\n      New BW estimate: \" + (_this.getBwEstimate() | 0) + \" bps\\n      Switching to level \" + nextLoadLevel + \" @ \" + (nextLoadLevelBitrate | 0) + \" bps\");\n        hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {\n          frag: frag,\n          part: part,\n          stats: stats\n        });\n      };\n      this.hls = _hls;\n      this.bwEstimator = this.initEstimator();\n      this.registerListeners();\n    }\n    var _proto = AbrController.prototype;\n    _proto.resetEstimator = function resetEstimator(abrEwmaDefaultEstimate) {\n      if (abrEwmaDefaultEstimate) {\n        logger.log(\"setting initial bwe to \" + abrEwmaDefaultEstimate);\n        this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;\n      }\n      this.firstSelection = -1;\n      this.bwEstimator = this.initEstimator();\n    };\n    _proto.initEstimator = function initEstimator() {\n      var config = this.hls.config;\n      return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n    };\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n      hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n      hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      if (!hls) {\n        return;\n      }\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n      hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n      hls.off(Events.ERROR, this.onError, this);\n    };\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.clearTimer();\n      // @ts-ignore\n      this.hls = this._abandonRulesCheck = null;\n      this.fragCurrent = this.partCurrent = null;\n    };\n    _proto.onManifestLoading = function onManifestLoading(event, data) {\n      this.lastLoadedFragLevel = -1;\n      this.firstSelection = -1;\n      this.lastLevelLoadSec = 0;\n      this.fragCurrent = this.partCurrent = null;\n      this.onLevelsUpdated();\n      this.clearTimer();\n    };\n    _proto.onLevelsUpdated = function onLevelsUpdated() {\n      if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {\n        this.lastLoadedFragLevel = this.fragCurrent.level;\n      }\n      this._nextAutoLevel = -1;\n      this.onMaxAutoLevelUpdated();\n      this.codecTiers = null;\n      this.audioTracksByGroup = null;\n    };\n    _proto.onMaxAutoLevelUpdated = function onMaxAutoLevelUpdated() {\n      this.firstSelection = -1;\n      this.nextAutoLevelKey = '';\n    };\n    _proto.onFragLoading = function onFragLoading(event, data) {\n      var frag = data.frag;\n      if (this.ignoreFragment(frag)) {\n        return;\n      }\n      if (!frag.bitrateTest) {\n        var _data$part;\n        this.fragCurrent = frag;\n        this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n      }\n      this.clearTimer();\n      this.timer = self.setInterval(this._abandonRulesCheck, 100);\n    };\n    _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n      this.clearTimer();\n    };\n    _proto.onError = function onError(event, data) {\n      if (data.fatal) {\n        return;\n      }\n      switch (data.details) {\n        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n        case ErrorDetails.BUFFER_APPEND_ERROR:\n          // Reset last loaded level so that a new selection can be made after calling recoverMediaError\n          this.lastLoadedFragLevel = -1;\n          this.firstSelection = -1;\n          break;\n        case ErrorDetails.FRAG_LOAD_TIMEOUT:\n          {\n            var frag = data.frag;\n            var fragCurrent = this.fragCurrent,\n              part = this.partCurrent;\n            if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {\n              var now = performance.now();\n              var stats = part ? part.stats : frag.stats;\n              var timeLoading = now - stats.loading.start;\n              var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n              var loadedFirstByte = stats.loaded && ttfb > -1;\n              if (loadedFirstByte) {\n                var ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n                this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n              } else {\n                this.bwEstimator.sampleTTFB(timeLoading);\n              }\n            }\n            break;\n          }\n      }\n    };\n    _proto.getTimeToLoadFrag = function getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {\n      var fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;\n      var playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;\n      return fragLoadSec + playlistLoadSec;\n    };\n    _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n      var config = this.hls.config;\n      var loading = data.stats.loading;\n      var timeLoadingMs = loading.end - loading.start;\n      if (isFiniteNumber(timeLoadingMs)) {\n        this.lastLevelLoadSec = timeLoadingMs / 1000;\n      }\n      if (data.details.live) {\n        this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n      } else {\n        this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n      }\n    };\n    _proto.onFragLoaded = function onFragLoaded(event, _ref) {\n      var frag = _ref.frag,\n        part = _ref.part;\n      var stats = part ? part.stats : frag.stats;\n      if (frag.type === PlaylistLevelType.MAIN) {\n        this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);\n      }\n      if (this.ignoreFragment(frag)) {\n        return;\n      }\n      // stop monitoring bw once frag loaded\n      this.clearTimer();\n      // reset forced auto level value so that next level will be selected\n      if (frag.level === this._nextAutoLevel) {\n        this._nextAutoLevel = -1;\n      }\n      this.firstSelection = -1;\n\n      // compute level average bitrate\n      if (this.hls.config.abrMaxWithRealBitrate) {\n        var duration = part ? part.duration : frag.duration;\n        var level = this.hls.levels[frag.level];\n        var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n        var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n        level.loaded = {\n          bytes: loadedBytes,\n          duration: loadedDuration\n        };\n        level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n      }\n      if (frag.bitrateTest) {\n        var fragBufferedData = {\n          stats: stats,\n          frag: frag,\n          part: part,\n          id: frag.type\n        };\n        this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);\n        frag.bitrateTest = false;\n      } else {\n        // store level id after successful fragment load for playback\n        this.lastLoadedFragLevel = frag.level;\n      }\n    };\n    _proto.onFragBuffered = function onFragBuffered(event, data) {\n      var frag = data.frag,\n        part = data.part;\n      var stats = part != null && part.stats.loaded ? part.stats : frag.stats;\n      if (stats.aborted) {\n        return;\n      }\n      if (this.ignoreFragment(frag)) {\n        return;\n      }\n      // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n      // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n      // is used. If we used buffering in that case, our BW estimate sample will be very large.\n      var processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());\n      this.bwEstimator.sample(processingMs, stats.loaded);\n      stats.bwEstimate = this.getBwEstimate();\n      if (frag.bitrateTest) {\n        this.bitrateTestDelay = processingMs / 1000;\n      } else {\n        this.bitrateTestDelay = 0;\n      }\n    };\n    _proto.ignoreFragment = function ignoreFragment(frag) {\n      // Only count non-alt-audio frags which were actually buffered in our BW calculations\n      return frag.type !== PlaylistLevelType.MAIN || frag.sn === 'initSegment';\n    };\n    _proto.clearTimer = function clearTimer() {\n      if (this.timer > -1) {\n        self.clearInterval(this.timer);\n        this.timer = -1;\n      }\n    };\n    _proto.getAutoLevelKey = function getAutoLevelKey() {\n      return this.getBwEstimate() + \"_\" + this.getStarvationDelay().toFixed(2);\n    };\n    _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {\n      var fragCurrent = this.fragCurrent,\n        partCurrent = this.partCurrent,\n        hls = this.hls;\n      var maxAutoLevel = hls.maxAutoLevel,\n        config = hls.config,\n        minAutoLevel = hls.minAutoLevel;\n      var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n      var avgbw = this.getBwEstimate();\n      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n      var bufferStarvationDelay = this.getStarvationDelay();\n      var bwFactor = config.abrBandWidthFactor;\n      var bwUpFactor = config.abrBandWidthUpFactor;\n\n      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n      if (bufferStarvationDelay) {\n        var _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);\n        if (_bestLevel >= 0) {\n          return _bestLevel;\n        }\n      }\n      // not possible to get rid of rebuffering... try to find level that will guarantee less than maxStarvationDelay of rebuffering\n      var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n      if (!bufferStarvationDelay) {\n        // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n        var bitrateTestDelay = this.bitrateTestDelay;\n        if (bitrateTestDelay) {\n          // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n          // max video loading delay used in  automatic start level selection :\n          // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n          // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n          // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n          var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n          maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n          logger.info(\"[abr] bitrate test took \" + Math.round(1000 * bitrateTestDelay) + \"ms, set first fragment max fetchDuration to \" + Math.round(1000 * maxStarvationDelay) + \" ms\");\n          // don't use conservative factor on bitrate test\n          bwFactor = bwUpFactor = 1;\n        }\n      }\n      var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);\n      logger.info(\"[abr] \" + (bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty') + \", optimal quality level \" + bestLevel);\n      if (bestLevel > -1) {\n        return bestLevel;\n      }\n      // If no matching level found, see if min auto level would be a better option\n      var minLevel = hls.levels[minAutoLevel];\n      var autoLevel = hls.levels[hls.loadLevel];\n      if ((minLevel == null ? void 0 : minLevel.bitrate) < (autoLevel == null ? void 0 : autoLevel.bitrate)) {\n        return minAutoLevel;\n      }\n      // or if bitrate is not lower, continue to use loadLevel\n      return hls.loadLevel;\n    };\n    _proto.getStarvationDelay = function getStarvationDelay() {\n      var hls = this.hls;\n      var media = hls.media;\n      if (!media) {\n        return Infinity;\n      }\n      // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n      // if we're playing back at the normal rate.\n      var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n      var bufferInfo = hls.mainForwardBufferInfo;\n      return (bufferInfo ? bufferInfo.len : 0) / playbackRate;\n    };\n    _proto.getBwEstimate = function getBwEstimate() {\n      return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;\n    };\n    _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {\n      var _level$details,\n        _this2 = this;\n      var maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;\n      var lastLoadedFragLevel = this.lastLoadedFragLevel;\n      var selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;\n      var fragCurrent = this.fragCurrent,\n        partCurrent = this.partCurrent;\n      var _this$hls = this.hls,\n        levels = _this$hls.levels,\n        allAudioTracks = _this$hls.allAudioTracks,\n        loadLevel = _this$hls.loadLevel,\n        config = _this$hls.config;\n      if (levels.length === 1) {\n        return 0;\n      }\n      var level = levels[selectionBaseLevel];\n      var live = !!(level != null && (_level$details = level.details) != null && _level$details.live);\n      var firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;\n      var currentCodecSet;\n      var currentVideoRange = 'SDR';\n      var currentFrameRate = (level == null ? void 0 : level.frameRate) || 0;\n      var audioPreference = config.audioPreference,\n        videoPreference = config.videoPreference;\n      var audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));\n      if (firstSelection) {\n        if (this.firstSelection !== -1) {\n          return this.firstSelection;\n        }\n        var codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));\n        var startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);\n        var codecSet = startTier.codecSet,\n          videoRanges = startTier.videoRanges,\n          minFramerate = startTier.minFramerate,\n          minBitrate = startTier.minBitrate,\n          preferHDR = startTier.preferHDR;\n        currentCodecSet = codecSet;\n        currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];\n        currentFrameRate = minFramerate;\n        currentBw = Math.max(currentBw, minBitrate);\n        logger.log(\"[abr] picked start tier \" + JSON.stringify(startTier));\n      } else {\n        currentCodecSet = level == null ? void 0 : level.codecSet;\n        currentVideoRange = level == null ? void 0 : level.videoRange;\n      }\n      var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n      var ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;\n      var levelsSkipped = [];\n      var _loop = function _loop() {\n          var _levelInfo$supportedR;\n          var levelInfo = levels[i];\n          var upSwitch = i > selectionBaseLevel;\n          if (!levelInfo) {\n            return 0; // continue\n          }\n          if (config.useMediaCapabilities && !levelInfo.supportedResult && !levelInfo.supportedPromise) {\n            var mediaCapabilities = navigator.mediaCapabilities;\n            if (typeof (mediaCapabilities == null ? void 0 : mediaCapabilities.decodingInfo) === 'function' && requiresMediaCapabilitiesDecodingInfo(levelInfo, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference)) {\n              levelInfo.supportedPromise = getMediaDecodingInfoPromise(levelInfo, audioTracksByGroup, mediaCapabilities);\n              levelInfo.supportedPromise.then(function (decodingInfo) {\n                if (!_this2.hls) {\n                  return;\n                }\n                levelInfo.supportedResult = decodingInfo;\n                var levels = _this2.hls.levels;\n                var index = levels.indexOf(levelInfo);\n                if (decodingInfo.error) {\n                  logger.warn(\"[abr] MediaCapabilities decodingInfo error: \\\"\" + decodingInfo.error + \"\\\" for level \" + index + \" \" + JSON.stringify(decodingInfo));\n                } else if (!decodingInfo.supported) {\n                  logger.warn(\"[abr] Unsupported MediaCapabilities decodingInfo result for level \" + index + \" \" + JSON.stringify(decodingInfo));\n                  if (index > -1 && levels.length > 1) {\n                    logger.log(\"[abr] Removing unsupported level \" + index);\n                    _this2.hls.removeLevel(index);\n                  }\n                }\n              });\n            } else {\n              levelInfo.supportedResult = SUPPORTED_INFO_DEFAULT;\n            }\n          }\n\n          // skip candidates which change codec-family or video-range,\n          // and which decrease or increase frame-rate for up and down-switch respectfully\n          if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || levelInfo.supportedResult && !((_levelInfo$supportedR = levelInfo.supportedResult.decodingInfoResults) != null && _levelInfo$supportedR[0].smooth)) {\n            levelsSkipped.push(i);\n            return 0; // continue\n          }\n          var levelDetails = levelInfo.details;\n          var avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n          var adjustedbw;\n          // follow algorithm captured from stagefright :\n          // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n          // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n          // consider only 80% of the available bandwidth, but if we are switching up,\n          // be even more conservative (70%) to avoid overestimating and immediately\n          // switching back.\n          if (!upSwitch) {\n            adjustedbw = bwFactor * currentBw;\n          } else {\n            adjustedbw = bwUpFactor * currentBw;\n          }\n\n          // Use average bitrate when starvation delay (buffer length) is gt or eq two segment durations and rebuffering is not expected (maxStarvationDelay > 0)\n          var bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levels[i].averageBitrate : levels[i].maxBitrate;\n          var fetchDuration = _this2.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);\n          var canSwitchWithinTolerance =\n          // if adjusted bw is greater than level bitrate AND\n          adjustedbw >= bitrate && (\n          // no level change, or new level has no error history\n          i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && (\n          // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n          // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n          // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n          fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !_this2.bitrateTestDelay || fetchDuration < maxFetchDuration);\n          if (canSwitchWithinTolerance) {\n            var forcedAutoLevel = _this2.forcedAutoLevel;\n            if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {\n              if (levelsSkipped.length) {\n                logger.trace(\"[abr] Skipped level(s) \" + levelsSkipped.join(',') + \" of \" + maxAutoLevel + \" max with CODECS and VIDEO-RANGE:\\\"\" + levels[levelsSkipped[0]].codecs + \"\\\" \" + levels[levelsSkipped[0]].videoRange + \"; not compatible with \\\"\" + level.codecs + \"\\\" \" + currentVideoRange);\n              }\n              logger.info(\"[abr] switch candidate:\" + selectionBaseLevel + \"->\" + i + \" adjustedbw(\" + Math.round(adjustedbw) + \")-bitrate=\" + Math.round(adjustedbw - bitrate) + \" ttfb:\" + ttfbEstimateSec.toFixed(1) + \" avgDuration:\" + avgDuration.toFixed(1) + \" maxFetchDuration:\" + maxFetchDuration.toFixed(1) + \" fetchDuration:\" + fetchDuration.toFixed(1) + \" firstSelection:\" + firstSelection + \" codecSet:\" + currentCodecSet + \" videoRange:\" + currentVideoRange + \" hls.loadLevel:\" + loadLevel);\n            }\n            if (firstSelection) {\n              _this2.firstSelection = i;\n            }\n            // as we are looping from highest to lowest, this will return the best achievable quality level\n            return {\n              v: i\n            };\n          }\n        },\n        _ret;\n      for (var i = maxAutoLevel; i >= minAutoLevel; i--) {\n        _ret = _loop();\n        if (_ret === 0) continue;\n        if (_ret) return _ret.v;\n      }\n      // not enough time budget even with quality level 0 ... rebuffering might happen\n      return -1;\n    };\n    _createClass(AbrController, [{\n      key: \"firstAutoLevel\",\n      get: function get() {\n        var _this$hls2 = this.hls,\n          maxAutoLevel = _this$hls2.maxAutoLevel,\n          minAutoLevel = _this$hls2.minAutoLevel;\n        var bwEstimate = this.getBwEstimate();\n        var maxStartDelay = this.hls.config.maxStarvationDelay;\n        var abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);\n        if (abrAutoLevel > -1) {\n          return abrAutoLevel;\n        }\n        var firstLevel = this.hls.firstLevel;\n        var clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);\n        logger.warn(\"[abr] Could not find best starting auto level. Defaulting to first in playlist \" + firstLevel + \" clamped to \" + clamped);\n        return clamped;\n      }\n    }, {\n      key: \"forcedAutoLevel\",\n      get: function get() {\n        if (this.nextAutoLevelKey) {\n          return -1;\n        }\n        return this._nextAutoLevel;\n      }\n\n      // return next auto level\n    }, {\n      key: \"nextAutoLevel\",\n      get: function get() {\n        var forcedAutoLevel = this.forcedAutoLevel;\n        var bwEstimator = this.bwEstimator;\n        var useEstimate = bwEstimator.canEstimate();\n        var loadedFirstFrag = this.lastLoadedFragLevel > -1;\n        // in case next auto level has been forced, and bw not available or not reliable, return forced value\n        if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {\n          return forcedAutoLevel;\n        }\n\n        // compute next level using ABR logic\n        var nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;\n\n        // use forced auto level while it hasn't errored more than ABR selection\n        if (forcedAutoLevel !== -1) {\n          var levels = this.hls.levels;\n          if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {\n            return forcedAutoLevel;\n          }\n        }\n\n        // save result until state has changed\n        this._nextAutoLevel = nextABRAutoLevel;\n        this.nextAutoLevelKey = this.getAutoLevelKey();\n        return nextABRAutoLevel;\n      },\n      set: function set(nextLevel) {\n        var _this$hls3 = this.hls,\n          maxAutoLevel = _this$hls3.maxAutoLevel,\n          minAutoLevel = _this$hls3.minAutoLevel;\n        var value = Math.min(Math.max(nextLevel, minAutoLevel), maxAutoLevel);\n        if (this._nextAutoLevel !== value) {\n          this.nextAutoLevelKey = '';\n          this._nextAutoLevel = value;\n        }\n      }\n    }]);\n    return AbrController;\n  }();\n\n  /**\n   * @ignore\n   * Sub-class specialization of EventHandler base class.\n   *\n   * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n   * scheduled asynchroneously, avoiding recursive calls in the same tick.\n   *\n   * The task itself is implemented in `doTick`. It can be requested and called for single execution\n   * using the `tick` method.\n   *\n   * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n   * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n   *\n   * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n   * and cancelled with `clearNextTick`.\n   *\n   * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n   *\n   * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n   *\n   * Further explanations:\n   *\n   * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n   * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n   *\n   * When the task execution (`tick` method) is called in re-entrant way this is detected and\n   * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n   * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n   */\n  var TaskLoop = /*#__PURE__*/function () {\n    function TaskLoop() {\n      this._boundTick = void 0;\n      this._tickTimer = null;\n      this._tickInterval = null;\n      this._tickCallCount = 0;\n      this._boundTick = this.tick.bind(this);\n    }\n    var _proto = TaskLoop.prototype;\n    _proto.destroy = function destroy() {\n      this.onHandlerDestroying();\n      this.onHandlerDestroyed();\n    };\n    _proto.onHandlerDestroying = function onHandlerDestroying() {\n      // clear all timers before unregistering from event bus\n      this.clearNextTick();\n      this.clearInterval();\n    };\n    _proto.onHandlerDestroyed = function onHandlerDestroyed() {};\n    _proto.hasInterval = function hasInterval() {\n      return !!this._tickInterval;\n    };\n    _proto.hasNextTick = function hasNextTick() {\n      return !!this._tickTimer;\n    }\n\n    /**\n     * @param millis - Interval time (ms)\n     * @eturns True when interval has been scheduled, false when already scheduled (no effect)\n     */;\n    _proto.setInterval = function setInterval(millis) {\n      if (!this._tickInterval) {\n        this._tickCallCount = 0;\n        this._tickInterval = self.setInterval(this._boundTick, millis);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @returns True when interval was cleared, false when none was set (no effect)\n     */;\n    _proto.clearInterval = function clearInterval() {\n      if (this._tickInterval) {\n        self.clearInterval(this._tickInterval);\n        this._tickInterval = null;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @returns True when timeout was cleared, false when none was set (no effect)\n     */;\n    _proto.clearNextTick = function clearNextTick() {\n      if (this._tickTimer) {\n        self.clearTimeout(this._tickTimer);\n        this._tickTimer = null;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Will call the subclass doTick implementation in this main loop tick\n     * or in the next one (via setTimeout(,0)) in case it has already been called\n     * in this tick (in case this is a re-entrant call).\n     */;\n    _proto.tick = function tick() {\n      this._tickCallCount++;\n      if (this._tickCallCount === 1) {\n        this.doTick();\n        // re-entrant call to tick from previous doTick call stack\n        // -> schedule a call on the next main loop iteration to process this task processing request\n        if (this._tickCallCount > 1) {\n          // make sure only one timer exists at any time at max\n          this.tickImmediate();\n        }\n        this._tickCallCount = 0;\n      }\n    };\n    _proto.tickImmediate = function tickImmediate() {\n      this.clearNextTick();\n      this._tickTimer = self.setTimeout(this._boundTick, 0);\n    }\n\n    /**\n     * For subclass to implement task logic\n     * @abstract\n     */;\n    _proto.doTick = function doTick() {};\n    return TaskLoop;\n  }();\n\n  var FragmentState = {\n    NOT_LOADED: \"NOT_LOADED\",\n    APPENDING: \"APPENDING\",\n    PARTIAL: \"PARTIAL\",\n    OK: \"OK\"\n  };\n  var FragmentTracker = /*#__PURE__*/function () {\n    function FragmentTracker(hls) {\n      this.activePartLists = Object.create(null);\n      this.endListFragments = Object.create(null);\n      this.fragments = Object.create(null);\n      this.timeRanges = Object.create(null);\n      this.bufferPadding = 0.2;\n      this.hls = void 0;\n      this.hasGaps = false;\n      this.hls = hls;\n      this._registerListeners();\n    }\n    var _proto = FragmentTracker.prototype;\n    _proto._registerListeners = function _registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    };\n    _proto._unregisterListeners = function _unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    };\n    _proto.destroy = function destroy() {\n      this._unregisterListeners();\n      // @ts-ignore\n      this.fragments =\n      // @ts-ignore\n      this.activePartLists =\n      // @ts-ignore\n      this.endListFragments = this.timeRanges = null;\n    }\n\n    /**\n     * Return a Fragment or Part with an appended range that matches the position and levelType\n     * Otherwise, return null\n     */;\n    _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {\n      var activeParts = this.activePartLists[levelType];\n      if (activeParts) {\n        for (var i = activeParts.length; i--;) {\n          var activePart = activeParts[i];\n          if (!activePart) {\n            break;\n          }\n          var appendedPTS = activePart.end;\n          if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {\n            return activePart;\n          }\n        }\n      }\n      return this.getBufferedFrag(position, levelType);\n    }\n\n    /**\n     * Return a buffered Fragment that matches the position and levelType.\n     * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n     * If not found any Fragment, return null\n     */;\n    _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {\n      var fragments = this.fragments;\n      var keys = Object.keys(fragments);\n      for (var i = keys.length; i--;) {\n        var fragmentEntity = fragments[keys[i]];\n        if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {\n          var frag = fragmentEntity.body;\n          if (frag.start <= position && position <= frag.end) {\n            return frag;\n          }\n        }\n      }\n      return null;\n    }\n\n    /**\n     * Partial fragments effected by coded frame eviction will be removed\n     * The browser will unload parts of the buffer to free up memory for new buffer data\n     * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n     */;\n    _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {\n      var _this = this;\n      if (this.timeRanges) {\n        this.timeRanges[elementaryStream] = timeRange;\n      }\n      // Check if any flagged fragments have been unloaded\n      // excluding anything newer than appendedPartSn\n      var appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;\n      Object.keys(this.fragments).forEach(function (key) {\n        var fragmentEntity = _this.fragments[key];\n        if (!fragmentEntity) {\n          return;\n        }\n        if (appendedPartSn >= fragmentEntity.body.sn) {\n          return;\n        }\n        if (!fragmentEntity.buffered && !fragmentEntity.loaded) {\n          if (fragmentEntity.body.type === playlistType) {\n            _this.removeFragment(fragmentEntity.body);\n          }\n          return;\n        }\n        var esData = fragmentEntity.range[elementaryStream];\n        if (!esData) {\n          return;\n        }\n        esData.time.some(function (time) {\n          var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n          if (isNotBuffered) {\n            // Unregister partial fragment as it needs to load again to be reused\n            _this.removeFragment(fragmentEntity.body);\n          }\n          return isNotBuffered;\n        });\n      });\n    }\n\n    /**\n     * Checks if the fragment passed in is loaded in the buffer properly\n     * Partially loaded fragments will be registered as a partial fragment\n     */;\n    _proto.detectPartialFragments = function detectPartialFragments(data) {\n      var _this2 = this;\n      var timeRanges = this.timeRanges;\n      var frag = data.frag,\n        part = data.part;\n      if (!timeRanges || frag.sn === 'initSegment') {\n        return;\n      }\n      var fragKey = getFragmentKey(frag);\n      var fragmentEntity = this.fragments[fragKey];\n      if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {\n        return;\n      }\n      var isFragHint = !frag.relurl;\n      Object.keys(timeRanges).forEach(function (elementaryStream) {\n        var streamInfo = frag.elementaryStreams[elementaryStream];\n        if (!streamInfo) {\n          return;\n        }\n        var timeRange = timeRanges[elementaryStream];\n        var partial = isFragHint || streamInfo.partial === true;\n        fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, part, partial, timeRange);\n      });\n      fragmentEntity.loaded = null;\n      if (Object.keys(fragmentEntity.range).length) {\n        fragmentEntity.buffered = true;\n        var endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;\n        if (endList) {\n          this.endListFragments[fragmentEntity.body.type] = fragmentEntity;\n        }\n        if (!isPartial(fragmentEntity)) {\n          // Remove older fragment parts from lookup after frag is tracked as buffered\n          this.removeParts(frag.sn - 1, frag.type);\n        }\n      } else {\n        // remove fragment if nothing was appended\n        this.removeFragment(fragmentEntity.body);\n      }\n    };\n    _proto.removeParts = function removeParts(snToKeep, levelType) {\n      var activeParts = this.activePartLists[levelType];\n      if (!activeParts) {\n        return;\n      }\n      this.activePartLists[levelType] = activeParts.filter(function (part) {\n        return part.fragment.sn >= snToKeep;\n      });\n    };\n    _proto.fragBuffered = function fragBuffered(frag, force) {\n      var fragKey = getFragmentKey(frag);\n      var fragmentEntity = this.fragments[fragKey];\n      if (!fragmentEntity && force) {\n        fragmentEntity = this.fragments[fragKey] = {\n          body: frag,\n          appendedPTS: null,\n          loaded: null,\n          buffered: false,\n          range: Object.create(null)\n        };\n        if (frag.gap) {\n          this.hasGaps = true;\n        }\n      }\n      if (fragmentEntity) {\n        fragmentEntity.loaded = null;\n        fragmentEntity.buffered = true;\n      }\n    };\n    _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {\n      var buffered = {\n        time: [],\n        partial: partial\n      };\n      var startPTS = fragment.start;\n      var endPTS = fragment.end;\n      var minEndPTS = fragment.minEndPTS || endPTS;\n      var maxStartPTS = fragment.maxStartPTS || startPTS;\n      for (var i = 0; i < timeRange.length; i++) {\n        var startTime = timeRange.start(i) - this.bufferPadding;\n        var endTime = timeRange.end(i) + this.bufferPadding;\n        if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n          // Fragment is entirely contained in buffer\n          // No need to check the other timeRange times since it's completely playable\n          buffered.time.push({\n            startPTS: Math.max(startPTS, timeRange.start(i)),\n            endPTS: Math.min(endPTS, timeRange.end(i))\n          });\n          break;\n        } else if (startPTS < endTime && endPTS > startTime) {\n          var start = Math.max(startPTS, timeRange.start(i));\n          var end = Math.min(endPTS, timeRange.end(i));\n          if (end > start) {\n            buffered.partial = true;\n            // Check for intersection with buffer\n            // Get playable sections of the fragment\n            buffered.time.push({\n              startPTS: start,\n              endPTS: end\n            });\n          }\n        } else if (endPTS <= startTime) {\n          // No need to check the rest of the timeRange as it is in order\n          break;\n        }\n      }\n      return buffered;\n    }\n\n    /**\n     * Gets the partial fragment for a certain time\n     */;\n    _proto.getPartialFragment = function getPartialFragment(time) {\n      var bestFragment = null;\n      var timePadding;\n      var startTime;\n      var endTime;\n      var bestOverlap = 0;\n      var bufferPadding = this.bufferPadding,\n        fragments = this.fragments;\n      Object.keys(fragments).forEach(function (key) {\n        var fragmentEntity = fragments[key];\n        if (!fragmentEntity) {\n          return;\n        }\n        if (isPartial(fragmentEntity)) {\n          startTime = fragmentEntity.body.start - bufferPadding;\n          endTime = fragmentEntity.body.end + bufferPadding;\n          if (time >= startTime && time <= endTime) {\n            // Use the fragment that has the most padding from start and end time\n            timePadding = Math.min(time - startTime, endTime - time);\n            if (bestOverlap <= timePadding) {\n              bestFragment = fragmentEntity.body;\n              bestOverlap = timePadding;\n            }\n          }\n        }\n      });\n      return bestFragment;\n    };\n    _proto.isEndListAppended = function isEndListAppended(type) {\n      var lastFragmentEntity = this.endListFragments[type];\n      return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));\n    };\n    _proto.getState = function getState(fragment) {\n      var fragKey = getFragmentKey(fragment);\n      var fragmentEntity = this.fragments[fragKey];\n      if (fragmentEntity) {\n        if (!fragmentEntity.buffered) {\n          return FragmentState.APPENDING;\n        } else if (isPartial(fragmentEntity)) {\n          return FragmentState.PARTIAL;\n        } else {\n          return FragmentState.OK;\n        }\n      }\n      return FragmentState.NOT_LOADED;\n    };\n    _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {\n      var startTime;\n      var endTime;\n      for (var i = 0; i < timeRange.length; i++) {\n        startTime = timeRange.start(i) - this.bufferPadding;\n        endTime = timeRange.end(i) + this.bufferPadding;\n        if (startPTS >= startTime && endPTS <= endTime) {\n          return true;\n        }\n        if (endPTS <= startTime) {\n          // No need to check the rest of the timeRange as it is in order\n          return false;\n        }\n      }\n      return false;\n    };\n    _proto.onFragLoaded = function onFragLoaded(event, data) {\n      var frag = data.frag,\n        part = data.part;\n      // don't track initsegment (for which sn is not a number)\n      // don't track frags used for bitrateTest, they're irrelevant.\n      if (frag.sn === 'initSegment' || frag.bitrateTest) {\n        return;\n      }\n\n      // Fragment entity `loaded` FragLoadedData is null when loading parts\n      var loaded = part ? null : data;\n      var fragKey = getFragmentKey(frag);\n      this.fragments[fragKey] = {\n        body: frag,\n        appendedPTS: null,\n        loaded: loaded,\n        buffered: false,\n        range: Object.create(null)\n      };\n    };\n    _proto.onBufferAppended = function onBufferAppended(event, data) {\n      var _this3 = this;\n      var frag = data.frag,\n        part = data.part,\n        timeRanges = data.timeRanges;\n      if (frag.sn === 'initSegment') {\n        return;\n      }\n      var playlistType = frag.type;\n      if (part) {\n        var activeParts = this.activePartLists[playlistType];\n        if (!activeParts) {\n          this.activePartLists[playlistType] = activeParts = [];\n        }\n        activeParts.push(part);\n      }\n      // Store the latest timeRanges loaded in the buffer\n      this.timeRanges = timeRanges;\n      Object.keys(timeRanges).forEach(function (elementaryStream) {\n        var timeRange = timeRanges[elementaryStream];\n        _this3.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);\n      });\n    };\n    _proto.onFragBuffered = function onFragBuffered(event, data) {\n      this.detectPartialFragments(data);\n    };\n    _proto.hasFragment = function hasFragment(fragment) {\n      var fragKey = getFragmentKey(fragment);\n      return !!this.fragments[fragKey];\n    };\n    _proto.hasParts = function hasParts(type) {\n      var _this$activePartLists;\n      return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);\n    };\n    _proto.removeFragmentsInRange = function removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {\n      var _this4 = this;\n      if (withGapOnly && !this.hasGaps) {\n        return;\n      }\n      Object.keys(this.fragments).forEach(function (key) {\n        var fragmentEntity = _this4.fragments[key];\n        if (!fragmentEntity) {\n          return;\n        }\n        var frag = fragmentEntity.body;\n        if (frag.type !== playlistType || withGapOnly && !frag.gap) {\n          return;\n        }\n        if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {\n          _this4.removeFragment(frag);\n        }\n      });\n    };\n    _proto.removeFragment = function removeFragment(fragment) {\n      var fragKey = getFragmentKey(fragment);\n      fragment.stats.loaded = 0;\n      fragment.clearElementaryStreamInfo();\n      var activeParts = this.activePartLists[fragment.type];\n      if (activeParts) {\n        var snToRemove = fragment.sn;\n        this.activePartLists[fragment.type] = activeParts.filter(function (part) {\n          return part.fragment.sn !== snToRemove;\n        });\n      }\n      delete this.fragments[fragKey];\n      if (fragment.endList) {\n        delete this.endListFragments[fragment.type];\n      }\n    };\n    _proto.removeAllFragments = function removeAllFragments() {\n      this.fragments = Object.create(null);\n      this.endListFragments = Object.create(null);\n      this.activePartLists = Object.create(null);\n      this.hasGaps = false;\n    };\n    return FragmentTracker;\n  }();\n  function isPartial(fragmentEntity) {\n    var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;\n    return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));\n  }\n  function getFragmentKey(fragment) {\n    return fragment.type + \"_\" + fragment.level + \"_\" + fragment.sn;\n  }\n\n  /**\n   * Provides methods dealing with buffer length retrieval for example.\n   *\n   * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n   *\n   * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n   */\n\n  var noopBuffered = {\n    length: 0,\n    start: function start() {\n      return 0;\n    },\n    end: function end() {\n      return 0;\n    }\n  };\n  var BufferHelper = /*#__PURE__*/function () {\n    function BufferHelper() {}\n    /**\n     * Return true if `media`'s buffered include `position`\n     */\n    BufferHelper.isBuffered = function isBuffered(media, position) {\n      try {\n        if (media) {\n          var buffered = BufferHelper.getBuffered(media);\n          for (var i = 0; i < buffered.length; i++) {\n            if (position >= buffered.start(i) && position <= buffered.end(i)) {\n              return true;\n            }\n          }\n        }\n      } catch (error) {\n        // this is to catch\n        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n        // This SourceBuffer has been removed from the parent media source\n      }\n      return false;\n    };\n    BufferHelper.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {\n      try {\n        if (media) {\n          var vbuffered = BufferHelper.getBuffered(media);\n          var buffered = [];\n          var i;\n          for (i = 0; i < vbuffered.length; i++) {\n            buffered.push({\n              start: vbuffered.start(i),\n              end: vbuffered.end(i)\n            });\n          }\n          return this.bufferedInfo(buffered, pos, maxHoleDuration);\n        }\n      } catch (error) {\n        // this is to catch\n        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n        // This SourceBuffer has been removed from the parent media source\n      }\n      return {\n        len: 0,\n        start: pos,\n        end: pos,\n        nextStart: undefined\n      };\n    };\n    BufferHelper.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {\n      pos = Math.max(0, pos);\n      // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n      buffered.sort(function (a, b) {\n        var diff = a.start - b.start;\n        if (diff) {\n          return diff;\n        } else {\n          return b.end - a.end;\n        }\n      });\n      var buffered2 = [];\n      if (maxHoleDuration) {\n        // there might be some small holes between buffer time range\n        // consider that holes smaller than maxHoleDuration are irrelevant and build another\n        // buffer time range representations that discards those holes\n        for (var i = 0; i < buffered.length; i++) {\n          var buf2len = buffered2.length;\n          if (buf2len) {\n            var buf2end = buffered2[buf2len - 1].end;\n            // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n            if (buffered[i].start - buf2end < maxHoleDuration) {\n              // merge overlapping time ranges\n              // update lastRange.end only if smaller than item.end\n              // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n              // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n              if (buffered[i].end > buf2end) {\n                buffered2[buf2len - 1].end = buffered[i].end;\n              }\n            } else {\n              // big hole\n              buffered2.push(buffered[i]);\n            }\n          } else {\n            // first value\n            buffered2.push(buffered[i]);\n          }\n        }\n      } else {\n        buffered2 = buffered;\n      }\n      var bufferLen = 0;\n\n      // bufferStartNext can possibly be undefined based on the conditional logic below\n      var bufferStartNext;\n\n      // bufferStart and bufferEnd are buffer boundaries around current video position\n      var bufferStart = pos;\n      var bufferEnd = pos;\n      for (var _i = 0; _i < buffered2.length; _i++) {\n        var start = buffered2[_i].start;\n        var end = buffered2[_i].end;\n        // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n        if (pos + maxHoleDuration >= start && pos < end) {\n          // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n          bufferStart = start;\n          bufferEnd = end;\n          bufferLen = bufferEnd - pos;\n        } else if (pos + maxHoleDuration < start) {\n          bufferStartNext = start;\n          break;\n        }\n      }\n      return {\n        len: bufferLen,\n        start: bufferStart || 0,\n        end: bufferEnd || 0,\n        nextStart: bufferStartNext\n      };\n    }\n\n    /**\n     * Safe method to get buffered property.\n     * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n     */;\n    BufferHelper.getBuffered = function getBuffered(media) {\n      try {\n        return media.buffered;\n      } catch (e) {\n        logger.log('failed to get media.buffered', e);\n        return noopBuffered;\n      }\n    };\n    return BufferHelper;\n  }();\n\n  var ChunkMetadata = function ChunkMetadata(level, sn, id, size, part, partial) {\n    if (size === void 0) {\n      size = 0;\n    }\n    if (part === void 0) {\n      part = -1;\n    }\n    if (partial === void 0) {\n      partial = false;\n    }\n    this.level = void 0;\n    this.sn = void 0;\n    this.part = void 0;\n    this.id = void 0;\n    this.size = void 0;\n    this.partial = void 0;\n    this.transmuxing = getNewPerformanceTiming();\n    this.buffering = {\n      audio: getNewPerformanceTiming(),\n      video: getNewPerformanceTiming(),\n      audiovideo: getNewPerformanceTiming()\n    };\n    this.level = level;\n    this.sn = sn;\n    this.id = id;\n    this.size = size;\n    this.part = part;\n    this.partial = partial;\n  };\n  function getNewPerformanceTiming() {\n    return {\n      start: 0,\n      executeStart: 0,\n      executeEnd: 0,\n      end: 0\n    };\n  }\n\n  function findFirstFragWithCC(fragments, cc) {\n    for (var i = 0, len = fragments.length; i < len; i++) {\n      var _fragments$i;\n      if (((_fragments$i = fragments[i]) == null ? void 0 : _fragments$i.cc) === cc) {\n        return fragments[i];\n      }\n    }\n    return null;\n  }\n  function shouldAlignOnDiscontinuities(lastFrag, switchDetails, details) {\n    if (switchDetails) {\n      if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Find the first frag in the previous level which matches the CC of the first frag of the new level\n  function findDiscontinuousReferenceFrag(prevDetails, curDetails) {\n    var prevFrags = prevDetails.fragments;\n    var curFrags = curDetails.fragments;\n    if (!curFrags.length || !prevFrags.length) {\n      logger.log('No fragments to align');\n      return;\n    }\n    var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);\n    if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {\n      logger.log('No frag in previous level to align on');\n      return;\n    }\n    return prevStartFrag;\n  }\n  function adjustFragmentStart(frag, sliding) {\n    if (frag) {\n      var start = frag.start + sliding;\n      frag.start = frag.startPTS = start;\n      frag.endPTS = start + frag.duration;\n    }\n  }\n  function adjustSlidingStart(sliding, details) {\n    // Update segments\n    var fragments = details.fragments;\n    for (var i = 0, len = fragments.length; i < len; i++) {\n      adjustFragmentStart(fragments[i], sliding);\n    }\n    // Update LL-HLS parts at the end of the playlist\n    if (details.fragmentHint) {\n      adjustFragmentStart(details.fragmentHint, sliding);\n    }\n    details.alignedSliding = true;\n  }\n\n  /**\n   * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n   * contiguous stream with the last fragments.\n   * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n   * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n   * and an extra download.\n   * @param lastFrag\n   * @param lastLevel\n   * @param details\n   */\n  function alignStream(lastFrag, switchDetails, details) {\n    if (!switchDetails) {\n      return;\n    }\n    alignDiscontinuities(lastFrag, details, switchDetails);\n    if (!details.alignedSliding && switchDetails) {\n      // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n      // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n      // discontinuity sequence.\n      alignMediaPlaylistByPDT(details, switchDetails);\n    }\n    if (!details.alignedSliding && switchDetails && !details.skippedSegments) {\n      // Try to align on sn so that we pick a better start fragment.\n      // Do not perform this on playlists with delta updates as this is only to align levels on switch\n      // and adjustSliding only adjusts fragments after skippedSegments.\n      adjustSliding(switchDetails, details);\n    }\n  }\n\n  /**\n   * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same\n   * discontinuity sequence.\n   * @param lastFrag - The last Fragment which shares the same discontinuity sequence\n   * @param lastLevel - The details of the last loaded level\n   * @param details - The details of the new level\n   */\n  function alignDiscontinuities(lastFrag, details, switchDetails) {\n    if (shouldAlignOnDiscontinuities(lastFrag, switchDetails, details)) {\n      var referenceFrag = findDiscontinuousReferenceFrag(switchDetails, details);\n      if (referenceFrag && isFiniteNumber(referenceFrag.start)) {\n        logger.log(\"Adjusting PTS using last level due to CC increase within current level \" + details.url);\n        adjustSlidingStart(referenceFrag.start, details);\n      }\n    }\n  }\n\n  /**\n   * Ensures appropriate time-alignment between renditions based on PDT.\n   * This function assumes the timelines represented in `refDetails` are accurate, including the PDTs\n   * for the last discontinuity sequence number shared by both playlists when present,\n   * and uses the \"wallclock\"/PDT timeline as a cross-reference to `details`, adjusting the presentation\n   * times/timelines of `details` accordingly.\n   * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,\n   * the primary purpose of this function is to ensure the \"local timelines\" of audio/subtitle tracks\n   * are aligned to the main/video timeline, using PDT as the cross-reference/\"anchor\" that should\n   * be consistent across playlists, per the HLS spec.\n   * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).\n   * @param refDetails - The details of the reference rendition with start and PDT times for alignment.\n   */\n  function alignMediaPlaylistByPDT(details, refDetails) {\n    if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {\n      return;\n    }\n    var fragments = details.fragments;\n    var refFragments = refDetails.fragments;\n    if (!fragments.length || !refFragments.length) {\n      return;\n    }\n\n    // Calculate a delta to apply to all fragments according to the delta in PDT times and start times\n    // of a fragment in the reference details, and a fragment in the target details of the same discontinuity.\n    // If a fragment of the same discontinuity was not found use the middle fragment of both.\n    var refFrag;\n    var frag;\n    var targetCC = Math.min(refDetails.endCC, details.endCC);\n    if (refDetails.startCC < targetCC && details.startCC < targetCC) {\n      refFrag = findFirstFragWithCC(refFragments, targetCC);\n      frag = findFirstFragWithCC(fragments, targetCC);\n    }\n    if (!refFrag || !frag) {\n      refFrag = refFragments[Math.floor(refFragments.length / 2)];\n      frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];\n    }\n    var refPDT = refFrag.programDateTime;\n    var targetPDT = frag.programDateTime;\n    if (!refPDT || !targetPDT) {\n      return;\n    }\n    var delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);\n    adjustSlidingStart(delta, details);\n  }\n\n  var MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\n  var FragmentLoader = /*#__PURE__*/function () {\n    function FragmentLoader(config) {\n      this.config = void 0;\n      this.loader = null;\n      this.partLoadTimeout = -1;\n      this.config = config;\n    }\n    var _proto = FragmentLoader.prototype;\n    _proto.destroy = function destroy() {\n      if (this.loader) {\n        this.loader.destroy();\n        this.loader = null;\n      }\n    };\n    _proto.abort = function abort() {\n      if (this.loader) {\n        // Abort the loader for current fragment. Only one may load at any given time\n        this.loader.abort();\n      }\n    };\n    _proto.load = function load(frag, _onProgress) {\n      var _this = this;\n      var url = frag.url;\n      if (!url) {\n        return Promise.reject(new LoadError({\n          type: ErrorTypes.NETWORK_ERROR,\n          details: ErrorDetails.FRAG_LOAD_ERROR,\n          fatal: false,\n          frag: frag,\n          error: new Error(\"Fragment does not have a \" + (url ? 'part list' : 'url')),\n          networkDetails: null\n        }));\n      }\n      this.abort();\n      var config = this.config;\n      var FragmentILoader = config.fLoader;\n      var DefaultILoader = config.loader;\n      return new Promise(function (resolve, reject) {\n        if (_this.loader) {\n          _this.loader.destroy();\n        }\n        if (frag.gap) {\n          if (frag.tagList.some(function (tags) {\n            return tags[0] === 'GAP';\n          })) {\n            reject(createGapLoadError(frag));\n            return;\n          } else {\n            // Reset temporary treatment as GAP tag\n            frag.gap = false;\n          }\n        }\n        var loader = _this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n        var loaderContext = createLoaderContext(frag);\n        var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n        var loaderConfig = {\n          loadPolicy: loadPolicy,\n          timeout: loadPolicy.maxLoadTimeMs,\n          maxRetry: 0,\n          retryDelay: 0,\n          maxRetryDelay: 0,\n          highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE\n        };\n        // Assign frag stats to the loader's stats reference\n        frag.stats = loader.stats;\n        loader.load(loaderContext, loaderConfig, {\n          onSuccess: function onSuccess(response, stats, context, networkDetails) {\n            _this.resetLoader(frag, loader);\n            var payload = response.data;\n            if (context.resetIV && frag.decryptdata) {\n              frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));\n              payload = payload.slice(16);\n            }\n            resolve({\n              frag: frag,\n              part: null,\n              payload: payload,\n              networkDetails: networkDetails\n            });\n          },\n          onError: function onError(response, context, networkDetails, stats) {\n            _this.resetLoader(frag, loader);\n            reject(new LoadError({\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.FRAG_LOAD_ERROR,\n              fatal: false,\n              frag: frag,\n              response: _objectSpread2({\n                url: url,\n                data: undefined\n              }, response),\n              error: new Error(\"HTTP Error \" + response.code + \" \" + response.text),\n              networkDetails: networkDetails,\n              stats: stats\n            }));\n          },\n          onAbort: function onAbort(stats, context, networkDetails) {\n            _this.resetLoader(frag, loader);\n            reject(new LoadError({\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.INTERNAL_ABORTED,\n              fatal: false,\n              frag: frag,\n              error: new Error('Aborted'),\n              networkDetails: networkDetails,\n              stats: stats\n            }));\n          },\n          onTimeout: function onTimeout(stats, context, networkDetails) {\n            _this.resetLoader(frag, loader);\n            reject(new LoadError({\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n              fatal: false,\n              frag: frag,\n              error: new Error(\"Timeout after \" + loaderConfig.timeout + \"ms\"),\n              networkDetails: networkDetails,\n              stats: stats\n            }));\n          },\n          onProgress: function onProgress(stats, context, data, networkDetails) {\n            if (_onProgress) {\n              _onProgress({\n                frag: frag,\n                part: null,\n                payload: data,\n                networkDetails: networkDetails\n              });\n            }\n          }\n        });\n      });\n    };\n    _proto.loadPart = function loadPart(frag, part, onProgress) {\n      var _this2 = this;\n      this.abort();\n      var config = this.config;\n      var FragmentILoader = config.fLoader;\n      var DefaultILoader = config.loader;\n      return new Promise(function (resolve, reject) {\n        if (_this2.loader) {\n          _this2.loader.destroy();\n        }\n        if (frag.gap || part.gap) {\n          reject(createGapLoadError(frag, part));\n          return;\n        }\n        var loader = _this2.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n        var loaderContext = createLoaderContext(frag, part);\n        // Should we define another load policy for parts?\n        var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n        var loaderConfig = {\n          loadPolicy: loadPolicy,\n          timeout: loadPolicy.maxLoadTimeMs,\n          maxRetry: 0,\n          retryDelay: 0,\n          maxRetryDelay: 0,\n          highWaterMark: MIN_CHUNK_SIZE\n        };\n        // Assign part stats to the loader's stats reference\n        part.stats = loader.stats;\n        loader.load(loaderContext, loaderConfig, {\n          onSuccess: function onSuccess(response, stats, context, networkDetails) {\n            _this2.resetLoader(frag, loader);\n            _this2.updateStatsFromPart(frag, part);\n            var partLoadedData = {\n              frag: frag,\n              part: part,\n              payload: response.data,\n              networkDetails: networkDetails\n            };\n            onProgress(partLoadedData);\n            resolve(partLoadedData);\n          },\n          onError: function onError(response, context, networkDetails, stats) {\n            _this2.resetLoader(frag, loader);\n            reject(new LoadError({\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.FRAG_LOAD_ERROR,\n              fatal: false,\n              frag: frag,\n              part: part,\n              response: _objectSpread2({\n                url: loaderContext.url,\n                data: undefined\n              }, response),\n              error: new Error(\"HTTP Error \" + response.code + \" \" + response.text),\n              networkDetails: networkDetails,\n              stats: stats\n            }));\n          },\n          onAbort: function onAbort(stats, context, networkDetails) {\n            frag.stats.aborted = part.stats.aborted;\n            _this2.resetLoader(frag, loader);\n            reject(new LoadError({\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.INTERNAL_ABORTED,\n              fatal: false,\n              frag: frag,\n              part: part,\n              error: new Error('Aborted'),\n              networkDetails: networkDetails,\n              stats: stats\n            }));\n          },\n          onTimeout: function onTimeout(stats, context, networkDetails) {\n            _this2.resetLoader(frag, loader);\n            reject(new LoadError({\n              type: ErrorTypes.NETWORK_ERROR,\n              details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n              fatal: false,\n              frag: frag,\n              part: part,\n              error: new Error(\"Timeout after \" + loaderConfig.timeout + \"ms\"),\n              networkDetails: networkDetails,\n              stats: stats\n            }));\n          }\n        });\n      });\n    };\n    _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {\n      var fragStats = frag.stats;\n      var partStats = part.stats;\n      var partTotal = partStats.total;\n      fragStats.loaded += partStats.loaded;\n      if (partTotal) {\n        var estTotalParts = Math.round(frag.duration / part.duration);\n        var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n        var estRemainingParts = estTotalParts - estLoadedParts;\n        var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n        fragStats.total = fragStats.loaded + estRemainingBytes;\n      } else {\n        fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n      }\n      var fragLoading = fragStats.loading;\n      var partLoading = partStats.loading;\n      if (fragLoading.start) {\n        // add to fragment loader latency\n        fragLoading.first += partLoading.first - partLoading.start;\n      } else {\n        fragLoading.start = partLoading.start;\n        fragLoading.first = partLoading.first;\n      }\n      fragLoading.end = partLoading.end;\n    };\n    _proto.resetLoader = function resetLoader(frag, loader) {\n      frag.loader = null;\n      if (this.loader === loader) {\n        self.clearTimeout(this.partLoadTimeout);\n        this.loader = null;\n      }\n      loader.destroy();\n    };\n    return FragmentLoader;\n  }();\n  function createLoaderContext(frag, part) {\n    if (part === void 0) {\n      part = null;\n    }\n    var segment = part || frag;\n    var loaderContext = {\n      frag: frag,\n      part: part,\n      responseType: 'arraybuffer',\n      url: segment.url,\n      headers: {},\n      rangeStart: 0,\n      rangeEnd: 0\n    };\n    var start = segment.byteRangeStartOffset;\n    var end = segment.byteRangeEndOffset;\n    if (isFiniteNumber(start) && isFiniteNumber(end)) {\n      var _frag$decryptdata;\n      var byteRangeStart = start;\n      var byteRangeEnd = end;\n      if (frag.sn === 'initSegment' && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === 'AES-128') {\n        // MAP segment encrypted with method 'AES-128', when served with HTTP Range,\n        // has the unencrypted size specified in the range.\n        // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6\n        var fragmentLen = end - start;\n        if (fragmentLen % 16) {\n          byteRangeEnd = end + (16 - fragmentLen % 16);\n        }\n        if (start !== 0) {\n          loaderContext.resetIV = true;\n          byteRangeStart = start - 16;\n        }\n      }\n      loaderContext.rangeStart = byteRangeStart;\n      loaderContext.rangeEnd = byteRangeEnd;\n    }\n    return loaderContext;\n  }\n  function createGapLoadError(frag, part) {\n    var error = new Error(\"GAP \" + (frag.gap ? 'tag' : 'attribute') + \" found\");\n    var errorData = {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_GAP,\n      fatal: false,\n      frag: frag,\n      error: error,\n      networkDetails: null\n    };\n    if (part) {\n      errorData.part = part;\n    }\n    (part ? part : frag).stats.aborted = true;\n    return new LoadError(errorData);\n  }\n  var LoadError = /*#__PURE__*/function (_Error) {\n    _inheritsLoose(LoadError, _Error);\n    function LoadError(data) {\n      var _this3;\n      _this3 = _Error.call(this, data.error.message) || this;\n      _this3.data = void 0;\n      _this3.data = data;\n      return _this3;\n    }\n    return LoadError;\n  }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n  var AESCrypto = /*#__PURE__*/function () {\n    function AESCrypto(subtle, iv) {\n      this.subtle = void 0;\n      this.aesIV = void 0;\n      this.subtle = subtle;\n      this.aesIV = iv;\n    }\n    var _proto = AESCrypto.prototype;\n    _proto.decrypt = function decrypt(data, key) {\n      return this.subtle.decrypt({\n        name: 'AES-CBC',\n        iv: this.aesIV\n      }, key, data);\n    };\n    return AESCrypto;\n  }();\n\n  var FastAESKey = /*#__PURE__*/function () {\n    function FastAESKey(subtle, key) {\n      this.subtle = void 0;\n      this.key = void 0;\n      this.subtle = subtle;\n      this.key = key;\n    }\n    var _proto = FastAESKey.prototype;\n    _proto.expandKey = function expandKey() {\n      return this.subtle.importKey('raw', this.key, {\n        name: 'AES-CBC'\n      }, false, ['encrypt', 'decrypt']);\n    };\n    return FastAESKey;\n  }();\n\n  // PKCS7\n  function removePadding(array) {\n    var outputBytes = array.byteLength;\n    var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n    if (paddingBytes) {\n      return sliceUint8(array, 0, outputBytes - paddingBytes);\n    }\n    return array;\n  }\n  var AESDecryptor = /*#__PURE__*/function () {\n    function AESDecryptor() {\n      this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n      this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n      this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n      this.sBox = new Uint32Array(256);\n      this.invSBox = new Uint32Array(256);\n      this.key = new Uint32Array(0);\n      this.ksRows = 0;\n      this.keySize = 0;\n      this.keySchedule = void 0;\n      this.invKeySchedule = void 0;\n      this.initTable();\n    }\n\n    // Using view.getUint32() also swaps the byte order.\n    var _proto = AESDecryptor.prototype;\n    _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {\n      var view = new DataView(arrayBuffer);\n      var newArray = new Uint32Array(4);\n      for (var i = 0; i < 4; i++) {\n        newArray[i] = view.getUint32(i * 4);\n      }\n      return newArray;\n    };\n    _proto.initTable = function initTable() {\n      var sBox = this.sBox;\n      var invSBox = this.invSBox;\n      var subMix = this.subMix;\n      var subMix0 = subMix[0];\n      var subMix1 = subMix[1];\n      var subMix2 = subMix[2];\n      var subMix3 = subMix[3];\n      var invSubMix = this.invSubMix;\n      var invSubMix0 = invSubMix[0];\n      var invSubMix1 = invSubMix[1];\n      var invSubMix2 = invSubMix[2];\n      var invSubMix3 = invSubMix[3];\n      var d = new Uint32Array(256);\n      var x = 0;\n      var xi = 0;\n      var i = 0;\n      for (i = 0; i < 256; i++) {\n        if (i < 128) {\n          d[i] = i << 1;\n        } else {\n          d[i] = i << 1 ^ 0x11b;\n        }\n      }\n      for (i = 0; i < 256; i++) {\n        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n        sBox[x] = sx;\n        invSBox[sx] = x;\n\n        // Compute multiplication\n        var x2 = d[x];\n        var x4 = d[x2];\n        var x8 = d[x4];\n\n        // Compute sub/invSub bytes, mix columns tables\n        var t = d[sx] * 0x101 ^ sx * 0x1010100;\n        subMix0[x] = t << 24 | t >>> 8;\n        subMix1[x] = t << 16 | t >>> 16;\n        subMix2[x] = t << 8 | t >>> 24;\n        subMix3[x] = t;\n\n        // Compute inv sub bytes, inv mix columns tables\n        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n        invSubMix0[sx] = t << 24 | t >>> 8;\n        invSubMix1[sx] = t << 16 | t >>> 16;\n        invSubMix2[sx] = t << 8 | t >>> 24;\n        invSubMix3[sx] = t;\n\n        // Compute next counter\n        if (!x) {\n          x = xi = 1;\n        } else {\n          x = x2 ^ d[d[d[x8 ^ x2]]];\n          xi ^= d[d[xi]];\n        }\n      }\n    };\n    _proto.expandKey = function expandKey(keyBuffer) {\n      // convert keyBuffer to Uint32Array\n      var key = this.uint8ArrayToUint32Array_(keyBuffer);\n      var sameKey = true;\n      var offset = 0;\n      while (offset < key.length && sameKey) {\n        sameKey = key[offset] === this.key[offset];\n        offset++;\n      }\n      if (sameKey) {\n        return;\n      }\n      this.key = key;\n      var keySize = this.keySize = key.length;\n      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n        throw new Error('Invalid aes key size=' + keySize);\n      }\n      var ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n      var ksRow;\n      var invKsRow;\n      var keySchedule = this.keySchedule = new Uint32Array(ksRows);\n      var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n      var sbox = this.sBox;\n      var rcon = this.rcon;\n      var invSubMix = this.invSubMix;\n      var invSubMix0 = invSubMix[0];\n      var invSubMix1 = invSubMix[1];\n      var invSubMix2 = invSubMix[2];\n      var invSubMix3 = invSubMix[3];\n      var prev;\n      var t;\n      for (ksRow = 0; ksRow < ksRows; ksRow++) {\n        if (ksRow < keySize) {\n          prev = keySchedule[ksRow] = key[ksRow];\n          continue;\n        }\n        t = prev;\n        if (ksRow % keySize === 0) {\n          // Rot word\n          t = t << 8 | t >>> 24;\n\n          // Sub word\n          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n\n          // Mix Rcon\n          t ^= rcon[ksRow / keySize | 0] << 24;\n        } else if (keySize > 6 && ksRow % keySize === 4) {\n          // Sub word\n          t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n        }\n        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n      }\n      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n        ksRow = ksRows - invKsRow;\n        if (invKsRow & 3) {\n          t = keySchedule[ksRow];\n        } else {\n          t = keySchedule[ksRow - 4];\n        }\n        if (invKsRow < 4 || ksRow <= 4) {\n          invKeySchedule[invKsRow] = t;\n        } else {\n          invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n        }\n        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n      }\n    }\n\n    // Adding this as a method greatly improves performance.\n    ;\n    _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {\n      return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n    };\n    _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {\n      var nRounds = this.keySize + 6;\n      var invKeySchedule = this.invKeySchedule;\n      var invSBOX = this.invSBox;\n      var invSubMix = this.invSubMix;\n      var invSubMix0 = invSubMix[0];\n      var invSubMix1 = invSubMix[1];\n      var invSubMix2 = invSubMix[2];\n      var invSubMix3 = invSubMix[3];\n      var initVector = this.uint8ArrayToUint32Array_(aesIV);\n      var initVector0 = initVector[0];\n      var initVector1 = initVector[1];\n      var initVector2 = initVector[2];\n      var initVector3 = initVector[3];\n      var inputInt32 = new Int32Array(inputArrayBuffer);\n      var outputInt32 = new Int32Array(inputInt32.length);\n      var t0, t1, t2, t3;\n      var s0, s1, s2, s3;\n      var inputWords0, inputWords1, inputWords2, inputWords3;\n      var ksRow, i;\n      var swapWord = this.networkToHostOrderSwap;\n      while (offset < inputInt32.length) {\n        inputWords0 = swapWord(inputInt32[offset]);\n        inputWords1 = swapWord(inputInt32[offset + 1]);\n        inputWords2 = swapWord(inputInt32[offset + 2]);\n        inputWords3 = swapWord(inputInt32[offset + 3]);\n        s0 = inputWords0 ^ invKeySchedule[0];\n        s1 = inputWords3 ^ invKeySchedule[1];\n        s2 = inputWords2 ^ invKeySchedule[2];\n        s3 = inputWords1 ^ invKeySchedule[3];\n        ksRow = 4;\n\n        // Iterate through the rounds of decryption\n        for (i = 1; i < nRounds; i++) {\n          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n          // Update state\n          s0 = t0;\n          s1 = t1;\n          s2 = t2;\n          s3 = t3;\n          ksRow = ksRow + 4;\n        }\n\n        // Shift rows, sub bytes, add round key\n        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n\n        // Write\n        outputInt32[offset] = swapWord(t0 ^ initVector0);\n        outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n        outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n        outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n        // reset initVector to last 4 unsigned int\n        initVector0 = inputWords0;\n        initVector1 = inputWords1;\n        initVector2 = inputWords2;\n        initVector3 = inputWords3;\n        offset = offset + 4;\n      }\n      return outputInt32.buffer;\n    };\n    return AESDecryptor;\n  }();\n\n  var CHUNK_SIZE = 16; // 16 bytes, 128 bits\n  var Decrypter = /*#__PURE__*/function () {\n    function Decrypter(config, _temp) {\n      var _ref = _temp === void 0 ? {} : _temp,\n        _ref$removePKCS7Paddi = _ref.removePKCS7Padding,\n        removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;\n      this.logEnabled = true;\n      this.removePKCS7Padding = void 0;\n      this.subtle = null;\n      this.softwareDecrypter = null;\n      this.key = null;\n      this.fastAesKey = null;\n      this.remainderData = null;\n      this.currentIV = null;\n      this.currentResult = null;\n      this.useSoftware = void 0;\n      this.useSoftware = config.enableSoftwareAES;\n      this.removePKCS7Padding = removePKCS7Padding;\n      // built in decryptor expects PKCS7 padding\n      if (removePKCS7Padding) {\n        try {\n          var browserCrypto = self.crypto;\n          if (browserCrypto) {\n            this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n          }\n        } catch (e) {\n          /* no-op */\n        }\n      }\n      this.useSoftware = !this.subtle;\n    }\n    var _proto = Decrypter.prototype;\n    _proto.destroy = function destroy() {\n      this.subtle = null;\n      this.softwareDecrypter = null;\n      this.key = null;\n      this.fastAesKey = null;\n      this.remainderData = null;\n      this.currentIV = null;\n      this.currentResult = null;\n    };\n    _proto.isSync = function isSync() {\n      return this.useSoftware;\n    };\n    _proto.flush = function flush() {\n      var currentResult = this.currentResult,\n        remainderData = this.remainderData;\n      if (!currentResult || remainderData) {\n        this.reset();\n        return null;\n      }\n      var data = new Uint8Array(currentResult);\n      this.reset();\n      if (this.removePKCS7Padding) {\n        return removePadding(data);\n      }\n      return data;\n    };\n    _proto.reset = function reset() {\n      this.currentResult = null;\n      this.currentIV = null;\n      this.remainderData = null;\n      if (this.softwareDecrypter) {\n        this.softwareDecrypter = null;\n      }\n    };\n    _proto.decrypt = function decrypt(data, key, iv) {\n      var _this = this;\n      if (this.useSoftware) {\n        return new Promise(function (resolve, reject) {\n          _this.softwareDecrypt(new Uint8Array(data), key, iv);\n          var decryptResult = _this.flush();\n          if (decryptResult) {\n            resolve(decryptResult.buffer);\n          } else {\n            reject(new Error('[softwareDecrypt] Failed to decrypt data'));\n          }\n        });\n      }\n      return this.webCryptoDecrypt(new Uint8Array(data), key, iv);\n    }\n\n    // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n    // data is handled in the flush() call\n    ;\n    _proto.softwareDecrypt = function softwareDecrypt(data, key, iv) {\n      var currentIV = this.currentIV,\n        currentResult = this.currentResult,\n        remainderData = this.remainderData;\n      this.logOnce('JS AES decrypt');\n      // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n      // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n      // the end on flush(), but by that time we have already received all bytes for the segment.\n      // Progressive decryption does not work with WebCrypto\n\n      if (remainderData) {\n        data = appendUint8Array(remainderData, data);\n        this.remainderData = null;\n      }\n\n      // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n      var currentChunk = this.getValidChunk(data);\n      if (!currentChunk.length) {\n        return null;\n      }\n      if (currentIV) {\n        iv = currentIV;\n      }\n      var softwareDecrypter = this.softwareDecrypter;\n      if (!softwareDecrypter) {\n        softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n      }\n      softwareDecrypter.expandKey(key);\n      var result = currentResult;\n      this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n      this.currentIV = sliceUint8(currentChunk, -16).buffer;\n      if (!result) {\n        return null;\n      }\n      return result;\n    };\n    _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv) {\n      var _this2 = this;\n      if (this.key !== key || !this.fastAesKey) {\n        if (!this.subtle) {\n          return Promise.resolve(this.onWebCryptoError(data, key, iv));\n        }\n        this.key = key;\n        this.fastAesKey = new FastAESKey(this.subtle, key);\n      }\n      return this.fastAesKey.expandKey().then(function (aesKey) {\n        // decrypt using web crypto\n        if (!_this2.subtle) {\n          return Promise.reject(new Error('web crypto not initialized'));\n        }\n        _this2.logOnce('WebCrypto AES decrypt');\n        var crypto = new AESCrypto(_this2.subtle, new Uint8Array(iv));\n        return crypto.decrypt(data.buffer, aesKey);\n      }).catch(function (err) {\n        logger.warn(\"[decrypter]: WebCrypto Error, disable WebCrypto API, \" + err.name + \": \" + err.message);\n        return _this2.onWebCryptoError(data, key, iv);\n      });\n    };\n    _proto.onWebCryptoError = function onWebCryptoError(data, key, iv) {\n      this.useSoftware = true;\n      this.logEnabled = true;\n      this.softwareDecrypt(data, key, iv);\n      var decryptResult = this.flush();\n      if (decryptResult) {\n        return decryptResult.buffer;\n      }\n      throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data');\n    };\n    _proto.getValidChunk = function getValidChunk(data) {\n      var currentChunk = data;\n      var splitPoint = data.length - data.length % CHUNK_SIZE;\n      if (splitPoint !== data.length) {\n        currentChunk = sliceUint8(data, 0, splitPoint);\n        this.remainderData = sliceUint8(data, splitPoint);\n      }\n      return currentChunk;\n    };\n    _proto.logOnce = function logOnce(msg) {\n      if (!this.logEnabled) {\n        return;\n      }\n      logger.log(\"[decrypter]: \" + msg);\n      this.logEnabled = false;\n    };\n    return Decrypter;\n  }();\n\n  /**\n   *  TimeRanges to string helper\n   */\n\n  var TimeRanges = {\n    toString: function toString(r) {\n      var log = '';\n      var len = r.length;\n      for (var i = 0; i < len; i++) {\n        log += \"[\" + r.start(i).toFixed(3) + \"-\" + r.end(i).toFixed(3) + \"]\";\n      }\n      return log;\n    }\n  };\n\n  var State = {\n    STOPPED: 'STOPPED',\n    IDLE: 'IDLE',\n    KEY_LOADING: 'KEY_LOADING',\n    FRAG_LOADING: 'FRAG_LOADING',\n    FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n    WAITING_TRACK: 'WAITING_TRACK',\n    PARSING: 'PARSING',\n    PARSED: 'PARSED',\n    ENDED: 'ENDED',\n    ERROR: 'ERROR',\n    WAITING_INIT_PTS: 'WAITING_INIT_PTS',\n    WAITING_LEVEL: 'WAITING_LEVEL'\n  };\n  var BaseStreamController = /*#__PURE__*/function (_TaskLoop) {\n    _inheritsLoose(BaseStreamController, _TaskLoop);\n    function BaseStreamController(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {\n      var _this;\n      _this = _TaskLoop.call(this) || this;\n      _this.hls = void 0;\n      _this.fragPrevious = null;\n      _this.fragCurrent = null;\n      _this.fragmentTracker = void 0;\n      _this.transmuxer = null;\n      _this._state = State.STOPPED;\n      _this.playlistType = void 0;\n      _this.media = null;\n      _this.mediaBuffer = null;\n      _this.config = void 0;\n      _this.bitrateTest = false;\n      _this.lastCurrentTime = 0;\n      _this.nextLoadPosition = 0;\n      _this.startPosition = 0;\n      _this.startTimeOffset = null;\n      _this.loadedmetadata = false;\n      _this.retryDate = 0;\n      _this.levels = null;\n      _this.fragmentLoader = void 0;\n      _this.keyLoader = void 0;\n      _this.levelLastLoaded = null;\n      _this.startFragRequested = false;\n      _this.decrypter = void 0;\n      _this.initPTS = [];\n      _this.onvseeking = null;\n      _this.onvended = null;\n      _this.logPrefix = '';\n      _this.log = void 0;\n      _this.warn = void 0;\n      _this.playlistType = playlistType;\n      _this.logPrefix = logPrefix;\n      _this.log = logger.log.bind(logger, logPrefix + \":\");\n      _this.warn = logger.warn.bind(logger, logPrefix + \":\");\n      _this.hls = hls;\n      _this.fragmentLoader = new FragmentLoader(hls.config);\n      _this.keyLoader = keyLoader;\n      _this.fragmentTracker = fragmentTracker;\n      _this.config = hls.config;\n      _this.decrypter = new Decrypter(hls.config);\n      hls.on(Events.MANIFEST_LOADED, _this.onManifestLoaded, _assertThisInitialized(_this));\n      return _this;\n    }\n    var _proto = BaseStreamController.prototype;\n    _proto.doTick = function doTick() {\n      this.onTickEnd();\n    };\n    _proto.onTickEnd = function onTickEnd() {}\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ;\n    _proto.startLoad = function startLoad(startPosition) {};\n    _proto.stopLoad = function stopLoad() {\n      this.fragmentLoader.abort();\n      this.keyLoader.abort(this.playlistType);\n      var frag = this.fragCurrent;\n      if (frag != null && frag.loader) {\n        frag.abortRequests();\n        this.fragmentTracker.removeFragment(frag);\n      }\n      this.resetTransmuxer();\n      this.fragCurrent = null;\n      this.fragPrevious = null;\n      this.clearInterval();\n      this.clearNextTick();\n      this.state = State.STOPPED;\n    };\n    _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {\n      // If playlist is live, there is another buffered range after the current range, nothing buffered, media is detached,\n      // of nothing loading/loaded return false\n      if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {\n        return false;\n      }\n      var partList = levelDetails.partList;\n      // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,\n      // check instead if the last part is buffered.\n      if (partList != null && partList.length) {\n        var lastPart = partList[partList.length - 1];\n\n        // Checking the midpoint of the part for potential margin of error and related issues.\n        // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n        // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n        // part mismatches for independent audio and video playlists/segments.\n        var lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n        return lastPartBuffered;\n      }\n      var playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;\n      return this.fragmentTracker.isEndListAppended(playlistType);\n    };\n    _proto.getLevelDetails = function getLevelDetails() {\n      if (this.levels && this.levelLastLoaded !== null) {\n        var _this$levelLastLoaded;\n        return (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details;\n      }\n    };\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      var media = this.media = this.mediaBuffer = data.media;\n      this.onvseeking = this.onMediaSeeking.bind(this);\n      this.onvended = this.onMediaEnded.bind(this);\n      media.addEventListener('seeking', this.onvseeking);\n      media.addEventListener('ended', this.onvended);\n      var config = this.config;\n      if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n        this.startLoad(config.startPosition);\n      }\n    };\n    _proto.onMediaDetaching = function onMediaDetaching() {\n      var media = this.media;\n      if (media != null && media.ended) {\n        this.log('MSE detaching and video ended, reset startPosition');\n        this.startPosition = this.lastCurrentTime = 0;\n      }\n\n      // remove video listeners\n      if (media && this.onvseeking && this.onvended) {\n        media.removeEventListener('seeking', this.onvseeking);\n        media.removeEventListener('ended', this.onvended);\n        this.onvseeking = this.onvended = null;\n      }\n      if (this.keyLoader) {\n        this.keyLoader.detach();\n      }\n      this.media = this.mediaBuffer = null;\n      this.loadedmetadata = false;\n      this.fragmentTracker.removeAllFragments();\n      this.stopLoad();\n    };\n    _proto.onMediaSeeking = function onMediaSeeking() {\n      var config = this.config,\n        fragCurrent = this.fragCurrent,\n        media = this.media,\n        mediaBuffer = this.mediaBuffer,\n        state = this.state;\n      var currentTime = media ? media.currentTime : 0;\n      var bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);\n      this.log(\"media seeking to \" + (isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime) + \", state: \" + state);\n      if (this.state === State.ENDED) {\n        this.resetLoadingState();\n      } else if (fragCurrent) {\n        // Seeking while frag load is in progress\n        var tolerance = config.maxFragLookUpTolerance;\n        var fragStartOffset = fragCurrent.start - tolerance;\n        var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n        // if seeking out of buffered range or into new one\n        if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {\n          var pastFragment = currentTime > fragEndOffset;\n          // if the seek position is outside the current fragment range\n          if (currentTime < fragStartOffset || pastFragment) {\n            if (pastFragment && fragCurrent.loader) {\n              this.log('seeking outside of buffer while fragment load in progress, cancel fragment load');\n              fragCurrent.abortRequests();\n              this.resetLoadingState();\n            }\n            this.fragPrevious = null;\n          }\n        }\n      }\n      if (media) {\n        // Remove gap fragments\n        this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);\n        this.lastCurrentTime = currentTime;\n      }\n\n      // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n      if (!this.loadedmetadata && !bufferInfo.len) {\n        this.nextLoadPosition = this.startPosition = currentTime;\n      }\n\n      // Async tick to speed up processing\n      this.tickImmediate();\n    };\n    _proto.onMediaEnded = function onMediaEnded() {\n      // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n      this.startPosition = this.lastCurrentTime = 0;\n    };\n    _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n      this.startTimeOffset = data.startTimeOffset;\n      this.initPTS = [];\n    };\n    _proto.onHandlerDestroying = function onHandlerDestroying() {\n      this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      this.stopLoad();\n      _TaskLoop.prototype.onHandlerDestroying.call(this);\n      // @ts-ignore\n      this.hls = null;\n    };\n    _proto.onHandlerDestroyed = function onHandlerDestroyed() {\n      this.state = State.STOPPED;\n      if (this.fragmentLoader) {\n        this.fragmentLoader.destroy();\n      }\n      if (this.keyLoader) {\n        this.keyLoader.destroy();\n      }\n      if (this.decrypter) {\n        this.decrypter.destroy();\n      }\n      this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;\n      _TaskLoop.prototype.onHandlerDestroyed.call(this);\n    };\n    _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {\n      this._loadFragForPlayback(frag, level, targetBufferTime);\n    };\n    _proto._loadFragForPlayback = function _loadFragForPlayback(frag, level, targetBufferTime) {\n      var _this2 = this;\n      var progressCallback = function progressCallback(data) {\n        if (_this2.fragContextChanged(frag)) {\n          _this2.warn(\"Fragment \" + frag.sn + (data.part ? ' p: ' + data.part.index : '') + \" of level \" + frag.level + \" was dropped during download.\");\n          _this2.fragmentTracker.removeFragment(frag);\n          return;\n        }\n        frag.stats.chunkCount++;\n        _this2._handleFragmentLoadProgress(data);\n      };\n      this._doFragLoad(frag, level, targetBufferTime, progressCallback).then(function (data) {\n        if (!data) {\n          // if we're here we probably needed to backtrack or are waiting for more parts\n          return;\n        }\n        var state = _this2.state;\n        if (_this2.fragContextChanged(frag)) {\n          if (state === State.FRAG_LOADING || !_this2.fragCurrent && state === State.PARSING) {\n            _this2.fragmentTracker.removeFragment(frag);\n            _this2.state = State.IDLE;\n          }\n          return;\n        }\n        if ('payload' in data) {\n          _this2.log(\"Loaded fragment \" + frag.sn + \" of level \" + frag.level);\n          _this2.hls.trigger(Events.FRAG_LOADED, data);\n        }\n\n        // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n        _this2._handleFragmentLoadComplete(data);\n      }).catch(function (reason) {\n        if (_this2.state === State.STOPPED || _this2.state === State.ERROR) {\n          return;\n        }\n        _this2.warn(\"Frag error: \" + ((reason == null ? void 0 : reason.message) || reason));\n        _this2.resetFragmentLoading(frag);\n      });\n    };\n    _proto.clearTrackerIfNeeded = function clearTrackerIfNeeded(frag) {\n      var _this$mediaBuffer;\n      var fragmentTracker = this.fragmentTracker;\n      var fragState = fragmentTracker.getState(frag);\n      if (fragState === FragmentState.APPENDING) {\n        // Lower the max buffer length and try again\n        var playlistType = frag.type;\n        var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n        var minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);\n        // If backtracking, always remove from the tracker without reducing max buffer length\n        var backtrackFragment = this.backtrackFragment;\n        var backtracked = backtrackFragment ? frag.sn - backtrackFragment.sn : 0;\n        if (backtracked === 1 || this.reduceMaxBufferLength(minForwardBufferLength, frag.duration)) {\n          fragmentTracker.removeFragment(frag);\n        }\n      } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {\n        // Stop gap for bad tracker / buffer flush behavior\n        fragmentTracker.removeAllFragments();\n      } else if (fragmentTracker.hasParts(frag.type)) {\n        // In low latency mode, remove fragments for which only some parts were buffered\n        fragmentTracker.detectPartialFragments({\n          frag: frag,\n          part: null,\n          stats: frag.stats,\n          id: frag.type\n        });\n        if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {\n          fragmentTracker.removeFragment(frag);\n        }\n      }\n    };\n    _proto.checkLiveUpdate = function checkLiveUpdate(details) {\n      if (details.updated && !details.live) {\n        // Live stream ended, update fragment tracker\n        var lastFragment = details.fragments[details.fragments.length - 1];\n        this.fragmentTracker.detectPartialFragments({\n          frag: lastFragment,\n          part: null,\n          stats: lastFragment.stats,\n          id: lastFragment.type\n        });\n      }\n      if (!details.fragments[0]) {\n        details.deltaUpdateFailed = true;\n      }\n    };\n    _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {\n      if (type === void 0) {\n        type = null;\n      }\n      if (!(startOffset - endOffset)) {\n        return;\n      }\n      // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n      // passing a null type flushes both buffers\n      var flushScope = {\n        startOffset: startOffset,\n        endOffset: endOffset,\n        type: type\n      };\n      this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);\n    };\n    _proto._loadInitSegment = function _loadInitSegment(frag, level) {\n      var _this3 = this;\n      this._doFragLoad(frag, level).then(function (data) {\n        if (!data || _this3.fragContextChanged(frag) || !_this3.levels) {\n          throw new Error('init load aborted');\n        }\n        return data;\n      }).then(function (data) {\n        var hls = _this3.hls;\n        var payload = data.payload;\n        var decryptData = frag.decryptdata;\n\n        // check to see if the payload needs to be decrypted\n        if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n          var startTime = self.performance.now();\n          // decrypt init segment data\n          return _this3.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(function (err) {\n            hls.trigger(Events.ERROR, {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.FRAG_DECRYPT_ERROR,\n              fatal: false,\n              error: err,\n              reason: err.message,\n              frag: frag\n            });\n            throw err;\n          }).then(function (decryptedData) {\n            var endTime = self.performance.now();\n            hls.trigger(Events.FRAG_DECRYPTED, {\n              frag: frag,\n              payload: decryptedData,\n              stats: {\n                tstart: startTime,\n                tdecrypt: endTime\n              }\n            });\n            data.payload = decryptedData;\n            return _this3.completeInitSegmentLoad(data);\n          });\n        }\n        return _this3.completeInitSegmentLoad(data);\n      }).catch(function (reason) {\n        if (_this3.state === State.STOPPED || _this3.state === State.ERROR) {\n          return;\n        }\n        _this3.warn(reason);\n        _this3.resetFragmentLoading(frag);\n      });\n    };\n    _proto.completeInitSegmentLoad = function completeInitSegmentLoad(data) {\n      var levels = this.levels;\n      if (!levels) {\n        throw new Error('init load aborted, missing levels');\n      }\n      var stats = data.frag.stats;\n      this.state = State.IDLE;\n      data.frag.data = new Uint8Array(data.payload);\n      stats.parsing.start = stats.buffering.start = self.performance.now();\n      stats.parsing.end = stats.buffering.end = self.performance.now();\n      this.tick();\n    };\n    _proto.fragContextChanged = function fragContextChanged(frag) {\n      var fragCurrent = this.fragCurrent;\n      return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;\n    };\n    _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {\n      var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;\n      var media = this.mediaBuffer ? this.mediaBuffer : this.media;\n      this.log(\"Buffered \" + frag.type + \" sn: \" + frag.sn + (part ? ' part: ' + part.index : '') + \" of \" + (this.playlistType === PlaylistLevelType.MAIN ? 'level' : 'track') + \" \" + frag.level + \" (frag:[\" + ((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3) + \"-\" + ((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3) + \"] > buffer:\" + (media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : '(detached)') + \")\");\n      if (frag.sn !== 'initSegment') {\n        var _this$levels;\n        if (frag.type !== PlaylistLevelType.SUBTITLE) {\n          var el = frag.elementaryStreams;\n          if (!Object.keys(el).some(function (type) {\n            return !!el[type];\n          })) {\n            // empty segment\n            this.state = State.IDLE;\n            return;\n          }\n        }\n        var level = (_this$levels = this.levels) == null ? void 0 : _this$levels[frag.level];\n        if (level != null && level.fragmentError) {\n          this.log(\"Resetting level fragment error count of \" + level.fragmentError + \" on frag buffered\");\n          level.fragmentError = 0;\n        }\n      }\n      this.state = State.IDLE;\n      if (!media) {\n        return;\n      }\n      if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {\n        this.loadedmetadata = true;\n        this.seekToStartPos();\n      }\n      this.tick();\n    };\n    _proto.seekToStartPos = function seekToStartPos() {};\n    _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {\n      var transmuxer = this.transmuxer;\n      if (!transmuxer) {\n        return;\n      }\n      var frag = fragLoadedEndData.frag,\n        part = fragLoadedEndData.part,\n        partsLoaded = fragLoadedEndData.partsLoaded;\n      // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n      var complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(function (fragLoaded) {\n        return !fragLoaded;\n      });\n      var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n      transmuxer.flush(chunkMeta);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ;\n    _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {};\n    _proto._doFragLoad = function _doFragLoad(frag, level, targetBufferTime, progressCallback) {\n      var _frag$decryptdata,\n        _this4 = this;\n      if (targetBufferTime === void 0) {\n        targetBufferTime = null;\n      }\n      var details = level == null ? void 0 : level.details;\n      if (!this.levels || !details) {\n        throw new Error(\"frag load aborted, missing level\" + (details ? '' : ' detail') + \"s\");\n      }\n      var keyLoadingPromise = null;\n      if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {\n        this.log(\"Loading key for \" + frag.sn + \" of [\" + details.startSN + \"-\" + details.endSN + \"], \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \" \" + frag.level);\n        this.state = State.KEY_LOADING;\n        this.fragCurrent = frag;\n        keyLoadingPromise = this.keyLoader.load(frag).then(function (keyLoadedData) {\n          if (!_this4.fragContextChanged(keyLoadedData.frag)) {\n            _this4.hls.trigger(Events.KEY_LOADED, keyLoadedData);\n            if (_this4.state === State.KEY_LOADING) {\n              _this4.state = State.IDLE;\n            }\n            return keyLoadedData;\n          }\n        });\n        this.hls.trigger(Events.KEY_LOADING, {\n          frag: frag\n        });\n        if (this.fragCurrent === null) {\n          keyLoadingPromise = Promise.reject(new Error(\"frag load aborted, context changed in KEY_LOADING\"));\n        }\n      } else if (!frag.encrypted && details.encryptedFragments.length) {\n        this.keyLoader.loadClear(frag, details.encryptedFragments);\n      }\n      targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n      if (this.config.lowLatencyMode && frag.sn !== 'initSegment') {\n        var partList = details.partList;\n        if (partList && progressCallback) {\n          if (targetBufferTime > frag.end && details.fragmentHint) {\n            frag = details.fragmentHint;\n          }\n          var partIndex = this.getNextPart(partList, frag, targetBufferTime);\n          if (partIndex > -1) {\n            var part = partList[partIndex];\n            this.log(\"Loading part sn: \" + frag.sn + \" p: \" + part.index + \" cc: \" + frag.cc + \" of playlist [\" + details.startSN + \"-\" + details.endSN + \"] parts [0-\" + partIndex + \"-\" + (partList.length - 1) + \"] \" + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \": \" + frag.level + \", target: \" + parseFloat(targetBufferTime.toFixed(3)));\n            this.nextLoadPosition = part.start + part.duration;\n            this.state = State.FRAG_LOADING;\n            var _result;\n            if (keyLoadingPromise) {\n              _result = keyLoadingPromise.then(function (keyLoadedData) {\n                if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData.frag)) {\n                  return null;\n                }\n                return _this4.doFragPartsLoad(frag, part, level, progressCallback);\n              }).catch(function (error) {\n                return _this4.handleFragLoadError(error);\n              });\n            } else {\n              _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(function (error) {\n                return _this4.handleFragLoadError(error);\n              });\n            }\n            this.hls.trigger(Events.FRAG_LOADING, {\n              frag: frag,\n              part: part,\n              targetBufferTime: targetBufferTime\n            });\n            if (this.fragCurrent === null) {\n              return Promise.reject(new Error(\"frag load aborted, context changed in FRAG_LOADING parts\"));\n            }\n            return _result;\n          } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n            // Fragment hint has no parts\n            return Promise.resolve(null);\n          }\n        }\n      }\n      this.log(\"Loading fragment \" + frag.sn + \" cc: \" + frag.cc + \" \" + (details ? 'of [' + details.startSN + '-' + details.endSN + '] ' : '') + (this.logPrefix === '[stream-controller]' ? 'level' : 'track') + \": \" + frag.level + \", target: \" + parseFloat(targetBufferTime.toFixed(3)));\n      // Don't update nextLoadPosition for fragments which are not buffered\n      if (isFiniteNumber(frag.sn) && !this.bitrateTest) {\n        this.nextLoadPosition = frag.start + frag.duration;\n      }\n      this.state = State.FRAG_LOADING;\n\n      // Load key before streaming fragment data\n      var dataOnProgress = this.config.progressive;\n      var result;\n      if (dataOnProgress && keyLoadingPromise) {\n        result = keyLoadingPromise.then(function (keyLoadedData) {\n          if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {\n            return null;\n          }\n          return _this4.fragmentLoader.load(frag, progressCallback);\n        }).catch(function (error) {\n          return _this4.handleFragLoadError(error);\n        });\n      } else {\n        // load unencrypted fragment data with progress event,\n        // or handle fragment result after key and fragment are finished loading\n        result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(function (_ref) {\n          var fragLoadedData = _ref[0];\n          if (!dataOnProgress && fragLoadedData && progressCallback) {\n            progressCallback(fragLoadedData);\n          }\n          return fragLoadedData;\n        }).catch(function (error) {\n          return _this4.handleFragLoadError(error);\n        });\n      }\n      this.hls.trigger(Events.FRAG_LOADING, {\n        frag: frag,\n        targetBufferTime: targetBufferTime\n      });\n      if (this.fragCurrent === null) {\n        return Promise.reject(new Error(\"frag load aborted, context changed in FRAG_LOADING\"));\n      }\n      return result;\n    };\n    _proto.doFragPartsLoad = function doFragPartsLoad(frag, fromPart, level, progressCallback) {\n      var _this5 = this;\n      return new Promise(function (resolve, reject) {\n        var _level$details;\n        var partsLoaded = [];\n        var initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;\n        var loadPart = function loadPart(part) {\n          _this5.fragmentLoader.loadPart(frag, part, progressCallback).then(function (partLoadedData) {\n            partsLoaded[part.index] = partLoadedData;\n            var loadedPart = partLoadedData.part;\n            _this5.hls.trigger(Events.FRAG_LOADED, partLoadedData);\n            var nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);\n            if (nextPart) {\n              loadPart(nextPart);\n            } else {\n              return resolve({\n                frag: frag,\n                part: loadedPart,\n                partsLoaded: partsLoaded\n              });\n            }\n          }).catch(reject);\n        };\n        loadPart(fromPart);\n      });\n    };\n    _proto.handleFragLoadError = function handleFragLoadError(error) {\n      if ('data' in error) {\n        var data = error.data;\n        if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {\n          this.handleFragLoadAborted(data.frag, data.part);\n        } else {\n          this.hls.trigger(Events.ERROR, data);\n        }\n      } else {\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.OTHER_ERROR,\n          details: ErrorDetails.INTERNAL_EXCEPTION,\n          err: error,\n          error: error,\n          fatal: true\n        });\n      }\n      return null;\n    };\n    _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {\n      var context = this.getCurrentContext(chunkMeta);\n      if (!context || this.state !== State.PARSING) {\n        if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {\n          this.state = State.IDLE;\n        }\n        return;\n      }\n      var frag = context.frag,\n        part = context.part,\n        level = context.level;\n      var now = self.performance.now();\n      frag.stats.parsing.end = now;\n      if (part) {\n        part.stats.parsing.end = now;\n      }\n      this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n    };\n    _proto.getCurrentContext = function getCurrentContext(chunkMeta) {\n      var levels = this.levels,\n        fragCurrent = this.fragCurrent;\n      var levelIndex = chunkMeta.level,\n        sn = chunkMeta.sn,\n        partIndex = chunkMeta.part;\n      if (!(levels != null && levels[levelIndex])) {\n        this.warn(\"Levels object was unset while buffering fragment \" + sn + \" of level \" + levelIndex + \". The current chunk will not be buffered.\");\n        return null;\n      }\n      var level = levels[levelIndex];\n      var part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;\n      var frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);\n      if (!frag) {\n        return null;\n      }\n      if (fragCurrent && fragCurrent !== frag) {\n        frag.stats = fragCurrent.stats;\n      }\n      return {\n        frag: frag,\n        part: part,\n        level: level\n      };\n    };\n    _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {\n      var _buffer;\n      if (!data || this.state !== State.PARSING) {\n        return;\n      }\n      var data1 = data.data1,\n        data2 = data.data2;\n      var buffer = data1;\n      if (data1 && data2) {\n        // Combine the moof + mdat so that we buffer with a single append\n        buffer = appendUint8Array(data1, data2);\n      }\n      if (!((_buffer = buffer) != null && _buffer.length)) {\n        return;\n      }\n      var segment = {\n        type: data.type,\n        frag: frag,\n        part: part,\n        chunkMeta: chunkMeta,\n        parent: frag.type,\n        data: buffer\n      };\n      this.hls.trigger(Events.BUFFER_APPENDING, segment);\n      if (data.dropped && data.independent && !part) {\n        if (noBacktracking) {\n          return;\n        }\n        // Clear buffer so that we reload previous segments sequentially if required\n        this.flushBufferGap(frag);\n      }\n    };\n    _proto.flushBufferGap = function flushBufferGap(frag) {\n      var media = this.media;\n      if (!media) {\n        return;\n      }\n      // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n      if (!BufferHelper.isBuffered(media, media.currentTime)) {\n        this.flushMainBuffer(0, frag.start);\n        return;\n      }\n      // Remove back-buffer without interrupting playback to allow back tracking\n      var currentTime = media.currentTime;\n      var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n      var fragDuration = frag.duration;\n      var segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n      var start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n      if (frag.start - start > segmentFraction) {\n        this.flushMainBuffer(start, frag.start);\n      }\n    };\n    _proto.getFwdBufferInfo = function getFwdBufferInfo(bufferable, type) {\n      var pos = this.getLoadPosition();\n      if (!isFiniteNumber(pos)) {\n        return null;\n      }\n      return this.getFwdBufferInfoAtPos(bufferable, pos, type);\n    };\n    _proto.getFwdBufferInfoAtPos = function getFwdBufferInfoAtPos(bufferable, pos, type) {\n      var maxBufferHole = this.config.maxBufferHole;\n      var bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);\n      // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n      if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n        var bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n        if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {\n          return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));\n        }\n      }\n      return bufferInfo;\n    };\n    _proto.getMaxBufferLength = function getMaxBufferLength(levelBitrate) {\n      var config = this.config;\n      var maxBufLen;\n      if (levelBitrate) {\n        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n      } else {\n        maxBufLen = config.maxBufferLength;\n      }\n      return Math.min(maxBufLen, config.maxMaxBufferLength);\n    };\n    _proto.reduceMaxBufferLength = function reduceMaxBufferLength(threshold, fragDuration) {\n      var config = this.config;\n      var minLength = Math.max(Math.min(threshold - fragDuration, config.maxBufferLength), fragDuration);\n      var reducedLength = Math.max(threshold - fragDuration * 3, config.maxMaxBufferLength / 2, minLength);\n      if (reducedLength >= minLength) {\n        // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n        config.maxMaxBufferLength = reducedLength;\n        this.warn(\"Reduce max buffer length to \" + reducedLength + \"s\");\n        return true;\n      }\n      return false;\n    };\n    _proto.getAppendedFrag = function getAppendedFrag(position, playlistType) {\n      var fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);\n      if (fragOrPart && 'fragment' in fragOrPart) {\n        return fragOrPart.fragment;\n      }\n      return fragOrPart;\n    };\n    _proto.getNextFragment = function getNextFragment(pos, levelDetails) {\n      var fragments = levelDetails.fragments;\n      var fragLen = fragments.length;\n      if (!fragLen) {\n        return null;\n      }\n\n      // find fragment index, contiguous with end of buffer position\n      var config = this.config;\n      var start = fragments[0].start;\n      var frag;\n      if (levelDetails.live) {\n        var initialLiveManifestSize = config.initialLiveManifestSize;\n        if (fragLen < initialLiveManifestSize) {\n          this.warn(\"Not enough fragments to start playback (have: \" + fragLen + \", need: \" + initialLiveManifestSize + \")\");\n          return null;\n        }\n        // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n        // In order to discover the range, we load the best matching fragment for that level and demux it.\n        // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n        // we get the fragment matching that start time\n        if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {\n          frag = this.getInitialLiveFragment(levelDetails, fragments);\n          this.startPosition = this.nextLoadPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;\n        }\n      } else if (pos <= start) {\n        // VoD playlist: if loadPosition before start of playlist, load first fragment\n        frag = fragments[0];\n      }\n\n      // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n      if (!frag) {\n        var end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;\n        frag = this.getFragmentAtPosition(pos, end, levelDetails);\n      }\n      return this.mapToInitFragWhenRequired(frag);\n    };\n    _proto.isLoopLoading = function isLoopLoading(frag, targetBufferTime) {\n      var trackerState = this.fragmentTracker.getState(frag);\n      return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;\n    };\n    _proto.getNextFragmentLoopLoading = function getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {\n      var gapStart = frag.gap;\n      var nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);\n      if (nextFragment === null) {\n        return nextFragment;\n      }\n      frag = nextFragment;\n      if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {\n        // Media buffered after GAP tags should not make the next buffer timerange exceed forward buffer length\n        var nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);\n        if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {\n          // Returning here might result in not finding an audio and video candiate to skip to\n          this.log(\"buffer full after gaps in \\\"\" + playlistType + \"\\\" playlist starting at sn: \" + frag.sn);\n          return null;\n        }\n      }\n      return frag;\n    };\n    _proto.mapToInitFragWhenRequired = function mapToInitFragWhenRequired(frag) {\n      // If an initSegment is present, it must be buffered first\n      if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {\n        return frag.initSegment;\n      }\n      return frag;\n    };\n    _proto.getNextPart = function getNextPart(partList, frag, targetBufferTime) {\n      var nextPart = -1;\n      var contiguous = false;\n      var independentAttrOmitted = true;\n      for (var i = 0, len = partList.length; i < len; i++) {\n        var part = partList[i];\n        independentAttrOmitted = independentAttrOmitted && !part.independent;\n        if (nextPart > -1 && targetBufferTime < part.start) {\n          break;\n        }\n        var loaded = part.loaded;\n        if (loaded) {\n          nextPart = -1;\n        } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n          nextPart = i;\n        }\n        contiguous = loaded;\n      }\n      return nextPart;\n    };\n    _proto.loadedEndOfParts = function loadedEndOfParts(partList, targetBufferTime) {\n      var lastPart = partList[partList.length - 1];\n      return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n    }\n\n    /*\n     This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n     \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n     start and end times for each fragment in the playlist (after which this method will not need to be called).\n    */;\n    _proto.getInitialLiveFragment = function getInitialLiveFragment(levelDetails, fragments) {\n      var fragPrevious = this.fragPrevious;\n      var frag = null;\n      if (fragPrevious) {\n        if (levelDetails.hasProgramDateTime) {\n          // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n          this.log(\"Live playlist, switching playlist, load frag with same PDT: \" + fragPrevious.programDateTime);\n          frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n        }\n        if (!frag) {\n          // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n          var targetSN = fragPrevious.sn + 1;\n          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n            var fragNext = fragments[targetSN - levelDetails.startSN];\n            // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n            if (fragPrevious.cc === fragNext.cc) {\n              frag = fragNext;\n              this.log(\"Live playlist, switching playlist, load frag with next SN: \" + frag.sn);\n            }\n          }\n          // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n          // will have the wrong start times\n          if (!frag) {\n            frag = findFragWithCC(fragments, fragPrevious.cc);\n            if (frag) {\n              this.log(\"Live playlist, switching playlist, load frag with same CC: \" + frag.sn);\n            }\n          }\n        }\n      } else {\n        // Find a new start fragment when fragPrevious is null\n        var liveStart = this.hls.liveSyncPosition;\n        if (liveStart !== null) {\n          frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n        }\n      }\n      return frag;\n    }\n\n    /*\n    This method finds the best matching fragment given the provided position.\n     */;\n    _proto.getFragmentAtPosition = function getFragmentAtPosition(bufferEnd, end, levelDetails) {\n      var config = this.config;\n      var fragPrevious = this.fragPrevious;\n      var fragments = levelDetails.fragments,\n        endSN = levelDetails.endSN;\n      var fragmentHint = levelDetails.fragmentHint;\n      var maxFragLookUpTolerance = config.maxFragLookUpTolerance;\n      var partList = levelDetails.partList;\n      var loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);\n      if (loadingParts && fragmentHint && !this.bitrateTest) {\n        // Include incomplete fragment with parts at end\n        fragments = fragments.concat(fragmentHint);\n        endSN = fragmentHint.sn;\n      }\n      var frag;\n      if (bufferEnd < end) {\n        var lookupTolerance = bufferEnd > end - maxFragLookUpTolerance ? 0 : maxFragLookUpTolerance;\n        // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n        // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n        frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);\n      } else {\n        // reach end of playlist\n        frag = fragments[fragments.length - 1];\n      }\n      if (frag) {\n        var curSNIdx = frag.sn - levelDetails.startSN;\n        // Move fragPrevious forward to support forcing the next fragment to load\n        // when the buffer catches up to a previously buffered range.\n        var fragState = this.fragmentTracker.getState(frag);\n        if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {\n          fragPrevious = frag;\n        }\n        if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {\n          // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n          // non-uniform fragment durations\n          var sameLevel = fragPrevious && frag.level === fragPrevious.level;\n          if (sameLevel) {\n            var nextFrag = fragments[curSNIdx + 1];\n            if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {\n              frag = nextFrag;\n            } else {\n              frag = null;\n            }\n          }\n        }\n      }\n      return frag;\n    };\n    _proto.synchronizeToLiveEdge = function synchronizeToLiveEdge(levelDetails) {\n      var config = this.config,\n        media = this.media;\n      if (!media) {\n        return;\n      }\n      var liveSyncPosition = this.hls.liveSyncPosition;\n      var currentTime = media.currentTime;\n      var start = levelDetails.fragments[0].start;\n      var end = levelDetails.edge;\n      var withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;\n      // Continue if we can seek forward to sync position or if current time is outside of sliding window\n      if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n        // Continue if buffer is starving or if current time is behind max latency\n        var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n        if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n          if (!this.loadedmetadata) {\n            this.nextLoadPosition = liveSyncPosition;\n          }\n          // Only seek if ready and there is not a significant forward buffer available for playback\n          if (media.readyState) {\n            this.warn(\"Playback: \" + currentTime.toFixed(3) + \" is located too far from the end of live sliding playlist: \" + end + \", reset currentTime to : \" + liveSyncPosition.toFixed(3));\n            media.currentTime = liveSyncPosition;\n          }\n        }\n      }\n    };\n    _proto.alignPlaylists = function alignPlaylists(details, previousDetails, switchDetails) {\n      // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n      //  this could all go in level-helper mergeDetails()\n      var length = details.fragments.length;\n      if (!length) {\n        this.warn(\"No fragments in live playlist\");\n        return 0;\n      }\n      var slidingStart = details.fragments[0].start;\n      var firstLevelLoad = !previousDetails;\n      var aligned = details.alignedSliding && isFiniteNumber(slidingStart);\n      if (firstLevelLoad || !aligned && !slidingStart) {\n        var fragPrevious = this.fragPrevious;\n        alignStream(fragPrevious, switchDetails, details);\n        var alignedSlidingStart = details.fragments[0].start;\n        this.log(\"Live playlist sliding: \" + alignedSlidingStart.toFixed(2) + \" start-sn: \" + (previousDetails ? previousDetails.startSN : 'na') + \"->\" + details.startSN + \" prev-sn: \" + (fragPrevious ? fragPrevious.sn : 'na') + \" fragments: \" + length);\n        return alignedSlidingStart;\n      }\n      return slidingStart;\n    };\n    _proto.waitForCdnTuneIn = function waitForCdnTuneIn(details) {\n      // Wait for Low-Latency CDN Tune-in to get an updated playlist\n      var advancePartLimit = 3;\n      return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n    };\n    _proto.setStartPosition = function setStartPosition(details, sliding) {\n      // compute start position if set to -1. use it straight away if value is defined\n      var startPosition = this.startPosition;\n      if (startPosition < sliding) {\n        startPosition = -1;\n      }\n      if (startPosition === -1 || this.lastCurrentTime === -1) {\n        // Use Playlist EXT-X-START:TIME-OFFSET when set\n        // Prioritize Multivariant Playlist offset so that main, audio, and subtitle stream-controller start times match\n        var offsetInMultivariantPlaylist = this.startTimeOffset !== null;\n        var startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;\n        if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {\n          startPosition = sliding + startTimeOffset;\n          if (startTimeOffset < 0) {\n            startPosition += details.totalduration;\n          }\n          startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n          this.log(\"Start time offset \" + startTimeOffset + \" found in \" + (offsetInMultivariantPlaylist ? 'multivariant' : 'media') + \" playlist, adjust startPosition to \" + startPosition);\n          this.startPosition = startPosition;\n        } else if (details.live) {\n          // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n          // not been specified via the config or an as an argument to startLoad (#3736).\n          startPosition = this.hls.liveSyncPosition || sliding;\n        } else {\n          this.startPosition = startPosition = 0;\n        }\n        this.lastCurrentTime = startPosition;\n      }\n      this.nextLoadPosition = startPosition;\n    };\n    _proto.getLoadPosition = function getLoadPosition() {\n      var media = this.media;\n      // if we have not yet loaded any fragment, start loading from start position\n      var pos = 0;\n      if (this.loadedmetadata && media) {\n        pos = media.currentTime;\n      } else if (this.nextLoadPosition) {\n        pos = this.nextLoadPosition;\n      }\n      return pos;\n    };\n    _proto.handleFragLoadAborted = function handleFragLoadAborted(frag, part) {\n      if (this.transmuxer && frag.sn !== 'initSegment' && frag.stats.aborted) {\n        this.warn(\"Fragment \" + frag.sn + (part ? ' part ' + part.index : '') + \" of level \" + frag.level + \" was aborted\");\n        this.resetFragmentLoading(frag);\n      }\n    };\n    _proto.resetFragmentLoading = function resetFragmentLoading(frag) {\n      if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {\n        this.state = State.IDLE;\n      }\n    };\n    _proto.onFragmentOrKeyLoadError = function onFragmentOrKeyLoadError(filterType, data) {\n      if (data.chunkMeta && !data.frag) {\n        var context = this.getCurrentContext(data.chunkMeta);\n        if (context) {\n          data.frag = context.frag;\n        }\n      }\n      var frag = data.frag;\n      // Handle frag error related to caller's filterType\n      if (!frag || frag.type !== filterType || !this.levels) {\n        return;\n      }\n      if (this.fragContextChanged(frag)) {\n        var _this$fragCurrent2;\n        this.warn(\"Frag load error must match current frag to retry \" + frag.url + \" > \" + ((_this$fragCurrent2 = this.fragCurrent) == null ? void 0 : _this$fragCurrent2.url));\n        return;\n      }\n      var gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;\n      if (gapTagEncountered) {\n        this.fragmentTracker.fragBuffered(frag, true);\n      }\n      // keep retrying until the limit will be reached\n      var errorAction = data.errorAction;\n      var _ref2 = errorAction || {},\n        action = _ref2.action,\n        _ref2$retryCount = _ref2.retryCount,\n        retryCount = _ref2$retryCount === void 0 ? 0 : _ref2$retryCount,\n        retryConfig = _ref2.retryConfig;\n      if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {\n        this.resetStartWhenNotLoaded(this.levelLastLoaded);\n        var delay = getRetryDelay(retryConfig, retryCount);\n        this.warn(\"Fragment \" + frag.sn + \" of \" + filterType + \" \" + frag.level + \" errored with \" + data.details + \", retrying loading \" + (retryCount + 1) + \"/\" + retryConfig.maxNumRetry + \" in \" + delay + \"ms\");\n        errorAction.resolved = true;\n        this.retryDate = self.performance.now() + delay;\n        this.state = State.FRAG_LOADING_WAITING_RETRY;\n      } else if (retryConfig && errorAction) {\n        this.resetFragmentErrors(filterType);\n        if (retryCount < retryConfig.maxNumRetry) {\n          // Network retry is skipped when level switch is preferred\n          if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {\n            errorAction.resolved = true;\n          }\n        } else {\n          logger.warn(data.details + \" reached or exceeded max retry (\" + retryCount + \")\");\n          return;\n        }\n      } else if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox) {\n        this.state = State.WAITING_LEVEL;\n      } else {\n        this.state = State.ERROR;\n      }\n      // Perform next async tick sooner to speed up error action resolution\n      this.tickImmediate();\n    };\n    _proto.reduceLengthAndFlushBuffer = function reduceLengthAndFlushBuffer(data) {\n      // if in appending state\n      if (this.state === State.PARSING || this.state === State.PARSED) {\n        var frag = data.frag;\n        var playlistType = data.parent;\n        var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n        // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n        // reduce max buf len if current position is buffered\n        var buffered = bufferedInfo && bufferedInfo.len > 0.5;\n        if (buffered) {\n          this.reduceMaxBufferLength(bufferedInfo.len, (frag == null ? void 0 : frag.duration) || 10);\n        }\n        var flushBuffer = !buffered;\n        if (flushBuffer) {\n          // current position is not buffered, but browser is still complaining about buffer full error\n          // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n          // in that case flush the whole audio buffer to recover\n          this.warn(\"Buffer full error while media.currentTime is not buffered, flush \" + playlistType + \" buffer\");\n        }\n        if (frag) {\n          this.fragmentTracker.removeFragment(frag);\n          this.nextLoadPosition = frag.start;\n        }\n        this.resetLoadingState();\n        return flushBuffer;\n      }\n      return false;\n    };\n    _proto.resetFragmentErrors = function resetFragmentErrors(filterType) {\n      if (filterType === PlaylistLevelType.AUDIO) {\n        // Reset current fragment since audio track audio is essential and may not have a fail-over track\n        this.fragCurrent = null;\n      }\n      // Fragment errors that result in a level switch or redundant fail-over\n      // should reset the stream controller state to idle\n      if (!this.loadedmetadata) {\n        this.startFragRequested = false;\n      }\n      if (this.state !== State.STOPPED) {\n        this.state = State.IDLE;\n      }\n    };\n    _proto.afterBufferFlushed = function afterBufferFlushed(media, bufferType, playlistType) {\n      if (!media) {\n        return;\n      }\n      // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n      // (so that we will check against video.buffered ranges in case of alt audio track)\n      var bufferedTimeRanges = BufferHelper.getBuffered(media);\n      this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n      if (this.state === State.ENDED) {\n        this.resetLoadingState();\n      }\n    };\n    _proto.resetLoadingState = function resetLoadingState() {\n      this.log('Reset loading state');\n      this.fragCurrent = null;\n      this.fragPrevious = null;\n      this.state = State.IDLE;\n    };\n    _proto.resetStartWhenNotLoaded = function resetStartWhenNotLoaded(level) {\n      // if loadedmetadata is not set, it means that first frag request failed\n      // in that case, reset startFragRequested flag\n      if (!this.loadedmetadata) {\n        this.startFragRequested = false;\n        var details = level ? level.details : null;\n        if (details != null && details.live) {\n          // Update the start position and return to IDLE to recover live start\n          this.startPosition = -1;\n          this.setStartPosition(details, 0);\n          this.resetLoadingState();\n        } else {\n          this.nextLoadPosition = this.startPosition;\n        }\n      }\n    };\n    _proto.resetWhenMissingContext = function resetWhenMissingContext(chunkMeta) {\n      this.warn(\"The loading context changed while buffering fragment \" + chunkMeta.sn + \" of level \" + chunkMeta.level + \". This chunk will not be buffered.\");\n      this.removeUnbufferedFrags();\n      this.resetStartWhenNotLoaded(this.levelLastLoaded);\n      this.resetLoadingState();\n    };\n    _proto.removeUnbufferedFrags = function removeUnbufferedFrags(start) {\n      if (start === void 0) {\n        start = 0;\n      }\n      this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);\n    };\n    _proto.updateLevelTiming = function updateLevelTiming(frag, part, level, partial) {\n      var _this6 = this,\n        _this$transmuxer;\n      var details = level.details;\n      if (!details) {\n        this.warn('level.details undefined');\n        return;\n      }\n      var parsed = Object.keys(frag.elementaryStreams).reduce(function (result, type) {\n        var info = frag.elementaryStreams[type];\n        if (info) {\n          var parsedDuration = info.endPTS - info.startPTS;\n          if (parsedDuration <= 0) {\n            // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n            // The new transmuxer will be configured with a time offset matching the next fragment start,\n            // preventing the timeline from shifting.\n            _this6.warn(\"Could not parse fragment \" + frag.sn + \" \" + type + \" duration reliably (\" + parsedDuration + \")\");\n            return result || false;\n          }\n          var drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n          _this6.hls.trigger(Events.LEVEL_PTS_UPDATED, {\n            details: details,\n            level: level,\n            drift: drift,\n            type: type,\n            frag: frag,\n            start: info.startPTS,\n            end: info.endPTS\n          });\n          return true;\n        }\n        return result;\n      }, false);\n      if (!parsed && ((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {\n        var error = new Error(\"Found no media in fragment \" + frag.sn + \" of level \" + frag.level + \" resetting transmuxer to fallback to playlist timing\");\n        if (level.fragmentError === 0) {\n          // Mark and track the odd empty segment as a gap to avoid reloading\n          level.fragmentError++;\n          frag.gap = true;\n          this.fragmentTracker.removeFragment(frag);\n          this.fragmentTracker.fragBuffered(frag, true);\n        }\n        this.warn(error.message);\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: false,\n          error: error,\n          frag: frag,\n          reason: \"Found no media in msn \" + frag.sn + \" of level \\\"\" + level.url + \"\\\"\"\n        });\n        if (!this.hls) {\n          return;\n        }\n        this.resetTransmuxer();\n        // For this error fallthrough. Marking parsed will allow advancing to next fragment.\n      }\n      this.state = State.PARSED;\n      this.hls.trigger(Events.FRAG_PARSED, {\n        frag: frag,\n        part: part\n      });\n    };\n    _proto.resetTransmuxer = function resetTransmuxer() {\n      if (this.transmuxer) {\n        this.transmuxer.destroy();\n        this.transmuxer = null;\n      }\n    };\n    _proto.recoverWorkerError = function recoverWorkerError(data) {\n      if (data.event === 'demuxerWorker') {\n        this.fragmentTracker.removeAllFragments();\n        this.resetTransmuxer();\n        this.resetStartWhenNotLoaded(this.levelLastLoaded);\n        this.resetLoadingState();\n      }\n    };\n    _createClass(BaseStreamController, [{\n      key: \"state\",\n      get: function get() {\n        return this._state;\n      },\n      set: function set(nextState) {\n        var previousState = this._state;\n        if (previousState !== nextState) {\n          this._state = nextState;\n          this.log(previousState + \"->\" + nextState);\n        }\n      }\n    }]);\n    return BaseStreamController;\n  }(TaskLoop);\n\n  var ChunkCache = /*#__PURE__*/function () {\n    function ChunkCache() {\n      this.chunks = [];\n      this.dataLength = 0;\n    }\n    var _proto = ChunkCache.prototype;\n    _proto.push = function push(chunk) {\n      this.chunks.push(chunk);\n      this.dataLength += chunk.length;\n    };\n    _proto.flush = function flush() {\n      var chunks = this.chunks,\n        dataLength = this.dataLength;\n      var result;\n      if (!chunks.length) {\n        return new Uint8Array(0);\n      } else if (chunks.length === 1) {\n        result = chunks[0];\n      } else {\n        result = concatUint8Arrays(chunks, dataLength);\n      }\n      this.reset();\n      return result;\n    };\n    _proto.reset = function reset() {\n      this.chunks.length = 0;\n      this.dataLength = 0;\n    };\n    return ChunkCache;\n  }();\n  function concatUint8Arrays(chunks, dataLength) {\n    var result = new Uint8Array(dataLength);\n    var offset = 0;\n    for (var i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i];\n      result.set(chunk, offset);\n      offset += chunk.length;\n    }\n    return result;\n  }\n\n  function dummyTrack(type, inputTimeScale) {\n    if (type === void 0) {\n      type = '';\n    }\n    if (inputTimeScale === void 0) {\n      inputTimeScale = 90000;\n    }\n    return {\n      type: type,\n      id: -1,\n      pid: -1,\n      inputTimeScale: inputTimeScale,\n      sequenceNumber: -1,\n      samples: [],\n      dropped: 0\n    };\n  }\n\n  var BaseAudioDemuxer = /*#__PURE__*/function () {\n    function BaseAudioDemuxer() {\n      this._audioTrack = void 0;\n      this._id3Track = void 0;\n      this.frameIndex = 0;\n      this.cachedData = null;\n      this.basePTS = null;\n      this.initPTS = null;\n      this.lastPTS = null;\n    }\n    var _proto = BaseAudioDemuxer.prototype;\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n      this._id3Track = {\n        type: 'id3',\n        id: 3,\n        pid: -1,\n        inputTimeScale: 90000,\n        sequenceNumber: 0,\n        samples: [],\n        dropped: 0\n      };\n    };\n    _proto.resetTimeStamp = function resetTimeStamp(deaultTimestamp) {\n      this.initPTS = deaultTimestamp;\n      this.resetContiguity();\n    };\n    _proto.resetContiguity = function resetContiguity() {\n      this.basePTS = null;\n      this.lastPTS = null;\n      this.frameIndex = 0;\n    };\n    _proto.canParse = function canParse(data, offset) {\n      return false;\n    };\n    _proto.appendFrame = function appendFrame(track, data, offset) {}\n\n    // feed incoming data to the front of the parsing pipeline\n    ;\n    _proto.demux = function demux(data, timeOffset) {\n      if (this.cachedData) {\n        data = appendUint8Array(this.cachedData, data);\n        this.cachedData = null;\n      }\n      var id3Data = getID3Data(data, 0);\n      var offset = id3Data ? id3Data.length : 0;\n      var lastDataIndex;\n      var track = this._audioTrack;\n      var id3Track = this._id3Track;\n      var timestamp = id3Data ? getTimeStamp(id3Data) : undefined;\n      var length = data.length;\n      if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {\n        this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n        this.lastPTS = this.basePTS;\n      }\n      if (this.lastPTS === null) {\n        this.lastPTS = this.basePTS;\n      }\n\n      // more expressive than alternative: id3Data?.length\n      if (id3Data && id3Data.length > 0) {\n        id3Track.samples.push({\n          pts: this.lastPTS,\n          dts: this.lastPTS,\n          data: id3Data,\n          type: MetadataSchema.audioId3,\n          duration: Number.POSITIVE_INFINITY\n        });\n      }\n      while (offset < length) {\n        if (this.canParse(data, offset)) {\n          var frame = this.appendFrame(track, data, offset);\n          if (frame) {\n            this.frameIndex++;\n            this.lastPTS = frame.sample.pts;\n            offset += frame.length;\n            lastDataIndex = offset;\n          } else {\n            offset = length;\n          }\n        } else if (canParse$2(data, offset)) {\n          // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\n          id3Data = getID3Data(data, offset);\n          id3Track.samples.push({\n            pts: this.lastPTS,\n            dts: this.lastPTS,\n            data: id3Data,\n            type: MetadataSchema.audioId3,\n            duration: Number.POSITIVE_INFINITY\n          });\n          offset += id3Data.length;\n          lastDataIndex = offset;\n        } else {\n          offset++;\n        }\n        if (offset === length && lastDataIndex !== length) {\n          var partialData = sliceUint8(data, lastDataIndex);\n          if (this.cachedData) {\n            this.cachedData = appendUint8Array(this.cachedData, partialData);\n          } else {\n            this.cachedData = partialData;\n          }\n        }\n      }\n      return {\n        audioTrack: track,\n        videoTrack: dummyTrack(),\n        id3Track: id3Track,\n        textTrack: dummyTrack()\n      };\n    };\n    _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n      return Promise.reject(new Error(\"[\" + this + \"] This demuxer does not support Sample-AES decryption\"));\n    };\n    _proto.flush = function flush(timeOffset) {\n      // Parse cache in case of remaining frames.\n      var cachedData = this.cachedData;\n      if (cachedData) {\n        this.cachedData = null;\n        this.demux(cachedData, 0);\n      }\n      return {\n        audioTrack: this._audioTrack,\n        videoTrack: dummyTrack(),\n        id3Track: this._id3Track,\n        textTrack: dummyTrack()\n      };\n    };\n    _proto.destroy = function destroy() {};\n    return BaseAudioDemuxer;\n  }();\n  /**\n   * Initialize PTS\n   * <p>\n   *    use timestamp unless it is undefined, NaN or Infinity\n   * </p>\n   */\n  var initPTSFn = function initPTSFn(timestamp, timeOffset, initPTS) {\n    if (isFiniteNumber(timestamp)) {\n      return timestamp * 90;\n    }\n    var init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;\n    return timeOffset * 90000 + init90kHz;\n  };\n\n  /**\n   * ADTS parser helper\n   * @link https://wiki.multimedia.cx/index.php?title=ADTS\n   */\n  function getAudioConfig(observer, data, offset, audioCodec) {\n    var adtsObjectType;\n    var adtsExtensionSamplingIndex;\n    var adtsChannelConfig;\n    var config;\n    var userAgent = navigator.userAgent.toLowerCase();\n    var manifestCodec = audioCodec;\n    var adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n    // byte 2\n    adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\n    var adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;\n    if (adtsSamplingIndex > adtsSamplingRates.length - 1) {\n      var error = new Error(\"invalid ADTS sampling index:\" + adtsSamplingIndex);\n      observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: true,\n        error: error,\n        reason: error.message\n      });\n      return;\n    }\n    adtsChannelConfig = (data[offset + 2] & 0x01) << 2;\n    // byte 3\n    adtsChannelConfig |= (data[offset + 3] & 0xc0) >>> 6;\n    logger.log(\"manifest codec:\" + audioCodec + \", ADTS type:\" + adtsObjectType + \", samplingIndex:\" + adtsSamplingIndex);\n    // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n    if (/firefox/i.test(userAgent)) {\n      if (adtsSamplingIndex >= 6) {\n        adtsObjectType = 5;\n        config = new Array(4);\n        // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n        // there is a factor 2 between frame sample rate and output sample rate\n        // multiply frequency by 2 (see table below, equivalent to substract 3)\n        adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n      } else {\n        adtsObjectType = 2;\n        config = new Array(2);\n        adtsExtensionSamplingIndex = adtsSamplingIndex;\n      }\n      // Android : always use AAC\n    } else if (userAgent.indexOf('android') !== -1) {\n      adtsObjectType = 2;\n      config = new Array(2);\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    } else {\n      /*  for other browsers (Chrome/Vivaldi/Opera ...)\n          always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n      */\n      adtsObjectType = 5;\n      config = new Array(4);\n      // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n      if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSamplingIndex >= 6) {\n        // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n        // there is a factor 2 between frame sample rate and output sample rate\n        // multiply frequency by 2 (see table below, equivalent to substract 3)\n        adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n      } else {\n        // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n        // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n        if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {\n          adtsObjectType = 2;\n          config = new Array(2);\n        }\n        adtsExtensionSamplingIndex = adtsSamplingIndex;\n      }\n    }\n    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n        ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()\n      Audio Profile / Audio Object Type\n      0: Null\n      1: AAC Main\n      2: AAC LC (Low Complexity)\n      3: AAC SSR (Scalable Sample Rate)\n      4: AAC LTP (Long Term Prediction)\n      5: SBR (Spectral Band Replication)\n      6: AAC Scalable\n     sampling freq\n      0: 96000 Hz\n      1: 88200 Hz\n      2: 64000 Hz\n      3: 48000 Hz\n      4: 44100 Hz\n      5: 32000 Hz\n      6: 24000 Hz\n      7: 22050 Hz\n      8: 16000 Hz\n      9: 12000 Hz\n      10: 11025 Hz\n      11: 8000 Hz\n      12: 7350 Hz\n      13: Reserved\n      14: Reserved\n      15: frequency is written explictly\n      Channel Configurations\n      These are the channel configurations:\n      0: Defined in AOT Specifc Config\n      1: 1 channel: front-center\n      2: 2 channels: front-left, front-right\n    */\n    // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n    config[0] = adtsObjectType << 3;\n    // samplingFrequencyIndex\n    config[0] |= (adtsSamplingIndex & 0x0e) >> 1;\n    config[1] |= (adtsSamplingIndex & 0x01) << 7;\n    // channelConfiguration\n    config[1] |= adtsChannelConfig << 3;\n    if (adtsObjectType === 5) {\n      // adtsExtensionSamplingIndex\n      config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;\n      config[2] = (adtsExtensionSamplingIndex & 0x01) << 7;\n      // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n      //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n      config[2] |= 2 << 2;\n      config[3] = 0;\n    }\n    return {\n      config: config,\n      samplerate: adtsSamplingRates[adtsSamplingIndex],\n      channelCount: adtsChannelConfig,\n      codec: 'mp4a.40.' + adtsObjectType,\n      manifestCodec: manifestCodec\n    };\n  }\n  function isHeaderPattern$1(data, offset) {\n    return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n  }\n  function getHeaderLength(data, offset) {\n    return data[offset + 1] & 0x01 ? 7 : 9;\n  }\n  function getFullFrameLength(data, offset) {\n    return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n  }\n  function canGetFrameLength(data, offset) {\n    return offset + 5 < data.length;\n  }\n  function isHeader$1(data, offset) {\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    return offset + 1 < data.length && isHeaderPattern$1(data, offset);\n  }\n  function canParse$1(data, offset) {\n    return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n  }\n  function probe$1(data, offset) {\n    // same as isHeader but we also check that ADTS frame follows last ADTS frame\n    // or end of data is reached\n    if (isHeader$1(data, offset)) {\n      // ADTS header Length\n      var headerLength = getHeaderLength(data, offset);\n      if (offset + headerLength >= data.length) {\n        return false;\n      }\n      // ADTS frame Length\n      var frameLength = getFullFrameLength(data, offset);\n      if (frameLength <= headerLength) {\n        return false;\n      }\n      var newOffset = offset + frameLength;\n      return newOffset === data.length || isHeader$1(data, newOffset);\n    }\n    return false;\n  }\n  function initTrackConfig(track, observer, data, offset, audioCodec) {\n    if (!track.samplerate) {\n      var config = getAudioConfig(observer, data, offset, audioCodec);\n      if (!config) {\n        return;\n      }\n      track.config = config.config;\n      track.samplerate = config.samplerate;\n      track.channelCount = config.channelCount;\n      track.codec = config.codec;\n      track.manifestCodec = config.manifestCodec;\n      logger.log(\"parsed codec:\" + track.codec + \", rate:\" + config.samplerate + \", channels:\" + config.channelCount);\n    }\n  }\n  function getFrameDuration(samplerate) {\n    return 1024 * 90000 / samplerate;\n  }\n  function parseFrameHeader(data, offset) {\n    // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n    var headerLength = getHeaderLength(data, offset);\n    if (offset + headerLength <= data.length) {\n      // retrieve frame size\n      var frameLength = getFullFrameLength(data, offset) - headerLength;\n      if (frameLength > 0) {\n        // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n        return {\n          headerLength: headerLength,\n          frameLength: frameLength\n        };\n      }\n    }\n  }\n  function appendFrame$1(track, data, offset, pts, frameIndex) {\n    var frameDuration = getFrameDuration(track.samplerate);\n    var stamp = pts + frameIndex * frameDuration;\n    var header = parseFrameHeader(data, offset);\n    var unit;\n    if (header) {\n      var frameLength = header.frameLength,\n        headerLength = header.headerLength;\n      var _length = headerLength + frameLength;\n      var missing = Math.max(0, offset + _length - data.length);\n      // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n      if (missing) {\n        unit = new Uint8Array(_length - headerLength);\n        unit.set(data.subarray(offset + headerLength, data.length), 0);\n      } else {\n        unit = data.subarray(offset + headerLength, offset + _length);\n      }\n      var _sample = {\n        unit: unit,\n        pts: stamp\n      };\n      if (!missing) {\n        track.samples.push(_sample);\n      }\n      return {\n        sample: _sample,\n        length: _length,\n        missing: missing\n      };\n    }\n    // overflow incomplete header\n    var length = data.length - offset;\n    unit = new Uint8Array(length);\n    unit.set(data.subarray(offset, data.length), 0);\n    var sample = {\n      unit: unit,\n      pts: stamp\n    };\n    return {\n      sample: sample,\n      length: length,\n      missing: -1\n    };\n  }\n\n  /**\n   *  MPEG parser helper\n   */\n\n  var chromeVersion$1 = null;\n  var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\n  var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\n  var SamplesCoefficients = [\n  // MPEG 2.5\n  [0,\n  // Reserved\n  72,\n  // Layer3\n  144,\n  // Layer2\n  12 // Layer1\n  ],\n  // Reserved\n  [0,\n  // Reserved\n  0,\n  // Layer3\n  0,\n  // Layer2\n  0 // Layer1\n  ],\n  // MPEG 2\n  [0,\n  // Reserved\n  72,\n  // Layer3\n  144,\n  // Layer2\n  12 // Layer1\n  ],\n  // MPEG 1\n  [0,\n  // Reserved\n  144,\n  // Layer3\n  144,\n  // Layer2\n  12 // Layer1\n  ]];\n  var BytesInSlot = [0,\n  // Reserved\n  1,\n  // Layer3\n  1,\n  // Layer2\n  4 // Layer1\n  ];\n  function appendFrame(track, data, offset, pts, frameIndex) {\n    // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n    if (offset + 24 > data.length) {\n      return;\n    }\n    var header = parseHeader(data, offset);\n    if (header && offset + header.frameLength <= data.length) {\n      var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n      var stamp = pts + frameIndex * frameDuration;\n      var sample = {\n        unit: data.subarray(offset, offset + header.frameLength),\n        pts: stamp,\n        dts: stamp\n      };\n      track.config = [];\n      track.channelCount = header.channelCount;\n      track.samplerate = header.sampleRate;\n      track.samples.push(sample);\n      return {\n        sample: sample,\n        length: header.frameLength,\n        missing: 0\n      };\n    }\n  }\n  function parseHeader(data, offset) {\n    var mpegVersion = data[offset + 1] >> 3 & 3;\n    var mpegLayer = data[offset + 1] >> 1 & 3;\n    var bitRateIndex = data[offset + 2] >> 4 & 15;\n    var sampleRateIndex = data[offset + 2] >> 2 & 3;\n    if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n      var paddingBit = data[offset + 2] >> 1 & 1;\n      var channelMode = data[offset + 3] >> 6;\n      var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n      var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n      var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n      var sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n      var channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n      var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n      var bytesInSlot = BytesInSlot[mpegLayer];\n      var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n      var frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n      if (chromeVersion$1 === null) {\n        var userAgent = navigator.userAgent || '';\n        var result = userAgent.match(/Chrome\\/(\\d+)/i);\n        chromeVersion$1 = result ? parseInt(result[1]) : 0;\n      }\n      var needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;\n      if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n        // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n        data[offset + 3] = data[offset + 3] | 0x80;\n      }\n      return {\n        sampleRate: sampleRate,\n        channelCount: channelCount,\n        frameLength: frameLength,\n        samplesPerFrame: samplesPerFrame\n      };\n    }\n  }\n  function isHeaderPattern(data, offset) {\n    return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n  }\n  function isHeader(data, offset) {\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    return offset + 1 < data.length && isHeaderPattern(data, offset);\n  }\n  function canParse(data, offset) {\n    var headerSize = 4;\n    return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n  }\n  function probe(data, offset) {\n    // same as isHeader but we also check that MPEG frame follows last MPEG frame\n    // or end of data is reached\n    if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n      // MPEG header Length\n      var headerLength = 4;\n      // MPEG frame Length\n      var header = parseHeader(data, offset);\n      var frameLength = headerLength;\n      if (header != null && header.frameLength) {\n        frameLength = header.frameLength;\n      }\n      var newOffset = offset + frameLength;\n      return newOffset === data.length || isHeader(data, newOffset);\n    }\n    return false;\n  }\n\n  var AACDemuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n    _inheritsLoose(AACDemuxer, _BaseAudioDemuxer);\n    function AACDemuxer(observer, config) {\n      var _this;\n      _this = _BaseAudioDemuxer.call(this) || this;\n      _this.observer = void 0;\n      _this.config = void 0;\n      _this.observer = observer;\n      _this.config = config;\n      return _this;\n    }\n    var _proto = AACDemuxer.prototype;\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n      _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n      this._audioTrack = {\n        container: 'audio/adts',\n        type: 'audio',\n        id: 2,\n        pid: -1,\n        sequenceNumber: 0,\n        segmentCodec: 'aac',\n        samples: [],\n        manifestCodec: audioCodec,\n        duration: trackDuration,\n        inputTimeScale: 90000,\n        dropped: 0\n      };\n    }\n\n    // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n    ;\n    AACDemuxer.probe = function probe$2(data) {\n      if (!data) {\n        return false;\n      }\n\n      // Check for the ADTS sync word\n      // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n      // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n      // More info https://wiki.multimedia.cx/index.php?title=ADTS\n      var id3Data = getID3Data(data, 0);\n      var offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n      if (probe(data, offset)) {\n        return false;\n      }\n      for (var length = data.length; offset < length; offset++) {\n        if (probe$1(data, offset)) {\n          logger.log('ADTS sync word found !');\n          return true;\n        }\n      }\n      return false;\n    };\n    _proto.canParse = function canParse(data, offset) {\n      return canParse$1(data, offset);\n    };\n    _proto.appendFrame = function appendFrame(track, data, offset) {\n      initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n      var frame = appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);\n      if (frame && frame.missing === 0) {\n        return frame;\n      }\n    };\n    return AACDemuxer;\n  }(BaseAudioDemuxer);\n\n  var emsgSchemePattern = /\\/emsg[-/]ID3/i;\n  var MP4Demuxer = /*#__PURE__*/function () {\n    function MP4Demuxer(observer, config) {\n      this.remainderData = null;\n      this.timeOffset = 0;\n      this.config = void 0;\n      this.videoTrack = void 0;\n      this.audioTrack = void 0;\n      this.id3Track = void 0;\n      this.txtTrack = void 0;\n      this.config = config;\n    }\n    var _proto = MP4Demuxer.prototype;\n    _proto.resetTimeStamp = function resetTimeStamp() {};\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n      var videoTrack = this.videoTrack = dummyTrack('video', 1);\n      var audioTrack = this.audioTrack = dummyTrack('audio', 1);\n      var captionTrack = this.txtTrack = dummyTrack('text', 1);\n      this.id3Track = dummyTrack('id3', 1);\n      this.timeOffset = 0;\n      if (!(initSegment != null && initSegment.byteLength)) {\n        return;\n      }\n      var initData = parseInitSegment(initSegment);\n      if (initData.video) {\n        var _initData$video = initData.video,\n          id = _initData$video.id,\n          timescale = _initData$video.timescale,\n          codec = _initData$video.codec;\n        videoTrack.id = id;\n        videoTrack.timescale = captionTrack.timescale = timescale;\n        videoTrack.codec = codec;\n      }\n      if (initData.audio) {\n        var _initData$audio = initData.audio,\n          _id = _initData$audio.id,\n          _timescale = _initData$audio.timescale,\n          _codec = _initData$audio.codec;\n        audioTrack.id = _id;\n        audioTrack.timescale = _timescale;\n        audioTrack.codec = _codec;\n      }\n      captionTrack.id = RemuxerTrackIdConfig.text;\n      videoTrack.sampleDuration = 0;\n      videoTrack.duration = audioTrack.duration = trackDuration;\n    };\n    _proto.resetContiguity = function resetContiguity() {\n      this.remainderData = null;\n    };\n    MP4Demuxer.probe = function probe(data) {\n      return hasMoofData(data);\n    };\n    _proto.demux = function demux(data, timeOffset) {\n      this.timeOffset = timeOffset;\n      // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n      var videoSamples = data;\n      var videoTrack = this.videoTrack;\n      var textTrack = this.txtTrack;\n      if (this.config.progressive) {\n        // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n        // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n        // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n        if (this.remainderData) {\n          videoSamples = appendUint8Array(this.remainderData, data);\n        }\n        var segmentedData = segmentValidRange(videoSamples);\n        this.remainderData = segmentedData.remainder;\n        videoTrack.samples = segmentedData.valid || new Uint8Array();\n      } else {\n        videoTrack.samples = videoSamples;\n      }\n      var id3Track = this.extractID3Track(videoTrack, timeOffset);\n      textTrack.samples = parseSamples(timeOffset, videoTrack);\n      return {\n        videoTrack: videoTrack,\n        audioTrack: this.audioTrack,\n        id3Track: id3Track,\n        textTrack: this.txtTrack\n      };\n    };\n    _proto.flush = function flush() {\n      var timeOffset = this.timeOffset;\n      var videoTrack = this.videoTrack;\n      var textTrack = this.txtTrack;\n      videoTrack.samples = this.remainderData || new Uint8Array();\n      this.remainderData = null;\n      var id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n      textTrack.samples = parseSamples(timeOffset, videoTrack);\n      return {\n        videoTrack: videoTrack,\n        audioTrack: dummyTrack(),\n        id3Track: id3Track,\n        textTrack: dummyTrack()\n      };\n    };\n    _proto.extractID3Track = function extractID3Track(videoTrack, timeOffset) {\n      var id3Track = this.id3Track;\n      if (videoTrack.samples.length) {\n        var emsgs = findBox(videoTrack.samples, ['emsg']);\n        if (emsgs) {\n          emsgs.forEach(function (data) {\n            var emsgInfo = parseEmsg(data);\n            if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n              var pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n              var duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;\n              // Safari takes anything <= 0.001 seconds and maps it to Infinity\n              if (duration <= 0.001) {\n                duration = Number.POSITIVE_INFINITY;\n              }\n              var payload = emsgInfo.payload;\n              id3Track.samples.push({\n                data: payload,\n                len: payload.byteLength,\n                dts: pts,\n                pts: pts,\n                type: MetadataSchema.emsg,\n                duration: duration\n              });\n            }\n          });\n        }\n      }\n      return id3Track;\n    };\n    _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n      return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));\n    };\n    _proto.destroy = function destroy() {};\n    return MP4Demuxer;\n  }();\n\n  var getAudioBSID = function getAudioBSID(data, offset) {\n    // check the bsid to confirm ac-3 | ec-3\n    var bsid = 0;\n    var numBits = 5;\n    offset += numBits;\n    var temp = new Uint32Array(1); // unsigned 32 bit for temporary storage\n    var mask = new Uint32Array(1); // unsigned 32 bit mask value\n    var _byte = new Uint8Array(1); // unsigned 8 bit for temporary storage\n    while (numBits > 0) {\n      _byte[0] = data[offset];\n      // read remaining bits, upto 8 bits at a time\n      var bits = Math.min(numBits, 8);\n      var shift = 8 - bits;\n      mask[0] = 0xff000000 >>> 24 + shift << shift;\n      temp[0] = (_byte[0] & mask[0]) >> shift;\n      bsid = !bsid ? temp[0] : bsid << bits | temp[0];\n      offset += 1;\n      numBits -= bits;\n    }\n    return bsid;\n  };\n\n  var AC3Demuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n    _inheritsLoose(AC3Demuxer, _BaseAudioDemuxer);\n    function AC3Demuxer(observer) {\n      var _this;\n      _this = _BaseAudioDemuxer.call(this) || this;\n      _this.observer = void 0;\n      _this.observer = observer;\n      return _this;\n    }\n    var _proto = AC3Demuxer.prototype;\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n      _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n      this._audioTrack = {\n        container: 'audio/ac-3',\n        type: 'audio',\n        id: 2,\n        pid: -1,\n        sequenceNumber: 0,\n        segmentCodec: 'ac3',\n        samples: [],\n        manifestCodec: audioCodec,\n        duration: trackDuration,\n        inputTimeScale: 90000,\n        dropped: 0\n      };\n    };\n    _proto.canParse = function canParse(data, offset) {\n      return offset + 64 < data.length;\n    };\n    _proto.appendFrame = function appendFrame(track, data, offset) {\n      var frameLength = _appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n      if (frameLength !== -1) {\n        var sample = track.samples[track.samples.length - 1];\n        return {\n          sample: sample,\n          length: frameLength,\n          missing: 0\n        };\n      }\n    };\n    AC3Demuxer.probe = function probe(data) {\n      if (!data) {\n        return false;\n      }\n      var id3Data = getID3Data(data, 0);\n      if (!id3Data) {\n        return false;\n      }\n\n      // look for the ac-3 sync bytes\n      var offset = id3Data.length;\n      if (data[offset] === 0x0b && data[offset + 1] === 0x77 && getTimeStamp(id3Data) !== undefined &&\n      // check the bsid to confirm ac-3\n      getAudioBSID(data, offset) < 16) {\n        return true;\n      }\n      return false;\n    };\n    return AC3Demuxer;\n  }(BaseAudioDemuxer);\n  function _appendFrame(track, data, start, pts, frameIndex) {\n    if (start + 8 > data.length) {\n      return -1; // not enough bytes left\n    }\n    if (data[start] !== 0x0b || data[start + 1] !== 0x77) {\n      return -1; // invalid magic\n    }\n\n    // get sample rate\n    var samplingRateCode = data[start + 4] >> 6;\n    if (samplingRateCode >= 3) {\n      return -1; // invalid sampling rate\n    }\n    var samplingRateMap = [48000, 44100, 32000];\n    var sampleRate = samplingRateMap[samplingRateCode];\n\n    // get frame size\n    var frameSizeCode = data[start + 4] & 0x3f;\n    var frameSizeMap = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920];\n    var frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;\n    if (start + frameLength > data.length) {\n      return -1;\n    }\n\n    // get channel count\n    var channelMode = data[start + 6] >> 5;\n    var skipCount = 0;\n    if (channelMode === 2) {\n      skipCount += 2;\n    } else {\n      if (channelMode & 1 && channelMode !== 1) {\n        skipCount += 2;\n      }\n      if (channelMode & 4) {\n        skipCount += 2;\n      }\n    }\n    var lfeon = (data[start + 6] << 8 | data[start + 7]) >> 12 - skipCount & 1;\n    var channelsMap = [2, 1, 2, 3, 3, 4, 4, 5];\n    var channelCount = channelsMap[channelMode] + lfeon;\n\n    // build dac3 box\n    var bsid = data[start + 5] >> 3;\n    var bsmod = data[start + 5] & 7;\n    var config = new Uint8Array([samplingRateCode << 6 | bsid << 1 | bsmod >> 2, (bsmod & 3) << 6 | channelMode << 3 | lfeon << 2 | frameSizeCode >> 4, frameSizeCode << 4 & 0xe0]);\n    var frameDuration = 1536 / sampleRate * 90000;\n    var stamp = pts + frameIndex * frameDuration;\n    var unit = data.subarray(start, start + frameLength);\n    track.config = config;\n    track.channelCount = channelCount;\n    track.samplerate = sampleRate;\n    track.samples.push({\n      unit: unit,\n      pts: stamp\n    });\n    return frameLength;\n  }\n\n  var BaseVideoParser = /*#__PURE__*/function () {\n    function BaseVideoParser() {\n      this.VideoSample = null;\n    }\n    var _proto = BaseVideoParser.prototype;\n    _proto.createVideoSample = function createVideoSample(key, pts, dts, debug) {\n      return {\n        key: key,\n        frame: false,\n        pts: pts,\n        dts: dts,\n        units: [],\n        debug: debug,\n        length: 0\n      };\n    };\n    _proto.getLastNalUnit = function getLastNalUnit(samples) {\n      var _VideoSample;\n      var VideoSample = this.VideoSample;\n      var lastUnit;\n      // try to fallback to previous sample if current one is empty\n      if (!VideoSample || VideoSample.units.length === 0) {\n        VideoSample = samples[samples.length - 1];\n      }\n      if ((_VideoSample = VideoSample) != null && _VideoSample.units) {\n        var units = VideoSample.units;\n        lastUnit = units[units.length - 1];\n      }\n      return lastUnit;\n    };\n    _proto.pushAccessUnit = function pushAccessUnit(VideoSample, videoTrack) {\n      if (VideoSample.units.length && VideoSample.frame) {\n        // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n        if (VideoSample.pts === undefined) {\n          var samples = videoTrack.samples;\n          var nbSamples = samples.length;\n          if (nbSamples) {\n            var lastSample = samples[nbSamples - 1];\n            VideoSample.pts = lastSample.pts;\n            VideoSample.dts = lastSample.dts;\n          } else {\n            // dropping samples, no timestamp found\n            videoTrack.dropped++;\n            return;\n          }\n        }\n        videoTrack.samples.push(VideoSample);\n      }\n      if (VideoSample.debug.length) {\n        logger.log(VideoSample.pts + '/' + VideoSample.dts + ':' + VideoSample.debug);\n      }\n    };\n    return BaseVideoParser;\n  }();\n\n  /**\n   * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n   */\n\n  var ExpGolomb = /*#__PURE__*/function () {\n    function ExpGolomb(data) {\n      this.data = void 0;\n      this.bytesAvailable = void 0;\n      this.word = void 0;\n      this.bitsAvailable = void 0;\n      this.data = data;\n      // the number of bytes left to examine in this.data\n      this.bytesAvailable = data.byteLength;\n      // the current word being examined\n      this.word = 0; // :uint\n      // the number of bits left to examine in the current word\n      this.bitsAvailable = 0; // :uint\n    }\n\n    // ():void\n    var _proto = ExpGolomb.prototype;\n    _proto.loadWord = function loadWord() {\n      var data = this.data;\n      var bytesAvailable = this.bytesAvailable;\n      var position = data.byteLength - bytesAvailable;\n      var workingBytes = new Uint8Array(4);\n      var availableBytes = Math.min(4, bytesAvailable);\n      if (availableBytes === 0) {\n        throw new Error('no bytes available');\n      }\n      workingBytes.set(data.subarray(position, position + availableBytes));\n      this.word = new DataView(workingBytes.buffer).getUint32(0);\n      // track the amount of this.data that has been processed\n      this.bitsAvailable = availableBytes * 8;\n      this.bytesAvailable -= availableBytes;\n    }\n\n    // (count:int):void\n    ;\n    _proto.skipBits = function skipBits(count) {\n      var skipBytes; // :int\n      count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n      if (this.bitsAvailable > count) {\n        this.word <<= count;\n        this.bitsAvailable -= count;\n      } else {\n        count -= this.bitsAvailable;\n        skipBytes = count >> 3;\n        count -= skipBytes << 3;\n        this.bytesAvailable -= skipBytes;\n        this.loadWord();\n        this.word <<= count;\n        this.bitsAvailable -= count;\n      }\n    }\n\n    // (size:int):uint\n    ;\n    _proto.readBits = function readBits(size) {\n      var bits = Math.min(this.bitsAvailable, size); // :uint\n      var valu = this.word >>> 32 - bits; // :uint\n      if (size > 32) {\n        logger.error('Cannot read more than 32 bits at a time');\n      }\n      this.bitsAvailable -= bits;\n      if (this.bitsAvailable > 0) {\n        this.word <<= bits;\n      } else if (this.bytesAvailable > 0) {\n        this.loadWord();\n      } else {\n        throw new Error('no bits available');\n      }\n      bits = size - bits;\n      if (bits > 0 && this.bitsAvailable) {\n        return valu << bits | this.readBits(bits);\n      } else {\n        return valu;\n      }\n    }\n\n    // ():uint\n    ;\n    _proto.skipLZ = function skipLZ() {\n      var leadingZeroCount; // :uint\n      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n        if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n          // the first bit of working word is 1\n          this.word <<= leadingZeroCount;\n          this.bitsAvailable -= leadingZeroCount;\n          return leadingZeroCount;\n        }\n      }\n      // we exhausted word and still have not found a 1\n      this.loadWord();\n      return leadingZeroCount + this.skipLZ();\n    }\n\n    // ():void\n    ;\n    _proto.skipUEG = function skipUEG() {\n      this.skipBits(1 + this.skipLZ());\n    }\n\n    // ():void\n    ;\n    _proto.skipEG = function skipEG() {\n      this.skipBits(1 + this.skipLZ());\n    }\n\n    // ():uint\n    ;\n    _proto.readUEG = function readUEG() {\n      var clz = this.skipLZ(); // :uint\n      return this.readBits(clz + 1) - 1;\n    }\n\n    // ():int\n    ;\n    _proto.readEG = function readEG() {\n      var valu = this.readUEG(); // :int\n      if (0x01 & valu) {\n        // the number is odd if the low order bit is set\n        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n      } else {\n        return -1 * (valu >>> 1); // divide by two then make it negative\n      }\n    }\n\n    // Some convenience functions\n    // :Boolean\n    ;\n    _proto.readBoolean = function readBoolean() {\n      return this.readBits(1) === 1;\n    }\n\n    // ():int\n    ;\n    _proto.readUByte = function readUByte() {\n      return this.readBits(8);\n    }\n\n    // ():int\n    ;\n    _proto.readUShort = function readUShort() {\n      return this.readBits(16);\n    }\n\n    // ():int\n    ;\n    _proto.readUInt = function readUInt() {\n      return this.readBits(32);\n    }\n\n    /**\n     * Advance the ExpGolomb decoder past a scaling list. The scaling\n     * list is optionally transmitted as part of a sequence parameter\n     * set and is not relevant to transmuxing.\n     * @param count the number of entries in this scaling list\n     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n     */;\n    _proto.skipScalingList = function skipScalingList(count) {\n      var lastScale = 8;\n      var nextScale = 8;\n      var deltaScale;\n      for (var j = 0; j < count; j++) {\n        if (nextScale !== 0) {\n          deltaScale = this.readEG();\n          nextScale = (lastScale + deltaScale + 256) % 256;\n        }\n        lastScale = nextScale === 0 ? lastScale : nextScale;\n      }\n    }\n\n    /**\n     * Read a sequence parameter set and return some interesting video\n     * properties. A sequence parameter set is the H264 metadata that\n     * describes the properties of upcoming video frames.\n     * @returns an object with configuration parsed from the\n     * sequence parameter set, including the dimensions of the\n     * associated video frames.\n     */;\n    _proto.readSPS = function readSPS() {\n      var frameCropLeftOffset = 0;\n      var frameCropRightOffset = 0;\n      var frameCropTopOffset = 0;\n      var frameCropBottomOffset = 0;\n      var numRefFramesInPicOrderCntCycle;\n      var scalingListCount;\n      var i;\n      var readUByte = this.readUByte.bind(this);\n      var readBits = this.readBits.bind(this);\n      var readUEG = this.readUEG.bind(this);\n      var readBoolean = this.readBoolean.bind(this);\n      var skipBits = this.skipBits.bind(this);\n      var skipEG = this.skipEG.bind(this);\n      var skipUEG = this.skipUEG.bind(this);\n      var skipScalingList = this.skipScalingList.bind(this);\n      readUByte();\n      var profileIdc = readUByte(); // profile_idc\n      readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n      skipBits(3); // reserved_zero_3bits u(3),\n      readUByte(); // level_idc u(8)\n      skipUEG(); // seq_parameter_set_id\n      // some profiles have more optional data we don't need\n      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n        var chromaFormatIdc = readUEG();\n        if (chromaFormatIdc === 3) {\n          skipBits(1);\n        } // separate_colour_plane_flag\n\n        skipUEG(); // bit_depth_luma_minus8\n        skipUEG(); // bit_depth_chroma_minus8\n        skipBits(1); // qpprime_y_zero_transform_bypass_flag\n        if (readBoolean()) {\n          // seq_scaling_matrix_present_flag\n          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n          for (i = 0; i < scalingListCount; i++) {\n            if (readBoolean()) {\n              // seq_scaling_list_present_flag[ i ]\n              if (i < 6) {\n                skipScalingList(16);\n              } else {\n                skipScalingList(64);\n              }\n            }\n          }\n        }\n      }\n      skipUEG(); // log2_max_frame_num_minus4\n      var picOrderCntType = readUEG();\n      if (picOrderCntType === 0) {\n        readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n      } else if (picOrderCntType === 1) {\n        skipBits(1); // delta_pic_order_always_zero_flag\n        skipEG(); // offset_for_non_ref_pic\n        skipEG(); // offset_for_top_to_bottom_field\n        numRefFramesInPicOrderCntCycle = readUEG();\n        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n          skipEG();\n        } // offset_for_ref_frame[ i ]\n      }\n      skipUEG(); // max_num_ref_frames\n      skipBits(1); // gaps_in_frame_num_value_allowed_flag\n      var picWidthInMbsMinus1 = readUEG();\n      var picHeightInMapUnitsMinus1 = readUEG();\n      var frameMbsOnlyFlag = readBits(1);\n      if (frameMbsOnlyFlag === 0) {\n        skipBits(1);\n      } // mb_adaptive_frame_field_flag\n\n      skipBits(1); // direct_8x8_inference_flag\n      if (readBoolean()) {\n        // frame_cropping_flag\n        frameCropLeftOffset = readUEG();\n        frameCropRightOffset = readUEG();\n        frameCropTopOffset = readUEG();\n        frameCropBottomOffset = readUEG();\n      }\n      var pixelRatio = [1, 1];\n      if (readBoolean()) {\n        // vui_parameters_present_flag\n        if (readBoolean()) {\n          // aspect_ratio_info_present_flag\n          var aspectRatioIdc = readUByte();\n          switch (aspectRatioIdc) {\n            case 1:\n              pixelRatio = [1, 1];\n              break;\n            case 2:\n              pixelRatio = [12, 11];\n              break;\n            case 3:\n              pixelRatio = [10, 11];\n              break;\n            case 4:\n              pixelRatio = [16, 11];\n              break;\n            case 5:\n              pixelRatio = [40, 33];\n              break;\n            case 6:\n              pixelRatio = [24, 11];\n              break;\n            case 7:\n              pixelRatio = [20, 11];\n              break;\n            case 8:\n              pixelRatio = [32, 11];\n              break;\n            case 9:\n              pixelRatio = [80, 33];\n              break;\n            case 10:\n              pixelRatio = [18, 11];\n              break;\n            case 11:\n              pixelRatio = [15, 11];\n              break;\n            case 12:\n              pixelRatio = [64, 33];\n              break;\n            case 13:\n              pixelRatio = [160, 99];\n              break;\n            case 14:\n              pixelRatio = [4, 3];\n              break;\n            case 15:\n              pixelRatio = [3, 2];\n              break;\n            case 16:\n              pixelRatio = [2, 1];\n              break;\n            case 255:\n              {\n                pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n                break;\n              }\n          }\n        }\n      }\n      return {\n        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n        pixelRatio: pixelRatio\n      };\n    };\n    _proto.readSliceType = function readSliceType() {\n      // skip NALu type\n      this.readUByte();\n      // discard first_mb_in_slice\n      this.readUEG();\n      // return slice_type\n      return this.readUEG();\n    };\n    return ExpGolomb;\n  }();\n\n  var AvcVideoParser = /*#__PURE__*/function (_BaseVideoParser) {\n    _inheritsLoose(AvcVideoParser, _BaseVideoParser);\n    function AvcVideoParser() {\n      return _BaseVideoParser.apply(this, arguments) || this;\n    }\n    var _proto = AvcVideoParser.prototype;\n    _proto.parseAVCPES = function parseAVCPES(track, textTrack, pes, last, duration) {\n      var _this = this;\n      var units = this.parseAVCNALu(track, pes.data);\n      var VideoSample = this.VideoSample;\n      var push;\n      var spsfound = false;\n      // free pes.data to save up some memory\n      pes.data = null;\n\n      // if new NAL units found and last sample still there, let's push ...\n      // this helps parsing streams with missing AUD (only do this if AUD never found)\n      if (VideoSample && units.length && !track.audFound) {\n        this.pushAccessUnit(VideoSample, track);\n        VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, '');\n      }\n      units.forEach(function (unit) {\n        var _VideoSample2;\n        switch (unit.type) {\n          // NDR\n          case 1:\n            {\n              var iskey = false;\n              push = true;\n              var data = unit.data;\n              // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n              if (spsfound && data.length > 4) {\n                // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n                var sliceType = new ExpGolomb(data).readSliceType();\n                // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n                // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n                // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n                // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n                // if (sliceType === 2 || sliceType === 7) {\n                if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                  iskey = true;\n                }\n              }\n              if (iskey) {\n                var _VideoSample;\n                // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\n                if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {\n                  _this.pushAccessUnit(VideoSample, track);\n                  VideoSample = _this.VideoSample = null;\n                }\n              }\n              if (!VideoSample) {\n                VideoSample = _this.VideoSample = _this.createVideoSample(true, pes.pts, pes.dts, '');\n              }\n              VideoSample.frame = true;\n              VideoSample.key = iskey;\n              break;\n              // IDR\n            }\n          case 5:\n            push = true;\n            // handle PES not starting with AUD\n            // if we have frame data already, that cannot belong to the same frame, so force a push\n            if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {\n              _this.pushAccessUnit(VideoSample, track);\n              VideoSample = _this.VideoSample = null;\n            }\n            if (!VideoSample) {\n              VideoSample = _this.VideoSample = _this.createVideoSample(true, pes.pts, pes.dts, '');\n            }\n            VideoSample.key = true;\n            VideoSample.frame = true;\n            break;\n          // SEI\n          case 6:\n            {\n              push = true;\n              parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);\n              break;\n              // SPS\n            }\n          case 7:\n            {\n              var _track$pixelRatio, _track$pixelRatio2;\n              push = true;\n              spsfound = true;\n              var sps = unit.data;\n              var expGolombDecoder = new ExpGolomb(sps);\n              var config = expGolombDecoder.readSPS();\n              if (!track.sps || track.width !== config.width || track.height !== config.height || ((_track$pixelRatio = track.pixelRatio) == null ? void 0 : _track$pixelRatio[0]) !== config.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? void 0 : _track$pixelRatio2[1]) !== config.pixelRatio[1]) {\n                track.width = config.width;\n                track.height = config.height;\n                track.pixelRatio = config.pixelRatio;\n                track.sps = [sps];\n                track.duration = duration;\n                var codecarray = sps.subarray(1, 4);\n                var codecstring = 'avc1.';\n                for (var i = 0; i < 3; i++) {\n                  var h = codecarray[i].toString(16);\n                  if (h.length < 2) {\n                    h = '0' + h;\n                  }\n                  codecstring += h;\n                }\n                track.codec = codecstring;\n              }\n              break;\n            }\n          // PPS\n          case 8:\n            push = true;\n            track.pps = [unit.data];\n            break;\n          // AUD\n          case 9:\n            push = true;\n            track.audFound = true;\n            if (VideoSample) {\n              _this.pushAccessUnit(VideoSample, track);\n            }\n            VideoSample = _this.VideoSample = _this.createVideoSample(false, pes.pts, pes.dts, '');\n            break;\n          // Filler Data\n          case 12:\n            push = true;\n            break;\n          default:\n            push = false;\n            if (VideoSample) {\n              VideoSample.debug += 'unknown NAL ' + unit.type + ' ';\n            }\n            break;\n        }\n        if (VideoSample && push) {\n          var _units = VideoSample.units;\n          _units.push(unit);\n        }\n      });\n      // if last PES packet, push samples\n      if (last && VideoSample) {\n        this.pushAccessUnit(VideoSample, track);\n        this.VideoSample = null;\n      }\n    };\n    _proto.parseAVCNALu = function parseAVCNALu(track, array) {\n      var len = array.byteLength;\n      var state = track.naluState || 0;\n      var lastState = state;\n      var units = [];\n      var i = 0;\n      var value;\n      var overflow;\n      var unitType;\n      var lastUnitStart = -1;\n      var lastUnitType = 0;\n      // logger.log('PES:' + Hex.hexDump(array));\n\n      if (state === -1) {\n        // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n        lastUnitStart = 0;\n        // NALu type is value read from offset 0\n        lastUnitType = array[0] & 0x1f;\n        state = 0;\n        i = 1;\n      }\n      while (i < len) {\n        value = array[i++];\n        // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n        if (!state) {\n          state = value ? 0 : 1;\n          continue;\n        }\n        if (state === 1) {\n          state = value ? 0 : 2;\n          continue;\n        }\n        // here we have state either equal to 2 or 3\n        if (!value) {\n          state = 3;\n        } else if (value === 1) {\n          overflow = i - state - 1;\n          if (lastUnitStart >= 0) {\n            var unit = {\n              data: array.subarray(lastUnitStart, overflow),\n              type: lastUnitType\n            };\n            // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n            units.push(unit);\n          } else {\n            // lastUnitStart is undefined => this is the first start code found in this PES packet\n            // first check if start code delimiter is overlapping between 2 PES packets,\n            // ie it started in last packet (lastState not zero)\n            // and ended at the beginning of this PES packet (i <= 4 - lastState)\n            var lastUnit = this.getLastNalUnit(track.samples);\n            if (lastUnit) {\n              if (lastState && i <= 4 - lastState) {\n                // start delimiter overlapping between PES packets\n                // strip start delimiter bytes from the end of last NAL unit\n                // check if lastUnit had a state different from zero\n                if (lastUnit.state) {\n                  // strip last bytes\n                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n                }\n              }\n              // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n\n              if (overflow > 0) {\n                // logger.log('first NALU found with overflow:' + overflow);\n                lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));\n                lastUnit.state = 0;\n              }\n            }\n          }\n          // check if we can read unit type\n          if (i < len) {\n            unitType = array[i] & 0x1f;\n            // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n            lastUnitStart = i;\n            lastUnitType = unitType;\n            state = 0;\n          } else {\n            // not enough byte to read unit type. let's read it on next PES parsing\n            state = -1;\n          }\n        } else {\n          state = 0;\n        }\n      }\n      if (lastUnitStart >= 0 && state >= 0) {\n        var _unit = {\n          data: array.subarray(lastUnitStart, len),\n          type: lastUnitType,\n          state: state\n        };\n        units.push(_unit);\n        // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n      }\n      // no NALu found\n      if (units.length === 0) {\n        // append pes.data to previous NAL unit\n        var _lastUnit = this.getLastNalUnit(track.samples);\n        if (_lastUnit) {\n          _lastUnit.data = appendUint8Array(_lastUnit.data, array);\n        }\n      }\n      track.naluState = state;\n      return units;\n    };\n    return AvcVideoParser;\n  }(BaseVideoParser);\n\n  /**\n   * SAMPLE-AES decrypter\n   */\n\n  var SampleAesDecrypter = /*#__PURE__*/function () {\n    function SampleAesDecrypter(observer, config, keyData) {\n      this.keyData = void 0;\n      this.decrypter = void 0;\n      this.keyData = keyData;\n      this.decrypter = new Decrypter(config, {\n        removePKCS7Padding: false\n      });\n    }\n    var _proto = SampleAesDecrypter.prototype;\n    _proto.decryptBuffer = function decryptBuffer(encryptedData) {\n      return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);\n    }\n\n    // AAC - encrypt all full 16 bytes blocks starting from offset 16\n    ;\n    _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback) {\n      var _this = this;\n      var curUnit = samples[sampleIndex].unit;\n      if (curUnit.length <= 16) {\n        // No encrypted portion in this sample (first 16 bytes is not\n        // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n        return;\n      }\n      var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n      var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n      this.decryptBuffer(encryptedBuffer).then(function (decryptedBuffer) {\n        var decryptedData = new Uint8Array(decryptedBuffer);\n        curUnit.set(decryptedData, 16);\n        if (!_this.decrypter.isSync()) {\n          _this.decryptAacSamples(samples, sampleIndex + 1, callback);\n        }\n      });\n    };\n    _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {\n      for (;; sampleIndex++) {\n        if (sampleIndex >= samples.length) {\n          callback();\n          return;\n        }\n        if (samples[sampleIndex].unit.length < 32) {\n          continue;\n        }\n        this.decryptAacSample(samples, sampleIndex, callback);\n        if (!this.decrypter.isSync()) {\n          return;\n        }\n      }\n    }\n\n    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n    ;\n    _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {\n      var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n      var encryptedData = new Int8Array(encryptedDataLen);\n      var outputPos = 0;\n      for (var inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {\n        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n      }\n      return encryptedData;\n    };\n    _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {\n      var uint8DecryptedData = new Uint8Array(decryptedData);\n      var inputPos = 0;\n      for (var outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {\n        decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n      }\n      return decodedData;\n    };\n    _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {\n      var _this2 = this;\n      var decodedData = discardEPB(curUnit.data);\n      var encryptedData = this.getAvcEncryptedData(decodedData);\n      this.decryptBuffer(encryptedData.buffer).then(function (decryptedBuffer) {\n        curUnit.data = _this2.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n        if (!_this2.decrypter.isSync()) {\n          _this2.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n        }\n      });\n    };\n    _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n      if (samples instanceof Uint8Array) {\n        throw new Error('Cannot decrypt samples of type Uint8Array');\n      }\n      for (;; sampleIndex++, unitIndex = 0) {\n        if (sampleIndex >= samples.length) {\n          callback();\n          return;\n        }\n        var curUnits = samples[sampleIndex].units;\n        for (;; unitIndex++) {\n          if (unitIndex >= curUnits.length) {\n            break;\n          }\n          var curUnit = curUnits[unitIndex];\n          if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n            continue;\n          }\n          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);\n          if (!this.decrypter.isSync()) {\n            return;\n          }\n        }\n      }\n    };\n    return SampleAesDecrypter;\n  }();\n\n  var PACKET_LENGTH = 188;\n  var TSDemuxer = /*#__PURE__*/function () {\n    function TSDemuxer(observer, config, typeSupported) {\n      this.observer = void 0;\n      this.config = void 0;\n      this.typeSupported = void 0;\n      this.sampleAes = null;\n      this.pmtParsed = false;\n      this.audioCodec = void 0;\n      this.videoCodec = void 0;\n      this._duration = 0;\n      this._pmtId = -1;\n      this._videoTrack = void 0;\n      this._audioTrack = void 0;\n      this._id3Track = void 0;\n      this._txtTrack = void 0;\n      this.aacOverFlow = null;\n      this.remainderData = null;\n      this.videoParser = void 0;\n      this.observer = observer;\n      this.config = config;\n      this.typeSupported = typeSupported;\n      this.videoParser = new AvcVideoParser();\n    }\n    TSDemuxer.probe = function probe(data) {\n      var syncOffset = TSDemuxer.syncOffset(data);\n      if (syncOffset > 0) {\n        logger.warn(\"MPEG2-TS detected but first sync word found @ offset \" + syncOffset);\n      }\n      return syncOffset !== -1;\n    };\n    TSDemuxer.syncOffset = function syncOffset(data) {\n      var length = data.length;\n      var scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;\n      var i = 0;\n      while (i < scanwindow) {\n        // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n        var foundPat = false;\n        var packetStart = -1;\n        var tsPackets = 0;\n        for (var j = i; j < length; j += PACKET_LENGTH) {\n          if (data[j] === 0x47 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 0x47)) {\n            tsPackets++;\n            if (packetStart === -1) {\n              packetStart = j;\n              // First sync word found at offset, increase scan length (#5251)\n              if (packetStart !== 0) {\n                scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;\n              }\n            }\n            if (!foundPat) {\n              foundPat = parsePID(data, j) === 0;\n            }\n            // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\n            if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {\n              return packetStart;\n            }\n          } else if (tsPackets) {\n            // Exit if sync word found, but does not contain contiguous packets\n            return -1;\n          } else {\n            break;\n          }\n        }\n        i++;\n      }\n      return -1;\n    }\n\n    /**\n     * Creates a track model internal to demuxer used to drive remuxing input\n     */;\n    TSDemuxer.createTrack = function createTrack(type, duration) {\n      return {\n        container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n        type: type,\n        id: RemuxerTrackIdConfig[type],\n        pid: -1,\n        inputTimeScale: 90000,\n        sequenceNumber: 0,\n        samples: [],\n        dropped: 0,\n        duration: type === 'audio' ? duration : undefined\n      };\n    }\n\n    /**\n     * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n     * Resets all internal track instances of the demuxer.\n     */;\n    var _proto = TSDemuxer.prototype;\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n      this.pmtParsed = false;\n      this._pmtId = -1;\n      this._videoTrack = TSDemuxer.createTrack('video');\n      this._audioTrack = TSDemuxer.createTrack('audio', trackDuration);\n      this._id3Track = TSDemuxer.createTrack('id3');\n      this._txtTrack = TSDemuxer.createTrack('text');\n      this._audioTrack.segmentCodec = 'aac';\n\n      // flush any partial content\n      this.aacOverFlow = null;\n      this.remainderData = null;\n      this.audioCodec = audioCodec;\n      this.videoCodec = videoCodec;\n      this._duration = trackDuration;\n    };\n    _proto.resetTimeStamp = function resetTimeStamp() {};\n    _proto.resetContiguity = function resetContiguity() {\n      var _audioTrack = this._audioTrack,\n        _videoTrack = this._videoTrack,\n        _id3Track = this._id3Track;\n      if (_audioTrack) {\n        _audioTrack.pesData = null;\n      }\n      if (_videoTrack) {\n        _videoTrack.pesData = null;\n      }\n      if (_id3Track) {\n        _id3Track.pesData = null;\n      }\n      this.aacOverFlow = null;\n      this.remainderData = null;\n    };\n    _proto.demux = function demux(data, timeOffset, isSampleAes, flush) {\n      if (isSampleAes === void 0) {\n        isSampleAes = false;\n      }\n      if (flush === void 0) {\n        flush = false;\n      }\n      if (!isSampleAes) {\n        this.sampleAes = null;\n      }\n      var pes;\n      var videoTrack = this._videoTrack;\n      var audioTrack = this._audioTrack;\n      var id3Track = this._id3Track;\n      var textTrack = this._txtTrack;\n      var videoPid = videoTrack.pid;\n      var videoData = videoTrack.pesData;\n      var audioPid = audioTrack.pid;\n      var id3Pid = id3Track.pid;\n      var audioData = audioTrack.pesData;\n      var id3Data = id3Track.pesData;\n      var unknownPID = null;\n      var pmtParsed = this.pmtParsed;\n      var pmtId = this._pmtId;\n      var len = data.length;\n      if (this.remainderData) {\n        data = appendUint8Array(this.remainderData, data);\n        len = data.length;\n        this.remainderData = null;\n      }\n      if (len < PACKET_LENGTH && !flush) {\n        this.remainderData = data;\n        return {\n          audioTrack: audioTrack,\n          videoTrack: videoTrack,\n          id3Track: id3Track,\n          textTrack: textTrack\n        };\n      }\n      var syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n      len -= (len - syncOffset) % PACKET_LENGTH;\n      if (len < data.byteLength && !flush) {\n        this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n      }\n\n      // loop through TS packets\n      var tsPacketErrors = 0;\n      for (var start = syncOffset; start < len; start += PACKET_LENGTH) {\n        if (data[start] === 0x47) {\n          var stt = !!(data[start + 1] & 0x40);\n          var pid = parsePID(data, start);\n          var atf = (data[start + 3] & 0x30) >> 4;\n\n          // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n          var offset = void 0;\n          if (atf > 1) {\n            offset = start + 5 + data[start + 4];\n            // continue if there is only adaptation field\n            if (offset === start + PACKET_LENGTH) {\n              continue;\n            }\n          } else {\n            offset = start + 4;\n          }\n          switch (pid) {\n            case videoPid:\n              if (stt) {\n                if (videoData && (pes = parsePES(videoData))) {\n                  this.videoParser.parseAVCPES(videoTrack, textTrack, pes, false, this._duration);\n                }\n                videoData = {\n                  data: [],\n                  size: 0\n                };\n              }\n              if (videoData) {\n                videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                videoData.size += start + PACKET_LENGTH - offset;\n              }\n              break;\n            case audioPid:\n              if (stt) {\n                if (audioData && (pes = parsePES(audioData))) {\n                  switch (audioTrack.segmentCodec) {\n                    case 'aac':\n                      this.parseAACPES(audioTrack, pes);\n                      break;\n                    case 'mp3':\n                      this.parseMPEGPES(audioTrack, pes);\n                      break;\n                    case 'ac3':\n                      {\n                        this.parseAC3PES(audioTrack, pes);\n                      }\n                      break;\n                  }\n                }\n                audioData = {\n                  data: [],\n                  size: 0\n                };\n              }\n              if (audioData) {\n                audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                audioData.size += start + PACKET_LENGTH - offset;\n              }\n              break;\n            case id3Pid:\n              if (stt) {\n                if (id3Data && (pes = parsePES(id3Data))) {\n                  this.parseID3PES(id3Track, pes);\n                }\n                id3Data = {\n                  data: [],\n                  size: 0\n                };\n              }\n              if (id3Data) {\n                id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                id3Data.size += start + PACKET_LENGTH - offset;\n              }\n              break;\n            case 0:\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n              pmtId = this._pmtId = parsePAT(data, offset);\n              // logger.log('PMT PID:'  + this._pmtId);\n              break;\n            case pmtId:\n              {\n                if (stt) {\n                  offset += data[offset] + 1;\n                }\n                var parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes, this.observer);\n\n                // only update track id if track PID found while parsing PMT\n                // this is to avoid resetting the PID to -1 in case\n                // track PID transiently disappears from the stream\n                // this could happen in case of transient missing audio samples for example\n                // NOTE this is only the PID of the track as found in TS,\n                // but we are not using this for MP4 track IDs.\n                videoPid = parsedPIDs.videoPid;\n                if (videoPid > 0) {\n                  videoTrack.pid = videoPid;\n                  videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;\n                }\n                audioPid = parsedPIDs.audioPid;\n                if (audioPid > 0) {\n                  audioTrack.pid = audioPid;\n                  audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;\n                }\n                id3Pid = parsedPIDs.id3Pid;\n                if (id3Pid > 0) {\n                  id3Track.pid = id3Pid;\n                }\n                if (unknownPID !== null && !pmtParsed) {\n                  logger.warn(\"MPEG-TS PMT found at \" + start + \" after unknown PID '\" + unknownPID + \"'. Backtracking to sync byte @\" + syncOffset + \" to parse all TS packets.\");\n                  unknownPID = null;\n                  // we set it to -188, the += 188 in the for loop will reset start to 0\n                  start = syncOffset - 188;\n                }\n                pmtParsed = this.pmtParsed = true;\n                break;\n              }\n            case 0x11:\n            case 0x1fff:\n              break;\n            default:\n              unknownPID = pid;\n              break;\n          }\n        } else {\n          tsPacketErrors++;\n        }\n      }\n      if (tsPacketErrors > 0) {\n        emitParsingError(this.observer, new Error(\"Found \" + tsPacketErrors + \" TS packet/s that do not start with 0x47\"));\n      }\n      videoTrack.pesData = videoData;\n      audioTrack.pesData = audioData;\n      id3Track.pesData = id3Data;\n      var demuxResult = {\n        audioTrack: audioTrack,\n        videoTrack: videoTrack,\n        id3Track: id3Track,\n        textTrack: textTrack\n      };\n      if (flush) {\n        this.extractRemainingSamples(demuxResult);\n      }\n      return demuxResult;\n    };\n    _proto.flush = function flush() {\n      var remainderData = this.remainderData;\n      this.remainderData = null;\n      var result;\n      if (remainderData) {\n        result = this.demux(remainderData, -1, false, true);\n      } else {\n        result = {\n          videoTrack: this._videoTrack,\n          audioTrack: this._audioTrack,\n          id3Track: this._id3Track,\n          textTrack: this._txtTrack\n        };\n      }\n      this.extractRemainingSamples(result);\n      if (this.sampleAes) {\n        return this.decrypt(result, this.sampleAes);\n      }\n      return result;\n    };\n    _proto.extractRemainingSamples = function extractRemainingSamples(demuxResult) {\n      var audioTrack = demuxResult.audioTrack,\n        videoTrack = demuxResult.videoTrack,\n        id3Track = demuxResult.id3Track,\n        textTrack = demuxResult.textTrack;\n      var videoData = videoTrack.pesData;\n      var audioData = audioTrack.pesData;\n      var id3Data = id3Track.pesData;\n      // try to parse last PES packets\n      var pes;\n      if (videoData && (pes = parsePES(videoData))) {\n        this.videoParser.parseAVCPES(videoTrack, textTrack, pes, true, this._duration);\n        videoTrack.pesData = null;\n      } else {\n        // either avcData null or PES truncated, keep it for next frag parsing\n        videoTrack.pesData = videoData;\n      }\n      if (audioData && (pes = parsePES(audioData))) {\n        switch (audioTrack.segmentCodec) {\n          case 'aac':\n            this.parseAACPES(audioTrack, pes);\n            break;\n          case 'mp3':\n            this.parseMPEGPES(audioTrack, pes);\n            break;\n          case 'ac3':\n            {\n              this.parseAC3PES(audioTrack, pes);\n            }\n            break;\n        }\n        audioTrack.pesData = null;\n      } else {\n        if (audioData != null && audioData.size) {\n          logger.log('last AAC PES packet truncated,might overlap between fragments');\n        }\n\n        // either audioData null or PES truncated, keep it for next frag parsing\n        audioTrack.pesData = audioData;\n      }\n      if (id3Data && (pes = parsePES(id3Data))) {\n        this.parseID3PES(id3Track, pes);\n        id3Track.pesData = null;\n      } else {\n        // either id3Data null or PES truncated, keep it for next frag parsing\n        id3Track.pesData = id3Data;\n      }\n    };\n    _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {\n      var demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n      var sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);\n      return this.decrypt(demuxResult, sampleAes);\n    };\n    _proto.decrypt = function decrypt(demuxResult, sampleAes) {\n      return new Promise(function (resolve) {\n        var audioTrack = demuxResult.audioTrack,\n          videoTrack = demuxResult.videoTrack;\n        if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\n          sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {\n            if (videoTrack.samples) {\n              sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n                resolve(demuxResult);\n              });\n            } else {\n              resolve(demuxResult);\n            }\n          });\n        } else if (videoTrack.samples) {\n          sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {\n            resolve(demuxResult);\n          });\n        }\n      });\n    };\n    _proto.destroy = function destroy() {\n      this._duration = 0;\n    };\n    _proto.parseAACPES = function parseAACPES(track, pes) {\n      var startOffset = 0;\n      var aacOverFlow = this.aacOverFlow;\n      var data = pes.data;\n      if (aacOverFlow) {\n        this.aacOverFlow = null;\n        var frameMissingBytes = aacOverFlow.missing;\n        var sampleLength = aacOverFlow.sample.unit.byteLength;\n        // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n        if (frameMissingBytes === -1) {\n          data = appendUint8Array(aacOverFlow.sample.unit, data);\n        } else {\n          var frameOverflowBytes = sampleLength - frameMissingBytes;\n          aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n          track.samples.push(aacOverFlow.sample);\n          startOffset = aacOverFlow.missing;\n        }\n      }\n      // look for ADTS header (0xFFFx)\n      var offset;\n      var len;\n      for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n        if (isHeader$1(data, offset)) {\n          break;\n        }\n      }\n      // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n      if (offset !== startOffset) {\n        var reason;\n        var recoverable = offset < len - 1;\n        if (recoverable) {\n          reason = \"AAC PES did not start with ADTS header,offset:\" + offset;\n        } else {\n          reason = 'No ADTS header found in AAC PES';\n        }\n        emitParsingError(this.observer, new Error(reason), recoverable);\n        if (!recoverable) {\n          return;\n        }\n      }\n      initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n      var pts;\n      if (pes.pts !== undefined) {\n        pts = pes.pts;\n      } else if (aacOverFlow) {\n        // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n        // first sample PTS should be equal to last sample PTS + frameDuration\n        var frameDuration = getFrameDuration(track.samplerate);\n        pts = aacOverFlow.sample.pts + frameDuration;\n      } else {\n        logger.warn('[tsdemuxer]: AAC PES unknown PTS');\n        return;\n      }\n\n      // scan for aac samples\n      var frameIndex = 0;\n      var frame;\n      while (offset < len) {\n        frame = appendFrame$1(track, data, offset, pts, frameIndex);\n        offset += frame.length;\n        if (!frame.missing) {\n          frameIndex++;\n          for (; offset < len - 1; offset++) {\n            if (isHeader$1(data, offset)) {\n              break;\n            }\n          }\n        } else {\n          this.aacOverFlow = frame;\n          break;\n        }\n      }\n    };\n    _proto.parseMPEGPES = function parseMPEGPES(track, pes) {\n      var data = pes.data;\n      var length = data.length;\n      var frameIndex = 0;\n      var offset = 0;\n      var pts = pes.pts;\n      if (pts === undefined) {\n        logger.warn('[tsdemuxer]: MPEG PES unknown PTS');\n        return;\n      }\n      while (offset < length) {\n        if (isHeader(data, offset)) {\n          var frame = appendFrame(track, data, offset, pts, frameIndex);\n          if (frame) {\n            offset += frame.length;\n            frameIndex++;\n          } else {\n            // logger.log('Unable to parse Mpeg audio frame');\n            break;\n          }\n        } else {\n          // nothing found, keep looking\n          offset++;\n        }\n      }\n    };\n    _proto.parseAC3PES = function parseAC3PES(track, pes) {\n      {\n        var data = pes.data;\n        var pts = pes.pts;\n        if (pts === undefined) {\n          logger.warn('[tsdemuxer]: AC3 PES unknown PTS');\n          return;\n        }\n        var length = data.length;\n        var frameIndex = 0;\n        var offset = 0;\n        var parsed;\n        while (offset < length && (parsed = _appendFrame(track, data, offset, pts, frameIndex++)) > 0) {\n          offset += parsed;\n        }\n      }\n    };\n    _proto.parseID3PES = function parseID3PES(id3Track, pes) {\n      if (pes.pts === undefined) {\n        logger.warn('[tsdemuxer]: ID3 PES unknown PTS');\n        return;\n      }\n      var id3Sample = _extends({}, pes, {\n        type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\n        duration: Number.POSITIVE_INFINITY\n      });\n      id3Track.samples.push(id3Sample);\n    };\n    return TSDemuxer;\n  }();\n  function parsePID(data, offset) {\n    // pid is a 13-bit field starting at the last bit of TS[1]\n    return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n  }\n  function parsePAT(data, offset) {\n    // skip the PSI header and parse the first PMT entry\n    return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n  }\n  function parsePMT(data, offset, typeSupported, isSampleAes, observer) {\n    var result = {\n      audioPid: -1,\n      videoPid: -1,\n      id3Pid: -1,\n      segmentVideoCodec: 'avc',\n      segmentAudioCodec: 'aac'\n    };\n    var sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n    var tableEnd = offset + 3 + sectionLength - 4;\n    // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n    var programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n    // advance the offset to the first entry in the mapping table\n    offset += 12 + programInfoLength;\n    while (offset < tableEnd) {\n      var pid = parsePID(data, offset);\n      var esInfoLength = (data[offset + 3] & 0x0f) << 8 | data[offset + 4];\n      switch (data[offset]) {\n        case 0xcf:\n          // SAMPLE-AES AAC\n          if (!isSampleAes) {\n            logEncryptedSamplesFoundInUnencryptedStream('ADTS AAC');\n            break;\n          }\n        /* falls through */\n        case 0x0f:\n          // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n          // logger.log('AAC PID:'  + pid);\n          if (result.audioPid === -1) {\n            result.audioPid = pid;\n          }\n          break;\n\n        // Packetized metadata (ID3)\n        case 0x15:\n          // logger.log('ID3 PID:'  + pid);\n          if (result.id3Pid === -1) {\n            result.id3Pid = pid;\n          }\n          break;\n        case 0xdb:\n          // SAMPLE-AES AVC\n          if (!isSampleAes) {\n            logEncryptedSamplesFoundInUnencryptedStream('H.264');\n            break;\n          }\n        /* falls through */\n        case 0x1b:\n          // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n          // logger.log('AVC PID:'  + pid);\n          if (result.videoPid === -1) {\n            result.videoPid = pid;\n            result.segmentVideoCodec = 'avc';\n          }\n          break;\n\n        // ISO/IEC 11172-3 (MPEG-1 audio)\n        // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n        case 0x03:\n        case 0x04:\n          // logger.log('MPEG PID:'  + pid);\n          if (!typeSupported.mpeg && !typeSupported.mp3) {\n            logger.log('MPEG audio found, not supported in this browser');\n          } else if (result.audioPid === -1) {\n            result.audioPid = pid;\n            result.segmentAudioCodec = 'mp3';\n          }\n          break;\n        case 0xc1:\n          // SAMPLE-AES AC3\n          if (!isSampleAes) {\n            logEncryptedSamplesFoundInUnencryptedStream('AC-3');\n            break;\n          }\n        /* falls through */\n        case 0x81:\n          {\n            if (!typeSupported.ac3) {\n              logger.log('AC-3 audio found, not supported in this browser');\n            } else if (result.audioPid === -1) {\n              result.audioPid = pid;\n              result.segmentAudioCodec = 'ac3';\n            }\n          }\n          break;\n        case 0x06:\n          // stream_type 6 can mean a lot of different things in case of DVB.\n          // We need to look at the descriptors. Right now, we're only interested\n          // in AC-3 audio, so we do the descriptor parsing only when we don't have\n          // an audio PID yet.\n          if (result.audioPid === -1 && esInfoLength > 0) {\n            var parsePos = offset + 5;\n            var remaining = esInfoLength;\n            while (remaining > 2) {\n              var descriptorId = data[parsePos];\n              switch (descriptorId) {\n                case 0x6a:\n                  // DVB Descriptor for AC-3\n                  {\n                    if (typeSupported.ac3 !== true) {\n                      logger.log('AC-3 audio found, not supported in this browser for now');\n                    } else {\n                      result.audioPid = pid;\n                      result.segmentAudioCodec = 'ac3';\n                    }\n                  }\n                  break;\n              }\n              var descriptorLen = data[parsePos + 1] + 2;\n              parsePos += descriptorLen;\n              remaining -= descriptorLen;\n            }\n          }\n          break;\n        case 0xc2: // SAMPLE-AES EC3\n        /* falls through */\n        case 0x87:\n          emitParsingError(observer, new Error('Unsupported EC-3 in M2TS found'));\n          return result;\n        case 0x24:\n          emitParsingError(observer, new Error('Unsupported HEVC in M2TS found'));\n          return result;\n      }\n      // move to the next table entry\n      // skip past the elementary stream descriptors, if present\n      offset += esInfoLength + 5;\n    }\n    return result;\n  }\n  function emitParsingError(observer, error, levelRetry) {\n    logger.warn(\"parsing error: \" + error.message);\n    observer.emit(Events.ERROR, Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      fatal: false,\n      levelRetry: levelRetry,\n      error: error,\n      reason: error.message\n    });\n  }\n  function logEncryptedSamplesFoundInUnencryptedStream(type) {\n    logger.log(type + \" with AES-128-CBC encryption found in unencrypted stream\");\n  }\n  function parsePES(stream) {\n    var i = 0;\n    var frag;\n    var pesLen;\n    var pesHdrLen;\n    var pesPts;\n    var pesDts;\n    var data = stream.data;\n    // safety check\n    if (!stream || stream.size === 0) {\n      return null;\n    }\n\n    // we might need up to 19 bytes to read PES header\n    // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n    // usually only one merge is needed (and this is rare ...)\n    while (data[0].length < 19 && data.length > 1) {\n      data[0] = appendUint8Array(data[0], data[1]);\n      data.splice(1, 1);\n    }\n    // retrieve PTS/DTS from first fragment\n    frag = data[0];\n    var pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n    if (pesPrefix === 1) {\n      pesLen = (frag[4] << 8) + frag[5];\n      // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n      // minus 6 : PES header size\n      if (pesLen && pesLen > stream.size - 6) {\n        return null;\n      }\n      var pesFlags = frag[7];\n      if (pesFlags & 0xc0) {\n        /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n            as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n            as Bitwise operators treat their operands as a sequence of 32 bits */\n        pesPts = (frag[9] & 0x0e) * 536870912 +\n        // 1 << 29\n        (frag[10] & 0xff) * 4194304 +\n        // 1 << 22\n        (frag[11] & 0xfe) * 16384 +\n        // 1 << 14\n        (frag[12] & 0xff) * 128 +\n        // 1 << 7\n        (frag[13] & 0xfe) / 2;\n        if (pesFlags & 0x40) {\n          pesDts = (frag[14] & 0x0e) * 536870912 +\n          // 1 << 29\n          (frag[15] & 0xff) * 4194304 +\n          // 1 << 22\n          (frag[16] & 0xfe) * 16384 +\n          // 1 << 14\n          (frag[17] & 0xff) * 128 +\n          // 1 << 7\n          (frag[18] & 0xfe) / 2;\n          if (pesPts - pesDts > 60 * 90000) {\n            logger.warn(Math.round((pesPts - pesDts) / 90000) + \"s delta between PTS and DTS, align them\");\n            pesPts = pesDts;\n          }\n        } else {\n          pesDts = pesPts;\n        }\n      }\n      pesHdrLen = frag[8];\n      // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n      var payloadStartOffset = pesHdrLen + 9;\n      if (stream.size <= payloadStartOffset) {\n        return null;\n      }\n      stream.size -= payloadStartOffset;\n      // reassemble PES packet\n      var pesData = new Uint8Array(stream.size);\n      for (var j = 0, dataLen = data.length; j < dataLen; j++) {\n        frag = data[j];\n        var len = frag.byteLength;\n        if (payloadStartOffset) {\n          if (payloadStartOffset > len) {\n            // trim full frag if PES header bigger than frag\n            payloadStartOffset -= len;\n            continue;\n          } else {\n            // trim partial frag if PES header smaller than frag\n            frag = frag.subarray(payloadStartOffset);\n            len -= payloadStartOffset;\n            payloadStartOffset = 0;\n          }\n        }\n        pesData.set(frag, i);\n        i += len;\n      }\n      if (pesLen) {\n        // payload size : remove PES header + PES extension\n        pesLen -= pesHdrLen + 3;\n      }\n      return {\n        data: pesData,\n        pts: pesPts,\n        dts: pesDts,\n        len: pesLen\n      };\n    }\n    return null;\n  }\n\n  var MP3Demuxer = /*#__PURE__*/function (_BaseAudioDemuxer) {\n    _inheritsLoose(MP3Demuxer, _BaseAudioDemuxer);\n    function MP3Demuxer() {\n      return _BaseAudioDemuxer.apply(this, arguments) || this;\n    }\n    var _proto = MP3Demuxer.prototype;\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n      _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);\n      this._audioTrack = {\n        container: 'audio/mpeg',\n        type: 'audio',\n        id: 2,\n        pid: -1,\n        sequenceNumber: 0,\n        segmentCodec: 'mp3',\n        samples: [],\n        manifestCodec: audioCodec,\n        duration: trackDuration,\n        inputTimeScale: 90000,\n        dropped: 0\n      };\n    };\n    MP3Demuxer.probe = function probe$1(data) {\n      if (!data) {\n        return false;\n      }\n\n      // check if data contains ID3 timestamp and MPEG sync word\n      // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n      // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n      // More info http://www.mp3-tech.org/programmer/frame_header.html\n      var id3Data = getID3Data(data, 0);\n      var offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n\n      // Check for ac-3|ec-3 sync bytes and return false if present\n      if (id3Data && data[offset] === 0x0b && data[offset + 1] === 0x77 && getTimeStamp(id3Data) !== undefined &&\n      // check the bsid to confirm ac-3 or ec-3 (not mp3)\n      getAudioBSID(data, offset) <= 16) {\n        return false;\n      }\n      for (var length = data.length; offset < length; offset++) {\n        if (probe(data, offset)) {\n          logger.log('MPEG Audio sync word found !');\n          return true;\n        }\n      }\n      return false;\n    };\n    _proto.canParse = function canParse$1(data, offset) {\n      return canParse(data, offset);\n    };\n    _proto.appendFrame = function appendFrame$1(track, data, offset) {\n      if (this.basePTS === null) {\n        return;\n      }\n      return appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n    };\n    return MP3Demuxer;\n  }(BaseAudioDemuxer);\n\n  /**\n   *  AAC helper\n   */\n  var AAC = /*#__PURE__*/function () {\n    function AAC() {}\n    AAC.getSilentFrame = function getSilentFrame(codec, channelCount) {\n      switch (codec) {\n        case 'mp4a.40.2':\n          if (channelCount === 1) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n          } else if (channelCount === 2) {\n            return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n          } else if (channelCount === 3) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n          } else if (channelCount === 4) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n          } else if (channelCount === 5) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n          } else if (channelCount === 6) {\n            return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n          }\n          break;\n        // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n        default:\n          if (channelCount === 1) {\n            // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n          } else if (channelCount === 2) {\n            // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n          } else if (channelCount === 3) {\n            // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n            return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n          }\n          break;\n      }\n      return undefined;\n    };\n    return AAC;\n  }();\n\n  /**\n   * Generate MP4 Box\n   */\n\n  var UINT32_MAX = Math.pow(2, 32) - 1;\n  var MP4 = /*#__PURE__*/function () {\n    function MP4() {}\n    MP4.init = function init() {\n      MP4.types = {\n        avc1: [],\n        // codingname\n        avcC: [],\n        btrt: [],\n        dinf: [],\n        dref: [],\n        esds: [],\n        ftyp: [],\n        hdlr: [],\n        mdat: [],\n        mdhd: [],\n        mdia: [],\n        mfhd: [],\n        minf: [],\n        moof: [],\n        moov: [],\n        mp4a: [],\n        '.mp3': [],\n        dac3: [],\n        'ac-3': [],\n        mvex: [],\n        mvhd: [],\n        pasp: [],\n        sdtp: [],\n        stbl: [],\n        stco: [],\n        stsc: [],\n        stsd: [],\n        stsz: [],\n        stts: [],\n        tfdt: [],\n        tfhd: [],\n        traf: [],\n        trak: [],\n        trun: [],\n        trex: [],\n        tkhd: [],\n        vmhd: [],\n        smhd: []\n      };\n      var i;\n      for (i in MP4.types) {\n        if (MP4.types.hasOwnProperty(i)) {\n          MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n        }\n      }\n      var videoHdlr = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00,\n      // pre_defined\n      0x76, 0x69, 0x64, 0x65,\n      // handler_type: 'vide'\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n      ]);\n      var audioHdlr = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00,\n      // pre_defined\n      0x73, 0x6f, 0x75, 0x6e,\n      // handler_type: 'soun'\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n      ]);\n      MP4.HDLR_TYPES = {\n        video: videoHdlr,\n        audio: audioHdlr\n      };\n      var dref = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x01,\n      // entry_count\n      0x00, 0x00, 0x00, 0x0c,\n      // entry_size\n      0x75, 0x72, 0x6c, 0x20,\n      // 'url' type\n      0x00,\n      // version 0\n      0x00, 0x00, 0x01 // entry_flags\n      ]);\n      var stco = new Uint8Array([0x00,\n      // version\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00 // entry_count\n      ]);\n      MP4.STTS = MP4.STSC = MP4.STCO = stco;\n      MP4.STSZ = new Uint8Array([0x00,\n      // version\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00,\n      // sample_size\n      0x00, 0x00, 0x00, 0x00 // sample_count\n      ]);\n      MP4.VMHD = new Uint8Array([0x00,\n      // version\n      0x00, 0x00, 0x01,\n      // flags\n      0x00, 0x00,\n      // graphicsmode\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n      ]);\n      MP4.SMHD = new Uint8Array([0x00,\n      // version\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00,\n      // balance\n      0x00, 0x00 // reserved\n      ]);\n      MP4.STSD = new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x01]); // entry_count\n\n      var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n      var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n      var minorVersion = new Uint8Array([0, 0, 0, 1]);\n      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n    };\n    MP4.box = function box(type) {\n      var size = 8;\n      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        payload[_key - 1] = arguments[_key];\n      }\n      var i = payload.length;\n      var len = i;\n      // calculate the total size we need to allocate\n      while (i--) {\n        size += payload[i].byteLength;\n      }\n      var result = new Uint8Array(size);\n      result[0] = size >> 24 & 0xff;\n      result[1] = size >> 16 & 0xff;\n      result[2] = size >> 8 & 0xff;\n      result[3] = size & 0xff;\n      result.set(type, 4);\n      // copy the payload into the result\n      for (i = 0, size = 8; i < len; i++) {\n        // copy payload[i] array @ offset size\n        result.set(payload[i], size);\n        size += payload[i].byteLength;\n      }\n      return result;\n    };\n    MP4.hdlr = function hdlr(type) {\n      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n    };\n    MP4.mdat = function mdat(data) {\n      return MP4.box(MP4.types.mdat, data);\n    };\n    MP4.mdhd = function mdhd(timescale, duration) {\n      duration *= timescale;\n      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n      return MP4.box(MP4.types.mdhd, new Uint8Array([0x01,\n      // version 1\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n      // creation_time\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n      // modification_time\n      timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n      // timescale\n      upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4,\n      // 'und' language (undetermined)\n      0x00, 0x00]));\n    };\n    MP4.mdia = function mdia(track) {\n      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n    };\n    MP4.mfhd = function mfhd(sequenceNumber) {\n      return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n      // flags\n      sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n      ]));\n    };\n    MP4.minf = function minf(track) {\n      if (track.type === 'audio') {\n        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n      } else {\n        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n      }\n    };\n    MP4.moof = function moof(sn, baseMediaDecodeTime, track) {\n      return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n    };\n    MP4.moov = function moov(tracks) {\n      var i = tracks.length;\n      var boxes = [];\n      while (i--) {\n        boxes[i] = MP4.trak(tracks[i]);\n      }\n      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n    };\n    MP4.mvex = function mvex(tracks) {\n      var i = tracks.length;\n      var boxes = [];\n      while (i--) {\n        boxes[i] = MP4.trex(tracks[i]);\n      }\n      return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));\n    };\n    MP4.mvhd = function mvhd(timescale, duration) {\n      duration *= timescale;\n      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n      var bytes = new Uint8Array([0x01,\n      // version 1\n      0x00, 0x00, 0x00,\n      // flags\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n      // creation_time\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n      // modification_time\n      timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n      // timescale\n      upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00,\n      // 1.0 rate\n      0x01, 0x00,\n      // 1.0 volume\n      0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n      // transformation: unity matrix\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // pre_defined\n      0xff, 0xff, 0xff, 0xff // next_track_ID\n      ]);\n      return MP4.box(MP4.types.mvhd, bytes);\n    };\n    MP4.sdtp = function sdtp(track) {\n      var samples = track.samples || [];\n      var bytes = new Uint8Array(4 + samples.length);\n      var i;\n      var flags;\n      // leave the full box header (4 bytes) all zero\n      // write the sample table\n      for (i = 0; i < samples.length; i++) {\n        flags = samples[i].flags;\n        bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n      }\n      return MP4.box(MP4.types.sdtp, bytes);\n    };\n    MP4.stbl = function stbl(track) {\n      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n    };\n    MP4.avc1 = function avc1(track) {\n      var sps = [];\n      var pps = [];\n      var i;\n      var data;\n      var len;\n      // assemble the SPSs\n\n      for (i = 0; i < track.sps.length; i++) {\n        data = track.sps[i];\n        len = data.byteLength;\n        sps.push(len >>> 8 & 0xff);\n        sps.push(len & 0xff);\n\n        // SPS\n        sps = sps.concat(Array.prototype.slice.call(data));\n      }\n\n      // assemble the PPSs\n      for (i = 0; i < track.pps.length; i++) {\n        data = track.pps[i];\n        len = data.byteLength;\n        pps.push(len >>> 8 & 0xff);\n        pps.push(len & 0xff);\n        pps = pps.concat(Array.prototype.slice.call(data));\n      }\n      var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01,\n      // version\n      sps[3],\n      // profile\n      sps[4],\n      // profile compat\n      sps[5],\n      // level\n      0xfc | 3,\n      // lengthSizeMinusOne, hard-coded to 4 bytes\n      0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n      ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n      ]).concat(pps))); // \"PPS\"\n      var width = track.width;\n      var height = track.height;\n      var hSpacing = track.pixelRatio[0];\n      var vSpacing = track.pixelRatio[1];\n      return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x01,\n      // data_reference_index\n      0x00, 0x00,\n      // pre_defined\n      0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // pre_defined\n      width >> 8 & 0xff, width & 0xff,\n      // width\n      height >> 8 & 0xff, height & 0xff,\n      // height\n      0x00, 0x48, 0x00, 0x00,\n      // horizresolution\n      0x00, 0x48, 0x00, 0x00,\n      // vertresolution\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x01,\n      // frame_count\n      0x12, 0x64, 0x61, 0x69, 0x6c,\n      // dailymotion/hls.js\n      0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // compressorname\n      0x00, 0x18,\n      // depth = 24\n      0x11, 0x11]),\n      // pre_defined = -1\n      avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n      // bufferSizeDB\n      0x00, 0x2d, 0xc6, 0xc0,\n      // maxBitrate\n      0x00, 0x2d, 0xc6, 0xc0])),\n      // avgBitrate\n      MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n      // hSpacing\n      hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n      // vSpacing\n      vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n    };\n    MP4.esds = function esds(track) {\n      var configlen = track.config.length;\n      return new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n\n      0x03,\n      // descriptor_type\n      0x17 + configlen,\n      // length\n      0x00, 0x01,\n      // es_id\n      0x00,\n      // stream_priority\n\n      0x04,\n      // descriptor_type\n      0x0f + configlen,\n      // length\n      0x40,\n      // codec : mpeg4_audio\n      0x15,\n      // stream_type\n      0x00, 0x00, 0x00,\n      // buffer_size\n      0x00, 0x00, 0x00, 0x00,\n      // maxBitrate\n      0x00, 0x00, 0x00, 0x00,\n      // avgBitrate\n\n      0x05 // descriptor_type\n      ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n    };\n    MP4.audioStsd = function audioStsd(track) {\n      var samplerate = track.samplerate;\n      return new Uint8Array([0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x01,\n      // data_reference_index\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, track.channelCount,\n      // channelcount\n      0x00, 0x10,\n      // sampleSize:16bits\n      0x00, 0x00, 0x00, 0x00,\n      // reserved2\n      samplerate >> 8 & 0xff, samplerate & 0xff,\n      //\n      0x00, 0x00]);\n    };\n    MP4.mp4a = function mp4a(track) {\n      return MP4.box(MP4.types.mp4a, MP4.audioStsd(track), MP4.box(MP4.types.esds, MP4.esds(track)));\n    };\n    MP4.mp3 = function mp3(track) {\n      return MP4.box(MP4.types['.mp3'], MP4.audioStsd(track));\n    };\n    MP4.ac3 = function ac3(track) {\n      return MP4.box(MP4.types['ac-3'], MP4.audioStsd(track), MP4.box(MP4.types.dac3, track.config));\n    };\n    MP4.stsd = function stsd(track) {\n      if (track.type === 'audio') {\n        if (track.segmentCodec === 'mp3' && track.codec === 'mp3') {\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n        }\n        if (track.segmentCodec === 'ac3') {\n          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.ac3(track));\n        }\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n      } else {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n      }\n    };\n    MP4.tkhd = function tkhd(track) {\n      var id = track.id;\n      var duration = track.duration * track.timescale;\n      var width = track.width;\n      var height = track.height;\n      var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n      var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n      return MP4.box(MP4.types.tkhd, new Uint8Array([0x01,\n      // version 1\n      0x00, 0x00, 0x07,\n      // flags\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n      // creation_time\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n      // modification_time\n      id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n      // track_ID\n      0x00, 0x00, 0x00, 0x00,\n      // reserved\n      upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // reserved\n      0x00, 0x00,\n      // layer\n      0x00, 0x00,\n      // alternate_group\n      0x00, 0x00,\n      // non-audio track volume\n      0x00, 0x00,\n      // reserved\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n      // transformation: unity matrix\n      width >> 8 & 0xff, width & 0xff, 0x00, 0x00,\n      // width\n      height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n      ]));\n    };\n    MP4.traf = function traf(track, baseMediaDecodeTime) {\n      var sampleDependencyTable = MP4.sdtp(track);\n      var id = track.id;\n      var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n      var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n      return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n      ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01,\n      // version 1\n      0x00, 0x00, 0x00,\n      // flags\n      upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 +\n      // tfhd\n      20 +\n      // tfdt\n      8 +\n      // traf header\n      16 +\n      // mfhd\n      8 +\n      // moof header\n      8),\n      // mdat header\n      sampleDependencyTable);\n    }\n\n    /**\n     * Generate a track box.\n     * @param track a track definition\n     */;\n    MP4.trak = function trak(track) {\n      track.duration = track.duration || 0xffffffff;\n      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n    };\n    MP4.trex = function trex(track) {\n      var id = track.id;\n      return MP4.box(MP4.types.trex, new Uint8Array([0x00,\n      // version 0\n      0x00, 0x00, 0x00,\n      // flags\n      id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n      // track_ID\n      0x00, 0x00, 0x00, 0x01,\n      // default_sample_description_index\n      0x00, 0x00, 0x00, 0x00,\n      // default_sample_duration\n      0x00, 0x00, 0x00, 0x00,\n      // default_sample_size\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\n      ]));\n    };\n    MP4.trun = function trun(track, offset) {\n      var samples = track.samples || [];\n      var len = samples.length;\n      var arraylen = 12 + 16 * len;\n      var array = new Uint8Array(arraylen);\n      var i;\n      var sample;\n      var duration;\n      var size;\n      var flags;\n      var cts;\n      offset += 8 + arraylen;\n      array.set([track.type === 'video' ? 0x01 : 0x00,\n      // version 1 for video with signed-int sample_composition_time_offset\n      0x00, 0x0f, 0x01,\n      // flags\n      len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff,\n      // sample_count\n      offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n      ], 0);\n      for (i = 0; i < len; i++) {\n        sample = samples[i];\n        duration = sample.duration;\n        size = sample.size;\n        flags = sample.flags;\n        cts = sample.cts;\n        array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff,\n        // sample_duration\n        size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff,\n        // sample_size\n        flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f,\n        // sample_flags\n        cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n        ], 12 + 16 * i);\n      }\n      return MP4.box(MP4.types.trun, array);\n    };\n    MP4.initSegment = function initSegment(tracks) {\n      if (!MP4.types) {\n        MP4.init();\n      }\n      var movie = MP4.moov(tracks);\n      var result = appendUint8Array(MP4.FTYP, movie);\n      return result;\n    };\n    return MP4;\n  }();\n  MP4.types = void 0;\n  MP4.HDLR_TYPES = void 0;\n  MP4.STTS = void 0;\n  MP4.STSC = void 0;\n  MP4.STCO = void 0;\n  MP4.STSZ = void 0;\n  MP4.VMHD = void 0;\n  MP4.SMHD = void 0;\n  MP4.STSD = void 0;\n  MP4.FTYP = void 0;\n  MP4.DINF = void 0;\n\n  var MPEG_TS_CLOCK_FREQ_HZ = 90000;\n  function toTimescaleFromBase(baseTime, destScale, srcBase, round) {\n    if (srcBase === void 0) {\n      srcBase = 1;\n    }\n    if (round === void 0) {\n      round = false;\n    }\n    var result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n    return round ? Math.round(result) : result;\n  }\n  function toTimescaleFromScale(baseTime, destScale, srcScale, round) {\n    if (srcScale === void 0) {\n      srcScale = 1;\n    }\n    if (round === void 0) {\n      round = false;\n    }\n    return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);\n  }\n  function toMsFromMpegTsClock(baseTime, round) {\n    if (round === void 0) {\n      round = false;\n    }\n    return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n  }\n  function toMpegTsClockFromTimescale(baseTime, srcScale) {\n    if (srcScale === void 0) {\n      srcScale = 1;\n    }\n    return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n  }\n\n  var MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\n  var AAC_SAMPLES_PER_FRAME = 1024;\n  var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\n  var AC3_SAMPLES_PER_FRAME = 1536;\n  var chromeVersion = null;\n  var safariWebkitVersion = null;\n  var MP4Remuxer = /*#__PURE__*/function () {\n    function MP4Remuxer(observer, config, typeSupported, vendor) {\n      this.observer = void 0;\n      this.config = void 0;\n      this.typeSupported = void 0;\n      this.ISGenerated = false;\n      this._initPTS = null;\n      this._initDTS = null;\n      this.nextAvcDts = null;\n      this.nextAudioPts = null;\n      this.videoSampleDuration = null;\n      this.isAudioContiguous = false;\n      this.isVideoContiguous = false;\n      this.videoTrackConfig = void 0;\n      this.observer = observer;\n      this.config = config;\n      this.typeSupported = typeSupported;\n      this.ISGenerated = false;\n      if (chromeVersion === null) {\n        var userAgent = navigator.userAgent || '';\n        var result = userAgent.match(/Chrome\\/(\\d+)/i);\n        chromeVersion = result ? parseInt(result[1]) : 0;\n      }\n      if (safariWebkitVersion === null) {\n        var _result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n        safariWebkitVersion = _result ? parseInt(_result[1]) : 0;\n      }\n    }\n    var _proto = MP4Remuxer.prototype;\n    _proto.destroy = function destroy() {\n      // @ts-ignore\n      this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;\n    };\n    _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {\n      logger.log('[mp4-remuxer]: initPTS & initDTS reset');\n      this._initPTS = this._initDTS = defaultTimeStamp;\n    };\n    _proto.resetNextTimestamp = function resetNextTimestamp() {\n      logger.log('[mp4-remuxer]: reset next timestamp');\n      this.isVideoContiguous = false;\n      this.isAudioContiguous = false;\n    };\n    _proto.resetInitSegment = function resetInitSegment() {\n      logger.log('[mp4-remuxer]: ISGenerated flag reset');\n      this.ISGenerated = false;\n      this.videoTrackConfig = undefined;\n    };\n    _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {\n      var rolloverDetected = false;\n      var startPTS = videoSamples.reduce(function (minPTS, sample) {\n        var delta = sample.pts - minPTS;\n        if (delta < -4294967296) {\n          // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n          rolloverDetected = true;\n          return normalizePts(minPTS, sample.pts);\n        } else if (delta > 0) {\n          return minPTS;\n        } else {\n          return sample.pts;\n        }\n      }, videoSamples[0].pts);\n      if (rolloverDetected) {\n        logger.debug('PTS rollover detected');\n      }\n      return startPTS;\n    };\n    _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n      var video;\n      var audio;\n      var initSegment;\n      var text;\n      var id3;\n      var independent;\n      var audioTimeOffset = timeOffset;\n      var videoTimeOffset = timeOffset;\n\n      // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n      // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n      // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n      // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n      // then we can remux one track without waiting for the other.\n      var hasAudio = audioTrack.pid > -1;\n      var hasVideo = videoTrack.pid > -1;\n      var length = videoTrack.samples.length;\n      var enoughAudioSamples = audioTrack.samples.length > 0;\n      var enoughVideoSamples = flush && length > 0 || length > 1;\n      var canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n      if (canRemuxAvc) {\n        if (this.ISGenerated) {\n          var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;\n          var config = this.videoTrackConfig;\n          if (config && (videoTrack.width !== config.width || videoTrack.height !== config.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config.pixelRatio) == null ? void 0 : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config.pixelRatio) == null ? void 0 : _config$pixelRatio2[1]))) {\n            this.resetInitSegment();\n          }\n        } else {\n          initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n        }\n        var isVideoContiguous = this.isVideoContiguous;\n        var firstKeyFrameIndex = -1;\n        var firstKeyFramePTS;\n        if (enoughVideoSamples) {\n          firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n          if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n            independent = true;\n            if (firstKeyFrameIndex > 0) {\n              logger.warn(\"[mp4-remuxer]: Dropped \" + firstKeyFrameIndex + \" out of \" + length + \" video samples due to a missing keyframe\");\n              var startPTS = this.getVideoStartPts(videoTrack.samples);\n              videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n              videoTrack.dropped += firstKeyFrameIndex;\n              videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n              firstKeyFramePTS = videoTimeOffset;\n            } else if (firstKeyFrameIndex === -1) {\n              logger.warn(\"[mp4-remuxer]: No keyframe found out of \" + length + \" video samples\");\n              independent = false;\n            }\n          }\n        }\n        if (this.ISGenerated) {\n          if (enoughAudioSamples && enoughVideoSamples) {\n            // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n            // if first audio DTS is not aligned with first video DTS then we need to take that into account\n            // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n            // drift between audio and video streams\n            var _startPTS = this.getVideoStartPts(videoTrack.samples);\n            var tsDelta = normalizePts(audioTrack.samples[0].pts, _startPTS) - _startPTS;\n            var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n            audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n            videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n          }\n\n          // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n          if (enoughAudioSamples) {\n            // if initSegment was generated without audio samples, regenerate it again\n            if (!audioTrack.samplerate) {\n              logger.warn('[mp4-remuxer]: regenerate InitSegment as audio detected');\n              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n            }\n            audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);\n            if (enoughVideoSamples) {\n              var audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n              // if initSegment was generated without video samples, regenerate it again\n              if (!videoTrack.inputTimeScale) {\n                logger.warn('[mp4-remuxer]: regenerate InitSegment as video detected');\n                initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n              }\n              video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n            }\n          } else if (enoughVideoSamples) {\n            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n          }\n          if (video) {\n            video.firstKeyFrame = firstKeyFrameIndex;\n            video.independent = firstKeyFrameIndex !== -1;\n            video.firstKeyFramePTS = firstKeyFramePTS;\n          }\n        }\n      }\n\n      // Allow ID3 and text to remux, even if more audio/video samples are required\n      if (this.ISGenerated && this._initPTS && this._initDTS) {\n        if (id3Track.samples.length) {\n          id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n        }\n        if (textTrack.samples.length) {\n          text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n        }\n      }\n      return {\n        audio: audio,\n        video: video,\n        initSegment: initSegment,\n        independent: independent,\n        text: text,\n        id3: id3\n      };\n    };\n    _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {\n      var audioSamples = audioTrack.samples;\n      var videoSamples = videoTrack.samples;\n      var typeSupported = this.typeSupported;\n      var tracks = {};\n      var _initPTS = this._initPTS;\n      var computePTSDTS = !_initPTS || accurateTimeOffset;\n      var container = 'audio/mp4';\n      var initPTS;\n      var initDTS;\n      var timescale;\n      if (computePTSDTS) {\n        initPTS = initDTS = Infinity;\n      }\n      if (audioTrack.config && audioSamples.length) {\n        // let's use audio sampling rate as MP4 time scale.\n        // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n        // using audio sampling rate here helps having an integer MP4 frame duration\n        // this avoids potential rounding issue and AV sync issue\n        audioTrack.timescale = audioTrack.samplerate;\n        switch (audioTrack.segmentCodec) {\n          case 'mp3':\n            if (typeSupported.mpeg) {\n              // Chrome and Safari\n              container = 'audio/mpeg';\n              audioTrack.codec = '';\n            } else if (typeSupported.mp3) {\n              // Firefox\n              audioTrack.codec = 'mp3';\n            }\n            break;\n          case 'ac3':\n            audioTrack.codec = 'ac-3';\n            break;\n        }\n        tracks.audio = {\n          id: 'audio',\n          container: container,\n          codec: audioTrack.codec,\n          initSegment: audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),\n          metadata: {\n            channelCount: audioTrack.channelCount\n          }\n        };\n        if (computePTSDTS) {\n          timescale = audioTrack.inputTimeScale;\n          if (!_initPTS || timescale !== _initPTS.timescale) {\n            // remember first PTS of this demuxing context. for audio, PTS = DTS\n            initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n          } else {\n            computePTSDTS = false;\n          }\n        }\n      }\n      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n        // let's use input time scale as MP4 video timescale\n        // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n        videoTrack.timescale = videoTrack.inputTimeScale;\n        tracks.video = {\n          id: 'main',\n          container: 'video/mp4',\n          codec: videoTrack.codec,\n          initSegment: MP4.initSegment([videoTrack]),\n          metadata: {\n            width: videoTrack.width,\n            height: videoTrack.height\n          }\n        };\n        if (computePTSDTS) {\n          timescale = videoTrack.inputTimeScale;\n          if (!_initPTS || timescale !== _initPTS.timescale) {\n            var startPTS = this.getVideoStartPts(videoSamples);\n            var startOffset = Math.round(timescale * timeOffset);\n            initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n            initPTS = Math.min(initPTS, startPTS - startOffset);\n          } else {\n            computePTSDTS = false;\n          }\n        }\n        this.videoTrackConfig = {\n          width: videoTrack.width,\n          height: videoTrack.height,\n          pixelRatio: videoTrack.pixelRatio\n        };\n      }\n      if (Object.keys(tracks).length) {\n        this.ISGenerated = true;\n        if (computePTSDTS) {\n          this._initPTS = {\n            baseTime: initPTS,\n            timescale: timescale\n          };\n          this._initDTS = {\n            baseTime: initDTS,\n            timescale: timescale\n          };\n        } else {\n          initPTS = timescale = undefined;\n        }\n        return {\n          tracks: tracks,\n          initPTS: initPTS,\n          timescale: timescale\n        };\n      }\n    };\n    _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n      var timeScale = track.inputTimeScale;\n      var inputSamples = track.samples;\n      var outputSamples = [];\n      var nbSamples = inputSamples.length;\n      var initPTS = this._initPTS;\n      var nextAvcDts = this.nextAvcDts;\n      var offset = 8;\n      var mp4SampleDuration = this.videoSampleDuration;\n      var firstDTS;\n      var lastDTS;\n      var minPTS = Number.POSITIVE_INFINITY;\n      var maxPTS = Number.NEGATIVE_INFINITY;\n      var sortSamples = false;\n\n      // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n      if (!contiguous || nextAvcDts === null) {\n        var pts = timeOffset * timeScale;\n        var cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n        if (chromeVersion && nextAvcDts !== null && Math.abs(pts - cts - nextAvcDts) < 15000) {\n          // treat as contigous to adjust samples that would otherwise produce video buffer gaps in Chrome\n          contiguous = true;\n        } else {\n          // if not contiguous, let's use target timeOffset\n          nextAvcDts = pts - cts;\n        }\n      }\n\n      // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n      // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n      var initTime = initPTS.baseTime * timeScale / initPTS.timescale;\n      for (var i = 0; i < nbSamples; i++) {\n        var sample = inputSamples[i];\n        sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);\n        sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);\n        if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n          sortSamples = true;\n        }\n      }\n\n      // sort video samples by DTS then PTS then demux id order\n      if (sortSamples) {\n        inputSamples.sort(function (a, b) {\n          var deltadts = a.dts - b.dts;\n          var deltapts = a.pts - b.pts;\n          return deltadts || deltapts;\n        });\n      }\n\n      // Get first/last DTS\n      firstDTS = inputSamples[0].dts;\n      lastDTS = inputSamples[inputSamples.length - 1].dts;\n\n      // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n      // set this constant duration as being the avg delta between consecutive DTS.\n      var inputDuration = lastDTS - firstDTS;\n      var averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;\n\n      // if fragment are contiguous, detect hole/overlapping between fragments\n      if (contiguous) {\n        // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n        var delta = firstDTS - nextAvcDts;\n        var foundHole = delta > averageSampleDuration;\n        var foundOverlap = delta < -1;\n        if (foundHole || foundOverlap) {\n          if (foundHole) {\n            logger.warn(\"AVC: \" + toMsFromMpegTsClock(delta, true) + \" ms (\" + delta + \"dts) hole between fragments detected at \" + timeOffset.toFixed(3));\n          } else {\n            logger.warn(\"AVC: \" + toMsFromMpegTsClock(-delta, true) + \" ms (\" + delta + \"dts) overlapping between fragments detected at \" + timeOffset.toFixed(3));\n          }\n          if (!foundOverlap || nextAvcDts >= inputSamples[0].pts || chromeVersion) {\n            firstDTS = nextAvcDts;\n            var firstPTS = inputSamples[0].pts - delta;\n            if (foundHole) {\n              inputSamples[0].dts = firstDTS;\n              inputSamples[0].pts = firstPTS;\n            } else {\n              for (var _i = 0; _i < inputSamples.length; _i++) {\n                if (inputSamples[_i].dts > firstPTS) {\n                  break;\n                }\n                inputSamples[_i].dts -= delta;\n                inputSamples[_i].pts -= delta;\n              }\n            }\n            logger.log(\"Video: Initial PTS/DTS adjusted: \" + toMsFromMpegTsClock(firstPTS, true) + \"/\" + toMsFromMpegTsClock(firstDTS, true) + \", delta: \" + toMsFromMpegTsClock(delta, true) + \" ms\");\n          }\n        }\n      }\n      firstDTS = Math.max(0, firstDTS);\n      var nbNalu = 0;\n      var naluLen = 0;\n      var dtsStep = firstDTS;\n      for (var _i2 = 0; _i2 < nbSamples; _i2++) {\n        // compute total/avc sample length and nb of NAL units\n        var _sample = inputSamples[_i2];\n        var units = _sample.units;\n        var nbUnits = units.length;\n        var sampleLen = 0;\n        for (var j = 0; j < nbUnits; j++) {\n          sampleLen += units[j].data.length;\n        }\n        naluLen += sampleLen;\n        nbNalu += nbUnits;\n        _sample.length = sampleLen;\n\n        // ensure sample monotonic DTS\n        if (_sample.dts < dtsStep) {\n          _sample.dts = dtsStep;\n          dtsStep += averageSampleDuration / 4 | 0 || 1;\n        } else {\n          dtsStep = _sample.dts;\n        }\n        minPTS = Math.min(_sample.pts, minPTS);\n        maxPTS = Math.max(_sample.pts, maxPTS);\n      }\n      lastDTS = inputSamples[nbSamples - 1].dts;\n\n      /* concatenate the video data and construct the mdat in place\n        (need 8 more bytes to fill length and mpdat type) */\n      var mdatSize = naluLen + 4 * nbNalu + 8;\n      var mdat;\n      try {\n        mdat = new Uint8Array(mdatSize);\n      } catch (err) {\n        this.observer.emit(Events.ERROR, Events.ERROR, {\n          type: ErrorTypes.MUX_ERROR,\n          details: ErrorDetails.REMUX_ALLOC_ERROR,\n          fatal: false,\n          error: err,\n          bytes: mdatSize,\n          reason: \"fail allocating video mdat \" + mdatSize\n        });\n        return;\n      }\n      var view = new DataView(mdat.buffer);\n      view.setUint32(0, mdatSize);\n      mdat.set(MP4.types.mdat, 4);\n      var stretchedLastFrame = false;\n      var minDtsDelta = Number.POSITIVE_INFINITY;\n      var minPtsDelta = Number.POSITIVE_INFINITY;\n      var maxDtsDelta = Number.NEGATIVE_INFINITY;\n      var maxPtsDelta = Number.NEGATIVE_INFINITY;\n      for (var _i3 = 0; _i3 < nbSamples; _i3++) {\n        var _VideoSample = inputSamples[_i3];\n        var VideoSampleUnits = _VideoSample.units;\n        var mp4SampleLength = 0;\n        // convert NALU bitstream to MP4 format (prepend NALU with size field)\n        for (var _j = 0, _nbUnits = VideoSampleUnits.length; _j < _nbUnits; _j++) {\n          var unit = VideoSampleUnits[_j];\n          var unitData = unit.data;\n          var unitDataLen = unit.data.byteLength;\n          view.setUint32(offset, unitDataLen);\n          offset += 4;\n          mdat.set(unitData, offset);\n          offset += unitDataLen;\n          mp4SampleLength += 4 + unitDataLen;\n        }\n\n        // expected sample duration is the Decoding Timestamp diff of consecutive samples\n        var ptsDelta = void 0;\n        if (_i3 < nbSamples - 1) {\n          mp4SampleDuration = inputSamples[_i3 + 1].dts - _VideoSample.dts;\n          ptsDelta = inputSamples[_i3 + 1].pts - _VideoSample.pts;\n        } else {\n          var config = this.config;\n          var lastFrameDuration = _i3 > 0 ? _VideoSample.dts - inputSamples[_i3 - 1].dts : averageSampleDuration;\n          ptsDelta = _i3 > 0 ? _VideoSample.pts - inputSamples[_i3 - 1].pts : averageSampleDuration;\n          if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\n            // In some cases, a segment's audio track duration may exceed the video track duration.\n            // Since we've already remuxed audio, and we know how long the audio track is, we look to\n            // see if the delta to the next segment is longer than maxBufferHole.\n            // If so, playback would potentially get stuck, so we artificially inflate\n            // the duration of the last frame to minimize any potential gap between segments.\n            var gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n            var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - _VideoSample.pts;\n            if (deltaToFrameEnd > gapTolerance) {\n              // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n              // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n              mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n              if (mp4SampleDuration < 0) {\n                mp4SampleDuration = lastFrameDuration;\n              } else {\n                stretchedLastFrame = true;\n              }\n              logger.log(\"[mp4-remuxer]: It is approximately \" + deltaToFrameEnd / 90 + \" ms to the next segment; using duration \" + mp4SampleDuration / 90 + \" ms for the last video frame.\");\n            } else {\n              mp4SampleDuration = lastFrameDuration;\n            }\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        }\n        var compositionTimeOffset = Math.round(_VideoSample.pts - _VideoSample.dts);\n        minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n        maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n        minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n        maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n        outputSamples.push(new Mp4Sample(_VideoSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n      }\n      if (outputSamples.length) {\n        if (chromeVersion) {\n          if (chromeVersion < 70) {\n            // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n            // https://code.google.com/p/chromium/issues/detail?id=229412\n            var flags = outputSamples[0].flags;\n            flags.dependsOn = 2;\n            flags.isNonSync = 0;\n          }\n        } else if (safariWebkitVersion) {\n          // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n          // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n          if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {\n            logger.warn('Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.');\n            var dts = firstDTS;\n            for (var _i4 = 0, len = outputSamples.length; _i4 < len; _i4++) {\n              var nextDts = dts + outputSamples[_i4].duration;\n              var _pts = dts + outputSamples[_i4].cts;\n              if (_i4 < len - 1) {\n                var nextPts = nextDts + outputSamples[_i4 + 1].cts;\n                outputSamples[_i4].duration = nextPts - _pts;\n              } else {\n                outputSamples[_i4].duration = _i4 ? outputSamples[_i4 - 1].duration : averageSampleDuration;\n              }\n              outputSamples[_i4].cts = 0;\n              dts = nextDts;\n            }\n          }\n        }\n      }\n      // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n      mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n      this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\n      this.videoSampleDuration = mp4SampleDuration;\n      this.isVideoContiguous = true;\n      var moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends({}, track, {\n        samples: outputSamples\n      }));\n      var type = 'video';\n      var data = {\n        data1: moof,\n        data2: mdat,\n        startPTS: minPTS / timeScale,\n        endPTS: (maxPTS + mp4SampleDuration) / timeScale,\n        startDTS: firstDTS / timeScale,\n        endDTS: nextAvcDts / timeScale,\n        type: type,\n        hasAudio: false,\n        hasVideo: true,\n        nb: outputSamples.length,\n        dropped: track.dropped\n      };\n      track.samples = [];\n      track.dropped = 0;\n      return data;\n    };\n    _proto.getSamplesPerFrame = function getSamplesPerFrame(track) {\n      switch (track.segmentCodec) {\n        case 'mp3':\n          return MPEG_AUDIO_SAMPLE_PER_FRAME;\n        case 'ac3':\n          return AC3_SAMPLES_PER_FRAME;\n        default:\n          return AAC_SAMPLES_PER_FRAME;\n      }\n    };\n    _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n      var inputTimeScale = track.inputTimeScale;\n      var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n      var scaleFactor = inputTimeScale / mp4timeScale;\n      var mp4SampleDuration = this.getSamplesPerFrame(track);\n      var inputSampleDuration = mp4SampleDuration * scaleFactor;\n      var initPTS = this._initPTS;\n      var rawMPEG = track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n      var outputSamples = [];\n      var alignedWithVideo = videoTimeOffset !== undefined;\n      var inputSamples = track.samples;\n      var offset = rawMPEG ? 0 : 8;\n      var nextAudioPts = this.nextAudioPts || -1;\n\n      // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n\n      // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n      // for sake of clarity:\n      // consecutive fragments are frags with\n      //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n      //  - less than 20 audio frames distance\n      // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n      // this helps ensuring audio continuity\n      // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n      var timeOffsetMpegTS = timeOffset * inputTimeScale;\n      var initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;\n      this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);\n\n      // compute normalized PTS\n      inputSamples.forEach(function (sample) {\n        sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);\n      });\n      if (!contiguous || nextAudioPts < 0) {\n        // filter out sample with negative PTS that are not playable anyway\n        // if we don't remove these negative samples, they will shift all audio samples forward.\n        // leading to audio overlap between current / next fragment\n        inputSamples = inputSamples.filter(function (sample) {\n          return sample.pts >= 0;\n        });\n\n        // in case all samples have negative PTS, and have been filtered out, return now\n        if (!inputSamples.length) {\n          return;\n        }\n        if (videoTimeOffset === 0) {\n          // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\n          nextAudioPts = 0;\n        } else if (accurateTimeOffset && !alignedWithVideo) {\n          // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n          nextAudioPts = Math.max(0, timeOffsetMpegTS);\n        } else {\n          // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n          nextAudioPts = inputSamples[0].pts;\n        }\n      }\n\n      // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n      // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n      // In an effort to prevent this from happening, we inject frames here where there are gaps.\n      // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n      // frame.\n\n      if (track.segmentCodec === 'aac') {\n        var maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n        for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {\n          // First, let's see how far off this frame is from where we expect it to be\n          var sample = inputSamples[i];\n          var pts = sample.pts;\n          var delta = pts - nextPts;\n          var duration = Math.abs(1000 * delta / inputTimeScale);\n\n          // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n          if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n            if (i === 0) {\n              logger.warn(\"Audio frame @ \" + (pts / inputTimeScale).toFixed(3) + \"s overlaps nextAudioPts by \" + Math.round(1000 * delta / inputTimeScale) + \" ms.\");\n              this.nextAudioPts = nextAudioPts = nextPts = pts;\n            }\n          } // eslint-disable-line brace-style\n\n          // Insert missing frames if:\n          // 1: We're more than maxAudioFramesDrift frame away\n          // 2: Not more than MAX_SILENT_FRAME_DURATION away\n          // 3: currentTime (aka nextPtsNorm) is not 0\n          // 4: remuxing with video (videoTimeOffset !== undefined)\n          else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n            var missing = Math.round(delta / inputSampleDuration);\n            // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n            // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n            nextPts = pts - missing * inputSampleDuration;\n            if (nextPts < 0) {\n              missing--;\n              nextPts += inputSampleDuration;\n            }\n            if (i === 0) {\n              this.nextAudioPts = nextAudioPts = nextPts;\n            }\n            logger.warn(\"[mp4-remuxer]: Injecting \" + missing + \" audio frame @ \" + (nextPts / inputTimeScale).toFixed(3) + \"s due to \" + Math.round(1000 * delta / inputTimeScale) + \" ms gap.\");\n            for (var j = 0; j < missing; j++) {\n              var newStamp = Math.max(nextPts, 0);\n              var fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n              if (!fillFrame) {\n                logger.log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.');\n                fillFrame = sample.unit.subarray();\n              }\n              inputSamples.splice(i, 0, {\n                unit: fillFrame,\n                pts: newStamp\n              });\n              nextPts += inputSampleDuration;\n              i++;\n            }\n          }\n          sample.pts = nextPts;\n          nextPts += inputSampleDuration;\n        }\n      }\n      var firstPTS = null;\n      var lastPTS = null;\n      var mdat;\n      var mdatSize = 0;\n      var sampleLength = inputSamples.length;\n      while (sampleLength--) {\n        mdatSize += inputSamples[sampleLength].unit.byteLength;\n      }\n      for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {\n        var audioSample = inputSamples[_j2];\n        var unit = audioSample.unit;\n        var _pts2 = audioSample.pts;\n        if (lastPTS !== null) {\n          // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n          // the previous sample\n          var prevSample = outputSamples[_j2 - 1];\n          prevSample.duration = Math.round((_pts2 - lastPTS) / scaleFactor);\n        } else {\n          if (contiguous && track.segmentCodec === 'aac') {\n            // set PTS/DTS to expected PTS/DTS\n            _pts2 = nextAudioPts;\n          }\n          // remember first PTS of our audioSamples\n          firstPTS = _pts2;\n          if (mdatSize > 0) {\n            /* concatenate the audio data and construct the mdat in place\n              (need 8 more bytes to fill length and mdat type) */\n            mdatSize += offset;\n            try {\n              mdat = new Uint8Array(mdatSize);\n            } catch (err) {\n              this.observer.emit(Events.ERROR, Events.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.REMUX_ALLOC_ERROR,\n                fatal: false,\n                error: err,\n                bytes: mdatSize,\n                reason: \"fail allocating audio mdat \" + mdatSize\n              });\n              return;\n            }\n            if (!rawMPEG) {\n              var view = new DataView(mdat.buffer);\n              view.setUint32(0, mdatSize);\n              mdat.set(MP4.types.mdat, 4);\n            }\n          } else {\n            // no audio samples\n            return;\n          }\n        }\n        mdat.set(unit, offset);\n        var unitLen = unit.byteLength;\n        offset += unitLen;\n        // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n        // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n        // becomes the PTS diff with the previous sample\n        outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\n        lastPTS = _pts2;\n      }\n\n      // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n      var nbSamples = outputSamples.length;\n      if (!nbSamples) {\n        return;\n      }\n\n      // The next audio sample PTS should be equal to last sample PTS + duration\n      var lastSample = outputSamples[outputSamples.length - 1];\n      this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;\n\n      // Set the track samples from inputSamples to outputSamples before remuxing\n      var moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n        samples: outputSamples\n      }));\n\n      // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n      track.samples = [];\n      var start = firstPTS / inputTimeScale;\n      var end = nextAudioPts / inputTimeScale;\n      var type = 'audio';\n      var audioData = {\n        data1: moof,\n        data2: mdat,\n        startPTS: start,\n        endPTS: end,\n        startDTS: start,\n        endDTS: end,\n        type: type,\n        hasAudio: true,\n        hasVideo: false,\n        nb: nbSamples\n      };\n      this.isAudioContiguous = true;\n      return audioData;\n    };\n    _proto.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n      var inputTimeScale = track.inputTimeScale;\n      var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n      var scaleFactor = inputTimeScale / mp4timeScale;\n      var nextAudioPts = this.nextAudioPts;\n      // sync with video's timestamp\n      var initDTS = this._initDTS;\n      var init90kHz = initDTS.baseTime * 90000 / initDTS.timescale;\n      var startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;\n      var endDTS = videoData.endDTS * inputTimeScale + init90kHz;\n      // one sample's duration value\n      var frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;\n      // samples count of this segment's duration\n      var nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);\n      // silent frame\n      var silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n      logger.warn('[mp4-remuxer]: remux empty Audio');\n      // Can't remux if we can't generate a silent frame...\n      if (!silentFrame) {\n        logger.trace('[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec');\n        return;\n      }\n      var samples = [];\n      for (var i = 0; i < nbSamples; i++) {\n        var stamp = startDTS + i * frameDuration;\n        samples.push({\n          unit: silentFrame,\n          pts: stamp,\n          dts: stamp\n        });\n      }\n      track.samples = samples;\n      return this.remuxAudio(track, timeOffset, contiguous, false);\n    };\n    return MP4Remuxer;\n  }();\n  function normalizePts(value, reference) {\n    var offset;\n    if (reference === null) {\n      return value;\n    }\n    if (reference < value) {\n      // - 2^33\n      offset = -8589934592;\n    } else {\n      // + 2^33\n      offset = 8589934592;\n    }\n    /* PTS is 33bit (from 0 to 2^33 -1)\n      if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n      PTS looping occured. fill the gap */\n    while (Math.abs(value - reference) > 4294967296) {\n      value += offset;\n    }\n    return value;\n  }\n  function findKeyframeIndex(samples) {\n    for (var i = 0; i < samples.length; i++) {\n      if (samples[i].key) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n    var length = track.samples.length;\n    if (!length) {\n      return;\n    }\n    var inputTimeScale = track.inputTimeScale;\n    for (var index = 0; index < length; index++) {\n      var sample = track.samples[index];\n      // setting id3 pts, dts to relative time\n      // using this._initPTS and this._initDTS to calculate relative time\n      sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n      sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    }\n    var samples = track.samples;\n    track.samples = [];\n    return {\n      samples: samples\n    };\n  }\n  function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n    var length = track.samples.length;\n    if (!length) {\n      return;\n    }\n    var inputTimeScale = track.inputTimeScale;\n    for (var index = 0; index < length; index++) {\n      var sample = track.samples[index];\n      // setting text pts, dts to relative time\n      // using this._initPTS and this._initDTS to calculate relative time\n      sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    }\n    track.samples.sort(function (a, b) {\n      return a.pts - b.pts;\n    });\n    var samples = track.samples;\n    track.samples = [];\n    return {\n      samples: samples\n    };\n  }\n  var Mp4Sample = function Mp4Sample(isKeyframe, duration, size, cts) {\n    this.size = void 0;\n    this.duration = void 0;\n    this.cts = void 0;\n    this.flags = void 0;\n    this.duration = duration;\n    this.size = size;\n    this.cts = cts;\n    this.flags = {\n      isLeading: 0,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradPrio: 0,\n      dependsOn: isKeyframe ? 2 : 1,\n      isNonSync: isKeyframe ? 0 : 1\n    };\n  };\n\n  var PassThroughRemuxer = /*#__PURE__*/function () {\n    function PassThroughRemuxer() {\n      this.emitInitSegment = false;\n      this.audioCodec = void 0;\n      this.videoCodec = void 0;\n      this.initData = void 0;\n      this.initPTS = null;\n      this.initTracks = void 0;\n      this.lastEndTime = null;\n    }\n    var _proto = PassThroughRemuxer.prototype;\n    _proto.destroy = function destroy() {};\n    _proto.resetTimeStamp = function resetTimeStamp(defaultInitPTS) {\n      this.initPTS = defaultInitPTS;\n      this.lastEndTime = null;\n    };\n    _proto.resetNextTimestamp = function resetNextTimestamp() {\n      this.lastEndTime = null;\n    };\n    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {\n      this.audioCodec = audioCodec;\n      this.videoCodec = videoCodec;\n      this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));\n      this.emitInitSegment = true;\n    };\n    _proto.generateInitSegment = function generateInitSegment(initSegment) {\n      var audioCodec = this.audioCodec,\n        videoCodec = this.videoCodec;\n      if (!(initSegment != null && initSegment.byteLength)) {\n        this.initTracks = undefined;\n        this.initData = undefined;\n        return;\n      }\n      var initData = this.initData = parseInitSegment(initSegment);\n\n      // Get codec from initSegment or fallback to default\n      if (initData.audio) {\n        audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);\n      }\n      if (initData.video) {\n        videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);\n      }\n      var tracks = {};\n      if (initData.audio && initData.video) {\n        tracks.audiovideo = {\n          container: 'video/mp4',\n          codec: audioCodec + ',' + videoCodec,\n          initSegment: initSegment,\n          id: 'main'\n        };\n      } else if (initData.audio) {\n        tracks.audio = {\n          container: 'audio/mp4',\n          codec: audioCodec,\n          initSegment: initSegment,\n          id: 'audio'\n        };\n      } else if (initData.video) {\n        tracks.video = {\n          container: 'video/mp4',\n          codec: videoCodec,\n          initSegment: initSegment,\n          id: 'main'\n        };\n      } else {\n        logger.warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.');\n      }\n      this.initTracks = tracks;\n    };\n    _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {\n      var _initData, _initData2;\n      var initPTS = this.initPTS,\n        lastEndTime = this.lastEndTime;\n      var result = {\n        audio: undefined,\n        video: undefined,\n        text: textTrack,\n        id3: id3Track,\n        initSegment: undefined\n      };\n\n      // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n      // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n      // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n      if (!isFiniteNumber(lastEndTime)) {\n        lastEndTime = this.lastEndTime = timeOffset || 0;\n      }\n\n      // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n      // audio or video (or both); adding it to video was an arbitrary choice.\n      var data = videoTrack.samples;\n      if (!(data != null && data.length)) {\n        return result;\n      }\n      var initSegment = {\n        initPTS: undefined,\n        timescale: 1\n      };\n      var initData = this.initData;\n      if (!((_initData = initData) != null && _initData.length)) {\n        this.generateInitSegment(data);\n        initData = this.initData;\n      }\n      if (!((_initData2 = initData) != null && _initData2.length)) {\n        // We can't remux if the initSegment could not be generated\n        logger.warn('[passthrough-remuxer.ts]: Failed to generate initSegment.');\n        return result;\n      }\n      if (this.emitInitSegment) {\n        initSegment.tracks = this.initTracks;\n        this.emitInitSegment = false;\n      }\n      var duration = getDuration(data, initData);\n      var startDTS = getStartDTS(initData, data);\n      var decodeTime = startDTS === null ? timeOffset : startDTS;\n      if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {\n        initSegment.initPTS = decodeTime - timeOffset;\n        if (initPTS && initPTS.timescale === 1) {\n          logger.warn(\"Adjusting initPTS by \" + (initSegment.initPTS - initPTS.baseTime));\n        }\n        this.initPTS = initPTS = {\n          baseTime: initSegment.initPTS,\n          timescale: 1\n        };\n      }\n      var startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;\n      var endTime = startTime + duration;\n      offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);\n      if (duration > 0) {\n        this.lastEndTime = endTime;\n      } else {\n        logger.warn('Duration parsed from mp4 should be greater than zero');\n        this.resetNextTimestamp();\n      }\n      var hasAudio = !!initData.audio;\n      var hasVideo = !!initData.video;\n      var type = '';\n      if (hasAudio) {\n        type += 'audio';\n      }\n      if (hasVideo) {\n        type += 'video';\n      }\n      var track = {\n        data1: data,\n        startPTS: startTime,\n        startDTS: startTime,\n        endPTS: endTime,\n        endDTS: endTime,\n        type: type,\n        hasAudio: hasAudio,\n        hasVideo: hasVideo,\n        nb: 1,\n        dropped: 0\n      };\n      result.audio = track.type === 'audio' ? track : undefined;\n      result.video = track.type !== 'audio' ? track : undefined;\n      result.initSegment = initSegment;\n      result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);\n      if (textTrack.samples.length) {\n        result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);\n      }\n      return result;\n    };\n    return PassThroughRemuxer;\n  }();\n  function isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {\n    if (initPTS === null) {\n      return true;\n    }\n    // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\n    var minDuration = Math.max(duration, 1);\n    var startTime = startDTS - initPTS.baseTime / initPTS.timescale;\n    return Math.abs(startTime - timeOffset) > minDuration;\n  }\n  function getParsedTrackCodec(track, type) {\n    var parsedCodec = track == null ? void 0 : track.codec;\n    if (parsedCodec && parsedCodec.length > 4) {\n      return parsedCodec;\n    }\n    if (type === ElementaryStreamTypes.AUDIO) {\n      if (parsedCodec === 'ec-3' || parsedCodec === 'ac-3' || parsedCodec === 'alac') {\n        return parsedCodec;\n      }\n      if (parsedCodec === 'fLaC' || parsedCodec === 'Opus') {\n        // Opting not to get `preferManagedMediaSource` from player config for isSupported() check for simplicity\n        var preferManagedMediaSource = false;\n        return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);\n      }\n      var result = 'mp4a.40.5';\n      logger.info(\"Parsed audio codec \\\"\" + parsedCodec + \"\\\" or audio object type not handled. Using \\\"\" + result + \"\\\"\");\n      return result;\n    }\n    // Provide defaults based on codec type\n    // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n    logger.warn(\"Unhandled video codec \\\"\" + parsedCodec + \"\\\"\");\n    if (parsedCodec === 'hvc1' || parsedCodec === 'hev1') {\n      return 'hvc1.1.6.L120.90';\n    }\n    if (parsedCodec === 'av01') {\n      return 'av01.0.04M.08';\n    }\n    return 'avc1.42e01e';\n  }\n\n  var now;\n  // performance.now() not available on WebWorker, at least on Safari Desktop\n  try {\n    now = self.performance.now.bind(self.performance);\n  } catch (err) {\n    logger.debug('Unable to use Performance API on this environment');\n    now = optionalSelf == null ? void 0 : optionalSelf.Date.now;\n  }\n  var muxConfig = [{\n    demux: MP4Demuxer,\n    remux: PassThroughRemuxer\n  }, {\n    demux: TSDemuxer,\n    remux: MP4Remuxer\n  }, {\n    demux: AACDemuxer,\n    remux: MP4Remuxer\n  }, {\n    demux: MP3Demuxer,\n    remux: MP4Remuxer\n  }];\n  {\n    muxConfig.splice(2, 0, {\n      demux: AC3Demuxer,\n      remux: MP4Remuxer\n    });\n  }\n  var Transmuxer = /*#__PURE__*/function () {\n    function Transmuxer(observer, typeSupported, config, vendor, id) {\n      this.async = false;\n      this.observer = void 0;\n      this.typeSupported = void 0;\n      this.config = void 0;\n      this.vendor = void 0;\n      this.id = void 0;\n      this.demuxer = void 0;\n      this.remuxer = void 0;\n      this.decrypter = void 0;\n      this.probe = void 0;\n      this.decryptionPromise = null;\n      this.transmuxConfig = void 0;\n      this.currentTransmuxState = void 0;\n      this.observer = observer;\n      this.typeSupported = typeSupported;\n      this.config = config;\n      this.vendor = vendor;\n      this.id = id;\n    }\n    var _proto = Transmuxer.prototype;\n    _proto.configure = function configure(transmuxConfig) {\n      this.transmuxConfig = transmuxConfig;\n      if (this.decrypter) {\n        this.decrypter.reset();\n      }\n    };\n    _proto.push = function push(data, decryptdata, chunkMeta, state) {\n      var _this = this;\n      var stats = chunkMeta.transmuxing;\n      stats.executeStart = now();\n      var uintData = new Uint8Array(data);\n      var currentTransmuxState = this.currentTransmuxState,\n        transmuxConfig = this.transmuxConfig;\n      if (state) {\n        this.currentTransmuxState = state;\n      }\n      var _ref = state || currentTransmuxState,\n        contiguous = _ref.contiguous,\n        discontinuity = _ref.discontinuity,\n        trackSwitch = _ref.trackSwitch,\n        accurateTimeOffset = _ref.accurateTimeOffset,\n        timeOffset = _ref.timeOffset,\n        initSegmentChange = _ref.initSegmentChange;\n      var audioCodec = transmuxConfig.audioCodec,\n        videoCodec = transmuxConfig.videoCodec,\n        defaultInitPts = transmuxConfig.defaultInitPts,\n        duration = transmuxConfig.duration,\n        initSegmentData = transmuxConfig.initSegmentData;\n      var keyData = getEncryptionType(uintData, decryptdata);\n      if (keyData && keyData.method === 'AES-128') {\n        var decrypter = this.getDecrypter();\n        // Software decryption is synchronous; webCrypto is not\n        if (decrypter.isSync()) {\n          // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n          // data is handled in the flush() call\n          var decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);\n          // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n          var loadingParts = chunkMeta.part > -1;\n          if (loadingParts) {\n            decryptedData = decrypter.flush();\n          }\n          if (!decryptedData) {\n            stats.executeEnd = now();\n            return emptyResult(chunkMeta);\n          }\n          uintData = new Uint8Array(decryptedData);\n        } else {\n          this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(function (decryptedData) {\n            // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n            // the decrypted data has been transmuxed\n            var result = _this.push(decryptedData, null, chunkMeta);\n            _this.decryptionPromise = null;\n            return result;\n          });\n          return this.decryptionPromise;\n        }\n      }\n      var resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n      if (resetMuxers) {\n        var error = this.configureTransmuxer(uintData);\n        if (error) {\n          logger.warn(\"[transmuxer] \" + error.message);\n          this.observer.emit(Events.ERROR, Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_PARSING_ERROR,\n            fatal: false,\n            error: error,\n            reason: error.message\n          });\n          stats.executeEnd = now();\n          return emptyResult(chunkMeta);\n        }\n      }\n      if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n        this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);\n      }\n      if (discontinuity || initSegmentChange || resetMuxers) {\n        this.resetInitialTimestamp(defaultInitPts);\n      }\n      if (!contiguous) {\n        this.resetContiguity();\n      }\n      var result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n      var currentState = this.currentTransmuxState;\n      currentState.contiguous = true;\n      currentState.discontinuity = false;\n      currentState.trackSwitch = false;\n      stats.executeEnd = now();\n      return result;\n    }\n\n    // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n    ;\n    _proto.flush = function flush(chunkMeta) {\n      var _this2 = this;\n      var stats = chunkMeta.transmuxing;\n      stats.executeStart = now();\n      var decrypter = this.decrypter,\n        currentTransmuxState = this.currentTransmuxState,\n        decryptionPromise = this.decryptionPromise;\n      if (decryptionPromise) {\n        // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n        // only flushing is required for async decryption\n        return decryptionPromise.then(function () {\n          return _this2.flush(chunkMeta);\n        });\n      }\n      var transmuxResults = [];\n      var timeOffset = currentTransmuxState.timeOffset;\n      if (decrypter) {\n        // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n        // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n        // or for progressive downloads with small segments)\n        var decryptedData = decrypter.flush();\n        if (decryptedData) {\n          // Push always returns a TransmuxerResult if decryptdata is null\n          transmuxResults.push(this.push(decryptedData, null, chunkMeta));\n        }\n      }\n      var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n      if (!demuxer || !remuxer) {\n        // If probing failed, then Hls.js has been given content its not able to handle\n        stats.executeEnd = now();\n        return [emptyResult(chunkMeta)];\n      }\n      var demuxResultOrPromise = demuxer.flush(timeOffset);\n      if (isPromise(demuxResultOrPromise)) {\n        // Decrypt final SAMPLE-AES samples\n        return demuxResultOrPromise.then(function (demuxResult) {\n          _this2.flushRemux(transmuxResults, demuxResult, chunkMeta);\n          return transmuxResults;\n        });\n      }\n      this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n      return transmuxResults;\n    };\n    _proto.flushRemux = function flushRemux(transmuxResults, demuxResult, chunkMeta) {\n      var audioTrack = demuxResult.audioTrack,\n        videoTrack = demuxResult.videoTrack,\n        id3Track = demuxResult.id3Track,\n        textTrack = demuxResult.textTrack;\n      var _this$currentTransmux = this.currentTransmuxState,\n        accurateTimeOffset = _this$currentTransmux.accurateTimeOffset,\n        timeOffset = _this$currentTransmux.timeOffset;\n      logger.log(\"[transmuxer.ts]: Flushed fragment \" + chunkMeta.sn + (chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : '') + \" of level \" + chunkMeta.level);\n      var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n      transmuxResults.push({\n        remuxResult: remuxResult,\n        chunkMeta: chunkMeta\n      });\n      chunkMeta.transmuxing.executeEnd = now();\n    };\n    _proto.resetInitialTimestamp = function resetInitialTimestamp(defaultInitPts) {\n      var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n      if (!demuxer || !remuxer) {\n        return;\n      }\n      demuxer.resetTimeStamp(defaultInitPts);\n      remuxer.resetTimeStamp(defaultInitPts);\n    };\n    _proto.resetContiguity = function resetContiguity() {\n      var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n      if (!demuxer || !remuxer) {\n        return;\n      }\n      demuxer.resetContiguity();\n      remuxer.resetNextTimestamp();\n    };\n    _proto.resetInitSegment = function resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {\n      var demuxer = this.demuxer,\n        remuxer = this.remuxer;\n      if (!demuxer || !remuxer) {\n        return;\n      }\n      demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n      remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);\n    };\n    _proto.destroy = function destroy() {\n      if (this.demuxer) {\n        this.demuxer.destroy();\n        this.demuxer = undefined;\n      }\n      if (this.remuxer) {\n        this.remuxer.destroy();\n        this.remuxer = undefined;\n      }\n    };\n    _proto.transmux = function transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n      var result;\n      if (keyData && keyData.method === 'SAMPLE-AES') {\n        result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n      } else {\n        result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n      }\n      return result;\n    };\n    _proto.transmuxUnencrypted = function transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n      var _demux = this.demuxer.demux(data, timeOffset, false, !this.config.progressive),\n        audioTrack = _demux.audioTrack,\n        videoTrack = _demux.videoTrack,\n        id3Track = _demux.id3Track,\n        textTrack = _demux.textTrack;\n      var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n      return {\n        remuxResult: remuxResult,\n        chunkMeta: chunkMeta\n      };\n    };\n    _proto.transmuxSampleAes = function transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n      var _this3 = this;\n      return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(function (demuxResult) {\n        var remuxResult = _this3.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, _this3.id);\n        return {\n          remuxResult: remuxResult,\n          chunkMeta: chunkMeta\n        };\n      });\n    };\n    _proto.configureTransmuxer = function configureTransmuxer(data) {\n      var config = this.config,\n        observer = this.observer,\n        typeSupported = this.typeSupported,\n        vendor = this.vendor;\n      // probe for content type\n      var mux;\n      for (var i = 0, len = muxConfig.length; i < len; i++) {\n        var _muxConfig$i$demux;\n        if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data)) {\n          mux = muxConfig[i];\n          break;\n        }\n      }\n      if (!mux) {\n        return new Error('Failed to find demuxer by probing fragment data');\n      }\n      // so let's check that current remuxer and demuxer are still valid\n      var demuxer = this.demuxer;\n      var remuxer = this.remuxer;\n      var Remuxer = mux.remux;\n      var Demuxer = mux.demux;\n      if (!remuxer || !(remuxer instanceof Remuxer)) {\n        this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\n      }\n      if (!demuxer || !(demuxer instanceof Demuxer)) {\n        this.demuxer = new Demuxer(observer, config, typeSupported);\n        this.probe = Demuxer.probe;\n      }\n    };\n    _proto.needsProbing = function needsProbing(discontinuity, trackSwitch) {\n      // in case of continuity change, or track switch\n      // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n      return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n    };\n    _proto.getDecrypter = function getDecrypter() {\n      var decrypter = this.decrypter;\n      if (!decrypter) {\n        decrypter = this.decrypter = new Decrypter(this.config);\n      }\n      return decrypter;\n    };\n    return Transmuxer;\n  }();\n  function getEncryptionType(data, decryptData) {\n    var encryptionType = null;\n    if (data.byteLength > 0 && (decryptData == null ? void 0 : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {\n      encryptionType = decryptData;\n    }\n    return encryptionType;\n  }\n  var emptyResult = function emptyResult(chunkMeta) {\n    return {\n      remuxResult: {},\n      chunkMeta: chunkMeta\n    };\n  };\n  function isPromise(p) {\n    return 'then' in p && p.then instanceof Function;\n  }\n  var TransmuxConfig = function TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initSegmentData = void 0;\n    this.duration = void 0;\n    this.defaultInitPts = void 0;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.initSegmentData = initSegmentData;\n    this.duration = duration;\n    this.defaultInitPts = defaultInitPts || null;\n  };\n  var TransmuxState = function TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {\n    this.discontinuity = void 0;\n    this.contiguous = void 0;\n    this.accurateTimeOffset = void 0;\n    this.trackSwitch = void 0;\n    this.timeOffset = void 0;\n    this.initSegmentChange = void 0;\n    this.discontinuity = discontinuity;\n    this.contiguous = contiguous;\n    this.accurateTimeOffset = accurateTimeOffset;\n    this.trackSwitch = trackSwitch;\n    this.timeOffset = timeOffset;\n    this.initSegmentChange = initSegmentChange;\n  };\n\n  var eventemitter3 = {exports: {}};\n\n  (function (module) {\n\n  \tvar has = Object.prototype.hasOwnProperty\n  \t  , prefix = '~';\n\n  \t/**\n  \t * Constructor to create a storage for our `EE` objects.\n  \t * An `Events` instance is a plain object whose properties are event names.\n  \t *\n  \t * @constructor\n  \t * @private\n  \t */\n  \tfunction Events() {}\n\n  \t//\n  \t// We try to not inherit from `Object.prototype`. In some engines creating an\n  \t// instance in this way is faster than calling `Object.create(null)` directly.\n  \t// If `Object.create(null)` is not supported we prefix the event names with a\n  \t// character to make sure that the built-in object properties are not\n  \t// overridden or used as an attack vector.\n  \t//\n  \tif (Object.create) {\n  \t  Events.prototype = Object.create(null);\n\n  \t  //\n  \t  // This hack is needed because the `__proto__` property is still inherited in\n  \t  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  \t  //\n  \t  if (!new Events().__proto__) prefix = false;\n  \t}\n\n  \t/**\n  \t * Representation of a single event listener.\n  \t *\n  \t * @param {Function} fn The listener function.\n  \t * @param {*} context The context to invoke the listener with.\n  \t * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n  \t * @constructor\n  \t * @private\n  \t */\n  \tfunction EE(fn, context, once) {\n  \t  this.fn = fn;\n  \t  this.context = context;\n  \t  this.once = once || false;\n  \t}\n\n  \t/**\n  \t * Add a listener for a given event.\n  \t *\n  \t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n  \t * @param {(String|Symbol)} event The event name.\n  \t * @param {Function} fn The listener function.\n  \t * @param {*} context The context to invoke the listener with.\n  \t * @param {Boolean} once Specify if the listener is a one-time listener.\n  \t * @returns {EventEmitter}\n  \t * @private\n  \t */\n  \tfunction addListener(emitter, event, fn, context, once) {\n  \t  if (typeof fn !== 'function') {\n  \t    throw new TypeError('The listener must be a function');\n  \t  }\n\n  \t  var listener = new EE(fn, context || emitter, once)\n  \t    , evt = prefix ? prefix + event : event;\n\n  \t  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  \t  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  \t  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  \t  return emitter;\n  \t}\n\n  \t/**\n  \t * Clear event by name.\n  \t *\n  \t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n  \t * @param {(String|Symbol)} evt The Event name.\n  \t * @private\n  \t */\n  \tfunction clearEvent(emitter, evt) {\n  \t  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  \t  else delete emitter._events[evt];\n  \t}\n\n  \t/**\n  \t * Minimal `EventEmitter` interface that is molded against the Node.js\n  \t * `EventEmitter` interface.\n  \t *\n  \t * @constructor\n  \t * @public\n  \t */\n  \tfunction EventEmitter() {\n  \t  this._events = new Events();\n  \t  this._eventsCount = 0;\n  \t}\n\n  \t/**\n  \t * Return an array listing the events for which the emitter has registered\n  \t * listeners.\n  \t *\n  \t * @returns {Array}\n  \t * @public\n  \t */\n  \tEventEmitter.prototype.eventNames = function eventNames() {\n  \t  var names = []\n  \t    , events\n  \t    , name;\n\n  \t  if (this._eventsCount === 0) return names;\n\n  \t  for (name in (events = this._events)) {\n  \t    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  \t  }\n\n  \t  if (Object.getOwnPropertySymbols) {\n  \t    return names.concat(Object.getOwnPropertySymbols(events));\n  \t  }\n\n  \t  return names;\n  \t};\n\n  \t/**\n  \t * Return the listeners registered for a given event.\n  \t *\n  \t * @param {(String|Symbol)} event The event name.\n  \t * @returns {Array} The registered listeners.\n  \t * @public\n  \t */\n  \tEventEmitter.prototype.listeners = function listeners(event) {\n  \t  var evt = prefix ? prefix + event : event\n  \t    , handlers = this._events[evt];\n\n  \t  if (!handlers) return [];\n  \t  if (handlers.fn) return [handlers.fn];\n\n  \t  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n  \t    ee[i] = handlers[i].fn;\n  \t  }\n\n  \t  return ee;\n  \t};\n\n  \t/**\n  \t * Return the number of listeners listening to a given event.\n  \t *\n  \t * @param {(String|Symbol)} event The event name.\n  \t * @returns {Number} The number of listeners.\n  \t * @public\n  \t */\n  \tEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  \t  var evt = prefix ? prefix + event : event\n  \t    , listeners = this._events[evt];\n\n  \t  if (!listeners) return 0;\n  \t  if (listeners.fn) return 1;\n  \t  return listeners.length;\n  \t};\n\n  \t/**\n  \t * Calls each of the listeners registered for a given event.\n  \t *\n  \t * @param {(String|Symbol)} event The event name.\n  \t * @returns {Boolean} `true` if the event had listeners, else `false`.\n  \t * @public\n  \t */\n  \tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  \t  var evt = prefix ? prefix + event : event;\n\n  \t  if (!this._events[evt]) return false;\n\n  \t  var listeners = this._events[evt]\n  \t    , len = arguments.length\n  \t    , args\n  \t    , i;\n\n  \t  if (listeners.fn) {\n  \t    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n  \t    switch (len) {\n  \t      case 1: return listeners.fn.call(listeners.context), true;\n  \t      case 2: return listeners.fn.call(listeners.context, a1), true;\n  \t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n  \t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n  \t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n  \t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n  \t    }\n\n  \t    for (i = 1, args = new Array(len -1); i < len; i++) {\n  \t      args[i - 1] = arguments[i];\n  \t    }\n\n  \t    listeners.fn.apply(listeners.context, args);\n  \t  } else {\n  \t    var length = listeners.length\n  \t      , j;\n\n  \t    for (i = 0; i < length; i++) {\n  \t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n  \t      switch (len) {\n  \t        case 1: listeners[i].fn.call(listeners[i].context); break;\n  \t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n  \t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n  \t        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n  \t        default:\n  \t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n  \t            args[j - 1] = arguments[j];\n  \t          }\n\n  \t          listeners[i].fn.apply(listeners[i].context, args);\n  \t      }\n  \t    }\n  \t  }\n\n  \t  return true;\n  \t};\n\n  \t/**\n  \t * Add a listener for a given event.\n  \t *\n  \t * @param {(String|Symbol)} event The event name.\n  \t * @param {Function} fn The listener function.\n  \t * @param {*} [context=this] The context to invoke the listener with.\n  \t * @returns {EventEmitter} `this`.\n  \t * @public\n  \t */\n  \tEventEmitter.prototype.on = function on(event, fn, context) {\n  \t  return addListener(this, event, fn, context, false);\n  \t};\n\n  \t/**\n  \t * Add a one-time listener for a given event.\n  \t *\n  \t * @param {(String|Symbol)} event The event name.\n  \t * @param {Function} fn The listener function.\n  \t * @param {*} [context=this] The context to invoke the listener with.\n  \t * @returns {EventEmitter} `this`.\n  \t * @public\n  \t */\n  \tEventEmitter.prototype.once = function once(event, fn, context) {\n  \t  return addListener(this, event, fn, context, true);\n  \t};\n\n  \t/**\n  \t * Remove the listeners of a given event.\n  \t *\n  \t * @param {(String|Symbol)} event The event name.\n  \t * @param {Function} fn Only remove the listeners that match this function.\n  \t * @param {*} context Only remove the listeners that have this context.\n  \t * @param {Boolean} once Only remove one-time listeners.\n  \t * @returns {EventEmitter} `this`.\n  \t * @public\n  \t */\n  \tEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  \t  var evt = prefix ? prefix + event : event;\n\n  \t  if (!this._events[evt]) return this;\n  \t  if (!fn) {\n  \t    clearEvent(this, evt);\n  \t    return this;\n  \t  }\n\n  \t  var listeners = this._events[evt];\n\n  \t  if (listeners.fn) {\n  \t    if (\n  \t      listeners.fn === fn &&\n  \t      (!once || listeners.once) &&\n  \t      (!context || listeners.context === context)\n  \t    ) {\n  \t      clearEvent(this, evt);\n  \t    }\n  \t  } else {\n  \t    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n  \t      if (\n  \t        listeners[i].fn !== fn ||\n  \t        (once && !listeners[i].once) ||\n  \t        (context && listeners[i].context !== context)\n  \t      ) {\n  \t        events.push(listeners[i]);\n  \t      }\n  \t    }\n\n  \t    //\n  \t    // Reset the array, or remove it completely if we have no more listeners.\n  \t    //\n  \t    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n  \t    else clearEvent(this, evt);\n  \t  }\n\n  \t  return this;\n  \t};\n\n  \t/**\n  \t * Remove all listeners, or those of the specified event.\n  \t *\n  \t * @param {(String|Symbol)} [event] The event name.\n  \t * @returns {EventEmitter} `this`.\n  \t * @public\n  \t */\n  \tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  \t  var evt;\n\n  \t  if (event) {\n  \t    evt = prefix ? prefix + event : event;\n  \t    if (this._events[evt]) clearEvent(this, evt);\n  \t  } else {\n  \t    this._events = new Events();\n  \t    this._eventsCount = 0;\n  \t  }\n\n  \t  return this;\n  \t};\n\n  \t//\n  \t// Alias methods names because people roll like that.\n  \t//\n  \tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n  \tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  \t//\n  \t// Expose the prefix.\n  \t//\n  \tEventEmitter.prefixed = prefix;\n\n  \t//\n  \t// Allow `EventEmitter` to be imported as module namespace.\n  \t//\n  \tEventEmitter.EventEmitter = EventEmitter;\n\n  \t//\n  \t// Expose the module.\n  \t//\n  \t{\n  \t  module.exports = EventEmitter;\n  \t} \n  } (eventemitter3));\n\n  var eventemitter3Exports = eventemitter3.exports;\n  var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);\n\n  if (typeof __IN_WORKER__ !== 'undefined' && __IN_WORKER__) {\n    startWorker(self);\n  }\n  function startWorker(self) {\n    var observer = new EventEmitter();\n    var forwardMessage = function forwardMessage(ev, data) {\n      self.postMessage({\n        event: ev,\n        data: data\n      });\n    };\n\n    // forward events to main thread\n    observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n    observer.on(Events.ERROR, forwardMessage);\n\n    // forward logger events to main thread\n    var forwardWorkerLogs = function forwardWorkerLogs() {\n      var _loop = function _loop(logFn) {\n        var func = function func(message) {\n          forwardMessage('workerLog', {\n            logType: logFn,\n            message: message\n          });\n        };\n        logger[logFn] = func;\n      };\n      for (var logFn in logger) {\n        _loop(logFn);\n      }\n    };\n    self.addEventListener('message', function (ev) {\n      var data = ev.data;\n      switch (data.cmd) {\n        case 'init':\n          {\n            var config = JSON.parse(data.config);\n            self.transmuxer = new Transmuxer(observer, data.typeSupported, config, '', data.id);\n            enableLogs(config.debug, data.id);\n            forwardWorkerLogs();\n            forwardMessage('init', null);\n            break;\n          }\n        case 'configure':\n          {\n            self.transmuxer.configure(data.config);\n            break;\n          }\n        case 'demux':\n          {\n            var transmuxResult = self.transmuxer.push(data.data, data.decryptdata, data.chunkMeta, data.state);\n            if (isPromise(transmuxResult)) {\n              self.transmuxer.async = true;\n              transmuxResult.then(function (data) {\n                emitTransmuxComplete(self, data);\n              }).catch(function (error) {\n                forwardMessage(Events.ERROR, {\n                  type: ErrorTypes.MEDIA_ERROR,\n                  details: ErrorDetails.FRAG_PARSING_ERROR,\n                  chunkMeta: data.chunkMeta,\n                  fatal: false,\n                  error: error,\n                  err: error,\n                  reason: \"transmuxer-worker push error\"\n                });\n              });\n            } else {\n              self.transmuxer.async = false;\n              emitTransmuxComplete(self, transmuxResult);\n            }\n            break;\n          }\n        case 'flush':\n          {\n            var id = data.chunkMeta;\n            var _transmuxResult = self.transmuxer.flush(id);\n            var asyncFlush = isPromise(_transmuxResult);\n            if (asyncFlush || self.transmuxer.async) {\n              if (!isPromise(_transmuxResult)) {\n                _transmuxResult = Promise.resolve(_transmuxResult);\n              }\n              _transmuxResult.then(function (results) {\n                handleFlushResult(self, results, id);\n              }).catch(function (error) {\n                forwardMessage(Events.ERROR, {\n                  type: ErrorTypes.MEDIA_ERROR,\n                  details: ErrorDetails.FRAG_PARSING_ERROR,\n                  chunkMeta: data.chunkMeta,\n                  fatal: false,\n                  error: error,\n                  err: error,\n                  reason: \"transmuxer-worker flush error\"\n                });\n              });\n            } else {\n              handleFlushResult(self, _transmuxResult, id);\n            }\n            break;\n          }\n      }\n    });\n  }\n  function emitTransmuxComplete(self, transmuxResult) {\n    if (isEmptyResult(transmuxResult.remuxResult)) {\n      return false;\n    }\n    var transferable = [];\n    var _transmuxResult$remux = transmuxResult.remuxResult,\n      audio = _transmuxResult$remux.audio,\n      video = _transmuxResult$remux.video;\n    if (audio) {\n      addToTransferable(transferable, audio);\n    }\n    if (video) {\n      addToTransferable(transferable, video);\n    }\n    self.postMessage({\n      event: 'transmuxComplete',\n      data: transmuxResult\n    }, transferable);\n    return true;\n  }\n\n  // Converts data to a transferable object https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast)\n  // in order to minimize message passing overhead\n  function addToTransferable(transferable, track) {\n    if (track.data1) {\n      transferable.push(track.data1.buffer);\n    }\n    if (track.data2) {\n      transferable.push(track.data2.buffer);\n    }\n  }\n  function handleFlushResult(self, results, chunkMeta) {\n    var parsed = results.reduce(function (parsed, result) {\n      return emitTransmuxComplete(self, result) || parsed;\n    }, false);\n    if (!parsed) {\n      // Emit at least one \"transmuxComplete\" message even if media is not found to update stream-controller state to PARSING\n      self.postMessage({\n        event: 'transmuxComplete',\n        data: results[0]\n      });\n    }\n    self.postMessage({\n      event: 'flush',\n      data: chunkMeta\n    });\n  }\n  function isEmptyResult(remuxResult) {\n    return !remuxResult.audio && !remuxResult.video && !remuxResult.text && !remuxResult.id3 && !remuxResult.initSegment;\n  }\n\n  // ensure the worker ends up in the bundle\n  // If the worker should not be included this gets aliased to empty.js\n  function hasUMDWorker() {\n    return typeof __HLS_WORKER_BUNDLE__ === 'function';\n  }\n  function injectWorker() {\n    var blob = new self.Blob([\"var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(\" + __HLS_WORKER_BUNDLE__.toString() + \")(true);\"], {\n      type: 'text/javascript'\n    });\n    var objectURL = self.URL.createObjectURL(blob);\n    var worker = new self.Worker(objectURL);\n    return {\n      worker: worker,\n      objectURL: objectURL\n    };\n  }\n  function loadWorker(path) {\n    var scriptURL = new self.URL(path, self.location.href).href;\n    var worker = new self.Worker(scriptURL);\n    return {\n      worker: worker,\n      scriptURL: scriptURL\n    };\n  }\n\n  var TransmuxerInterface = /*#__PURE__*/function () {\n    function TransmuxerInterface(hls, id, onTransmuxComplete, onFlush) {\n      var _this = this;\n      this.error = null;\n      this.hls = void 0;\n      this.id = void 0;\n      this.observer = void 0;\n      this.frag = null;\n      this.part = null;\n      this.useWorker = void 0;\n      this.workerContext = null;\n      this.onwmsg = void 0;\n      this.transmuxer = null;\n      this.onTransmuxComplete = void 0;\n      this.onFlush = void 0;\n      var config = hls.config;\n      this.hls = hls;\n      this.id = id;\n      this.useWorker = !!config.enableWorker;\n      this.onTransmuxComplete = onTransmuxComplete;\n      this.onFlush = onFlush;\n      var forwardMessage = function forwardMessage(ev, data) {\n        data = data || {};\n        data.frag = _this.frag;\n        data.id = _this.id;\n        if (ev === Events.ERROR) {\n          _this.error = data.error;\n        }\n        _this.hls.trigger(ev, data);\n      };\n\n      // forward events to main thread\n      this.observer = new EventEmitter();\n      this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n      this.observer.on(Events.ERROR, forwardMessage);\n      var MediaSource = getMediaSource(config.preferManagedMediaSource) || {\n        isTypeSupported: function isTypeSupported() {\n          return false;\n        }\n      };\n      var m2tsTypeSupported = {\n        mpeg: MediaSource.isTypeSupported('audio/mpeg'),\n        mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"'),\n        ac3: MediaSource.isTypeSupported('audio/mp4; codecs=\"ac-3\"') \n      };\n      if (this.useWorker && typeof Worker !== 'undefined') {\n        var canCreateWorker = config.workerPath || hasUMDWorker();\n        if (canCreateWorker) {\n          try {\n            if (config.workerPath) {\n              logger.log(\"loading Web Worker \" + config.workerPath + \" for \\\"\" + id + \"\\\"\");\n              this.workerContext = loadWorker(config.workerPath);\n            } else {\n              logger.log(\"injecting Web Worker for \\\"\" + id + \"\\\"\");\n              this.workerContext = injectWorker();\n            }\n            this.onwmsg = function (event) {\n              return _this.onWorkerMessage(event);\n            };\n            var worker = this.workerContext.worker;\n            worker.addEventListener('message', this.onwmsg);\n            worker.onerror = function (event) {\n              var error = new Error(event.message + \"  (\" + event.filename + \":\" + event.lineno + \")\");\n              config.enableWorker = false;\n              logger.warn(\"Error in \\\"\" + id + \"\\\" Web Worker, fallback to inline\");\n              _this.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.OTHER_ERROR,\n                details: ErrorDetails.INTERNAL_EXCEPTION,\n                fatal: false,\n                event: 'demuxerWorker',\n                error: error\n              });\n            };\n            worker.postMessage({\n              cmd: 'init',\n              typeSupported: m2tsTypeSupported,\n              vendor: '',\n              id: id,\n              config: JSON.stringify(config)\n            });\n          } catch (err) {\n            logger.warn(\"Error setting up \\\"\" + id + \"\\\" Web Worker, fallback to inline\", err);\n            this.resetWorker();\n            this.error = null;\n            this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, '', id);\n          }\n          return;\n        }\n      }\n      this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, '', id);\n    }\n    var _proto = TransmuxerInterface.prototype;\n    _proto.resetWorker = function resetWorker() {\n      if (this.workerContext) {\n        var _this$workerContext = this.workerContext,\n          worker = _this$workerContext.worker,\n          objectURL = _this$workerContext.objectURL;\n        if (objectURL) {\n          // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n          self.URL.revokeObjectURL(objectURL);\n        }\n        worker.removeEventListener('message', this.onwmsg);\n        worker.onerror = null;\n        worker.terminate();\n        this.workerContext = null;\n      }\n    };\n    _proto.destroy = function destroy() {\n      if (this.workerContext) {\n        this.resetWorker();\n        this.onwmsg = undefined;\n      } else {\n        var transmuxer = this.transmuxer;\n        if (transmuxer) {\n          transmuxer.destroy();\n          this.transmuxer = null;\n        }\n      }\n      var observer = this.observer;\n      if (observer) {\n        observer.removeAllListeners();\n      }\n      this.frag = null;\n      // @ts-ignore\n      this.observer = null;\n      // @ts-ignore\n      this.hls = null;\n    };\n    _proto.push = function push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n      var _frag$initSegment,\n        _lastFrag$initSegment,\n        _this2 = this;\n      chunkMeta.transmuxing.start = self.performance.now();\n      var transmuxer = this.transmuxer;\n      var timeOffset = part ? part.start : frag.start;\n      // TODO: push \"clear-lead\" decrypt data for unencrypted fragments in streams with encrypted ones\n      var decryptdata = frag.decryptdata;\n      var lastFrag = this.frag;\n      var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n      var trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n      var snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n      var partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n      var progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);\n      var contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));\n      var now = self.performance.now();\n      if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n        frag.stats.parsing.start = now;\n      }\n      if (part && (partDiff || !contiguous)) {\n        part.stats.parsing.start = now;\n      }\n      var initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));\n      var state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n      if (!contiguous || discontinuity || initSegmentChange) {\n        logger.log(\"[transmuxer-interface, \" + frag.type + \"]: Starting new transmux session for sn: \" + chunkMeta.sn + \" p: \" + chunkMeta.part + \" level: \" + chunkMeta.level + \" id: \" + chunkMeta.id + \"\\n        discontinuity: \" + discontinuity + \"\\n        trackSwitch: \" + trackSwitch + \"\\n        contiguous: \" + contiguous + \"\\n        accurateTimeOffset: \" + accurateTimeOffset + \"\\n        timeOffset: \" + timeOffset + \"\\n        initSegmentChange: \" + initSegmentChange);\n        var config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n        this.configureTransmuxer(config);\n      }\n      this.frag = frag;\n      this.part = part;\n\n      // Frags with sn of 'initSegment' are not transmuxed\n      if (this.workerContext) {\n        // post fragment payload as transferable objects for ArrayBuffer (no copy)\n        this.workerContext.worker.postMessage({\n          cmd: 'demux',\n          data: data,\n          decryptdata: decryptdata,\n          chunkMeta: chunkMeta,\n          state: state\n        }, data instanceof ArrayBuffer ? [data] : []);\n      } else if (transmuxer) {\n        var _transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n        if (isPromise(_transmuxResult)) {\n          transmuxer.async = true;\n          _transmuxResult.then(function (data) {\n            _this2.handleTransmuxComplete(data);\n          }).catch(function (error) {\n            _this2.transmuxerError(error, chunkMeta, 'transmuxer-interface push error');\n          });\n        } else {\n          transmuxer.async = false;\n          this.handleTransmuxComplete(_transmuxResult);\n        }\n      }\n    };\n    _proto.flush = function flush(chunkMeta) {\n      var _this3 = this;\n      chunkMeta.transmuxing.start = self.performance.now();\n      var transmuxer = this.transmuxer;\n      if (this.workerContext) {\n        this.workerContext.worker.postMessage({\n          cmd: 'flush',\n          chunkMeta: chunkMeta\n        });\n      } else if (transmuxer) {\n        var _transmuxResult2 = transmuxer.flush(chunkMeta);\n        var asyncFlush = isPromise(_transmuxResult2);\n        if (asyncFlush || transmuxer.async) {\n          if (!isPromise(_transmuxResult2)) {\n            _transmuxResult2 = Promise.resolve(_transmuxResult2);\n          }\n          _transmuxResult2.then(function (data) {\n            _this3.handleFlushResult(data, chunkMeta);\n          }).catch(function (error) {\n            _this3.transmuxerError(error, chunkMeta, 'transmuxer-interface flush error');\n          });\n        } else {\n          this.handleFlushResult(_transmuxResult2, chunkMeta);\n        }\n      }\n    };\n    _proto.transmuxerError = function transmuxerError(error, chunkMeta, reason) {\n      if (!this.hls) {\n        return;\n      }\n      this.error = error;\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        chunkMeta: chunkMeta,\n        frag: this.frag || undefined,\n        fatal: false,\n        error: error,\n        err: error,\n        reason: reason\n      });\n    };\n    _proto.handleFlushResult = function handleFlushResult(results, chunkMeta) {\n      var _this4 = this;\n      results.forEach(function (result) {\n        _this4.handleTransmuxComplete(result);\n      });\n      this.onFlush(chunkMeta);\n    };\n    _proto.onWorkerMessage = function onWorkerMessage(event) {\n      var data = event.data;\n      if (!(data != null && data.event)) {\n        logger.warn(\"worker message received with no \" + (data ? 'event name' : 'data'));\n        return;\n      }\n      var hls = this.hls;\n      if (!this.hls) {\n        return;\n      }\n      switch (data.event) {\n        case 'init':\n          {\n            var _this$workerContext2;\n            var objectURL = (_this$workerContext2 = this.workerContext) == null ? void 0 : _this$workerContext2.objectURL;\n            if (objectURL) {\n              // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n              self.URL.revokeObjectURL(objectURL);\n            }\n            break;\n          }\n        case 'transmuxComplete':\n          {\n            this.handleTransmuxComplete(data.data);\n            break;\n          }\n        case 'flush':\n          {\n            this.onFlush(data.data);\n            break;\n          }\n\n        // pass logs from the worker thread to the main logger\n        case 'workerLog':\n          if (logger[data.data.logType]) {\n            logger[data.data.logType](data.data.message);\n          }\n          break;\n        default:\n          {\n            data.data = data.data || {};\n            data.data.frag = this.frag;\n            data.data.id = this.id;\n            hls.trigger(data.event, data.data);\n            break;\n          }\n      }\n    };\n    _proto.configureTransmuxer = function configureTransmuxer(config) {\n      var transmuxer = this.transmuxer;\n      if (this.workerContext) {\n        this.workerContext.worker.postMessage({\n          cmd: 'configure',\n          config: config\n        });\n      } else if (transmuxer) {\n        transmuxer.configure(config);\n      }\n    };\n    _proto.handleTransmuxComplete = function handleTransmuxComplete(result) {\n      result.chunkMeta.transmuxing.end = self.performance.now();\n      this.onTransmuxComplete(result);\n    };\n    return TransmuxerInterface;\n  }();\n\n  function subtitleOptionsIdentical(trackList1, trackList2) {\n    if (trackList1.length !== trackList2.length) {\n      return false;\n    }\n    for (var i = 0; i < trackList1.length; i++) {\n      if (!mediaAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function mediaAttributesIdentical(attrs1, attrs2, customAttributes) {\n    // Media options with the same rendition ID must be bit identical\n    var stableRenditionId = attrs1['STABLE-RENDITION-ID'];\n    if (stableRenditionId && !customAttributes) {\n      return stableRenditionId === attrs2['STABLE-RENDITION-ID'];\n    }\n    // When rendition ID is not present, compare attributes\n    return !(customAttributes || ['LANGUAGE', 'NAME', 'CHARACTERISTICS', 'AUTOSELECT', 'DEFAULT', 'FORCED', 'ASSOC-LANGUAGE']).some(function (subtitleAttribute) {\n      return attrs1[subtitleAttribute] !== attrs2[subtitleAttribute];\n    });\n  }\n  function subtitleTrackMatchesTextTrack(subtitleTrack, textTrack) {\n    return textTrack.label.toLowerCase() === subtitleTrack.name.toLowerCase() && (!textTrack.language || textTrack.language.toLowerCase() === (subtitleTrack.lang || '').toLowerCase());\n  }\n\n  var TICK_INTERVAL$2 = 100; // how often to tick in ms\n  var AudioStreamController = /*#__PURE__*/function (_BaseStreamController) {\n    _inheritsLoose(AudioStreamController, _BaseStreamController);\n    function AudioStreamController(hls, fragmentTracker, keyLoader) {\n      var _this;\n      _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, '[audio-stream-controller]', PlaylistLevelType.AUDIO) || this;\n      _this.videoBuffer = null;\n      _this.videoTrackCC = -1;\n      _this.waitingVideoCC = -1;\n      _this.bufferedTrack = null;\n      _this.switchingTrack = null;\n      _this.trackId = -1;\n      _this.waitingData = null;\n      _this.mainDetails = null;\n      _this.flushing = false;\n      _this.bufferFlushed = false;\n      _this.cachedTrackLoadedData = null;\n      _this._registerListeners();\n      return _this;\n    }\n    var _proto = AudioStreamController.prototype;\n    _proto.onHandlerDestroying = function onHandlerDestroying() {\n      this._unregisterListeners();\n      _BaseStreamController.prototype.onHandlerDestroying.call(this);\n      this.mainDetails = null;\n      this.bufferedTrack = null;\n      this.switchingTrack = null;\n    };\n    _proto._registerListeners = function _registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n      hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n      hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n      hls.on(Events.ERROR, this.onError, this);\n      hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n      hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n      hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    };\n    _proto._unregisterListeners = function _unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n      hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n      hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n      hls.off(Events.ERROR, this.onError, this);\n      hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n      hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n      hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n\n    // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value\n    ;\n    _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {\n      var frag = _ref.frag,\n        id = _ref.id,\n        initPTS = _ref.initPTS,\n        timescale = _ref.timescale;\n      // Always update the new INIT PTS\n      // Can change due level switch\n      if (id === 'main') {\n        var cc = frag.cc;\n        this.initPTS[frag.cc] = {\n          baseTime: initPTS,\n          timescale: timescale\n        };\n        this.log(\"InitPTS for cc: \" + cc + \" found from main: \" + initPTS);\n        this.videoTrackCC = cc;\n        // If we are waiting, tick immediately to unblock audio fragment transmuxing\n        if (this.state === State.WAITING_INIT_PTS) {\n          this.tick();\n        }\n      }\n    };\n    _proto.startLoad = function startLoad(startPosition) {\n      if (!this.levels) {\n        this.startPosition = startPosition;\n        this.state = State.STOPPED;\n        return;\n      }\n      var lastCurrentTime = this.lastCurrentTime;\n      this.stopLoad();\n      this.setInterval(TICK_INTERVAL$2);\n      if (lastCurrentTime > 0 && startPosition === -1) {\n        this.log(\"Override startPosition with lastCurrentTime @\" + lastCurrentTime.toFixed(3));\n        startPosition = lastCurrentTime;\n        this.state = State.IDLE;\n      } else {\n        this.loadedmetadata = false;\n        this.state = State.WAITING_TRACK;\n      }\n      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n      this.tick();\n    };\n    _proto.doTick = function doTick() {\n      switch (this.state) {\n        case State.IDLE:\n          this.doTickIdle();\n          break;\n        case State.WAITING_TRACK:\n          {\n            var _levels$trackId;\n            var levels = this.levels,\n              trackId = this.trackId;\n            var details = levels == null ? void 0 : (_levels$trackId = levels[trackId]) == null ? void 0 : _levels$trackId.details;\n            if (details) {\n              if (this.waitForCdnTuneIn(details)) {\n                break;\n              }\n              this.state = State.WAITING_INIT_PTS;\n            }\n            break;\n          }\n        case State.FRAG_LOADING_WAITING_RETRY:\n          {\n            var _this$media;\n            var now = performance.now();\n            var retryDate = this.retryDate;\n            // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n            if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n              var _levels = this.levels,\n                _trackId = this.trackId;\n              this.log('RetryDate reached, switch back to IDLE state');\n              this.resetStartWhenNotLoaded((_levels == null ? void 0 : _levels[_trackId]) || null);\n              this.state = State.IDLE;\n            }\n            break;\n          }\n        case State.WAITING_INIT_PTS:\n          {\n            // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS\n            var waitingData = this.waitingData;\n            if (waitingData) {\n              var frag = waitingData.frag,\n                part = waitingData.part,\n                cache = waitingData.cache,\n                complete = waitingData.complete;\n              if (this.initPTS[frag.cc] !== undefined) {\n                this.waitingData = null;\n                this.waitingVideoCC = -1;\n                this.state = State.FRAG_LOADING;\n                var payload = cache.flush();\n                var data = {\n                  frag: frag,\n                  part: part,\n                  payload: payload,\n                  networkDetails: null\n                };\n                this._handleFragmentLoadProgress(data);\n                if (complete) {\n                  _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, data);\n                }\n              } else if (this.videoTrackCC !== this.waitingVideoCC) {\n                // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found\n                this.log(\"Waiting fragment cc (\" + frag.cc + \") cancelled because video is at cc \" + this.videoTrackCC);\n                this.clearWaitingFragment();\n              } else {\n                // Drop waiting fragment if an earlier fragment is needed\n                var pos = this.getLoadPosition();\n                var bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);\n                var waitingFragmentAtPosition = fragmentWithinToleranceTest(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);\n                if (waitingFragmentAtPosition < 0) {\n                  this.log(\"Waiting fragment cc (\" + frag.cc + \") @ \" + frag.start + \" cancelled because another fragment at \" + bufferInfo.end + \" is needed\");\n                  this.clearWaitingFragment();\n                }\n              }\n            } else {\n              this.state = State.IDLE;\n            }\n          }\n      }\n      this.onTickEnd();\n    };\n    _proto.clearWaitingFragment = function clearWaitingFragment() {\n      var waitingData = this.waitingData;\n      if (waitingData) {\n        this.fragmentTracker.removeFragment(waitingData.frag);\n        this.waitingData = null;\n        this.waitingVideoCC = -1;\n        this.state = State.IDLE;\n      }\n    };\n    _proto.resetLoadingState = function resetLoadingState() {\n      this.clearWaitingFragment();\n      _BaseStreamController.prototype.resetLoadingState.call(this);\n    };\n    _proto.onTickEnd = function onTickEnd() {\n      var media = this.media;\n      if (!(media != null && media.readyState)) {\n        // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n        return;\n      }\n      this.lastCurrentTime = media.currentTime;\n    };\n    _proto.doTickIdle = function doTickIdle() {\n      var hls = this.hls,\n        levels = this.levels,\n        media = this.media,\n        trackId = this.trackId;\n      var config = hls.config;\n\n      // 1. if video not attached AND\n      //    start fragment already requested OR start frag prefetch not enabled\n      // 2. if tracks or track not loaded and selected\n      // then exit loop\n      // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n      if (!media && (this.startFragRequested || !config.startFragPrefetch) || !(levels != null && levels[trackId])) {\n        return;\n      }\n      var levelInfo = levels[trackId];\n      var trackDetails = levelInfo.details;\n      if (!trackDetails || trackDetails.live && this.levelLastLoaded !== levelInfo || this.waitForCdnTuneIn(trackDetails)) {\n        this.state = State.WAITING_TRACK;\n        return;\n      }\n      var bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;\n      if (this.bufferFlushed && bufferable) {\n        this.bufferFlushed = false;\n        this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);\n      }\n      var bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);\n      if (bufferInfo === null) {\n        return;\n      }\n      var bufferedTrack = this.bufferedTrack,\n        switchingTrack = this.switchingTrack;\n      if (!switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {\n        hls.trigger(Events.BUFFER_EOS, {\n          type: 'audio'\n        });\n        this.state = State.ENDED;\n        return;\n      }\n      var mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, PlaylistLevelType.MAIN);\n      var bufferLen = bufferInfo.len;\n      var maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len);\n      var fragments = trackDetails.fragments;\n      var start = fragments[0].start;\n      var targetBufferTime = this.flushing ? this.getLoadPosition() : bufferInfo.end;\n      if (switchingTrack && media) {\n        var pos = this.getLoadPosition();\n        // STABLE\n        if (bufferedTrack && !mediaAttributesIdentical(switchingTrack.attrs, bufferedTrack.attrs)) {\n          targetBufferTime = pos;\n        }\n        // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n        if (trackDetails.PTSKnown && pos < start) {\n          // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n          if (bufferInfo.end > start || bufferInfo.nextStart) {\n            this.log('Alt audio track ahead of main track, seek to start of alt audio track');\n            media.currentTime = start + 0.05;\n          }\n        }\n      }\n\n      // if buffer length is less than maxBufLen, or near the end, find a fragment to load\n      if (bufferLen >= maxBufLen && !switchingTrack && targetBufferTime < fragments[fragments.length - 1].start) {\n        return;\n      }\n      var frag = this.getNextFragment(targetBufferTime, trackDetails);\n      var atGap = false;\n      // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n      if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n        atGap = !!frag.gap;\n        frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n      }\n      if (!frag) {\n        this.bufferFlushed = true;\n        return;\n      }\n\n      // Buffer audio up to one target duration ahead of main buffer\n      var atBufferSyncLimit = mainBufferInfo && frag.start > mainBufferInfo.end + trackDetails.targetduration;\n      if (atBufferSyncLimit ||\n      // Or wait for main buffer after buffing some audio\n      !(mainBufferInfo != null && mainBufferInfo.len) && bufferInfo.len) {\n        // Check fragment-tracker for main fragments since GAP segments do not show up in bufferInfo\n        var mainFrag = this.getAppendedFrag(frag.start, PlaylistLevelType.MAIN);\n        if (mainFrag === null) {\n          return;\n        }\n        // Bridge gaps in main buffer\n        atGap || (atGap = !!mainFrag.gap || !!atBufferSyncLimit && mainBufferInfo.len === 0);\n        if (atBufferSyncLimit && !atGap || atGap && bufferInfo.nextStart && bufferInfo.nextStart < mainFrag.end) {\n          return;\n        }\n      }\n      this.loadFragment(frag, levelInfo, targetBufferTime);\n    };\n    _proto.getMaxBufferLength = function getMaxBufferLength(mainBufferLength) {\n      var maxConfigBuffer = _BaseStreamController.prototype.getMaxBufferLength.call(this);\n      if (!mainBufferLength) {\n        return maxConfigBuffer;\n      }\n      return Math.min(Math.max(maxConfigBuffer, mainBufferLength), this.config.maxMaxBufferLength);\n    };\n    _proto.onMediaDetaching = function onMediaDetaching() {\n      this.videoBuffer = null;\n      this.bufferFlushed = this.flushing = false;\n      _BaseStreamController.prototype.onMediaDetaching.call(this);\n    };\n    _proto.onAudioTracksUpdated = function onAudioTracksUpdated(event, _ref2) {\n      var audioTracks = _ref2.audioTracks;\n      // Reset tranxmuxer is essential for large context switches (Content Steering)\n      this.resetTransmuxer();\n      this.levels = audioTracks.map(function (mediaPlaylist) {\n        return new Level(mediaPlaylist);\n      });\n    };\n    _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {\n      // if any URL found on new audio track, it is an alternate audio track\n      var altAudio = !!data.url;\n      this.trackId = data.id;\n      var fragCurrent = this.fragCurrent;\n      if (fragCurrent) {\n        fragCurrent.abortRequests();\n        this.removeUnbufferedFrags(fragCurrent.start);\n      }\n      this.resetLoadingState();\n      // destroy useless transmuxer when switching audio to main\n      if (!altAudio) {\n        this.resetTransmuxer();\n      } else {\n        // switching to audio track, start timer if not already started\n        this.setInterval(TICK_INTERVAL$2);\n      }\n\n      // should we switch tracks ?\n      if (altAudio) {\n        this.switchingTrack = data;\n        // main audio track are handled by stream-controller, just do something if switching to alt audio track\n        this.state = State.IDLE;\n        this.flushAudioIfNeeded(data);\n      } else {\n        this.switchingTrack = null;\n        this.bufferedTrack = data;\n        this.state = State.STOPPED;\n      }\n      this.tick();\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.fragmentTracker.removeAllFragments();\n      this.startPosition = this.lastCurrentTime = 0;\n      this.bufferFlushed = this.flushing = false;\n      this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null;\n      this.startFragRequested = false;\n      this.trackId = this.videoTrackCC = this.waitingVideoCC = -1;\n    };\n    _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n      this.mainDetails = data.details;\n      if (this.cachedTrackLoadedData !== null) {\n        this.hls.trigger(Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);\n        this.cachedTrackLoadedData = null;\n      }\n    };\n    _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {\n      var _track$details;\n      if (this.mainDetails == null) {\n        this.cachedTrackLoadedData = data;\n        return;\n      }\n      var levels = this.levels;\n      var newDetails = data.details,\n        trackId = data.id;\n      if (!levels) {\n        this.warn(\"Audio tracks were reset while loading level \" + trackId);\n        return;\n      }\n      this.log(\"Audio track \" + trackId + \" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"]\" + (newDetails.lastPartSn ? \"[part-\" + newDetails.lastPartSn + \"-\" + newDetails.lastPartIndex + \"]\" : '') + \",duration:\" + newDetails.totalduration);\n      var track = levels[trackId];\n      var sliding = 0;\n      if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n        this.checkLiveUpdate(newDetails);\n        var mainDetails = this.mainDetails;\n        if (newDetails.deltaUpdateFailed || !mainDetails) {\n          return;\n        }\n        if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n          // Make sure our audio rendition is aligned with the \"main\" rendition, using\n          // pdt as our reference times.\n          alignMediaPlaylistByPDT(newDetails, mainDetails);\n          sliding = newDetails.fragments[0].start;\n        } else {\n          var _this$levelLastLoaded;\n          sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n        }\n      }\n      track.details = newDetails;\n      this.levelLastLoaded = track;\n\n      // compute start position if we are aligned with the main playlist\n      if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n        this.setStartPosition(this.mainDetails || newDetails, sliding);\n      }\n      // only switch back to IDLE state if we were waiting for track to start downloading a new fragment\n      if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {\n        this.state = State.IDLE;\n      }\n\n      // trigger handler right now\n      this.tick();\n    };\n    _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {\n      var _frag$initSegment;\n      var frag = data.frag,\n        part = data.part,\n        payload = data.payload;\n      var config = this.config,\n        trackId = this.trackId,\n        levels = this.levels;\n      if (!levels) {\n        this.warn(\"Audio tracks were reset while fragment load was in progress. Fragment \" + frag.sn + \" of level \" + frag.level + \" will not be buffered\");\n        return;\n      }\n      var track = levels[trackId];\n      if (!track) {\n        this.warn('Audio track is undefined on fragment load progress');\n        return;\n      }\n      var details = track.details;\n      if (!details) {\n        this.warn('Audio track details undefined on fragment load progress');\n        this.removeUnbufferedFrags(frag.start);\n        return;\n      }\n      var audioCodec = config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2';\n      var transmuxer = this.transmuxer;\n      if (!transmuxer) {\n        transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n      }\n\n      // Check if we have video initPTS\n      // If not we need to wait for it\n      var initPTS = this.initPTS[frag.cc];\n      var initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n      if (initPTS !== undefined) {\n        // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n        // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n        var accurateTimeOffset = false; // details.PTSKnown || !details.live;\n        var partIndex = part ? part.index : -1;\n        var partial = partIndex !== -1;\n        var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n        transmuxer.push(payload, initSegmentData, audioCodec, '', frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n      } else {\n        this.log(\"Unknown video PTS for cc \" + frag.cc + \", waiting for video PTS before demuxing audio frag \" + frag.sn + \" of [\" + details.startSN + \" ,\" + details.endSN + \"],track \" + trackId);\n        var _this$waitingData = this.waitingData = this.waitingData || {\n            frag: frag,\n            part: part,\n            cache: new ChunkCache(),\n            complete: false\n          },\n          cache = _this$waitingData.cache;\n        cache.push(new Uint8Array(payload));\n        this.waitingVideoCC = this.videoTrackCC;\n        this.state = State.WAITING_INIT_PTS;\n      }\n    };\n    _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {\n      if (this.waitingData) {\n        this.waitingData.complete = true;\n        return;\n      }\n      _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, fragLoadedData);\n    };\n    _proto.onBufferReset = function onBufferReset( /* event: Events.BUFFER_RESET */\n    ) {\n      // reset reference to sourcebuffers\n      this.mediaBuffer = this.videoBuffer = null;\n      this.loadedmetadata = false;\n    };\n    _proto.onBufferCreated = function onBufferCreated(event, data) {\n      var audioTrack = data.tracks.audio;\n      if (audioTrack) {\n        this.mediaBuffer = audioTrack.buffer || null;\n      }\n      if (data.tracks.video) {\n        this.videoBuffer = data.tracks.video.buffer || null;\n      }\n    };\n    _proto.onFragBuffered = function onFragBuffered(event, data) {\n      var frag = data.frag,\n        part = data.part;\n      if (frag.type !== PlaylistLevelType.AUDIO) {\n        if (!this.loadedmetadata && frag.type === PlaylistLevelType.MAIN) {\n          var bufferable = this.videoBuffer || this.media;\n          if (bufferable) {\n            var bufferedTimeRanges = BufferHelper.getBuffered(bufferable);\n            if (bufferedTimeRanges.length) {\n              this.loadedmetadata = true;\n            }\n          }\n        }\n        return;\n      }\n      if (this.fragContextChanged(frag)) {\n        // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n        // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer\n        this.warn(\"Fragment \" + frag.sn + (part ? ' p: ' + part.index : '') + \" of level \" + frag.level + \" finished buffering, but was aborted. state: \" + this.state + \", audioSwitch: \" + (this.switchingTrack ? this.switchingTrack.name : 'false'));\n        return;\n      }\n      if (frag.sn !== 'initSegment') {\n        this.fragPrevious = frag;\n        var track = this.switchingTrack;\n        if (track) {\n          this.bufferedTrack = track;\n          this.switchingTrack = null;\n          this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));\n        }\n      }\n      this.fragBufferedComplete(frag, part);\n    };\n    _proto.onError = function onError(event, data) {\n      var _data$context;\n      if (data.fatal) {\n        this.state = State.ERROR;\n        return;\n      }\n      switch (data.details) {\n        case ErrorDetails.FRAG_GAP:\n        case ErrorDetails.FRAG_PARSING_ERROR:\n        case ErrorDetails.FRAG_DECRYPT_ERROR:\n        case ErrorDetails.FRAG_LOAD_ERROR:\n        case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case ErrorDetails.KEY_LOAD_ERROR:\n        case ErrorDetails.KEY_LOAD_TIMEOUT:\n          this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);\n          break;\n        case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n        case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n        case ErrorDetails.LEVEL_PARSING_ERROR:\n          // in case of non fatal error while loading track, if not retrying to load track, switch back to IDLE\n          if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {\n            this.state = State.IDLE;\n          }\n          break;\n        case ErrorDetails.BUFFER_APPEND_ERROR:\n        case ErrorDetails.BUFFER_FULL_ERROR:\n          if (!data.parent || data.parent !== 'audio') {\n            return;\n          }\n          if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {\n            this.resetLoadingState();\n            return;\n          }\n          if (this.reduceLengthAndFlushBuffer(data)) {\n            this.bufferedTrack = null;\n            _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, 'audio');\n          }\n          break;\n        case ErrorDetails.INTERNAL_EXCEPTION:\n          this.recoverWorkerError(data);\n          break;\n      }\n    };\n    _proto.onBufferFlushing = function onBufferFlushing(event, _ref3) {\n      var type = _ref3.type;\n      if (type !== ElementaryStreamTypes.VIDEO) {\n        this.flushing = true;\n      }\n    };\n    _proto.onBufferFlushed = function onBufferFlushed(event, _ref4) {\n      var type = _ref4.type;\n      if (type !== ElementaryStreamTypes.VIDEO) {\n        this.flushing = false;\n        this.bufferFlushed = true;\n        if (this.state === State.ENDED) {\n          this.state = State.IDLE;\n        }\n        var mediaBuffer = this.mediaBuffer || this.media;\n        if (mediaBuffer) {\n          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.AUDIO);\n          this.tick();\n        }\n      }\n    };\n    _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {\n      var _id3$samples;\n      var id = 'audio';\n      var hls = this.hls;\n      var remuxResult = transmuxResult.remuxResult,\n        chunkMeta = transmuxResult.chunkMeta;\n      var context = this.getCurrentContext(chunkMeta);\n      if (!context) {\n        this.resetWhenMissingContext(chunkMeta);\n        return;\n      }\n      var frag = context.frag,\n        part = context.part,\n        level = context.level;\n      var details = level.details;\n      var audio = remuxResult.audio,\n        text = remuxResult.text,\n        id3 = remuxResult.id3,\n        initSegment = remuxResult.initSegment;\n\n      // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n      // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n      if (this.fragContextChanged(frag) || !details) {\n        this.fragmentTracker.removeFragment(frag);\n        return;\n      }\n      this.state = State.PARSING;\n      if (this.switchingTrack && audio) {\n        this.completeAudioSwitch(this.switchingTrack);\n      }\n      if (initSegment != null && initSegment.tracks) {\n        var mapFragment = frag.initSegment || frag;\n        this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n        hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n          frag: mapFragment,\n          id: id,\n          tracks: initSegment.tracks\n        });\n        // Only flush audio from old audio tracks when PTS is known on new audio track\n      }\n      if (audio) {\n        var startPTS = audio.startPTS,\n          endPTS = audio.endPTS,\n          startDTS = audio.startDTS,\n          endDTS = audio.endDTS;\n        if (part) {\n          part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n            startPTS: startPTS,\n            endPTS: endPTS,\n            startDTS: startDTS,\n            endDTS: endDTS\n          };\n        }\n        frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n        this.bufferFragmentData(audio, frag, part, chunkMeta);\n      }\n      if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n        var emittedID3 = _extends({\n          id: id,\n          frag: frag,\n          details: details\n        }, id3);\n        hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n      }\n      if (text) {\n        var emittedText = _extends({\n          id: id,\n          frag: frag,\n          details: details\n        }, text);\n        hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n      }\n    };\n    _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n      if (this.state !== State.PARSING) {\n        return;\n      }\n      // delete any video track found on audio transmuxer\n      if (tracks.video) {\n        delete tracks.video;\n      }\n\n      // include levelCodec in audio and video tracks\n      var track = tracks.audio;\n      if (!track) {\n        return;\n      }\n      track.id = 'audio';\n      var variantAudioCodecs = currentLevel.audioCodec;\n      this.log(\"Init audio buffer, container:\" + track.container + \", codecs[level/parsed]=[\" + variantAudioCodecs + \"/\" + track.codec + \"]\");\n      // SourceBuffer will use track.levelCodec if defined\n      if (variantAudioCodecs && variantAudioCodecs.split(',').length === 1) {\n        track.levelCodec = variantAudioCodecs;\n      }\n      this.hls.trigger(Events.BUFFER_CODECS, tracks);\n      var initSegment = track.initSegment;\n      if (initSegment != null && initSegment.byteLength) {\n        var segment = {\n          type: 'audio',\n          frag: frag,\n          part: null,\n          chunkMeta: chunkMeta,\n          parent: frag.type,\n          data: initSegment\n        };\n        this.hls.trigger(Events.BUFFER_APPENDING, segment);\n      }\n      // trigger handler right now\n      this.tickImmediate();\n    };\n    _proto.loadFragment = function loadFragment(frag, track, targetBufferTime) {\n      // only load if fragment is not loaded or if in audio switch\n      var fragState = this.fragmentTracker.getState(frag);\n      this.fragCurrent = frag;\n\n      // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch\n      if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n        var _track$details2;\n        if (frag.sn === 'initSegment') {\n          this._loadInitSegment(frag, track);\n        } else if ((_track$details2 = track.details) != null && _track$details2.live && !this.initPTS[frag.cc]) {\n          this.log(\"Waiting for video PTS in continuity counter \" + frag.cc + \" of live stream before loading audio fragment \" + frag.sn + \" of level \" + this.trackId);\n          this.state = State.WAITING_INIT_PTS;\n          var mainDetails = this.mainDetails;\n          if (mainDetails && mainDetails.fragments[0].start !== track.details.fragments[0].start) {\n            alignMediaPlaylistByPDT(track.details, mainDetails);\n          }\n        } else {\n          this.startFragRequested = true;\n          _BaseStreamController.prototype.loadFragment.call(this, frag, track, targetBufferTime);\n        }\n      } else {\n        this.clearTrackerIfNeeded(frag);\n      }\n    };\n    _proto.flushAudioIfNeeded = function flushAudioIfNeeded(switchingTrack) {\n      var media = this.media,\n        bufferedTrack = this.bufferedTrack;\n      var bufferedAttributes = bufferedTrack == null ? void 0 : bufferedTrack.attrs;\n      var switchAttributes = switchingTrack.attrs;\n      if (media && bufferedAttributes && (bufferedAttributes.CHANNELS !== switchAttributes.CHANNELS || bufferedTrack.name !== switchingTrack.name || bufferedTrack.lang !== switchingTrack.lang)) {\n        this.log('Switching audio track : flushing all audio');\n        _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, 'audio');\n        this.bufferedTrack = null;\n      }\n    };\n    _proto.completeAudioSwitch = function completeAudioSwitch(switchingTrack) {\n      var hls = this.hls;\n      this.flushAudioIfNeeded(switchingTrack);\n      this.bufferedTrack = switchingTrack;\n      this.switchingTrack = null;\n      hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));\n    };\n    return AudioStreamController;\n  }(BaseStreamController);\n\n  var AudioTrackController = /*#__PURE__*/function (_BasePlaylistControll) {\n    _inheritsLoose(AudioTrackController, _BasePlaylistControll);\n    function AudioTrackController(hls) {\n      var _this;\n      _this = _BasePlaylistControll.call(this, hls, '[audio-track-controller]') || this;\n      _this.tracks = [];\n      _this.groupIds = null;\n      _this.tracksInGroup = [];\n      _this.trackId = -1;\n      _this.currentTrack = null;\n      _this.selectDefaultTrack = true;\n      _this.registerListeners();\n      return _this;\n    }\n    var _proto = AudioTrackController.prototype;\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n      hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n      hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n      hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n      hls.off(Events.ERROR, this.onError, this);\n    };\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.tracks.length = 0;\n      this.tracksInGroup.length = 0;\n      this.currentTrack = null;\n      _BasePlaylistControll.prototype.destroy.call(this);\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.tracks = [];\n      this.tracksInGroup = [];\n      this.groupIds = null;\n      this.currentTrack = null;\n      this.trackId = -1;\n      this.selectDefaultTrack = true;\n    };\n    _proto.onManifestParsed = function onManifestParsed(event, data) {\n      this.tracks = data.audioTracks || [];\n    };\n    _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {\n      var id = data.id,\n        groupId = data.groupId,\n        details = data.details;\n      var trackInActiveGroup = this.tracksInGroup[id];\n      if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n        this.warn(\"Audio track with id:\" + id + \" and group:\" + groupId + \" not found in active group \" + (trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId));\n        return;\n      }\n      var curDetails = trackInActiveGroup.details;\n      trackInActiveGroup.details = data.details;\n      this.log(\"Audio track \" + id + \" \\\"\" + trackInActiveGroup.name + \"\\\" lang:\" + trackInActiveGroup.lang + \" group:\" + groupId + \" loaded [\" + details.startSN + \"-\" + details.endSN + \"]\");\n      if (id === this.trackId) {\n        this.playlistLoaded(id, data, curDetails);\n      }\n    };\n    _proto.onLevelLoading = function onLevelLoading(event, data) {\n      this.switchLevel(data.level);\n    };\n    _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n      this.switchLevel(data.level);\n    };\n    _proto.switchLevel = function switchLevel(levelIndex) {\n      var levelInfo = this.hls.levels[levelIndex];\n      if (!levelInfo) {\n        return;\n      }\n      var audioGroups = levelInfo.audioGroups || null;\n      var currentGroups = this.groupIds;\n      var currentTrack = this.currentTrack;\n      if (!audioGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (audioGroups == null ? void 0 : audioGroups.length) || audioGroups != null && audioGroups.some(function (groupId) {\n        return (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1;\n      })) {\n        this.groupIds = audioGroups;\n        this.trackId = -1;\n        this.currentTrack = null;\n        var audioTracks = this.tracks.filter(function (track) {\n          return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;\n        });\n        if (audioTracks.length) {\n          // Disable selectDefaultTrack if there are no default tracks\n          if (this.selectDefaultTrack && !audioTracks.some(function (track) {\n            return track.default;\n          })) {\n            this.selectDefaultTrack = false;\n          }\n          // track.id should match hls.audioTracks index\n          audioTracks.forEach(function (track, i) {\n            track.id = i;\n          });\n        } else if (!currentTrack && !this.tracksInGroup.length) {\n          // Do not dispatch AUDIO_TRACKS_UPDATED when there were and are no tracks\n          return;\n        }\n        this.tracksInGroup = audioTracks;\n\n        // Find preferred track\n        var audioPreference = this.hls.config.audioPreference;\n        if (!currentTrack && audioPreference) {\n          var groupIndex = findMatchingOption(audioPreference, audioTracks, audioMatchPredicate);\n          if (groupIndex > -1) {\n            currentTrack = audioTracks[groupIndex];\n          } else {\n            var allIndex = findMatchingOption(audioPreference, this.tracks);\n            currentTrack = this.tracks[allIndex];\n          }\n        }\n\n        // Select initial track\n        var trackId = this.findTrackId(currentTrack);\n        if (trackId === -1 && currentTrack) {\n          trackId = this.findTrackId(null);\n        }\n\n        // Dispatch events and load track if needed\n        var audioTracksUpdated = {\n          audioTracks: audioTracks\n        };\n        this.log(\"Updating audio tracks, \" + audioTracks.length + \" track(s) found in group(s): \" + (audioGroups == null ? void 0 : audioGroups.join(',')));\n        this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);\n        var selectedTrackId = this.trackId;\n        if (trackId !== -1 && selectedTrackId === -1) {\n          this.setAudioTrack(trackId);\n        } else if (audioTracks.length && selectedTrackId === -1) {\n          var _this$groupIds;\n          var error = new Error(\"No audio track selected for current audio group-ID(s): \" + ((_this$groupIds = this.groupIds) == null ? void 0 : _this$groupIds.join(',')) + \" track count: \" + audioTracks.length);\n          this.warn(error.message);\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,\n            fatal: true,\n            error: error\n          });\n        }\n      } else if (this.shouldReloadPlaylist(currentTrack)) {\n        // Retry playlist loading if no playlist is or has been loaded yet\n        this.setAudioTrack(this.trackId);\n      }\n    };\n    _proto.onError = function onError(event, data) {\n      if (data.fatal || !data.context) {\n        return;\n      }\n      if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n        this.requestScheduled = -1;\n        this.checkRetry(data);\n      }\n    };\n    _proto.setAudioOption = function setAudioOption(audioOption) {\n      var hls = this.hls;\n      hls.config.audioPreference = audioOption;\n      if (audioOption) {\n        var allAudioTracks = this.allAudioTracks;\n        this.selectDefaultTrack = false;\n        if (allAudioTracks.length) {\n          // First see if current option matches (no switch op)\n          var currentTrack = this.currentTrack;\n          if (currentTrack && matchesOption(audioOption, currentTrack, audioMatchPredicate)) {\n            return currentTrack;\n          }\n          // Find option in available tracks (tracksInGroup)\n          var groupIndex = findMatchingOption(audioOption, this.tracksInGroup, audioMatchPredicate);\n          if (groupIndex > -1) {\n            var track = this.tracksInGroup[groupIndex];\n            this.setAudioTrack(groupIndex);\n            return track;\n          } else if (currentTrack) {\n            // Find option in nearest level audio group\n            var searchIndex = hls.loadLevel;\n            if (searchIndex === -1) {\n              searchIndex = hls.firstAutoLevel;\n            }\n            var switchIndex = findClosestLevelWithAudioGroup(audioOption, hls.levels, allAudioTracks, searchIndex, audioMatchPredicate);\n            if (switchIndex === -1) {\n              // could not find matching variant\n              return null;\n            }\n            // and switch level to acheive the audio group switch\n            hls.nextLoadLevel = switchIndex;\n          }\n          if (audioOption.channels || audioOption.audioCodec) {\n            // Could not find a match with codec / channels predicate\n            // Find a match without channels or codec\n            var withoutCodecAndChannelsMatch = findMatchingOption(audioOption, allAudioTracks);\n            if (withoutCodecAndChannelsMatch > -1) {\n              return allAudioTracks[withoutCodecAndChannelsMatch];\n            }\n          }\n        }\n      }\n      return null;\n    };\n    _proto.setAudioTrack = function setAudioTrack(newId) {\n      var tracks = this.tracksInGroup;\n\n      // check if level idx is valid\n      if (newId < 0 || newId >= tracks.length) {\n        this.warn(\"Invalid audio track id: \" + newId);\n        return;\n      }\n\n      // stopping live reloading timer if any\n      this.clearTimer();\n      this.selectDefaultTrack = false;\n      var lastTrack = this.currentTrack;\n      var track = tracks[newId];\n      var trackLoaded = track.details && !track.details.live;\n      if (newId === this.trackId && track === lastTrack && trackLoaded) {\n        return;\n      }\n      this.log(\"Switching to audio-track \" + newId + \" \\\"\" + track.name + \"\\\" lang:\" + track.lang + \" group:\" + track.groupId + \" channels:\" + track.channels);\n      this.trackId = newId;\n      this.currentTrack = track;\n      this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));\n      // Do not reload track unless live\n      if (trackLoaded) {\n        return;\n      }\n      var hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);\n      this.loadPlaylist(hlsUrlParameters);\n    };\n    _proto.findTrackId = function findTrackId(currentTrack) {\n      var audioTracks = this.tracksInGroup;\n      for (var i = 0; i < audioTracks.length; i++) {\n        var track = audioTracks[i];\n        if (this.selectDefaultTrack && !track.default) {\n          continue;\n        }\n        if (!currentTrack || matchesOption(currentTrack, track, audioMatchPredicate)) {\n          return i;\n        }\n      }\n      if (currentTrack) {\n        var name = currentTrack.name,\n          lang = currentTrack.lang,\n          assocLang = currentTrack.assocLang,\n          characteristics = currentTrack.characteristics,\n          audioCodec = currentTrack.audioCodec,\n          channels = currentTrack.channels;\n        for (var _i = 0; _i < audioTracks.length; _i++) {\n          var _track = audioTracks[_i];\n          if (matchesOption({\n            name: name,\n            lang: lang,\n            assocLang: assocLang,\n            characteristics: characteristics,\n            audioCodec: audioCodec,\n            channels: channels\n          }, _track, audioMatchPredicate)) {\n            return _i;\n          }\n        }\n        for (var _i2 = 0; _i2 < audioTracks.length; _i2++) {\n          var _track2 = audioTracks[_i2];\n          if (mediaAttributesIdentical(currentTrack.attrs, _track2.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) {\n            return _i2;\n          }\n        }\n        for (var _i3 = 0; _i3 < audioTracks.length; _i3++) {\n          var _track3 = audioTracks[_i3];\n          if (mediaAttributesIdentical(currentTrack.attrs, _track3.attrs, ['LANGUAGE'])) {\n            return _i3;\n          }\n        }\n      }\n      return -1;\n    };\n    _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n      var audioTrack = this.currentTrack;\n      if (this.shouldLoadPlaylist(audioTrack) && audioTrack) {\n        _BasePlaylistControll.prototype.loadPlaylist.call(this);\n        var id = audioTrack.id;\n        var groupId = audioTrack.groupId;\n        var url = audioTrack.url;\n        if (hlsUrlParameters) {\n          try {\n            url = hlsUrlParameters.addDirectives(url);\n          } catch (error) {\n            this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n          }\n        }\n        // track not retrieved yet, or live playlist we need to (re)load it\n        this.log(\"loading audio-track playlist \" + id + \" \\\"\" + audioTrack.name + \"\\\" lang:\" + audioTrack.lang + \" group:\" + groupId);\n        this.clearTimer();\n        this.hls.trigger(Events.AUDIO_TRACK_LOADING, {\n          url: url,\n          id: id,\n          groupId: groupId,\n          deliveryDirectives: hlsUrlParameters || null\n        });\n      }\n    };\n    _createClass(AudioTrackController, [{\n      key: \"allAudioTracks\",\n      get: function get() {\n        return this.tracks;\n      }\n    }, {\n      key: \"audioTracks\",\n      get: function get() {\n        return this.tracksInGroup;\n      }\n    }, {\n      key: \"audioTrack\",\n      get: function get() {\n        return this.trackId;\n      },\n      set: function set(newId) {\n        // If audio track is selected from API then don't choose from the manifest default track\n        this.selectDefaultTrack = false;\n        this.setAudioTrack(newId);\n      }\n    }]);\n    return AudioTrackController;\n  }(BasePlaylistController);\n\n  var TICK_INTERVAL$1 = 500; // how often to tick in ms\n\n  var SubtitleStreamController = /*#__PURE__*/function (_BaseStreamController) {\n    _inheritsLoose(SubtitleStreamController, _BaseStreamController);\n    function SubtitleStreamController(hls, fragmentTracker, keyLoader) {\n      var _this;\n      _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, '[subtitle-stream-controller]', PlaylistLevelType.SUBTITLE) || this;\n      _this.currentTrackId = -1;\n      _this.tracksBuffered = [];\n      _this.mainDetails = null;\n      _this._registerListeners();\n      return _this;\n    }\n    var _proto = SubtitleStreamController.prototype;\n    _proto.onHandlerDestroying = function onHandlerDestroying() {\n      this._unregisterListeners();\n      _BaseStreamController.prototype.onHandlerDestroying.call(this);\n      this.mainDetails = null;\n    };\n    _proto._registerListeners = function _registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.on(Events.ERROR, this.onError, this);\n      hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n      hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n      hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n      hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    };\n    _proto._unregisterListeners = function _unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.off(Events.ERROR, this.onError, this);\n      hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n      hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n      hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n      hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    };\n    _proto.startLoad = function startLoad(startPosition) {\n      this.stopLoad();\n      this.state = State.IDLE;\n      this.setInterval(TICK_INTERVAL$1);\n      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n      this.tick();\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.mainDetails = null;\n      this.fragmentTracker.removeAllFragments();\n    };\n    _proto.onMediaDetaching = function onMediaDetaching() {\n      this.tracksBuffered = [];\n      _BaseStreamController.prototype.onMediaDetaching.call(this);\n    };\n    _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n      this.mainDetails = data.details;\n    };\n    _proto.onSubtitleFragProcessed = function onSubtitleFragProcessed(event, data) {\n      var frag = data.frag,\n        success = data.success;\n      this.fragPrevious = frag;\n      this.state = State.IDLE;\n      if (!success) {\n        return;\n      }\n      var buffered = this.tracksBuffered[this.currentTrackId];\n      if (!buffered) {\n        return;\n      }\n\n      // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo\n      // so we can re-use the logic used to detect how much has been buffered\n      var timeRange;\n      var fragStart = frag.start;\n      for (var i = 0; i < buffered.length; i++) {\n        if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {\n          timeRange = buffered[i];\n          break;\n        }\n      }\n      var fragEnd = frag.start + frag.duration;\n      if (timeRange) {\n        timeRange.end = fragEnd;\n      } else {\n        timeRange = {\n          start: fragStart,\n          end: fragEnd\n        };\n        buffered.push(timeRange);\n      }\n      this.fragmentTracker.fragBuffered(frag);\n      this.fragBufferedComplete(frag, null);\n    };\n    _proto.onBufferFlushing = function onBufferFlushing(event, data) {\n      var startOffset = data.startOffset,\n        endOffset = data.endOffset;\n      if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {\n        var endOffsetSubtitles = endOffset - 1;\n        if (endOffsetSubtitles <= 0) {\n          return;\n        }\n        data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);\n        this.tracksBuffered.forEach(function (buffered) {\n          for (var i = 0; i < buffered.length;) {\n            if (buffered[i].end <= endOffsetSubtitles) {\n              buffered.shift();\n              continue;\n            } else if (buffered[i].start < endOffsetSubtitles) {\n              buffered[i].start = endOffsetSubtitles;\n            } else {\n              break;\n            }\n            i++;\n          }\n        });\n        this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);\n      }\n    };\n    _proto.onFragBuffered = function onFragBuffered(event, data) {\n      if (!this.loadedmetadata && data.frag.type === PlaylistLevelType.MAIN) {\n        var _this$media;\n        if ((_this$media = this.media) != null && _this$media.buffered.length) {\n          this.loadedmetadata = true;\n        }\n      }\n    }\n\n    // If something goes wrong, proceed to next frag, if we were processing one.\n    ;\n    _proto.onError = function onError(event, data) {\n      var frag = data.frag;\n      if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {\n        if (data.details === ErrorDetails.FRAG_GAP) {\n          this.fragmentTracker.fragBuffered(frag, true);\n        }\n        if (this.fragCurrent) {\n          this.fragCurrent.abortRequests();\n        }\n        if (this.state !== State.STOPPED) {\n          this.state = State.IDLE;\n        }\n      }\n    }\n\n    // Got all new subtitle levels.\n    ;\n    _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, _ref) {\n      var _this2 = this;\n      var subtitleTracks = _ref.subtitleTracks;\n      if (this.levels && subtitleOptionsIdentical(this.levels, subtitleTracks)) {\n        this.levels = subtitleTracks.map(function (mediaPlaylist) {\n          return new Level(mediaPlaylist);\n        });\n        return;\n      }\n      this.tracksBuffered = [];\n      this.levels = subtitleTracks.map(function (mediaPlaylist) {\n        var level = new Level(mediaPlaylist);\n        _this2.tracksBuffered[level.id] = [];\n        return level;\n      });\n      this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);\n      this.fragPrevious = null;\n      this.mediaBuffer = null;\n    };\n    _proto.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(event, data) {\n      var _this$levels;\n      this.currentTrackId = data.id;\n      if (!((_this$levels = this.levels) != null && _this$levels.length) || this.currentTrackId === -1) {\n        this.clearInterval();\n        return;\n      }\n\n      // Check if track has the necessary details to load fragments\n      var currentTrack = this.levels[this.currentTrackId];\n      if (currentTrack != null && currentTrack.details) {\n        this.mediaBuffer = this.mediaBufferTimeRanges;\n      } else {\n        this.mediaBuffer = null;\n      }\n      if (currentTrack) {\n        this.setInterval(TICK_INTERVAL$1);\n      }\n    }\n\n    // Got a new set of subtitle fragments.\n    ;\n    _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {\n      var _track$details;\n      var currentTrackId = this.currentTrackId,\n        levels = this.levels;\n      var newDetails = data.details,\n        trackId = data.id;\n      if (!levels) {\n        this.warn(\"Subtitle tracks were reset while loading level \" + trackId);\n        return;\n      }\n      var track = levels[trackId];\n      if (trackId >= levels.length || !track) {\n        return;\n      }\n      this.log(\"Subtitle track \" + trackId + \" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"]\" + (newDetails.lastPartSn ? \"[part-\" + newDetails.lastPartSn + \"-\" + newDetails.lastPartIndex + \"]\" : '') + \",duration:\" + newDetails.totalduration);\n      this.mediaBuffer = this.mediaBufferTimeRanges;\n      var sliding = 0;\n      if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n        var mainDetails = this.mainDetails;\n        if (newDetails.deltaUpdateFailed || !mainDetails) {\n          return;\n        }\n        var mainSlidingStartFragment = mainDetails.fragments[0];\n        if (!track.details) {\n          if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n            alignMediaPlaylistByPDT(newDetails, mainDetails);\n            sliding = newDetails.fragments[0].start;\n          } else if (mainSlidingStartFragment) {\n            // line up live playlist with main so that fragments in range are loaded\n            sliding = mainSlidingStartFragment.start;\n            addSliding(newDetails, sliding);\n          }\n        } else {\n          var _this$levelLastLoaded;\n          sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n          if (sliding === 0 && mainSlidingStartFragment) {\n            // realign with main when there is no overlap with last refresh\n            sliding = mainSlidingStartFragment.start;\n            addSliding(newDetails, sliding);\n          }\n        }\n      }\n      track.details = newDetails;\n      this.levelLastLoaded = track;\n      if (trackId !== currentTrackId) {\n        return;\n      }\n      if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n        this.setStartPosition(this.mainDetails || newDetails, sliding);\n      }\n\n      // trigger handler right now\n      this.tick();\n\n      // If playlist is misaligned because of bad PDT or drift, delete details to resync with main on reload\n      if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {\n        var foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);\n        if (!foundFrag) {\n          this.warn('Subtitle playlist not aligned with playback');\n          track.details = undefined;\n        }\n      }\n    };\n    _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {\n      var _this3 = this;\n      var frag = fragLoadedData.frag,\n        payload = fragLoadedData.payload;\n      var decryptData = frag.decryptdata;\n      var hls = this.hls;\n      if (this.fragContextChanged(frag)) {\n        return;\n      }\n      // check to see if the payload needs to be decrypted\n      if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n        var startTime = performance.now();\n        // decrypt the subtitles\n        this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(function (err) {\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_DECRYPT_ERROR,\n            fatal: false,\n            error: err,\n            reason: err.message,\n            frag: frag\n          });\n          throw err;\n        }).then(function (decryptedData) {\n          var endTime = performance.now();\n          hls.trigger(Events.FRAG_DECRYPTED, {\n            frag: frag,\n            payload: decryptedData,\n            stats: {\n              tstart: startTime,\n              tdecrypt: endTime\n            }\n          });\n        }).catch(function (err) {\n          _this3.warn(err.name + \": \" + err.message);\n          _this3.state = State.IDLE;\n        });\n      }\n    };\n    _proto.doTick = function doTick() {\n      if (!this.media) {\n        this.state = State.IDLE;\n        return;\n      }\n      if (this.state === State.IDLE) {\n        var currentTrackId = this.currentTrackId,\n          levels = this.levels;\n        var track = levels == null ? void 0 : levels[currentTrackId];\n        if (!track || !levels.length || !track.details) {\n          return;\n        }\n        var config = this.config;\n        var currentTime = this.getLoadPosition();\n        var bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);\n        var targetBufferTime = bufferedInfo.end,\n          bufferLen = bufferedInfo.len;\n        var mainBufferInfo = this.getFwdBufferInfo(this.media, PlaylistLevelType.MAIN);\n        var trackDetails = track.details;\n        var maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len) + trackDetails.levelTargetDuration;\n        if (bufferLen > maxBufLen) {\n          return;\n        }\n        var fragments = trackDetails.fragments;\n        var fragLen = fragments.length;\n        var end = trackDetails.edge;\n        var foundFrag = null;\n        var fragPrevious = this.fragPrevious;\n        if (targetBufferTime < end) {\n          var tolerance = config.maxFragLookUpTolerance;\n          var lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;\n          foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);\n          if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {\n            foundFrag = fragments[0];\n          }\n        } else {\n          foundFrag = fragments[fragLen - 1];\n        }\n        if (!foundFrag) {\n          return;\n        }\n        foundFrag = this.mapToInitFragWhenRequired(foundFrag);\n        if (foundFrag.sn !== 'initSegment') {\n          // Load earlier fragment in same discontinuity to make up for misaligned playlists and cues that extend beyond end of segment\n          var curSNIdx = foundFrag.sn - trackDetails.startSN;\n          var prevFrag = fragments[curSNIdx - 1];\n          if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {\n            foundFrag = prevFrag;\n          }\n        }\n        if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {\n          // only load if fragment is not loaded\n          this.loadFragment(foundFrag, track, targetBufferTime);\n        }\n      }\n    };\n    _proto.getMaxBufferLength = function getMaxBufferLength(mainBufferLength) {\n      var maxConfigBuffer = _BaseStreamController.prototype.getMaxBufferLength.call(this);\n      if (!mainBufferLength) {\n        return maxConfigBuffer;\n      }\n      return Math.max(maxConfigBuffer, mainBufferLength);\n    };\n    _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {\n      this.fragCurrent = frag;\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag, level);\n      } else {\n        this.startFragRequested = true;\n        _BaseStreamController.prototype.loadFragment.call(this, frag, level, targetBufferTime);\n      }\n    };\n    _createClass(SubtitleStreamController, [{\n      key: \"mediaBufferTimeRanges\",\n      get: function get() {\n        return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);\n      }\n    }]);\n    return SubtitleStreamController;\n  }(BaseStreamController);\n  var BufferableInstance = function BufferableInstance(timeranges) {\n    this.buffered = void 0;\n    var getRange = function getRange(name, index, length) {\n      index = index >>> 0;\n      if (index > length - 1) {\n        throw new DOMException(\"Failed to execute '\" + name + \"' on 'TimeRanges': The index provided (\" + index + \") is greater than the maximum bound (\" + length + \")\");\n      }\n      return timeranges[index][name];\n    };\n    this.buffered = {\n      get length() {\n        return timeranges.length;\n      },\n      end: function end(index) {\n        return getRange('end', index, timeranges.length);\n      },\n      start: function start(index) {\n        return getRange('start', index, timeranges.length);\n      }\n    };\n  };\n\n  var SubtitleTrackController = /*#__PURE__*/function (_BasePlaylistControll) {\n    _inheritsLoose(SubtitleTrackController, _BasePlaylistControll);\n    function SubtitleTrackController(hls) {\n      var _this;\n      _this = _BasePlaylistControll.call(this, hls, '[subtitle-track-controller]') || this;\n      _this.media = null;\n      _this.tracks = [];\n      _this.groupIds = null;\n      _this.tracksInGroup = [];\n      _this.trackId = -1;\n      _this.currentTrack = null;\n      _this.selectDefaultTrack = true;\n      _this.queuedDefaultTrack = -1;\n      _this.asyncPollTrackChange = function () {\n        return _this.pollTrackChange(0);\n      };\n      _this.useTextTrackPolling = false;\n      _this.subtitlePollingInterval = -1;\n      _this._subtitleDisplay = true;\n      _this.onTextTracksChanged = function () {\n        if (!_this.useTextTrackPolling) {\n          self.clearInterval(_this.subtitlePollingInterval);\n        }\n        // Media is undefined when switching streams via loadSource()\n        if (!_this.media || !_this.hls.config.renderTextTracksNatively) {\n          return;\n        }\n        var textTrack = null;\n        var tracks = filterSubtitleTracks(_this.media.textTracks);\n        for (var i = 0; i < tracks.length; i++) {\n          if (tracks[i].mode === 'hidden') {\n            // Do not break in case there is a following track with showing.\n            textTrack = tracks[i];\n          } else if (tracks[i].mode === 'showing') {\n            textTrack = tracks[i];\n            break;\n          }\n        }\n\n        // Find internal track index for TextTrack\n        var trackId = _this.findTrackForTextTrack(textTrack);\n        if (_this.subtitleTrack !== trackId) {\n          _this.setSubtitleTrack(trackId);\n        }\n      };\n      _this.registerListeners();\n      return _this;\n    }\n    var _proto = SubtitleTrackController.prototype;\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.tracks.length = 0;\n      this.tracksInGroup.length = 0;\n      this.currentTrack = null;\n      this.onTextTracksChanged = this.asyncPollTrackChange = null;\n      _BasePlaylistControll.prototype.destroy.call(this);\n    };\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n      hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n      hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n      hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n      hls.off(Events.ERROR, this.onError, this);\n    }\n\n    // Listen for subtitle track change, then extract the current track ID.\n    ;\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      this.media = data.media;\n      if (!this.media) {\n        return;\n      }\n      if (this.queuedDefaultTrack > -1) {\n        this.subtitleTrack = this.queuedDefaultTrack;\n        this.queuedDefaultTrack = -1;\n      }\n      this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);\n      if (this.useTextTrackPolling) {\n        this.pollTrackChange(500);\n      } else {\n        this.media.textTracks.addEventListener('change', this.asyncPollTrackChange);\n      }\n    };\n    _proto.pollTrackChange = function pollTrackChange(timeout) {\n      self.clearInterval(this.subtitlePollingInterval);\n      this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, timeout);\n    };\n    _proto.onMediaDetaching = function onMediaDetaching() {\n      if (!this.media) {\n        return;\n      }\n      self.clearInterval(this.subtitlePollingInterval);\n      if (!this.useTextTrackPolling) {\n        this.media.textTracks.removeEventListener('change', this.asyncPollTrackChange);\n      }\n      if (this.trackId > -1) {\n        this.queuedDefaultTrack = this.trackId;\n      }\n      var textTracks = filterSubtitleTracks(this.media.textTracks);\n      // Clear loaded cues on media detachment from tracks\n      textTracks.forEach(function (track) {\n        clearCurrentCues(track);\n      });\n      // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.\n      this.subtitleTrack = -1;\n      this.media = null;\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.tracks = [];\n      this.groupIds = null;\n      this.tracksInGroup = [];\n      this.trackId = -1;\n      this.currentTrack = null;\n      this.selectDefaultTrack = true;\n    }\n\n    // Fired whenever a new manifest is loaded.\n    ;\n    _proto.onManifestParsed = function onManifestParsed(event, data) {\n      this.tracks = data.subtitleTracks;\n    };\n    _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {\n      var id = data.id,\n        groupId = data.groupId,\n        details = data.details;\n      var trackInActiveGroup = this.tracksInGroup[id];\n      if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n        this.warn(\"Subtitle track with id:\" + id + \" and group:\" + groupId + \" not found in active group \" + (trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId));\n        return;\n      }\n      var curDetails = trackInActiveGroup.details;\n      trackInActiveGroup.details = data.details;\n      this.log(\"Subtitle track \" + id + \" \\\"\" + trackInActiveGroup.name + \"\\\" lang:\" + trackInActiveGroup.lang + \" group:\" + groupId + \" loaded [\" + details.startSN + \"-\" + details.endSN + \"]\");\n      if (id === this.trackId) {\n        this.playlistLoaded(id, data, curDetails);\n      }\n    };\n    _proto.onLevelLoading = function onLevelLoading(event, data) {\n      this.switchLevel(data.level);\n    };\n    _proto.onLevelSwitching = function onLevelSwitching(event, data) {\n      this.switchLevel(data.level);\n    };\n    _proto.switchLevel = function switchLevel(levelIndex) {\n      var levelInfo = this.hls.levels[levelIndex];\n      if (!levelInfo) {\n        return;\n      }\n      var subtitleGroups = levelInfo.subtitleGroups || null;\n      var currentGroups = this.groupIds;\n      var currentTrack = this.currentTrack;\n      if (!subtitleGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (subtitleGroups == null ? void 0 : subtitleGroups.length) || subtitleGroups != null && subtitleGroups.some(function (groupId) {\n        return (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1;\n      })) {\n        this.groupIds = subtitleGroups;\n        this.trackId = -1;\n        this.currentTrack = null;\n        var subtitleTracks = this.tracks.filter(function (track) {\n          return !subtitleGroups || subtitleGroups.indexOf(track.groupId) !== -1;\n        });\n        if (subtitleTracks.length) {\n          // Disable selectDefaultTrack if there are no default tracks\n          if (this.selectDefaultTrack && !subtitleTracks.some(function (track) {\n            return track.default;\n          })) {\n            this.selectDefaultTrack = false;\n          }\n          // track.id should match hls.audioTracks index\n          subtitleTracks.forEach(function (track, i) {\n            track.id = i;\n          });\n        } else if (!currentTrack && !this.tracksInGroup.length) {\n          // Do not dispatch SUBTITLE_TRACKS_UPDATED when there were and are no tracks\n          return;\n        }\n        this.tracksInGroup = subtitleTracks;\n\n        // Find preferred track\n        var subtitlePreference = this.hls.config.subtitlePreference;\n        if (!currentTrack && subtitlePreference) {\n          this.selectDefaultTrack = false;\n          var groupIndex = findMatchingOption(subtitlePreference, subtitleTracks);\n          if (groupIndex > -1) {\n            currentTrack = subtitleTracks[groupIndex];\n          } else {\n            var allIndex = findMatchingOption(subtitlePreference, this.tracks);\n            currentTrack = this.tracks[allIndex];\n          }\n        }\n\n        // Select initial track\n        var trackId = this.findTrackId(currentTrack);\n        if (trackId === -1 && currentTrack) {\n          trackId = this.findTrackId(null);\n        }\n\n        // Dispatch events and load track if needed\n        var subtitleTracksUpdated = {\n          subtitleTracks: subtitleTracks\n        };\n        this.log(\"Updating subtitle tracks, \" + subtitleTracks.length + \" track(s) found in \\\"\" + (subtitleGroups == null ? void 0 : subtitleGroups.join(',')) + \"\\\" group-id\");\n        this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);\n        if (trackId !== -1 && this.trackId === -1) {\n          this.setSubtitleTrack(trackId);\n        }\n      } else if (this.shouldReloadPlaylist(currentTrack)) {\n        // Retry playlist loading if no playlist is or has been loaded yet\n        this.setSubtitleTrack(this.trackId);\n      }\n    };\n    _proto.findTrackId = function findTrackId(currentTrack) {\n      var tracks = this.tracksInGroup;\n      var selectDefault = this.selectDefaultTrack;\n      for (var i = 0; i < tracks.length; i++) {\n        var track = tracks[i];\n        if (selectDefault && !track.default || !selectDefault && !currentTrack) {\n          continue;\n        }\n        if (!currentTrack || matchesOption(track, currentTrack)) {\n          return i;\n        }\n      }\n      if (currentTrack) {\n        for (var _i = 0; _i < tracks.length; _i++) {\n          var _track = tracks[_i];\n          if (mediaAttributesIdentical(currentTrack.attrs, _track.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) {\n            return _i;\n          }\n        }\n        for (var _i2 = 0; _i2 < tracks.length; _i2++) {\n          var _track2 = tracks[_i2];\n          if (mediaAttributesIdentical(currentTrack.attrs, _track2.attrs, ['LANGUAGE'])) {\n            return _i2;\n          }\n        }\n      }\n      return -1;\n    };\n    _proto.findTrackForTextTrack = function findTrackForTextTrack(textTrack) {\n      if (textTrack) {\n        var tracks = this.tracksInGroup;\n        for (var i = 0; i < tracks.length; i++) {\n          var track = tracks[i];\n          if (subtitleTrackMatchesTextTrack(track, textTrack)) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    _proto.onError = function onError(event, data) {\n      if (data.fatal || !data.context) {\n        return;\n      }\n      if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n        this.checkRetry(data);\n      }\n    };\n    _proto.setSubtitleOption = function setSubtitleOption(subtitleOption) {\n      this.hls.config.subtitlePreference = subtitleOption;\n      if (subtitleOption) {\n        var allSubtitleTracks = this.allSubtitleTracks;\n        this.selectDefaultTrack = false;\n        if (allSubtitleTracks.length) {\n          // First see if current option matches (no switch op)\n          var currentTrack = this.currentTrack;\n          if (currentTrack && matchesOption(subtitleOption, currentTrack)) {\n            return currentTrack;\n          }\n          // Find option in current group\n          var groupIndex = findMatchingOption(subtitleOption, this.tracksInGroup);\n          if (groupIndex > -1) {\n            var track = this.tracksInGroup[groupIndex];\n            this.setSubtitleTrack(groupIndex);\n            return track;\n          } else if (currentTrack) {\n            // If this is not the initial selection return null\n            // option should have matched one in active group\n            return null;\n          } else {\n            // Find the option in all tracks for initial selection\n            var allIndex = findMatchingOption(subtitleOption, allSubtitleTracks);\n            if (allIndex > -1) {\n              return allSubtitleTracks[allIndex];\n            }\n          }\n        }\n      }\n      return null;\n    };\n    _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n      _BasePlaylistControll.prototype.loadPlaylist.call(this);\n      var currentTrack = this.currentTrack;\n      if (this.shouldLoadPlaylist(currentTrack) && currentTrack) {\n        var id = currentTrack.id;\n        var groupId = currentTrack.groupId;\n        var url = currentTrack.url;\n        if (hlsUrlParameters) {\n          try {\n            url = hlsUrlParameters.addDirectives(url);\n          } catch (error) {\n            this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n          }\n        }\n        this.log(\"Loading subtitle playlist for id \" + id);\n        this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {\n          url: url,\n          id: id,\n          groupId: groupId,\n          deliveryDirectives: hlsUrlParameters || null\n        });\n      }\n    }\n\n    /**\n     * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.\n     * This operates on the DOM textTracks.\n     * A value of -1 will disable all subtitle tracks.\n     */;\n    _proto.toggleTrackModes = function toggleTrackModes() {\n      var media = this.media;\n      if (!media) {\n        return;\n      }\n      var textTracks = filterSubtitleTracks(media.textTracks);\n      var currentTrack = this.currentTrack;\n      var nextTrack;\n      if (currentTrack) {\n        nextTrack = textTracks.filter(function (textTrack) {\n          return subtitleTrackMatchesTextTrack(currentTrack, textTrack);\n        })[0];\n        if (!nextTrack) {\n          this.warn(\"Unable to find subtitle TextTrack with name \\\"\" + currentTrack.name + \"\\\" and language \\\"\" + currentTrack.lang + \"\\\"\");\n        }\n      }\n      [].slice.call(textTracks).forEach(function (track) {\n        if (track.mode !== 'disabled' && track !== nextTrack) {\n          track.mode = 'disabled';\n        }\n      });\n      if (nextTrack) {\n        var mode = this.subtitleDisplay ? 'showing' : 'hidden';\n        if (nextTrack.mode !== mode) {\n          nextTrack.mode = mode;\n        }\n      }\n    }\n\n    /**\n     * This method is responsible for validating the subtitle index and periodically reloading if live.\n     * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.\n     */;\n    _proto.setSubtitleTrack = function setSubtitleTrack(newId) {\n      var tracks = this.tracksInGroup;\n\n      // setting this.subtitleTrack will trigger internal logic\n      // if media has not been attached yet, it will fail\n      // we keep a reference to the default track id\n      // and we'll set subtitleTrack when onMediaAttached is triggered\n      if (!this.media) {\n        this.queuedDefaultTrack = newId;\n        return;\n      }\n\n      // exit if track id as already set or invalid\n      if (newId < -1 || newId >= tracks.length || !isFiniteNumber(newId)) {\n        this.warn(\"Invalid subtitle track id: \" + newId);\n        return;\n      }\n\n      // stopping live reloading timer if any\n      this.clearTimer();\n      this.selectDefaultTrack = false;\n      var lastTrack = this.currentTrack;\n      var track = tracks[newId] || null;\n      this.trackId = newId;\n      this.currentTrack = track;\n      this.toggleTrackModes();\n      if (!track) {\n        // switch to -1\n        this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n          id: newId\n        });\n        return;\n      }\n      var trackLoaded = !!track.details && !track.details.live;\n      if (newId === this.trackId && track === lastTrack && trackLoaded) {\n        return;\n      }\n      this.log(\"Switching to subtitle-track \" + newId + (track ? \" \\\"\" + track.name + \"\\\" lang:\" + track.lang + \" group:\" + track.groupId : ''));\n      var id = track.id,\n        _track$groupId = track.groupId,\n        groupId = _track$groupId === void 0 ? '' : _track$groupId,\n        name = track.name,\n        type = track.type,\n        url = track.url;\n      this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n        id: id,\n        groupId: groupId,\n        name: name,\n        type: type,\n        url: url\n      });\n      var hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);\n      this.loadPlaylist(hlsUrlParameters);\n    };\n    _createClass(SubtitleTrackController, [{\n      key: \"subtitleDisplay\",\n      get: function get() {\n        return this._subtitleDisplay;\n      },\n      set: function set(value) {\n        this._subtitleDisplay = value;\n        if (this.trackId > -1) {\n          this.toggleTrackModes();\n        }\n      }\n    }, {\n      key: \"allSubtitleTracks\",\n      get: function get() {\n        return this.tracks;\n      }\n\n      /** get alternate subtitle tracks list from playlist **/\n    }, {\n      key: \"subtitleTracks\",\n      get: function get() {\n        return this.tracksInGroup;\n      }\n\n      /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/\n    }, {\n      key: \"subtitleTrack\",\n      get: function get() {\n        return this.trackId;\n      },\n      set: function set(newId) {\n        this.selectDefaultTrack = false;\n        this.setSubtitleTrack(newId);\n      }\n    }]);\n    return SubtitleTrackController;\n  }(BasePlaylistController);\n\n  var BufferOperationQueue = /*#__PURE__*/function () {\n    function BufferOperationQueue(sourceBufferReference) {\n      this.buffers = void 0;\n      this.queues = {\n        video: [],\n        audio: [],\n        audiovideo: []\n      };\n      this.buffers = sourceBufferReference;\n    }\n    var _proto = BufferOperationQueue.prototype;\n    _proto.append = function append(operation, type, pending) {\n      var queue = this.queues[type];\n      queue.push(operation);\n      if (queue.length === 1 && !pending) {\n        this.executeNext(type);\n      }\n    };\n    _proto.insertAbort = function insertAbort(operation, type) {\n      var queue = this.queues[type];\n      queue.unshift(operation);\n      this.executeNext(type);\n    };\n    _proto.appendBlocker = function appendBlocker(type) {\n      var execute;\n      var promise = new Promise(function (resolve) {\n        execute = resolve;\n      });\n      var operation = {\n        execute: execute,\n        onStart: function onStart() {},\n        onComplete: function onComplete() {},\n        onError: function onError() {}\n      };\n      this.append(operation, type);\n      return promise;\n    };\n    _proto.executeNext = function executeNext(type) {\n      var queue = this.queues[type];\n      if (queue.length) {\n        var operation = queue[0];\n        try {\n          // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n          // which do not end with this event must call _onSBUpdateEnd manually\n          operation.execute();\n        } catch (error) {\n          logger.warn(\"[buffer-operation-queue]: Exception executing \\\"\" + type + \"\\\" SourceBuffer operation: \" + error);\n          operation.onError(error);\n\n          // Only shift the current operation off, otherwise the updateend handler will do this for us\n          var sb = this.buffers[type];\n          if (!(sb != null && sb.updating)) {\n            this.shiftAndExecuteNext(type);\n          }\n        }\n      }\n    };\n    _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {\n      this.queues[type].shift();\n      this.executeNext(type);\n    };\n    _proto.current = function current(type) {\n      return this.queues[type][0];\n    };\n    return BufferOperationQueue;\n  }();\n\n  var VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\\.[^.,]+)+/;\n  var BufferController = /*#__PURE__*/function () {\n    function BufferController(hls) {\n      var _this = this;\n      // The level details used to determine duration, target-duration and live\n      this.details = null;\n      // cache the self generated object url to detect hijack of video tag\n      this._objectUrl = null;\n      // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n      this.operationQueue = void 0;\n      // References to event listeners for each SourceBuffer, so that they can be referenced for event removal\n      this.listeners = void 0;\n      this.hls = void 0;\n      // The number of BUFFER_CODEC events received before any sourceBuffers are created\n      this.bufferCodecEventsExpected = 0;\n      // The total number of BUFFER_CODEC events received\n      this._bufferCodecEventsTotal = 0;\n      // A reference to the attached media element\n      this.media = null;\n      // A reference to the active media source\n      this.mediaSource = null;\n      // Last MP3 audio chunk appended\n      this.lastMpegAudioChunk = null;\n      this.appendSource = void 0;\n      // counters\n      this.appendErrors = {\n        audio: 0,\n        video: 0,\n        audiovideo: 0\n      };\n      this.tracks = {};\n      this.pendingTracks = {};\n      this.sourceBuffer = void 0;\n      this.log = void 0;\n      this.warn = void 0;\n      this.error = void 0;\n      this._onEndStreaming = function (event) {\n        if (!_this.hls) {\n          return;\n        }\n        _this.hls.pauseBuffering();\n      };\n      this._onStartStreaming = function (event) {\n        if (!_this.hls) {\n          return;\n        }\n        _this.hls.resumeBuffering();\n      };\n      // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n      this._onMediaSourceOpen = function () {\n        var media = _this.media,\n          mediaSource = _this.mediaSource;\n        _this.log('Media source opened');\n        if (media) {\n          media.removeEventListener('emptied', _this._onMediaEmptied);\n          _this.updateMediaElementDuration();\n          _this.hls.trigger(Events.MEDIA_ATTACHED, {\n            media: media,\n            mediaSource: mediaSource\n          });\n        }\n        if (mediaSource) {\n          // once received, don't listen anymore to sourceopen event\n          mediaSource.removeEventListener('sourceopen', _this._onMediaSourceOpen);\n        }\n        _this.checkPendingTracks();\n      };\n      this._onMediaSourceClose = function () {\n        _this.log('Media source closed');\n      };\n      this._onMediaSourceEnded = function () {\n        _this.log('Media source ended');\n      };\n      this._onMediaEmptied = function () {\n        var mediaSrc = _this.mediaSrc,\n          _objectUrl = _this._objectUrl;\n        if (mediaSrc !== _objectUrl) {\n          logger.error(\"Media element src was set while attaching MediaSource (\" + _objectUrl + \" > \" + mediaSrc + \")\");\n        }\n      };\n      this.hls = hls;\n      var logPrefix = '[buffer-controller]';\n      this.appendSource = isManagedMediaSource(getMediaSource(hls.config.preferManagedMediaSource));\n      this.log = logger.log.bind(logger, logPrefix);\n      this.warn = logger.warn.bind(logger, logPrefix);\n      this.error = logger.error.bind(logger, logPrefix);\n      this._initSourceBuffer();\n      this.registerListeners();\n    }\n    var _proto = BufferController.prototype;\n    _proto.hasSourceTypes = function hasSourceTypes() {\n      return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n    };\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.details = null;\n      this.lastMpegAudioChunk = null;\n      // @ts-ignore\n      this.hls = null;\n    };\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n      hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n      hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n      hls.on(Events.BUFFER_EOS, this.onBufferEos, this);\n      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      hls.on(Events.FRAG_PARSED, this.onFragParsed, this);\n      hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n      hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n      hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n      hls.off(Events.BUFFER_EOS, this.onBufferEos, this);\n      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n      hls.off(Events.FRAG_PARSED, this.onFragParsed, this);\n      hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);\n    };\n    _proto._initSourceBuffer = function _initSourceBuffer() {\n      this.sourceBuffer = {};\n      this.operationQueue = new BufferOperationQueue(this.sourceBuffer);\n      this.listeners = {\n        audio: [],\n        video: [],\n        audiovideo: []\n      };\n      this.appendErrors = {\n        audio: 0,\n        video: 0,\n        audiovideo: 0\n      };\n      this.lastMpegAudioChunk = null;\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;\n      this.details = null;\n    };\n    _proto.onManifestParsed = function onManifestParsed(event, data) {\n      // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n      // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n      // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n      // it will contain the expected nb of source buffers, no need to compute it\n      var codecEvents = 2;\n      if (data.audio && !data.video || !data.altAudio || !true) {\n        codecEvents = 1;\n      }\n      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;\n      this.log(this.bufferCodecEventsExpected + \" bufferCodec event(s) expected\");\n    };\n    _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n      var media = this.media = data.media;\n      var MediaSource = getMediaSource(this.appendSource);\n      if (media && MediaSource) {\n        var _ms$constructor;\n        var ms = this.mediaSource = new MediaSource();\n        this.log(\"created media source: \" + ((_ms$constructor = ms.constructor) == null ? void 0 : _ms$constructor.name));\n        // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n        ms.addEventListener('sourceopen', this._onMediaSourceOpen);\n        ms.addEventListener('sourceended', this._onMediaSourceEnded);\n        ms.addEventListener('sourceclose', this._onMediaSourceClose);\n        if (this.appendSource) {\n          ms.addEventListener('startstreaming', this._onStartStreaming);\n          ms.addEventListener('endstreaming', this._onEndStreaming);\n        }\n\n        // cache the locally generated object url\n        var objectUrl = this._objectUrl = self.URL.createObjectURL(ms);\n        // link video and media Source\n        if (this.appendSource) {\n          try {\n            media.removeAttribute('src');\n            // ManagedMediaSource will not open without disableRemotePlayback set to false or source alternatives\n            var MMS = self.ManagedMediaSource;\n            media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;\n            removeSourceChildren(media);\n            addSource(media, objectUrl);\n            media.load();\n          } catch (error) {\n            media.src = objectUrl;\n          }\n        } else {\n          media.src = objectUrl;\n        }\n        media.addEventListener('emptied', this._onMediaEmptied);\n      }\n    };\n    _proto.onMediaDetaching = function onMediaDetaching() {\n      var media = this.media,\n        mediaSource = this.mediaSource,\n        _objectUrl = this._objectUrl;\n      if (mediaSource) {\n        this.log('media source detaching');\n        if (mediaSource.readyState === 'open') {\n          try {\n            // endOfStream could trigger exception if any sourcebuffer is in updating state\n            // we don't really care about checking sourcebuffer state here,\n            // as we are anyway detaching the MediaSource\n            // let's just avoid this exception to propagate\n            mediaSource.endOfStream();\n          } catch (err) {\n            this.warn(\"onMediaDetaching: \" + err.message + \" while calling endOfStream\");\n          }\n        }\n        // Clean up the SourceBuffers by invoking onBufferReset\n        this.onBufferReset();\n        mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n        mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);\n        mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose);\n        if (this.appendSource) {\n          mediaSource.removeEventListener('startstreaming', this._onStartStreaming);\n          mediaSource.removeEventListener('endstreaming', this._onEndStreaming);\n        }\n\n        // Detach properly the MediaSource from the HTMLMediaElement as\n        // suggested in https://github.com/w3c/media-source/issues/53.\n        if (media) {\n          media.removeEventListener('emptied', this._onMediaEmptied);\n          if (_objectUrl) {\n            self.URL.revokeObjectURL(_objectUrl);\n          }\n\n          // clean up video tag src only if it's our own url. some external libraries might\n          // hijack the video tag and change its 'src' without destroying the Hls instance first\n          if (this.mediaSrc === _objectUrl) {\n            media.removeAttribute('src');\n            if (this.appendSource) {\n              removeSourceChildren(media);\n            }\n            media.load();\n          } else {\n            this.warn('media|source.src was changed by a third party - skip cleanup');\n          }\n        }\n        this.mediaSource = null;\n        this.media = null;\n        this._objectUrl = null;\n        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;\n        this.pendingTracks = {};\n        this.tracks = {};\n      }\n      this.hls.trigger(Events.MEDIA_DETACHED, undefined);\n    };\n    _proto.onBufferReset = function onBufferReset() {\n      var _this2 = this;\n      this.getSourceBufferTypes().forEach(function (type) {\n        _this2.resetBuffer(type);\n      });\n      this._initSourceBuffer();\n    };\n    _proto.resetBuffer = function resetBuffer(type) {\n      var sb = this.sourceBuffer[type];\n      try {\n        if (sb) {\n          var _this$mediaSource;\n          this.removeBufferListeners(type);\n          // Synchronously remove the SB from the map before the next call in order to prevent an async function from\n          // accessing it\n          this.sourceBuffer[type] = undefined;\n          if ((_this$mediaSource = this.mediaSource) != null && _this$mediaSource.sourceBuffers.length) {\n            this.mediaSource.removeSourceBuffer(sb);\n          }\n        }\n      } catch (err) {\n        this.warn(\"onBufferReset \" + type, err);\n      }\n    };\n    _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n      var _this3 = this;\n      var sourceBufferCount = this.getSourceBufferTypes().length;\n      var trackNames = Object.keys(data);\n      trackNames.forEach(function (trackName) {\n        if (sourceBufferCount) {\n          // check if SourceBuffer codec needs to change\n          var track = _this3.tracks[trackName];\n          if (track && typeof track.buffer.changeType === 'function') {\n            var _trackCodec;\n            var _data$trackName = data[trackName],\n              id = _data$trackName.id,\n              codec = _data$trackName.codec,\n              levelCodec = _data$trackName.levelCodec,\n              container = _data$trackName.container,\n              metadata = _data$trackName.metadata;\n            var currentCodecFull = pickMostCompleteCodecName(track.codec, track.levelCodec);\n            var currentCodec = currentCodecFull == null ? void 0 : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');\n            var trackCodec = pickMostCompleteCodecName(codec, levelCodec);\n            var nextCodec = (_trackCodec = trackCodec) == null ? void 0 : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');\n            if (trackCodec && currentCodec !== nextCodec) {\n              if (trackName.slice(0, 5) === 'audio') {\n                trackCodec = getCodecCompatibleName(trackCodec, _this3.appendSource);\n              }\n              var mimeType = container + \";codecs=\" + trackCodec;\n              _this3.appendChangeType(trackName, mimeType);\n              _this3.log(\"switching codec \" + currentCodecFull + \" to \" + trackCodec);\n              _this3.tracks[trackName] = {\n                buffer: track.buffer,\n                codec: codec,\n                container: container,\n                levelCodec: levelCodec,\n                metadata: metadata,\n                id: id\n              };\n            }\n          }\n        } else {\n          // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n          _this3.pendingTracks[trackName] = data[trackName];\n        }\n      });\n\n      // if sourcebuffers already created, do nothing ...\n      if (sourceBufferCount) {\n        return;\n      }\n      var bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);\n      if (this.bufferCodecEventsExpected !== bufferCodecEventsExpected) {\n        this.log(bufferCodecEventsExpected + \" bufferCodec event(s) expected \" + trackNames.join(','));\n        this.bufferCodecEventsExpected = bufferCodecEventsExpected;\n      }\n      if (this.mediaSource && this.mediaSource.readyState === 'open') {\n        this.checkPendingTracks();\n      }\n    };\n    _proto.appendChangeType = function appendChangeType(type, mimeType) {\n      var _this4 = this;\n      var operationQueue = this.operationQueue;\n      var operation = {\n        execute: function execute() {\n          var sb = _this4.sourceBuffer[type];\n          if (sb) {\n            _this4.log(\"changing \" + type + \" sourceBuffer type to \" + mimeType);\n            sb.changeType(mimeType);\n          }\n          operationQueue.shiftAndExecuteNext(type);\n        },\n        onStart: function onStart() {},\n        onComplete: function onComplete() {},\n        onError: function onError(error) {\n          _this4.warn(\"Failed to change \" + type + \" SourceBuffer type\", error);\n        }\n      };\n      operationQueue.append(operation, type, !!this.pendingTracks[type]);\n    };\n    _proto.onBufferAppending = function onBufferAppending(event, eventData) {\n      var _this5 = this;\n      var hls = this.hls,\n        operationQueue = this.operationQueue,\n        tracks = this.tracks;\n      var data = eventData.data,\n        type = eventData.type,\n        frag = eventData.frag,\n        part = eventData.part,\n        chunkMeta = eventData.chunkMeta;\n      var chunkStats = chunkMeta.buffering[type];\n      var bufferAppendingStart = self.performance.now();\n      chunkStats.start = bufferAppendingStart;\n      var fragBuffering = frag.stats.buffering;\n      var partBuffering = part ? part.stats.buffering : null;\n      if (fragBuffering.start === 0) {\n        fragBuffering.start = bufferAppendingStart;\n      }\n      if (partBuffering && partBuffering.start === 0) {\n        partBuffering.start = bufferAppendingStart;\n      }\n\n      // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n      // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n      // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n      // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n      // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n      var audioTrack = tracks.audio;\n      var checkTimestampOffset = false;\n      if (type === 'audio' && (audioTrack == null ? void 0 : audioTrack.container) === 'audio/mpeg') {\n        checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;\n        this.lastMpegAudioChunk = chunkMeta;\n      }\n      var fragStart = frag.start;\n      var operation = {\n        execute: function execute() {\n          chunkStats.executeStart = self.performance.now();\n          if (checkTimestampOffset) {\n            var sb = _this5.sourceBuffer[type];\n            if (sb) {\n              var delta = fragStart - sb.timestampOffset;\n              if (Math.abs(delta) >= 0.1) {\n                _this5.log(\"Updating audio SourceBuffer timestampOffset to \" + fragStart + \" (delta: \" + delta + \") sn: \" + frag.sn + \")\");\n                sb.timestampOffset = fragStart;\n              }\n            }\n          }\n          _this5.appendExecutor(data, type);\n        },\n        onStart: function onStart() {\n          // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n        },\n        onComplete: function onComplete() {\n          // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n          var end = self.performance.now();\n          chunkStats.executeEnd = chunkStats.end = end;\n          if (fragBuffering.first === 0) {\n            fragBuffering.first = end;\n          }\n          if (partBuffering && partBuffering.first === 0) {\n            partBuffering.first = end;\n          }\n          var sourceBuffer = _this5.sourceBuffer;\n          var timeRanges = {};\n          for (var _type in sourceBuffer) {\n            timeRanges[_type] = BufferHelper.getBuffered(sourceBuffer[_type]);\n          }\n          _this5.appendErrors[type] = 0;\n          if (type === 'audio' || type === 'video') {\n            _this5.appendErrors.audiovideo = 0;\n          } else {\n            _this5.appendErrors.audio = 0;\n            _this5.appendErrors.video = 0;\n          }\n          _this5.hls.trigger(Events.BUFFER_APPENDED, {\n            type: type,\n            frag: frag,\n            part: part,\n            chunkMeta: chunkMeta,\n            parent: frag.type,\n            timeRanges: timeRanges\n          });\n        },\n        onError: function onError(error) {\n          // in case any error occured while appending, put back segment in segments table\n          var event = {\n            type: ErrorTypes.MEDIA_ERROR,\n            parent: frag.type,\n            details: ErrorDetails.BUFFER_APPEND_ERROR,\n            sourceBufferName: type,\n            frag: frag,\n            part: part,\n            chunkMeta: chunkMeta,\n            error: error,\n            err: error,\n            fatal: false\n          };\n          if (error.code === DOMException.QUOTA_EXCEEDED_ERR) {\n            // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n            // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n            event.details = ErrorDetails.BUFFER_FULL_ERROR;\n          } else {\n            var appendErrorCount = ++_this5.appendErrors[type];\n            event.details = ErrorDetails.BUFFER_APPEND_ERROR;\n            /* with UHD content, we could get loop of quota exceeded error until\n              browser is able to evict some data from sourcebuffer. Retrying can help recover.\n            */\n            _this5.warn(\"Failed \" + appendErrorCount + \"/\" + hls.config.appendErrorMaxRetry + \" times to append segment in \\\"\" + type + \"\\\" sourceBuffer\");\n            if (appendErrorCount >= hls.config.appendErrorMaxRetry) {\n              event.fatal = true;\n            }\n          }\n          hls.trigger(Events.ERROR, event);\n        }\n      };\n      operationQueue.append(operation, type, !!this.pendingTracks[type]);\n    };\n    _proto.onBufferFlushing = function onBufferFlushing(event, data) {\n      var _this6 = this;\n      var operationQueue = this.operationQueue;\n      var flushOperation = function flushOperation(type) {\n        return {\n          execute: _this6.removeExecutor.bind(_this6, type, data.startOffset, data.endOffset),\n          onStart: function onStart() {\n            // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n          },\n          onComplete: function onComplete() {\n            // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n            _this6.hls.trigger(Events.BUFFER_FLUSHED, {\n              type: type\n            });\n          },\n          onError: function onError(error) {\n            _this6.warn(\"Failed to remove from \" + type + \" SourceBuffer\", error);\n          }\n        };\n      };\n      if (data.type) {\n        operationQueue.append(flushOperation(data.type), data.type);\n      } else {\n        this.getSourceBufferTypes().forEach(function (type) {\n          operationQueue.append(flushOperation(type), type);\n        });\n      }\n    };\n    _proto.onFragParsed = function onFragParsed(event, data) {\n      var _this7 = this;\n      var frag = data.frag,\n        part = data.part;\n      var buffersAppendedTo = [];\n      var elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n      if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {\n        buffersAppendedTo.push('audiovideo');\n      } else {\n        if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {\n          buffersAppendedTo.push('audio');\n        }\n        if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {\n          buffersAppendedTo.push('video');\n        }\n      }\n      var onUnblocked = function onUnblocked() {\n        var now = self.performance.now();\n        frag.stats.buffering.end = now;\n        if (part) {\n          part.stats.buffering.end = now;\n        }\n        var stats = part ? part.stats : frag.stats;\n        _this7.hls.trigger(Events.FRAG_BUFFERED, {\n          frag: frag,\n          part: part,\n          stats: stats,\n          id: frag.type\n        });\n      };\n      if (buffersAppendedTo.length === 0) {\n        this.warn(\"Fragments must have at least one ElementaryStreamType set. type: \" + frag.type + \" level: \" + frag.level + \" sn: \" + frag.sn);\n      }\n      this.blockBuffers(onUnblocked, buffersAppendedTo);\n    };\n    _proto.onFragChanged = function onFragChanged(event, data) {\n      this.trimBuffers();\n    }\n\n    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n    // an undefined data.type will mark all buffers as EOS.\n    ;\n    _proto.onBufferEos = function onBufferEos(event, data) {\n      var _this8 = this;\n      var ended = this.getSourceBufferTypes().reduce(function (acc, type) {\n        var sb = _this8.sourceBuffer[type];\n        if (sb && (!data.type || data.type === type)) {\n          sb.ending = true;\n          if (!sb.ended) {\n            sb.ended = true;\n            _this8.log(type + \" sourceBuffer now EOS\");\n          }\n        }\n        return acc && !!(!sb || sb.ended);\n      }, true);\n      if (ended) {\n        this.log(\"Queueing mediaSource.endOfStream()\");\n        this.blockBuffers(function () {\n          _this8.getSourceBufferTypes().forEach(function (type) {\n            var sb = _this8.sourceBuffer[type];\n            if (sb) {\n              sb.ending = false;\n            }\n          });\n          var mediaSource = _this8.mediaSource;\n          if (!mediaSource || mediaSource.readyState !== 'open') {\n            if (mediaSource) {\n              _this8.log(\"Could not call mediaSource.endOfStream(). mediaSource.readyState: \" + mediaSource.readyState);\n            }\n            return;\n          }\n          _this8.log(\"Calling mediaSource.endOfStream()\");\n          // Allow this to throw and be caught by the enqueueing function\n          mediaSource.endOfStream();\n        });\n      }\n    };\n    _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {\n      var details = _ref.details;\n      if (!details.fragments.length) {\n        return;\n      }\n      this.details = details;\n      if (this.getSourceBufferTypes().length) {\n        this.blockBuffers(this.updateMediaElementDuration.bind(this));\n      } else {\n        this.updateMediaElementDuration();\n      }\n    };\n    _proto.trimBuffers = function trimBuffers() {\n      var hls = this.hls,\n        details = this.details,\n        media = this.media;\n      if (!media || details === null) {\n        return;\n      }\n      var sourceBufferTypes = this.getSourceBufferTypes();\n      if (!sourceBufferTypes.length) {\n        return;\n      }\n      var config = hls.config;\n      var currentTime = media.currentTime;\n      var targetDuration = details.levelTargetDuration;\n\n      // Support for deprecated liveBackBufferLength\n      var backBufferLength = details.live && config.liveBackBufferLength !== null ? config.liveBackBufferLength : config.backBufferLength;\n      if (isFiniteNumber(backBufferLength) && backBufferLength > 0) {\n        var maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n        var targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n        this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);\n      }\n      if (isFiniteNumber(config.frontBufferFlushThreshold) && config.frontBufferFlushThreshold > 0) {\n        var frontBufferLength = Math.max(config.maxBufferLength, config.frontBufferFlushThreshold);\n        var maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);\n        var targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;\n        this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);\n      }\n    };\n    _proto.flushBackBuffer = function flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {\n      var _this9 = this;\n      var details = this.details,\n        sourceBuffer = this.sourceBuffer;\n      var sourceBufferTypes = this.getSourceBufferTypes();\n      sourceBufferTypes.forEach(function (type) {\n        var sb = sourceBuffer[type];\n        if (sb) {\n          var buffered = BufferHelper.getBuffered(sb);\n          // when target buffer start exceeds actual buffer start\n          if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n            _this9.hls.trigger(Events.BACK_BUFFER_REACHED, {\n              bufferEnd: targetBackBufferPosition\n            });\n\n            // Support for deprecated event:\n            if (details != null && details.live) {\n              _this9.hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {\n                bufferEnd: targetBackBufferPosition\n              });\n            } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {\n              _this9.log(\"Cannot flush \" + type + \" back buffer while SourceBuffer is in ended state\");\n              return;\n            }\n            _this9.hls.trigger(Events.BUFFER_FLUSHING, {\n              startOffset: 0,\n              endOffset: targetBackBufferPosition,\n              type: type\n            });\n          }\n        }\n      });\n    };\n    _proto.flushFrontBuffer = function flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {\n      var _this10 = this;\n      var sourceBuffer = this.sourceBuffer;\n      var sourceBufferTypes = this.getSourceBufferTypes();\n      sourceBufferTypes.forEach(function (type) {\n        var sb = sourceBuffer[type];\n        if (sb) {\n          var buffered = BufferHelper.getBuffered(sb);\n          var numBufferedRanges = buffered.length;\n          // The buffer is either empty or contiguous\n          if (numBufferedRanges < 2) {\n            return;\n          }\n          var bufferStart = buffered.start(numBufferedRanges - 1);\n          var bufferEnd = buffered.end(numBufferedRanges - 1);\n          // No flush if we can tolerate the current buffer length or the current buffer range we would flush is contiguous with current position\n          if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {\n            return;\n          } else if (sb.ended && currentTime - bufferEnd < 2 * targetDuration) {\n            _this10.log(\"Cannot flush \" + type + \" front buffer while SourceBuffer is in ended state\");\n            return;\n          }\n          _this10.hls.trigger(Events.BUFFER_FLUSHING, {\n            startOffset: bufferStart,\n            endOffset: Infinity,\n            type: type\n          });\n        }\n      });\n    }\n\n    /**\n     * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n     * 'liveDurationInfinity` is set to `true`\n     * More details: https://github.com/video-dev/hls.js/issues/355\n     */;\n    _proto.updateMediaElementDuration = function updateMediaElementDuration() {\n      if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open') {\n        return;\n      }\n      var details = this.details,\n        hls = this.hls,\n        media = this.media,\n        mediaSource = this.mediaSource;\n      var levelDuration = details.fragments[0].start + details.totalduration;\n      var mediaDuration = media.duration;\n      var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;\n      if (details.live && hls.config.liveDurationInfinity) {\n        // Override duration to Infinity\n        mediaSource.duration = Infinity;\n        this.updateSeekableRange(details);\n      } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {\n        // levelDuration was the last value we set.\n        // not using mediaSource.duration as the browser may tweak this value\n        // only update Media Source duration if its value increase, this is to avoid\n        // flushing already buffered portion when switching between quality level\n        this.log(\"Updating Media Source duration to \" + levelDuration.toFixed(3));\n        mediaSource.duration = levelDuration;\n      }\n    };\n    _proto.updateSeekableRange = function updateSeekableRange(levelDetails) {\n      var mediaSource = this.mediaSource;\n      var fragments = levelDetails.fragments;\n      var len = fragments.length;\n      if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {\n        var start = Math.max(0, fragments[0].start);\n        var end = Math.max(start, start + levelDetails.totalduration);\n        this.log(\"Media Source duration is set to \" + mediaSource.duration + \". Setting seekable range to \" + start + \"-\" + end + \".\");\n        mediaSource.setLiveSeekableRange(start, end);\n      }\n    };\n    _proto.checkPendingTracks = function checkPendingTracks() {\n      var bufferCodecEventsExpected = this.bufferCodecEventsExpected,\n        operationQueue = this.operationQueue,\n        pendingTracks = this.pendingTracks;\n\n      // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n      // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n      // data has been appended to existing ones.\n      // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n      var pendingTracksCount = Object.keys(pendingTracks).length;\n      if (pendingTracksCount && (!bufferCodecEventsExpected || pendingTracksCount === 2 || 'audiovideo' in pendingTracks)) {\n        // ok, let's create them now !\n        this.createSourceBuffers(pendingTracks);\n        this.pendingTracks = {};\n        // append any pending segments now !\n        var buffers = this.getSourceBufferTypes();\n        if (buffers.length) {\n          this.hls.trigger(Events.BUFFER_CREATED, {\n            tracks: this.tracks\n          });\n          buffers.forEach(function (type) {\n            operationQueue.executeNext(type);\n          });\n        } else {\n          var error = new Error('could not create source buffer for media codec(s)');\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n            fatal: true,\n            error: error,\n            reason: error.message\n          });\n        }\n      }\n    };\n    _proto.createSourceBuffers = function createSourceBuffers(tracks) {\n      var _this11 = this;\n      var sourceBuffer = this.sourceBuffer,\n        mediaSource = this.mediaSource;\n      if (!mediaSource) {\n        throw Error('createSourceBuffers called when mediaSource was null');\n      }\n      var _loop = function _loop(trackName) {\n        if (!sourceBuffer[trackName]) {\n          var _track$levelCodec;\n          var track = tracks[trackName];\n          if (!track) {\n            throw Error(\"source buffer exists for track \" + trackName + \", however track does not\");\n          }\n          // use levelCodec as first priority unless it contains multiple comma-separated codec values\n          var codec = ((_track$levelCodec = track.levelCodec) == null ? void 0 : _track$levelCodec.indexOf(',')) === -1 ? track.levelCodec : track.codec;\n          if (codec) {\n            if (trackName.slice(0, 5) === 'audio') {\n              codec = getCodecCompatibleName(codec, _this11.appendSource);\n            }\n          }\n          var mimeType = track.container + \";codecs=\" + codec;\n          _this11.log(\"creating sourceBuffer(\" + mimeType + \")\");\n          try {\n            var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n            var sbName = trackName;\n            _this11.addBufferListener(sbName, 'updatestart', _this11._onSBUpdateStart);\n            _this11.addBufferListener(sbName, 'updateend', _this11._onSBUpdateEnd);\n            _this11.addBufferListener(sbName, 'error', _this11._onSBUpdateError);\n            // ManagedSourceBuffer bufferedchange event\n            if (_this11.appendSource) {\n              _this11.addBufferListener(sbName, 'bufferedchange', function (type, event) {\n                // If media was ejected check for a change. Added ranges are redundant with changes on 'updateend' event.\n                var removedRanges = event.removedRanges;\n                if (removedRanges != null && removedRanges.length) {\n                  _this11.hls.trigger(Events.BUFFER_FLUSHED, {\n                    type: trackName\n                  });\n                }\n              });\n            }\n            _this11.tracks[trackName] = {\n              buffer: sb,\n              codec: codec,\n              container: track.container,\n              levelCodec: track.levelCodec,\n              metadata: track.metadata,\n              id: track.id\n            };\n          } catch (err) {\n            _this11.error(\"error while trying to add sourceBuffer: \" + err.message);\n            _this11.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n              fatal: false,\n              error: err,\n              sourceBufferName: trackName,\n              mimeType: mimeType\n            });\n          }\n        }\n      };\n      for (var trackName in tracks) {\n        _loop(trackName);\n      }\n    };\n    _proto._onSBUpdateStart = function _onSBUpdateStart(type) {\n      var operationQueue = this.operationQueue;\n      var operation = operationQueue.current(type);\n      operation.onStart();\n    };\n    _proto._onSBUpdateEnd = function _onSBUpdateEnd(type) {\n      var _this$mediaSource2;\n      if (((_this$mediaSource2 = this.mediaSource) == null ? void 0 : _this$mediaSource2.readyState) === 'closed') {\n        this.resetBuffer(type);\n        return;\n      }\n      var operationQueue = this.operationQueue;\n      var operation = operationQueue.current(type);\n      operation.onComplete();\n      operationQueue.shiftAndExecuteNext(type);\n    };\n    _proto._onSBUpdateError = function _onSBUpdateError(type, event) {\n      var _this$mediaSource3;\n      var error = new Error(type + \" SourceBuffer error. MediaSource readyState: \" + ((_this$mediaSource3 = this.mediaSource) == null ? void 0 : _this$mediaSource3.readyState));\n      this.error(\"\" + error, event);\n      // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n      // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_APPENDING_ERROR,\n        sourceBufferName: type,\n        error: error,\n        fatal: false\n      });\n      // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n      var operation = this.operationQueue.current(type);\n      if (operation) {\n        operation.onError(error);\n      }\n    }\n\n    // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually\n    ;\n    _proto.removeExecutor = function removeExecutor(type, startOffset, endOffset) {\n      var media = this.media,\n        mediaSource = this.mediaSource,\n        operationQueue = this.operationQueue,\n        sourceBuffer = this.sourceBuffer;\n      var sb = sourceBuffer[type];\n      if (!media || !mediaSource || !sb) {\n        this.warn(\"Attempting to remove from the \" + type + \" SourceBuffer, but it does not exist\");\n        operationQueue.shiftAndExecuteNext(type);\n        return;\n      }\n      var mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;\n      var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;\n      var removeStart = Math.max(0, startOffset);\n      var removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n      if (removeEnd > removeStart && (!sb.ending || sb.ended)) {\n        sb.ended = false;\n        this.log(\"Removing [\" + removeStart + \",\" + removeEnd + \"] from the \" + type + \" SourceBuffer\");\n        sb.remove(removeStart, removeEnd);\n      } else {\n        // Cycle the queue\n        operationQueue.shiftAndExecuteNext(type);\n      }\n    }\n\n    // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually\n    ;\n    _proto.appendExecutor = function appendExecutor(data, type) {\n      var sb = this.sourceBuffer[type];\n      if (!sb) {\n        if (!this.pendingTracks[type]) {\n          throw new Error(\"Attempting to append to the \" + type + \" SourceBuffer, but it does not exist\");\n        }\n        return;\n      }\n      sb.ended = false;\n      sb.appendBuffer(data);\n    }\n\n    // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n    // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n    // upon completion, since we already do it here\n    ;\n    _proto.blockBuffers = function blockBuffers(onUnblocked, buffers) {\n      var _this12 = this;\n      if (buffers === void 0) {\n        buffers = this.getSourceBufferTypes();\n      }\n      if (!buffers.length) {\n        this.log('Blocking operation requested, but no SourceBuffers exist');\n        Promise.resolve().then(onUnblocked);\n        return;\n      }\n      var operationQueue = this.operationQueue;\n\n      // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n      var blockingOperations = buffers.map(function (type) {\n        return operationQueue.appendBlocker(type);\n      });\n      Promise.all(blockingOperations).then(function () {\n        // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n        onUnblocked();\n        buffers.forEach(function (type) {\n          var sb = _this12.sourceBuffer[type];\n          // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n          // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n          // While this is a workaround, it's probably useful to have around\n          if (!(sb != null && sb.updating)) {\n            operationQueue.shiftAndExecuteNext(type);\n          }\n        });\n      });\n    };\n    _proto.getSourceBufferTypes = function getSourceBufferTypes() {\n      return Object.keys(this.sourceBuffer);\n    };\n    _proto.addBufferListener = function addBufferListener(type, event, fn) {\n      var buffer = this.sourceBuffer[type];\n      if (!buffer) {\n        return;\n      }\n      var listener = fn.bind(this, type);\n      this.listeners[type].push({\n        event: event,\n        listener: listener\n      });\n      buffer.addEventListener(event, listener);\n    };\n    _proto.removeBufferListeners = function removeBufferListeners(type) {\n      var buffer = this.sourceBuffer[type];\n      if (!buffer) {\n        return;\n      }\n      this.listeners[type].forEach(function (l) {\n        buffer.removeEventListener(l.event, l.listener);\n      });\n    };\n    _createClass(BufferController, [{\n      key: \"mediaSrc\",\n      get: function get() {\n        var _this$media, _this$media$querySele;\n        var media = ((_this$media = this.media) == null ? void 0 : (_this$media$querySele = _this$media.querySelector) == null ? void 0 : _this$media$querySele.call(_this$media, 'source')) || this.media;\n        return media == null ? void 0 : media.src;\n      }\n    }]);\n    return BufferController;\n  }();\n  function removeSourceChildren(node) {\n    var sourceChildren = node.querySelectorAll('source');\n    [].slice.call(sourceChildren).forEach(function (source) {\n      node.removeChild(source);\n    });\n  }\n  function addSource(media, url) {\n    var source = self.document.createElement('source');\n    source.type = 'video/mp4';\n    source.src = url;\n    media.appendChild(source);\n  }\n\n  /**\n   *\n   * This code was ported from the dash.js project at:\n   *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n   *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n   *\n   * The original copyright appears below:\n   *\n   * The copyright in this software is being made available under the BSD License,\n   * included below. This software may be subject to other third party and contributor\n   * rights, including patent rights, and no such rights are granted under this license.\n   *\n   * Copyright (c) 2015-2016, DASH Industry Forum.\n   * All rights reserved.\n   *\n   * Redistribution and use in source and binary forms, with or without modification,\n   * are permitted provided that the following conditions are met:\n   *  1. Redistributions of source code must retain the above copyright notice, this\n   *  list of conditions and the following disclaimer.\n   *  * Redistributions in binary form must reproduce the above copyright notice,\n   *  this list of conditions and the following disclaimer in the documentation and/or\n   *  other materials provided with the distribution.\n   *  2. Neither the name of Dash Industry Forum nor the names of its\n   *  contributors may be used to endorse or promote products derived from this software\n   *  without specific prior written permission.\n   *\n   *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n   *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n   *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n   *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n   *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n   *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n   *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n   *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n   *  POSSIBILITY OF SUCH DAMAGE.\n   */\n  /**\n   *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n   */\n\n  var specialCea608CharsCodes = {\n    0x2a: 0xe1,\n    // lowercase a, acute accent\n    0x5c: 0xe9,\n    // lowercase e, acute accent\n    0x5e: 0xed,\n    // lowercase i, acute accent\n    0x5f: 0xf3,\n    // lowercase o, acute accent\n    0x60: 0xfa,\n    // lowercase u, acute accent\n    0x7b: 0xe7,\n    // lowercase c with cedilla\n    0x7c: 0xf7,\n    // division symbol\n    0x7d: 0xd1,\n    // uppercase N tilde\n    0x7e: 0xf1,\n    // lowercase n tilde\n    0x7f: 0x2588,\n    // Full block\n    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n    // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n    0x80: 0xae,\n    // Registered symbol (R)\n    0x81: 0xb0,\n    // degree sign\n    0x82: 0xbd,\n    // 1/2 symbol\n    0x83: 0xbf,\n    // Inverted (open) question mark\n    0x84: 0x2122,\n    // Trademark symbol (TM)\n    0x85: 0xa2,\n    // Cents symbol\n    0x86: 0xa3,\n    // Pounds sterling\n    0x87: 0x266a,\n    // Music 8'th note\n    0x88: 0xe0,\n    // lowercase a, grave accent\n    0x89: 0x20,\n    // transparent space (regular)\n    0x8a: 0xe8,\n    // lowercase e, grave accent\n    0x8b: 0xe2,\n    // lowercase a, circumflex accent\n    0x8c: 0xea,\n    // lowercase e, circumflex accent\n    0x8d: 0xee,\n    // lowercase i, circumflex accent\n    0x8e: 0xf4,\n    // lowercase o, circumflex accent\n    0x8f: 0xfb,\n    // lowercase u, circumflex accent\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n    0x90: 0xc1,\n    // capital letter A with acute\n    0x91: 0xc9,\n    // capital letter E with acute\n    0x92: 0xd3,\n    // capital letter O with acute\n    0x93: 0xda,\n    // capital letter U with acute\n    0x94: 0xdc,\n    // capital letter U with diaresis\n    0x95: 0xfc,\n    // lowercase letter U with diaeresis\n    0x96: 0x2018,\n    // opening single quote\n    0x97: 0xa1,\n    // inverted exclamation mark\n    0x98: 0x2a,\n    // asterisk\n    0x99: 0x2019,\n    // closing single quote\n    0x9a: 0x2501,\n    // box drawings heavy horizontal\n    0x9b: 0xa9,\n    // copyright sign\n    0x9c: 0x2120,\n    // Service mark\n    0x9d: 0x2022,\n    // (round) bullet\n    0x9e: 0x201c,\n    // Left double quotation mark\n    0x9f: 0x201d,\n    // Right double quotation mark\n    0xa0: 0xc0,\n    // uppercase A, grave accent\n    0xa1: 0xc2,\n    // uppercase A, circumflex\n    0xa2: 0xc7,\n    // uppercase C with cedilla\n    0xa3: 0xc8,\n    // uppercase E, grave accent\n    0xa4: 0xca,\n    // uppercase E, circumflex\n    0xa5: 0xcb,\n    // capital letter E with diaresis\n    0xa6: 0xeb,\n    // lowercase letter e with diaresis\n    0xa7: 0xce,\n    // uppercase I, circumflex\n    0xa8: 0xcf,\n    // uppercase I, with diaresis\n    0xa9: 0xef,\n    // lowercase i, with diaresis\n    0xaa: 0xd4,\n    // uppercase O, circumflex\n    0xab: 0xd9,\n    // uppercase U, grave accent\n    0xac: 0xf9,\n    // lowercase u, grave accent\n    0xad: 0xdb,\n    // uppercase U, circumflex\n    0xae: 0xab,\n    // left-pointing double angle quotation mark\n    0xaf: 0xbb,\n    // right-pointing double angle quotation mark\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n    0xb0: 0xc3,\n    // Uppercase A, tilde\n    0xb1: 0xe3,\n    // Lowercase a, tilde\n    0xb2: 0xcd,\n    // Uppercase I, acute accent\n    0xb3: 0xcc,\n    // Uppercase I, grave accent\n    0xb4: 0xec,\n    // Lowercase i, grave accent\n    0xb5: 0xd2,\n    // Uppercase O, grave accent\n    0xb6: 0xf2,\n    // Lowercase o, grave accent\n    0xb7: 0xd5,\n    // Uppercase O, tilde\n    0xb8: 0xf5,\n    // Lowercase o, tilde\n    0xb9: 0x7b,\n    // Open curly brace\n    0xba: 0x7d,\n    // Closing curly brace\n    0xbb: 0x5c,\n    // Backslash\n    0xbc: 0x5e,\n    // Caret\n    0xbd: 0x5f,\n    // Underscore\n    0xbe: 0x7c,\n    // Pipe (vertical line)\n    0xbf: 0x223c,\n    // Tilde operator\n    0xc0: 0xc4,\n    // Uppercase A, umlaut\n    0xc1: 0xe4,\n    // Lowercase A, umlaut\n    0xc2: 0xd6,\n    // Uppercase O, umlaut\n    0xc3: 0xf6,\n    // Lowercase o, umlaut\n    0xc4: 0xdf,\n    // Esszett (sharp S)\n    0xc5: 0xa5,\n    // Yen symbol\n    0xc6: 0xa4,\n    // Generic currency sign\n    0xc7: 0x2503,\n    // Box drawings heavy vertical\n    0xc8: 0xc5,\n    // Uppercase A, ring\n    0xc9: 0xe5,\n    // Lowercase A, ring\n    0xca: 0xd8,\n    // Uppercase O, stroke\n    0xcb: 0xf8,\n    // Lowercase o, strok\n    0xcc: 0x250f,\n    // Box drawings heavy down and right\n    0xcd: 0x2513,\n    // Box drawings heavy down and left\n    0xce: 0x2517,\n    // Box drawings heavy up and right\n    0xcf: 0x251b // Box drawings heavy up and left\n  };\n\n  /**\n   * Utils\n   */\n  var getCharForByte = function getCharForByte(_byte) {\n    return String.fromCharCode(specialCea608CharsCodes[_byte] || _byte);\n  };\n  var NR_ROWS = 15;\n  var NR_COLS = 100;\n  // Tables to look up row from PAC data\n  var rowsLowCh1 = {\n    0x11: 1,\n    0x12: 3,\n    0x15: 5,\n    0x16: 7,\n    0x17: 9,\n    0x10: 11,\n    0x13: 12,\n    0x14: 14\n  };\n  var rowsHighCh1 = {\n    0x11: 2,\n    0x12: 4,\n    0x15: 6,\n    0x16: 8,\n    0x17: 10,\n    0x13: 13,\n    0x14: 15\n  };\n  var rowsLowCh2 = {\n    0x19: 1,\n    0x1a: 3,\n    0x1d: 5,\n    0x1e: 7,\n    0x1f: 9,\n    0x18: 11,\n    0x1b: 12,\n    0x1c: 14\n  };\n  var rowsHighCh2 = {\n    0x19: 2,\n    0x1a: 4,\n    0x1d: 6,\n    0x1e: 8,\n    0x1f: 10,\n    0x1b: 13,\n    0x1c: 15\n  };\n  var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\n  var CaptionsLogger = /*#__PURE__*/function () {\n    function CaptionsLogger() {\n      this.time = null;\n      this.verboseLevel = 0;\n    }\n    var _proto = CaptionsLogger.prototype;\n    _proto.log = function log(severity, msg) {\n      if (this.verboseLevel >= severity) {\n        var m = typeof msg === 'function' ? msg() : msg;\n        logger.log(this.time + \" [\" + severity + \"] \" + m);\n      }\n    };\n    return CaptionsLogger;\n  }();\n  var numArrayToHexArray = function numArrayToHexArray(numArray) {\n    var hexArray = [];\n    for (var j = 0; j < numArray.length; j++) {\n      hexArray.push(numArray[j].toString(16));\n    }\n    return hexArray;\n  };\n  var PenState = /*#__PURE__*/function () {\n    function PenState() {\n      this.foreground = 'white';\n      this.underline = false;\n      this.italics = false;\n      this.background = 'black';\n      this.flash = false;\n    }\n    var _proto2 = PenState.prototype;\n    _proto2.reset = function reset() {\n      this.foreground = 'white';\n      this.underline = false;\n      this.italics = false;\n      this.background = 'black';\n      this.flash = false;\n    };\n    _proto2.setStyles = function setStyles(styles) {\n      var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];\n      for (var i = 0; i < attribs.length; i++) {\n        var style = attribs[i];\n        if (styles.hasOwnProperty(style)) {\n          this[style] = styles[style];\n        }\n      }\n    };\n    _proto2.isDefault = function isDefault() {\n      return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;\n    };\n    _proto2.equals = function equals(other) {\n      return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n    };\n    _proto2.copy = function copy(newPenState) {\n      this.foreground = newPenState.foreground;\n      this.underline = newPenState.underline;\n      this.italics = newPenState.italics;\n      this.background = newPenState.background;\n      this.flash = newPenState.flash;\n    };\n    _proto2.toString = function toString() {\n      return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;\n    };\n    return PenState;\n  }();\n  /**\n   * Unicode character with styling and background.\n   * @constructor\n   */\n  var StyledUnicodeChar = /*#__PURE__*/function () {\n    function StyledUnicodeChar() {\n      this.uchar = ' ';\n      this.penState = new PenState();\n    }\n    var _proto3 = StyledUnicodeChar.prototype;\n    _proto3.reset = function reset() {\n      this.uchar = ' ';\n      this.penState.reset();\n    };\n    _proto3.setChar = function setChar(uchar, newPenState) {\n      this.uchar = uchar;\n      this.penState.copy(newPenState);\n    };\n    _proto3.setPenState = function setPenState(newPenState) {\n      this.penState.copy(newPenState);\n    };\n    _proto3.equals = function equals(other) {\n      return this.uchar === other.uchar && this.penState.equals(other.penState);\n    };\n    _proto3.copy = function copy(newChar) {\n      this.uchar = newChar.uchar;\n      this.penState.copy(newChar.penState);\n    };\n    _proto3.isEmpty = function isEmpty() {\n      return this.uchar === ' ' && this.penState.isDefault();\n    };\n    return StyledUnicodeChar;\n  }();\n  /**\n   * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n   * @constructor\n   */\n  var Row = /*#__PURE__*/function () {\n    function Row(logger) {\n      this.chars = [];\n      this.pos = 0;\n      this.currPenState = new PenState();\n      this.cueStartTime = null;\n      this.logger = void 0;\n      for (var i = 0; i < NR_COLS; i++) {\n        this.chars.push(new StyledUnicodeChar());\n      }\n      this.logger = logger;\n    }\n    var _proto4 = Row.prototype;\n    _proto4.equals = function equals(other) {\n      for (var i = 0; i < NR_COLS; i++) {\n        if (!this.chars[i].equals(other.chars[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n    _proto4.copy = function copy(other) {\n      for (var i = 0; i < NR_COLS; i++) {\n        this.chars[i].copy(other.chars[i]);\n      }\n    };\n    _proto4.isEmpty = function isEmpty() {\n      var empty = true;\n      for (var i = 0; i < NR_COLS; i++) {\n        if (!this.chars[i].isEmpty()) {\n          empty = false;\n          break;\n        }\n      }\n      return empty;\n    }\n\n    /**\n     *  Set the cursor to a valid column.\n     */;\n    _proto4.setCursor = function setCursor(absPos) {\n      if (this.pos !== absPos) {\n        this.pos = absPos;\n      }\n      if (this.pos < 0) {\n        this.logger.log(3, 'Negative cursor position ' + this.pos);\n        this.pos = 0;\n      } else if (this.pos > NR_COLS) {\n        this.logger.log(3, 'Too large cursor position ' + this.pos);\n        this.pos = NR_COLS;\n      }\n    }\n\n    /**\n     * Move the cursor relative to current position.\n     */;\n    _proto4.moveCursor = function moveCursor(relPos) {\n      var newPos = this.pos + relPos;\n      if (relPos > 1) {\n        for (var i = this.pos + 1; i < newPos + 1; i++) {\n          this.chars[i].setPenState(this.currPenState);\n        }\n      }\n      this.setCursor(newPos);\n    }\n\n    /**\n     * Backspace, move one step back and clear character.\n     */;\n    _proto4.backSpace = function backSpace() {\n      this.moveCursor(-1);\n      this.chars[this.pos].setChar(' ', this.currPenState);\n    };\n    _proto4.insertChar = function insertChar(_byte2) {\n      var _this = this;\n      if (_byte2 >= 0x90) {\n        // Extended char\n        this.backSpace();\n      }\n      var _char = getCharForByte(_byte2);\n      if (this.pos >= NR_COLS) {\n        this.logger.log(0, function () {\n          return 'Cannot insert ' + _byte2.toString(16) + ' (' + _char + ') at position ' + _this.pos + '. Skipping it!';\n        });\n        return;\n      }\n      this.chars[this.pos].setChar(_char, this.currPenState);\n      this.moveCursor(1);\n    };\n    _proto4.clearFromPos = function clearFromPos(startPos) {\n      var i;\n      for (i = startPos; i < NR_COLS; i++) {\n        this.chars[i].reset();\n      }\n    };\n    _proto4.clear = function clear() {\n      this.clearFromPos(0);\n      this.pos = 0;\n      this.currPenState.reset();\n    };\n    _proto4.clearToEndOfRow = function clearToEndOfRow() {\n      this.clearFromPos(this.pos);\n    };\n    _proto4.getTextString = function getTextString() {\n      var chars = [];\n      var empty = true;\n      for (var i = 0; i < NR_COLS; i++) {\n        var _char2 = this.chars[i].uchar;\n        if (_char2 !== ' ') {\n          empty = false;\n        }\n        chars.push(_char2);\n      }\n      if (empty) {\n        return '';\n      } else {\n        return chars.join('');\n      }\n    };\n    _proto4.setPenStyles = function setPenStyles(styles) {\n      this.currPenState.setStyles(styles);\n      var currChar = this.chars[this.pos];\n      currChar.setPenState(this.currPenState);\n    };\n    return Row;\n  }();\n\n  /**\n   * Keep a CEA-608 screen of 32x15 styled characters\n   * @constructor\n   */\n  var CaptionScreen = /*#__PURE__*/function () {\n    function CaptionScreen(logger) {\n      this.rows = [];\n      this.currRow = NR_ROWS - 1;\n      this.nrRollUpRows = null;\n      this.lastOutputScreen = null;\n      this.logger = void 0;\n      for (var i = 0; i < NR_ROWS; i++) {\n        this.rows.push(new Row(logger));\n      }\n      this.logger = logger;\n    }\n    var _proto5 = CaptionScreen.prototype;\n    _proto5.reset = function reset() {\n      for (var i = 0; i < NR_ROWS; i++) {\n        this.rows[i].clear();\n      }\n      this.currRow = NR_ROWS - 1;\n    };\n    _proto5.equals = function equals(other) {\n      var equal = true;\n      for (var i = 0; i < NR_ROWS; i++) {\n        if (!this.rows[i].equals(other.rows[i])) {\n          equal = false;\n          break;\n        }\n      }\n      return equal;\n    };\n    _proto5.copy = function copy(other) {\n      for (var i = 0; i < NR_ROWS; i++) {\n        this.rows[i].copy(other.rows[i]);\n      }\n    };\n    _proto5.isEmpty = function isEmpty() {\n      var empty = true;\n      for (var i = 0; i < NR_ROWS; i++) {\n        if (!this.rows[i].isEmpty()) {\n          empty = false;\n          break;\n        }\n      }\n      return empty;\n    };\n    _proto5.backSpace = function backSpace() {\n      var row = this.rows[this.currRow];\n      row.backSpace();\n    };\n    _proto5.clearToEndOfRow = function clearToEndOfRow() {\n      var row = this.rows[this.currRow];\n      row.clearToEndOfRow();\n    }\n\n    /**\n     * Insert a character (without styling) in the current row.\n     */;\n    _proto5.insertChar = function insertChar(_char3) {\n      var row = this.rows[this.currRow];\n      row.insertChar(_char3);\n    };\n    _proto5.setPen = function setPen(styles) {\n      var row = this.rows[this.currRow];\n      row.setPenStyles(styles);\n    };\n    _proto5.moveCursor = function moveCursor(relPos) {\n      var row = this.rows[this.currRow];\n      row.moveCursor(relPos);\n    };\n    _proto5.setCursor = function setCursor(absPos) {\n      this.logger.log(2, 'setCursor: ' + absPos);\n      var row = this.rows[this.currRow];\n      row.setCursor(absPos);\n    };\n    _proto5.setPAC = function setPAC(pacData) {\n      this.logger.log(2, function () {\n        return 'pacData = ' + JSON.stringify(pacData);\n      });\n      var newRow = pacData.row - 1;\n      if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n        newRow = this.nrRollUpRows - 1;\n      }\n\n      // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n      if (this.nrRollUpRows && this.currRow !== newRow) {\n        // clear all rows first\n        for (var i = 0; i < NR_ROWS; i++) {\n          this.rows[i].clear();\n        }\n\n        // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n        // topRowIndex - the start of rows to copy (inclusive index)\n        var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n        // We only copy if the last position was already shown.\n        // We use the cueStartTime value to check this.\n        var lastOutputScreen = this.lastOutputScreen;\n        if (lastOutputScreen) {\n          var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n          var time = this.logger.time;\n          if (prevLineTime !== null && time !== null && prevLineTime < time) {\n            for (var _i = 0; _i < this.nrRollUpRows; _i++) {\n              this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);\n            }\n          }\n        }\n      }\n      this.currRow = newRow;\n      var row = this.rows[this.currRow];\n      if (pacData.indent !== null) {\n        var indent = pacData.indent;\n        var prevPos = Math.max(indent - 1, 0);\n        row.setCursor(pacData.indent);\n        pacData.color = row.chars[prevPos].penState.foreground;\n      }\n      var styles = {\n        foreground: pacData.color,\n        underline: pacData.underline,\n        italics: pacData.italics,\n        background: 'black',\n        flash: false\n      };\n      this.setPen(styles);\n    }\n\n    /**\n     * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n     */;\n    _proto5.setBkgData = function setBkgData(bkgData) {\n      this.logger.log(2, function () {\n        return 'bkgData = ' + JSON.stringify(bkgData);\n      });\n      this.backSpace();\n      this.setPen(bkgData);\n      this.insertChar(0x20); // Space\n    };\n    _proto5.setRollUpRows = function setRollUpRows(nrRows) {\n      this.nrRollUpRows = nrRows;\n    };\n    _proto5.rollUp = function rollUp() {\n      var _this2 = this;\n      if (this.nrRollUpRows === null) {\n        this.logger.log(3, 'roll_up but nrRollUpRows not set yet');\n        return; // Not properly setup\n      }\n      this.logger.log(1, function () {\n        return _this2.getDisplayText();\n      });\n      var topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n      var topRow = this.rows.splice(topRowIndex, 1)[0];\n      topRow.clear();\n      this.rows.splice(this.currRow, 0, topRow);\n      this.logger.log(2, 'Rolling up');\n      // this.logger.log(VerboseLevel.TEXT, this.get_display_text())\n    }\n\n    /**\n     * Get all non-empty rows with as unicode text.\n     */;\n    _proto5.getDisplayText = function getDisplayText(asOneRow) {\n      asOneRow = asOneRow || false;\n      var displayText = [];\n      var text = '';\n      var rowNr = -1;\n      for (var i = 0; i < NR_ROWS; i++) {\n        var rowText = this.rows[i].getTextString();\n        if (rowText) {\n          rowNr = i + 1;\n          if (asOneRow) {\n            displayText.push('Row ' + rowNr + \": '\" + rowText + \"'\");\n          } else {\n            displayText.push(rowText.trim());\n          }\n        }\n      }\n      if (displayText.length > 0) {\n        if (asOneRow) {\n          text = '[' + displayText.join(' | ') + ']';\n        } else {\n          text = displayText.join('\\n');\n        }\n      }\n      return text;\n    };\n    _proto5.getTextAndFormat = function getTextAndFormat() {\n      return this.rows;\n    };\n    return CaptionScreen;\n  }();\n\n  // var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\n  var Cea608Channel = /*#__PURE__*/function () {\n    function Cea608Channel(channelNumber, outputFilter, logger) {\n      this.chNr = void 0;\n      this.outputFilter = void 0;\n      this.mode = void 0;\n      this.verbose = void 0;\n      this.displayedMemory = void 0;\n      this.nonDisplayedMemory = void 0;\n      this.lastOutputScreen = void 0;\n      this.currRollUpRow = void 0;\n      this.writeScreen = void 0;\n      this.cueStartTime = void 0;\n      this.logger = void 0;\n      this.chNr = channelNumber;\n      this.outputFilter = outputFilter;\n      this.mode = null;\n      this.verbose = 0;\n      this.displayedMemory = new CaptionScreen(logger);\n      this.nonDisplayedMemory = new CaptionScreen(logger);\n      this.lastOutputScreen = new CaptionScreen(logger);\n      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n      this.writeScreen = this.displayedMemory;\n      this.mode = null;\n      this.cueStartTime = null; // Keeps track of where a cue started.\n      this.logger = logger;\n    }\n    var _proto6 = Cea608Channel.prototype;\n    _proto6.reset = function reset() {\n      this.mode = null;\n      this.displayedMemory.reset();\n      this.nonDisplayedMemory.reset();\n      this.lastOutputScreen.reset();\n      this.outputFilter.reset();\n      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n      this.writeScreen = this.displayedMemory;\n      this.mode = null;\n      this.cueStartTime = null;\n    };\n    _proto6.getHandler = function getHandler() {\n      return this.outputFilter;\n    };\n    _proto6.setHandler = function setHandler(newHandler) {\n      this.outputFilter = newHandler;\n    };\n    _proto6.setPAC = function setPAC(pacData) {\n      this.writeScreen.setPAC(pacData);\n    };\n    _proto6.setBkgData = function setBkgData(bkgData) {\n      this.writeScreen.setBkgData(bkgData);\n    };\n    _proto6.setMode = function setMode(newMode) {\n      if (newMode === this.mode) {\n        return;\n      }\n      this.mode = newMode;\n      this.logger.log(2, function () {\n        return 'MODE=' + newMode;\n      });\n      if (this.mode === 'MODE_POP-ON') {\n        this.writeScreen = this.nonDisplayedMemory;\n      } else {\n        this.writeScreen = this.displayedMemory;\n        this.writeScreen.reset();\n      }\n      if (this.mode !== 'MODE_ROLL-UP') {\n        this.displayedMemory.nrRollUpRows = null;\n        this.nonDisplayedMemory.nrRollUpRows = null;\n      }\n      this.mode = newMode;\n    };\n    _proto6.insertChars = function insertChars(chars) {\n      var _this3 = this;\n      for (var i = 0; i < chars.length; i++) {\n        this.writeScreen.insertChar(chars[i]);\n      }\n      var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';\n      this.logger.log(2, function () {\n        return screen + ': ' + _this3.writeScreen.getDisplayText(true);\n      });\n      if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {\n        this.logger.log(1, function () {\n          return 'DISPLAYED: ' + _this3.displayedMemory.getDisplayText(true);\n        });\n        this.outputDataUpdate();\n      }\n    };\n    _proto6.ccRCL = function ccRCL() {\n      // Resume Caption Loading (switch mode to Pop On)\n      this.logger.log(2, 'RCL - Resume Caption Loading');\n      this.setMode('MODE_POP-ON');\n    };\n    _proto6.ccBS = function ccBS() {\n      // BackSpace\n      this.logger.log(2, 'BS - BackSpace');\n      if (this.mode === 'MODE_TEXT') {\n        return;\n      }\n      this.writeScreen.backSpace();\n      if (this.writeScreen === this.displayedMemory) {\n        this.outputDataUpdate();\n      }\n    };\n    _proto6.ccAOF = function ccAOF() {\n      // Reserved (formerly Alarm Off)\n    };\n    _proto6.ccAON = function ccAON() {\n      // Reserved (formerly Alarm On)\n    };\n    _proto6.ccDER = function ccDER() {\n      // Delete to End of Row\n      this.logger.log(2, 'DER- Delete to End of Row');\n      this.writeScreen.clearToEndOfRow();\n      this.outputDataUpdate();\n    };\n    _proto6.ccRU = function ccRU(nrRows) {\n      // Roll-Up Captions-2,3,or 4 Rows\n      this.logger.log(2, 'RU(' + nrRows + ') - Roll Up');\n      this.writeScreen = this.displayedMemory;\n      this.setMode('MODE_ROLL-UP');\n      this.writeScreen.setRollUpRows(nrRows);\n    };\n    _proto6.ccFON = function ccFON() {\n      // Flash On\n      this.logger.log(2, 'FON - Flash On');\n      this.writeScreen.setPen({\n        flash: true\n      });\n    };\n    _proto6.ccRDC = function ccRDC() {\n      // Resume Direct Captioning (switch mode to PaintOn)\n      this.logger.log(2, 'RDC - Resume Direct Captioning');\n      this.setMode('MODE_PAINT-ON');\n    };\n    _proto6.ccTR = function ccTR() {\n      // Text Restart in text mode (not supported, however)\n      this.logger.log(2, 'TR');\n      this.setMode('MODE_TEXT');\n    };\n    _proto6.ccRTD = function ccRTD() {\n      // Resume Text Display in Text mode (not supported, however)\n      this.logger.log(2, 'RTD');\n      this.setMode('MODE_TEXT');\n    };\n    _proto6.ccEDM = function ccEDM() {\n      // Erase Displayed Memory\n      this.logger.log(2, 'EDM - Erase Displayed Memory');\n      this.displayedMemory.reset();\n      this.outputDataUpdate(true);\n    };\n    _proto6.ccCR = function ccCR() {\n      // Carriage Return\n      this.logger.log(2, 'CR - Carriage Return');\n      this.writeScreen.rollUp();\n      this.outputDataUpdate(true);\n    };\n    _proto6.ccENM = function ccENM() {\n      // Erase Non-Displayed Memory\n      this.logger.log(2, 'ENM - Erase Non-displayed Memory');\n      this.nonDisplayedMemory.reset();\n    };\n    _proto6.ccEOC = function ccEOC() {\n      var _this4 = this;\n      // End of Caption (Flip Memories)\n      this.logger.log(2, 'EOC - End Of Caption');\n      if (this.mode === 'MODE_POP-ON') {\n        var tmp = this.displayedMemory;\n        this.displayedMemory = this.nonDisplayedMemory;\n        this.nonDisplayedMemory = tmp;\n        this.writeScreen = this.nonDisplayedMemory;\n        this.logger.log(1, function () {\n          return 'DISP: ' + _this4.displayedMemory.getDisplayText();\n        });\n      }\n      this.outputDataUpdate(true);\n    };\n    _proto6.ccTO = function ccTO(nrCols) {\n      // Tab Offset 1,2, or 3 columns\n      this.logger.log(2, 'TO(' + nrCols + ') - Tab Offset');\n      this.writeScreen.moveCursor(nrCols);\n    };\n    _proto6.ccMIDROW = function ccMIDROW(secondByte) {\n      // Parse MIDROW command\n      var styles = {\n        flash: false\n      };\n      styles.underline = secondByte % 2 === 1;\n      styles.italics = secondByte >= 0x2e;\n      if (!styles.italics) {\n        var colorIndex = Math.floor(secondByte / 2) - 0x10;\n        var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];\n        styles.foreground = colors[colorIndex];\n      } else {\n        styles.foreground = 'white';\n      }\n      this.logger.log(2, 'MIDROW: ' + JSON.stringify(styles));\n      this.writeScreen.setPen(styles);\n    };\n    _proto6.outputDataUpdate = function outputDataUpdate(dispatch) {\n      if (dispatch === void 0) {\n        dispatch = false;\n      }\n      var time = this.logger.time;\n      if (time === null) {\n        return;\n      }\n      if (this.outputFilter) {\n        if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n          // Start of a new cue\n          this.cueStartTime = time;\n        } else {\n          if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n            this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);\n            if (dispatch && this.outputFilter.dispatchCue) {\n              this.outputFilter.dispatchCue();\n            }\n            this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;\n          }\n        }\n        this.lastOutputScreen.copy(this.displayedMemory);\n      }\n    };\n    _proto6.cueSplitAtTime = function cueSplitAtTime(t) {\n      if (this.outputFilter) {\n        if (!this.displayedMemory.isEmpty()) {\n          if (this.outputFilter.newCue) {\n            this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n          }\n          this.cueStartTime = t;\n        }\n      }\n    };\n    return Cea608Channel;\n  }(); // Will be 1 or 2 when parsing captions\n  var Cea608Parser = /*#__PURE__*/function () {\n    function Cea608Parser(field, out1, out2) {\n      this.channels = void 0;\n      this.currentChannel = 0;\n      this.cmdHistory = createCmdHistory();\n      this.logger = void 0;\n      var logger = this.logger = new CaptionsLogger();\n      this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];\n    }\n    var _proto7 = Cea608Parser.prototype;\n    _proto7.getHandler = function getHandler(channel) {\n      return this.channels[channel].getHandler();\n    };\n    _proto7.setHandler = function setHandler(channel, newHandler) {\n      this.channels[channel].setHandler(newHandler);\n    }\n\n    /**\n     * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n     */;\n    _proto7.addData = function addData(time, byteList) {\n      var _this5 = this;\n      this.logger.time = time;\n      var _loop = function _loop(i) {\n          var a = byteList[i] & 0x7f;\n          var b = byteList[i + 1] & 0x7f;\n          var cmdFound = false;\n          var charsFound = null;\n          if (a === 0 && b === 0) {\n            return 0; // continue\n          } else {\n            _this5.logger.log(3, function () {\n              return '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')';\n            });\n          }\n          var cmdHistory = _this5.cmdHistory;\n          var isControlCode = a >= 0x10 && a <= 0x1f;\n          if (isControlCode) {\n            // Skip redundant control codes\n            if (hasCmdRepeated(a, b, cmdHistory)) {\n              setLastCmd(null, null, cmdHistory);\n              _this5.logger.log(3, function () {\n                return 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped';\n              });\n              return 0; // continue\n            }\n            setLastCmd(a, b, _this5.cmdHistory);\n            cmdFound = _this5.parseCmd(a, b);\n            if (!cmdFound) {\n              cmdFound = _this5.parseMidrow(a, b);\n            }\n            if (!cmdFound) {\n              cmdFound = _this5.parsePAC(a, b);\n            }\n            if (!cmdFound) {\n              cmdFound = _this5.parseBackgroundAttributes(a, b);\n            }\n          } else {\n            setLastCmd(null, null, cmdHistory);\n          }\n          if (!cmdFound) {\n            charsFound = _this5.parseChars(a, b);\n            if (charsFound) {\n              var currChNr = _this5.currentChannel;\n              if (currChNr && currChNr > 0) {\n                var channel = _this5.channels[currChNr];\n                channel.insertChars(charsFound);\n              } else {\n                _this5.logger.log(2, 'No channel found yet. TEXT-MODE?');\n              }\n            }\n          }\n          if (!cmdFound && !charsFound) {\n            _this5.logger.log(2, function () {\n              return \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]);\n            });\n          }\n        },\n        _ret;\n      for (var i = 0; i < byteList.length; i += 2) {\n        _ret = _loop(i);\n        if (_ret === 0) continue;\n      }\n    }\n\n    /**\n     * Parse Command.\n     * @returns True if a command was found\n     */;\n    _proto7.parseCmd = function parseCmd(a, b) {\n      var cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;\n      var cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;\n      if (!(cond1 || cond2)) {\n        return false;\n      }\n      var chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;\n      var channel = this.channels[chNr];\n      if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {\n        if (b === 0x20) {\n          channel.ccRCL();\n        } else if (b === 0x21) {\n          channel.ccBS();\n        } else if (b === 0x22) {\n          channel.ccAOF();\n        } else if (b === 0x23) {\n          channel.ccAON();\n        } else if (b === 0x24) {\n          channel.ccDER();\n        } else if (b === 0x25) {\n          channel.ccRU(2);\n        } else if (b === 0x26) {\n          channel.ccRU(3);\n        } else if (b === 0x27) {\n          channel.ccRU(4);\n        } else if (b === 0x28) {\n          channel.ccFON();\n        } else if (b === 0x29) {\n          channel.ccRDC();\n        } else if (b === 0x2a) {\n          channel.ccTR();\n        } else if (b === 0x2b) {\n          channel.ccRTD();\n        } else if (b === 0x2c) {\n          channel.ccEDM();\n        } else if (b === 0x2d) {\n          channel.ccCR();\n        } else if (b === 0x2e) {\n          channel.ccENM();\n        } else if (b === 0x2f) {\n          channel.ccEOC();\n        }\n      } else {\n        // a == 0x17 || a == 0x1F\n        channel.ccTO(b - 0x20);\n      }\n      this.currentChannel = chNr;\n      return true;\n    }\n\n    /**\n     * Parse midrow styling command\n     */;\n    _proto7.parseMidrow = function parseMidrow(a, b) {\n      var chNr = 0;\n      if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {\n        if (a === 0x11) {\n          chNr = 1;\n        } else {\n          chNr = 2;\n        }\n        if (chNr !== this.currentChannel) {\n          this.logger.log(0, 'Mismatch channel in midrow parsing');\n          return false;\n        }\n        var channel = this.channels[chNr];\n        if (!channel) {\n          return false;\n        }\n        channel.ccMIDROW(b);\n        this.logger.log(3, function () {\n          return 'MIDROW (' + numArrayToHexArray([a, b]) + ')';\n        });\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Parse Preable Access Codes (Table 53).\n     * @returns {Boolean} Tells if PAC found\n     */;\n    _proto7.parsePAC = function parsePAC(a, b) {\n      var row;\n      var case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;\n      var case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;\n      if (!(case1 || case2)) {\n        return false;\n      }\n      var chNr = a <= 0x17 ? 1 : 2;\n      if (b >= 0x40 && b <= 0x5f) {\n        row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n      } else {\n        // 0x60 <= b <= 0x7F\n        row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n      }\n      var channel = this.channels[chNr];\n      if (!channel) {\n        return false;\n      }\n      channel.setPAC(this.interpretPAC(row, b));\n      this.currentChannel = chNr;\n      return true;\n    }\n\n    /**\n     * Interpret the second byte of the pac, and return the information.\n     * @returns pacData with style parameters\n     */;\n    _proto7.interpretPAC = function interpretPAC(row, _byte3) {\n      var pacIndex;\n      var pacData = {\n        color: null,\n        italics: false,\n        indent: null,\n        underline: false,\n        row: row\n      };\n      if (_byte3 > 0x5f) {\n        pacIndex = _byte3 - 0x60;\n      } else {\n        pacIndex = _byte3 - 0x40;\n      }\n      pacData.underline = (pacIndex & 1) === 1;\n      if (pacIndex <= 0xd) {\n        pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n      } else if (pacIndex <= 0xf) {\n        pacData.italics = true;\n        pacData.color = 'white';\n      } else {\n        pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n      }\n      return pacData; // Note that row has zero offset. The spec uses 1.\n    }\n\n    /**\n     * Parse characters.\n     * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n     */;\n    _proto7.parseChars = function parseChars(a, b) {\n      var channelNr;\n      var charCodes = null;\n      var charCode1 = null;\n      if (a >= 0x19) {\n        channelNr = 2;\n        charCode1 = a - 8;\n      } else {\n        channelNr = 1;\n        charCode1 = a;\n      }\n      if (charCode1 >= 0x11 && charCode1 <= 0x13) {\n        // Special character\n        var oneCode;\n        if (charCode1 === 0x11) {\n          oneCode = b + 0x50;\n        } else if (charCode1 === 0x12) {\n          oneCode = b + 0x70;\n        } else {\n          oneCode = b + 0x90;\n        }\n        this.logger.log(2, function () {\n          return \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr;\n        });\n        charCodes = [oneCode];\n      } else if (a >= 0x20 && a <= 0x7f) {\n        charCodes = b === 0 ? [a] : [a, b];\n      }\n      if (charCodes) {\n        this.logger.log(3, function () {\n          return 'Char codes =  ' + numArrayToHexArray(charCodes).join(',');\n        });\n      }\n      return charCodes;\n    }\n\n    /**\n     * Parse extended background attributes as well as new foreground color black.\n     * @returns True if background attributes are found\n     */;\n    _proto7.parseBackgroundAttributes = function parseBackgroundAttributes(a, b) {\n      var case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;\n      var case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;\n      if (!(case1 || case2)) {\n        return false;\n      }\n      var index;\n      var bkgData = {};\n      if (a === 0x10 || a === 0x18) {\n        index = Math.floor((b - 0x20) / 2);\n        bkgData.background = backgroundColors[index];\n        if (b % 2 === 1) {\n          bkgData.background = bkgData.background + '_semi';\n        }\n      } else if (b === 0x2d) {\n        bkgData.background = 'transparent';\n      } else {\n        bkgData.foreground = 'black';\n        if (b === 0x2f) {\n          bkgData.underline = true;\n        }\n      }\n      var chNr = a <= 0x17 ? 1 : 2;\n      var channel = this.channels[chNr];\n      channel.setBkgData(bkgData);\n      return true;\n    }\n\n    /**\n     * Reset state of parser and its channels.\n     */;\n    _proto7.reset = function reset() {\n      for (var i = 0; i < Object.keys(this.channels).length; i++) {\n        var channel = this.channels[i];\n        if (channel) {\n          channel.reset();\n        }\n      }\n      setLastCmd(null, null, this.cmdHistory);\n    }\n\n    /**\n     * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n     */;\n    _proto7.cueSplitAtTime = function cueSplitAtTime(t) {\n      for (var i = 0; i < this.channels.length; i++) {\n        var channel = this.channels[i];\n        if (channel) {\n          channel.cueSplitAtTime(t);\n        }\n      }\n    };\n    return Cea608Parser;\n  }();\n  function setLastCmd(a, b, cmdHistory) {\n    cmdHistory.a = a;\n    cmdHistory.b = b;\n  }\n  function hasCmdRepeated(a, b, cmdHistory) {\n    return cmdHistory.a === a && cmdHistory.b === b;\n  }\n  function createCmdHistory() {\n    return {\n      a: null,\n      b: null\n    };\n  }\n\n  var OutputFilter = /*#__PURE__*/function () {\n    function OutputFilter(timelineController, trackName) {\n      this.timelineController = void 0;\n      this.cueRanges = [];\n      this.trackName = void 0;\n      this.startTime = null;\n      this.endTime = null;\n      this.screen = null;\n      this.timelineController = timelineController;\n      this.trackName = trackName;\n    }\n    var _proto = OutputFilter.prototype;\n    _proto.dispatchCue = function dispatchCue() {\n      if (this.startTime === null) {\n        return;\n      }\n      this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);\n      this.startTime = null;\n    };\n    _proto.newCue = function newCue(startTime, endTime, screen) {\n      if (this.startTime === null || this.startTime > startTime) {\n        this.startTime = startTime;\n      }\n      this.endTime = endTime;\n      this.screen = screen;\n      this.timelineController.createCaptionsTrack(this.trackName);\n    };\n    _proto.reset = function reset() {\n      this.cueRanges = [];\n      this.startTime = null;\n    };\n    return OutputFilter;\n  }();\n\n  /**\n   * Copyright 2013 vtt.js Contributors\n   *\n   * Licensed under the Apache License, Version 2.0 (the 'License');\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an 'AS IS' BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  var VTTCue = (function () {\n    if (optionalSelf != null && optionalSelf.VTTCue) {\n      return self.VTTCue;\n    }\n    var AllowedDirections = ['', 'lr', 'rl'];\n    var AllowedAlignments = ['start', 'middle', 'end', 'left', 'right'];\n    function isAllowedValue(allowed, value) {\n      if (typeof value !== 'string') {\n        return false;\n      }\n      // necessary for assuring the generic conforms to the Array interface\n      if (!Array.isArray(allowed)) {\n        return false;\n      }\n      // reset the type so that the next narrowing works well\n      var lcValue = value.toLowerCase();\n      // use the allow list to narrow the type to a specific subset of strings\n      if (~allowed.indexOf(lcValue)) {\n        return lcValue;\n      }\n      return false;\n    }\n    function findDirectionSetting(value) {\n      return isAllowedValue(AllowedDirections, value);\n    }\n    function findAlignSetting(value) {\n      return isAllowedValue(AllowedAlignments, value);\n    }\n    function extend(obj) {\n      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        rest[_key - 1] = arguments[_key];\n      }\n      var i = 1;\n      for (; i < arguments.length; i++) {\n        var cobj = arguments[i];\n        for (var p in cobj) {\n          obj[p] = cobj[p];\n        }\n      }\n      return obj;\n    }\n    function VTTCue(startTime, endTime, text) {\n      var cue = this;\n      var baseObj = {\n        enumerable: true\n      };\n      /**\n       * Shim implementation specific properties. These properties are not in\n       * the spec.\n       */\n\n      // Lets us know when the VTTCue's data has changed in such a way that we need\n      // to recompute its display state. This lets us compute its display state\n      // lazily.\n      cue.hasBeenReset = false;\n\n      /**\n       * VTTCue and TextTrackCue properties\n       * http://dev.w3.org/html5/webvtt/#vttcue-interface\n       */\n\n      var _id = '';\n      var _pauseOnExit = false;\n      var _startTime = startTime;\n      var _endTime = endTime;\n      var _text = text;\n      var _region = null;\n      var _vertical = '';\n      var _snapToLines = true;\n      var _line = 'auto';\n      var _lineAlign = 'start';\n      var _position = 50;\n      var _positionAlign = 'middle';\n      var _size = 50;\n      var _align = 'middle';\n      Object.defineProperty(cue, 'id', extend({}, baseObj, {\n        get: function get() {\n          return _id;\n        },\n        set: function set(value) {\n          _id = '' + value;\n        }\n      }));\n      Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {\n        get: function get() {\n          return _pauseOnExit;\n        },\n        set: function set(value) {\n          _pauseOnExit = !!value;\n        }\n      }));\n      Object.defineProperty(cue, 'startTime', extend({}, baseObj, {\n        get: function get() {\n          return _startTime;\n        },\n        set: function set(value) {\n          if (typeof value !== 'number') {\n            throw new TypeError('Start time must be set to a number.');\n          }\n          _startTime = value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'endTime', extend({}, baseObj, {\n        get: function get() {\n          return _endTime;\n        },\n        set: function set(value) {\n          if (typeof value !== 'number') {\n            throw new TypeError('End time must be set to a number.');\n          }\n          _endTime = value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'text', extend({}, baseObj, {\n        get: function get() {\n          return _text;\n        },\n        set: function set(value) {\n          _text = '' + value;\n          this.hasBeenReset = true;\n        }\n      }));\n\n      // todo: implement VTTRegion polyfill?\n      Object.defineProperty(cue, 'region', extend({}, baseObj, {\n        get: function get() {\n          return _region;\n        },\n        set: function set(value) {\n          _region = value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'vertical', extend({}, baseObj, {\n        get: function get() {\n          return _vertical;\n        },\n        set: function set(value) {\n          var setting = findDirectionSetting(value);\n          // Have to check for false because the setting an be an empty string.\n          if (setting === false) {\n            throw new SyntaxError('An invalid or illegal string was specified.');\n          }\n          _vertical = setting;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {\n        get: function get() {\n          return _snapToLines;\n        },\n        set: function set(value) {\n          _snapToLines = !!value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'line', extend({}, baseObj, {\n        get: function get() {\n          return _line;\n        },\n        set: function set(value) {\n          if (typeof value !== 'number' && value !== 'auto') {\n            throw new SyntaxError('An invalid number or illegal string was specified.');\n          }\n          _line = value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {\n        get: function get() {\n          return _lineAlign;\n        },\n        set: function set(value) {\n          var setting = findAlignSetting(value);\n          if (!setting) {\n            throw new SyntaxError('An invalid or illegal string was specified.');\n          }\n          _lineAlign = setting;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'position', extend({}, baseObj, {\n        get: function get() {\n          return _position;\n        },\n        set: function set(value) {\n          if (value < 0 || value > 100) {\n            throw new Error('Position must be between 0 and 100.');\n          }\n          _position = value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {\n        get: function get() {\n          return _positionAlign;\n        },\n        set: function set(value) {\n          var setting = findAlignSetting(value);\n          if (!setting) {\n            throw new SyntaxError('An invalid or illegal string was specified.');\n          }\n          _positionAlign = setting;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'size', extend({}, baseObj, {\n        get: function get() {\n          return _size;\n        },\n        set: function set(value) {\n          if (value < 0 || value > 100) {\n            throw new Error('Size must be between 0 and 100.');\n          }\n          _size = value;\n          this.hasBeenReset = true;\n        }\n      }));\n      Object.defineProperty(cue, 'align', extend({}, baseObj, {\n        get: function get() {\n          return _align;\n        },\n        set: function set(value) {\n          var setting = findAlignSetting(value);\n          if (!setting) {\n            throw new SyntaxError('An invalid or illegal string was specified.');\n          }\n          _align = setting;\n          this.hasBeenReset = true;\n        }\n      }));\n\n      /**\n       * Other <track> spec defined properties\n       */\n\n      // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n      cue.displayState = undefined;\n    }\n\n    /**\n     * VTTCue methods\n     */\n\n    VTTCue.prototype.getCueAsHTML = function () {\n      // Assume WebVTT.convertCueToDOMTree is on the global.\n      var WebVTT = self.WebVTT;\n      return WebVTT.convertCueToDOMTree(self, this.text);\n    };\n    // this is a polyfill hack\n    return VTTCue;\n  })();\n\n  /*\n   * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js\n   */\n\n  var StringDecoder = /*#__PURE__*/function () {\n    function StringDecoder() {}\n    var _proto = StringDecoder.prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _proto.decode = function decode(data, options) {\n      if (!data) {\n        return '';\n      }\n      if (typeof data !== 'string') {\n        throw new Error('Error - expected string data.');\n      }\n      return decodeURIComponent(encodeURIComponent(data));\n    };\n    return StringDecoder;\n  }(); // Try to parse input as a time stamp.\n  function parseTimeStamp(input) {\n    function computeSeconds(h, m, s, f) {\n      return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);\n    }\n    var m = input.match(/^(?:(\\d+):)?(\\d{2}):(\\d{2})(\\.\\d+)?/);\n    if (!m) {\n      return null;\n    }\n    if (parseFloat(m[2]) > 59) {\n      // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n      // First position is hours as it's over 59.\n      return computeSeconds(m[2], m[3], 0, m[4]);\n    }\n    // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]\n    return computeSeconds(m[1], m[2], m[3], m[4]);\n  }\n\n  // A settings object holds key/value pairs and will ignore anything but the first\n  // assignment to a specific key.\n  var Settings = /*#__PURE__*/function () {\n    function Settings() {\n      this.values = Object.create(null);\n    }\n    var _proto2 = Settings.prototype;\n    // Only accept the first assignment to any key.\n    _proto2.set = function set(k, v) {\n      if (!this.get(k) && v !== '') {\n        this.values[k] = v;\n      }\n    }\n    // Return the value for a key, or a default value.\n    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n    // a number of possible default values as properties where 'defaultKey' is\n    // the key of the property that will be chosen; otherwise it's assumed to be\n    // a single value.\n    ;\n    _proto2.get = function get(k, dflt, defaultKey) {\n      if (defaultKey) {\n        return this.has(k) ? this.values[k] : dflt[defaultKey];\n      }\n      return this.has(k) ? this.values[k] : dflt;\n    }\n    // Check whether we have a value for a key.\n    ;\n    _proto2.has = function has(k) {\n      return k in this.values;\n    }\n    // Accept a setting if its one of the given alternatives.\n    ;\n    _proto2.alt = function alt(k, v, a) {\n      for (var n = 0; n < a.length; ++n) {\n        if (v === a[n]) {\n          this.set(k, v);\n          break;\n        }\n      }\n    }\n    // Accept a setting if its a valid (signed) integer.\n    ;\n    _proto2.integer = function integer(k, v) {\n      if (/^-?\\d+$/.test(v)) {\n        // integer\n        this.set(k, parseInt(v, 10));\n      }\n    }\n    // Accept a setting if its a valid percentage.\n    ;\n    _proto2.percent = function percent(k, v) {\n      if (/^([\\d]{1,3})(\\.[\\d]*)?%$/.test(v)) {\n        var percent = parseFloat(v);\n        if (percent >= 0 && percent <= 100) {\n          this.set(k, percent);\n          return true;\n        }\n      }\n      return false;\n    };\n    return Settings;\n  }(); // Helper function to parse input into groups separated by 'groupDelim', and\n  // interpret each group as a key/value pair separated by 'keyValueDelim'.\n  function parseOptions(input, callback, keyValueDelim, groupDelim) {\n    var groups = groupDelim ? input.split(groupDelim) : [input];\n    for (var i in groups) {\n      if (typeof groups[i] !== 'string') {\n        continue;\n      }\n      var kv = groups[i].split(keyValueDelim);\n      if (kv.length !== 2) {\n        continue;\n      }\n      var _k = kv[0];\n      var _v = kv[1];\n      callback(_k, _v);\n    }\n  }\n  var defaults = new VTTCue(0, 0, '');\n  // 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n  //  Safari doesn't yet support this change, but FF and Chrome do.\n  var center = defaults.align === 'middle' ? 'middle' : 'center';\n  function parseCue(input, cue, regionList) {\n    // Remember the original input if we need to throw an error.\n    var oInput = input;\n    // 4.1 WebVTT timestamp\n    function consumeTimeStamp() {\n      var ts = parseTimeStamp(input);\n      if (ts === null) {\n        throw new Error('Malformed timestamp: ' + oInput);\n      }\n\n      // Remove time stamp from input.\n      input = input.replace(/^[^\\sa-zA-Z-]+/, '');\n      return ts;\n    }\n\n    // 4.4.2 WebVTT cue settings\n    function consumeCueSettings(input, cue) {\n      var settings = new Settings();\n      parseOptions(input, function (k, v) {\n        var vals;\n        switch (k) {\n          case 'region':\n            // Find the last region we parsed with the same region id.\n            for (var i = regionList.length - 1; i >= 0; i--) {\n              if (regionList[i].id === v) {\n                settings.set(k, regionList[i].region);\n                break;\n              }\n            }\n            break;\n          case 'vertical':\n            settings.alt(k, v, ['rl', 'lr']);\n            break;\n          case 'line':\n            vals = v.split(',');\n            settings.integer(k, vals[0]);\n            if (settings.percent(k, vals[0])) {\n              settings.set('snapToLines', false);\n            }\n            settings.alt(k, vals[0], ['auto']);\n            if (vals.length === 2) {\n              settings.alt('lineAlign', vals[1], ['start', center, 'end']);\n            }\n            break;\n          case 'position':\n            vals = v.split(',');\n            settings.percent(k, vals[0]);\n            if (vals.length === 2) {\n              settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);\n            }\n            break;\n          case 'size':\n            settings.percent(k, v);\n            break;\n          case 'align':\n            settings.alt(k, v, ['start', center, 'end', 'left', 'right']);\n            break;\n        }\n      }, /:/, /\\s/);\n\n      // Apply default values for any missing fields.\n      cue.region = settings.get('region', null);\n      cue.vertical = settings.get('vertical', '');\n      var line = settings.get('line', 'auto');\n      if (line === 'auto' && defaults.line === -1) {\n        // set numeric line number for Safari\n        line = -1;\n      }\n      cue.line = line;\n      cue.lineAlign = settings.get('lineAlign', 'start');\n      cue.snapToLines = settings.get('snapToLines', true);\n      cue.size = settings.get('size', 100);\n      cue.align = settings.get('align', center);\n      var position = settings.get('position', 'auto');\n      if (position === 'auto' && defaults.position === 50) {\n        // set numeric position for Safari\n        position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;\n      }\n      cue.position = position;\n    }\n    function skipWhitespace() {\n      input = input.replace(/^\\s+/, '');\n    }\n\n    // 4.1 WebVTT cue timings.\n    skipWhitespace();\n    cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n    skipWhitespace();\n    if (input.slice(0, 3) !== '--\x3e') {\n      // (3) next characters must match '--\x3e'\n      throw new Error(\"Malformed time stamp (time stamps must be separated by '--\x3e'): \" + oInput);\n    }\n    input = input.slice(3);\n    skipWhitespace();\n    cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n    // 4.1 WebVTT cue settings list.\n    skipWhitespace();\n    consumeCueSettings(input, cue);\n  }\n  function fixLineBreaks(input) {\n    return input.replace(/<br(?: \\/)?>/gi, '\\n');\n  }\n  var VTTParser = /*#__PURE__*/function () {\n    function VTTParser() {\n      this.state = 'INITIAL';\n      this.buffer = '';\n      this.decoder = new StringDecoder();\n      this.regionList = [];\n      this.cue = null;\n      this.oncue = void 0;\n      this.onparsingerror = void 0;\n      this.onflush = void 0;\n    }\n    var _proto3 = VTTParser.prototype;\n    _proto3.parse = function parse(data) {\n      var _this = this;\n\n      // If there is no data then we won't decode it, but will just try to parse\n      // whatever is in buffer already. This may occur in circumstances, for\n      // example when flush() is called.\n      if (data) {\n        // Try to decode the data that we received.\n        _this.buffer += _this.decoder.decode(data, {\n          stream: true\n        });\n      }\n      function collectNextLine() {\n        var buffer = _this.buffer;\n        var pos = 0;\n        buffer = fixLineBreaks(buffer);\n        while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n          ++pos;\n        }\n        var line = buffer.slice(0, pos);\n        // Advance the buffer early in case we fail below.\n        if (buffer[pos] === '\\r') {\n          ++pos;\n        }\n        if (buffer[pos] === '\\n') {\n          ++pos;\n        }\n        _this.buffer = buffer.slice(pos);\n        return line;\n      }\n\n      // 3.2 WebVTT metadata header syntax\n      function parseHeader(input) {\n        parseOptions(input, function (k, v) {\n          // switch (k) {\n          // case 'region':\n          // 3.3 WebVTT region metadata header syntax\n          // console.log('parse region', v);\n          // parseRegion(v);\n          // break;\n          // }\n        }, /:/);\n      }\n\n      // 5.1 WebVTT file parsing.\n      try {\n        var line = '';\n        if (_this.state === 'INITIAL') {\n          // We can't start parsing until we have the first line.\n          if (!/\\r\\n|\\n/.test(_this.buffer)) {\n            return this;\n          }\n          line = collectNextLine();\n          // strip of UTF-8 BOM if any\n          // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8\n          var m = line.match(/^()?WEBVTT([ \\t].*)?$/);\n          if (!(m != null && m[0])) {\n            throw new Error('Malformed WebVTT signature.');\n          }\n          _this.state = 'HEADER';\n        }\n        var alreadyCollectedLine = false;\n        while (_this.buffer) {\n          // We can't parse a line until we have the full line.\n          if (!/\\r\\n|\\n/.test(_this.buffer)) {\n            return this;\n          }\n          if (!alreadyCollectedLine) {\n            line = collectNextLine();\n          } else {\n            alreadyCollectedLine = false;\n          }\n          switch (_this.state) {\n            case 'HEADER':\n              // 13-18 - Allow a header (metadata) under the WEBVTT line.\n              if (/:/.test(line)) {\n                parseHeader(line);\n              } else if (!line) {\n                // An empty line terminates the header and starts the body (cues).\n                _this.state = 'ID';\n              }\n              continue;\n            case 'NOTE':\n              // Ignore NOTE blocks.\n              if (!line) {\n                _this.state = 'ID';\n              }\n              continue;\n            case 'ID':\n              // Check for the start of NOTE blocks.\n              if (/^NOTE($|[ \\t])/.test(line)) {\n                _this.state = 'NOTE';\n                break;\n              }\n              // 19-29 - Allow any number of line terminators, then initialize new cue values.\n              if (!line) {\n                continue;\n              }\n              _this.cue = new VTTCue(0, 0, '');\n              _this.state = 'CUE';\n              // 30-39 - Check if self line contains an optional identifier or timing data.\n              if (line.indexOf('--\x3e') === -1) {\n                _this.cue.id = line;\n                continue;\n              }\n            // Process line as start of a cue.\n            /* falls through */\n            case 'CUE':\n              // 40 - Collect cue timings and settings.\n              if (!_this.cue) {\n                _this.state = 'BADCUE';\n                continue;\n              }\n              try {\n                parseCue(line, _this.cue, _this.regionList);\n              } catch (e) {\n                // In case of an error ignore rest of the cue.\n                _this.cue = null;\n                _this.state = 'BADCUE';\n                continue;\n              }\n              _this.state = 'CUETEXT';\n              continue;\n            case 'CUETEXT':\n              {\n                var hasSubstring = line.indexOf('--\x3e') !== -1;\n                // 34 - If we have an empty line then report the cue.\n                // 35 - If we have the special substring '--\x3e' then report the cue,\n                // but do not collect the line as we need to process the current\n                // one as a new cue.\n                if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                  // We are done parsing self cue.\n                  if (_this.oncue && _this.cue) {\n                    _this.oncue(_this.cue);\n                  }\n                  _this.cue = null;\n                  _this.state = 'ID';\n                  continue;\n                }\n                if (_this.cue === null) {\n                  continue;\n                }\n                if (_this.cue.text) {\n                  _this.cue.text += '\\n';\n                }\n                _this.cue.text += line;\n              }\n              continue;\n            case 'BADCUE':\n              // 54-62 - Collect and discard the remaining cue.\n              if (!line) {\n                _this.state = 'ID';\n              }\n          }\n        }\n      } catch (e) {\n        // If we are currently parsing a cue, report what we have.\n        if (_this.state === 'CUETEXT' && _this.cue && _this.oncue) {\n          _this.oncue(_this.cue);\n        }\n        _this.cue = null;\n        // Enter BADWEBVTT state if header was not parsed correctly otherwise\n        // another exception occurred so enter BADCUE state.\n        _this.state = _this.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';\n      }\n      return this;\n    };\n    _proto3.flush = function flush() {\n      var _this = this;\n      try {\n        // Finish decoding the stream.\n        // _this.buffer += _this.decoder.decode();\n        // Synthesize the end of the current cue or region.\n        if (_this.cue || _this.state === 'HEADER') {\n          _this.buffer += '\\n\\n';\n          _this.parse();\n        }\n        // If we've flushed, parsed, and we're still on the INITIAL state then\n        // that means we don't have enough of the stream to parse the first\n        // line.\n        if (_this.state === 'INITIAL' || _this.state === 'BADWEBVTT') {\n          throw new Error('Malformed WebVTT signature.');\n        }\n      } catch (e) {\n        if (_this.onparsingerror) {\n          _this.onparsingerror(e);\n        }\n      }\n      if (_this.onflush) {\n        _this.onflush();\n      }\n      return this;\n    };\n    return VTTParser;\n  }();\n\n  var LINEBREAKS = /\\r\\n|\\n\\r|\\n|\\r/g;\n\n  // String.prototype.startsWith is not supported in IE11\n  var startsWith = function startsWith(inputString, searchString, position) {\n    if (position === void 0) {\n      position = 0;\n    }\n    return inputString.slice(position, position + searchString.length) === searchString;\n  };\n  var cueString2millis = function cueString2millis(timeString) {\n    var ts = parseInt(timeString.slice(-3));\n    var secs = parseInt(timeString.slice(-6, -4));\n    var mins = parseInt(timeString.slice(-9, -7));\n    var hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(':'))) : 0;\n    if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {\n      throw Error(\"Malformed X-TIMESTAMP-MAP: Local:\" + timeString);\n    }\n    ts += 1000 * secs;\n    ts += 60 * 1000 * mins;\n    ts += 60 * 60 * 1000 * hours;\n    return ts;\n  };\n\n  // From https://github.com/darkskyapp/string-hash\n  var hash = function hash(text) {\n    var hash = 5381;\n    var i = text.length;\n    while (i) {\n      hash = hash * 33 ^ text.charCodeAt(--i);\n    }\n    return (hash >>> 0).toString();\n  };\n\n  // Create a unique hash id for a cue based on start/end times and text.\n  // This helps timeline-controller to avoid showing repeated captions.\n  function generateCueId(startTime, endTime, text) {\n    return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);\n  }\n  var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n    var currCC = vttCCs[cc];\n    var prevCC = vttCCs[currCC.prevCC];\n\n    // This is the first discontinuity or cues have been processed since the last discontinuity\n    // Offset = current discontinuity time\n    if (!prevCC || !prevCC.new && currCC.new) {\n      vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n      currCC.new = false;\n      return;\n    }\n\n    // There have been discontinuities since cues were last parsed.\n    // Offset = time elapsed\n    while ((_prevCC = prevCC) != null && _prevCC.new) {\n      var _prevCC;\n      vttCCs.ccOffset += currCC.start - prevCC.start;\n      currCC.new = false;\n      currCC = prevCC;\n      prevCC = vttCCs[currCC.prevCC];\n    }\n    vttCCs.presentationOffset = presentationTime;\n  };\n  function parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {\n    var parser = new VTTParser();\n    // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n    // Uint8Array.prototype.reduce is not implemented in IE11\n    var vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, '\\n').split('\\n');\n    var cues = [];\n    var init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;\n    var cueTime = '00:00.000';\n    var timestampMapMPEGTS = 0;\n    var timestampMapLOCAL = 0;\n    var parsingError;\n    var inHeader = true;\n    parser.oncue = function (cue) {\n      // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n      var currCC = vttCCs[cc];\n      var cueOffset = vttCCs.ccOffset;\n\n      // Calculate subtitle PTS offset\n      var webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 90000;\n\n      // Update offsets for new discontinuities\n      if (currCC != null && currCC.new) {\n        if (timestampMapLOCAL !== undefined) {\n          // When local time is provided, offset = discontinuity start time - local time\n          cueOffset = vttCCs.ccOffset = currCC.start;\n        } else {\n          calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);\n        }\n      }\n      if (webVttMpegTsMapOffset) {\n        if (!initPTS) {\n          parsingError = new Error('Missing initPTS for VTT MPEGTS');\n          return;\n        }\n        // If we have MPEGTS, offset = presentation time + discontinuity offset\n        cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;\n      }\n      var duration = cue.endTime - cue.startTime;\n      var startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;\n      cue.startTime = Math.max(startTime, 0);\n      cue.endTime = Math.max(startTime + duration, 0);\n\n      //trim trailing webvtt block whitespaces\n      var text = cue.text.trim();\n\n      // Fix encoding of special characters\n      cue.text = decodeURIComponent(encodeURIComponent(text));\n\n      // If the cue was not assigned an id from the VTT file (line above the content), create one.\n      if (!cue.id) {\n        cue.id = generateCueId(cue.startTime, cue.endTime, text);\n      }\n      if (cue.endTime > 0) {\n        cues.push(cue);\n      }\n    };\n    parser.onparsingerror = function (error) {\n      parsingError = error;\n    };\n    parser.onflush = function () {\n      if (parsingError) {\n        errorCallBack(parsingError);\n        return;\n      }\n      callBack(cues);\n    };\n\n    // Go through contents line by line.\n    vttLines.forEach(function (line) {\n      if (inHeader) {\n        // Look for X-TIMESTAMP-MAP in header.\n        if (startsWith(line, 'X-TIMESTAMP-MAP=')) {\n          // Once found, no more are allowed anyway, so stop searching.\n          inHeader = false;\n          // Extract LOCAL and MPEGTS.\n          line.slice(16).split(',').forEach(function (timestamp) {\n            if (startsWith(timestamp, 'LOCAL:')) {\n              cueTime = timestamp.slice(6);\n            } else if (startsWith(timestamp, 'MPEGTS:')) {\n              timestampMapMPEGTS = parseInt(timestamp.slice(7));\n            }\n          });\n          try {\n            // Convert cue time to seconds\n            timestampMapLOCAL = cueString2millis(cueTime) / 1000;\n          } catch (error) {\n            parsingError = error;\n          }\n          // Return without parsing X-TIMESTAMP-MAP line.\n          return;\n        } else if (line === '') {\n          inHeader = false;\n        }\n      }\n      // Parse line by default.\n      parser.parse(line + '\\n');\n    });\n    parser.flush();\n  }\n\n  var IMSC1_CODEC = 'stpp.ttml.im1t';\n\n  // Time format: h:m:s:frames(.subframes)\n  var HMSF_REGEX = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n\n  // Time format: hours, minutes, seconds, milliseconds, frames, ticks\n  var TIME_UNIT_REGEX = /^(\\d*(?:\\.\\d*)?)(h|m|s|ms|f|t)$/;\n  var textAlignToLineAlign = {\n    left: 'start',\n    center: 'center',\n    right: 'end',\n    start: 'start',\n    end: 'end'\n  };\n  function parseIMSC1(payload, initPTS, callBack, errorCallBack) {\n    var results = findBox(new Uint8Array(payload), ['mdat']);\n    if (results.length === 0) {\n      errorCallBack(new Error('Could not parse IMSC1 mdat'));\n      return;\n    }\n    var ttmlList = results.map(function (mdat) {\n      return utf8ArrayToStr(mdat);\n    });\n    var syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);\n    try {\n      ttmlList.forEach(function (ttml) {\n        return callBack(parseTTML(ttml, syncTime));\n      });\n    } catch (error) {\n      errorCallBack(error);\n    }\n  }\n  function parseTTML(ttml, syncTime) {\n    var parser = new DOMParser();\n    var xmlDoc = parser.parseFromString(ttml, 'text/xml');\n    var tt = xmlDoc.getElementsByTagName('tt')[0];\n    if (!tt) {\n      throw new Error('Invalid ttml');\n    }\n    var defaultRateInfo = {\n      frameRate: 30,\n      subFrameRate: 1,\n      frameRateMultiplier: 0,\n      tickRate: 0\n    };\n    var rateInfo = Object.keys(defaultRateInfo).reduce(function (result, key) {\n      result[key] = tt.getAttribute(\"ttp:\" + key) || defaultRateInfo[key];\n      return result;\n    }, {});\n    var trim = tt.getAttribute('xml:space') !== 'preserve';\n    var styleElements = collectionToDictionary(getElementCollection(tt, 'styling', 'style'));\n    var regionElements = collectionToDictionary(getElementCollection(tt, 'layout', 'region'));\n    var cueElements = getElementCollection(tt, 'body', '[begin]');\n    return [].map.call(cueElements, function (cueElement) {\n      var cueText = getTextContent(cueElement, trim);\n      if (!cueText || !cueElement.hasAttribute('begin')) {\n        return null;\n      }\n      var startTime = parseTtmlTime(cueElement.getAttribute('begin'), rateInfo);\n      var duration = parseTtmlTime(cueElement.getAttribute('dur'), rateInfo);\n      var endTime = parseTtmlTime(cueElement.getAttribute('end'), rateInfo);\n      if (startTime === null) {\n        throw timestampParsingError(cueElement);\n      }\n      if (endTime === null) {\n        if (duration === null) {\n          throw timestampParsingError(cueElement);\n        }\n        endTime = startTime + duration;\n      }\n      var cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);\n      cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);\n      var region = regionElements[cueElement.getAttribute('region')];\n      var style = styleElements[cueElement.getAttribute('style')];\n\n      // Apply styles to cue\n      var styles = getTtmlStyles(region, style, styleElements);\n      var textAlign = styles.textAlign;\n      if (textAlign) {\n        // cue.positionAlign not settable in FF~2016\n        var lineAlign = textAlignToLineAlign[textAlign];\n        if (lineAlign) {\n          cue.lineAlign = lineAlign;\n        }\n        cue.align = textAlign;\n      }\n      _extends(cue, styles);\n      return cue;\n    }).filter(function (cue) {\n      return cue !== null;\n    });\n  }\n  function getElementCollection(fromElement, parentName, childName) {\n    var parent = fromElement.getElementsByTagName(parentName)[0];\n    if (parent) {\n      return [].slice.call(parent.querySelectorAll(childName));\n    }\n    return [];\n  }\n  function collectionToDictionary(elementsWithId) {\n    return elementsWithId.reduce(function (dict, element) {\n      var id = element.getAttribute('xml:id');\n      if (id) {\n        dict[id] = element;\n      }\n      return dict;\n    }, {});\n  }\n  function getTextContent(element, trim) {\n    return [].slice.call(element.childNodes).reduce(function (str, node, i) {\n      var _node$childNodes;\n      if (node.nodeName === 'br' && i) {\n        return str + '\\n';\n      }\n      if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {\n        return getTextContent(node, trim);\n      } else if (trim) {\n        return str + node.textContent.trim().replace(/\\s+/g, ' ');\n      }\n      return str + node.textContent;\n    }, '');\n  }\n  function getTtmlStyles(region, style, styleElements) {\n    var ttsNs = 'http://www.w3.org/ns/ttml#styling';\n    var regionStyle = null;\n    var styleAttributes = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily'\n    // 'fontWeight',\n    // 'lineHeight',\n    // 'wrapOption',\n    // 'fontStyle',\n    // 'direction',\n    // 'writingMode'\n    ];\n    var regionStyleName = region != null && region.hasAttribute('style') ? region.getAttribute('style') : null;\n    if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {\n      regionStyle = styleElements[regionStyleName];\n    }\n    return styleAttributes.reduce(function (styles, name) {\n      var value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);\n      if (value) {\n        styles[name] = value;\n      }\n      return styles;\n    }, {});\n  }\n  function getAttributeNS(element, ns, name) {\n    if (!element) {\n      return null;\n    }\n    return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;\n  }\n  function timestampParsingError(node) {\n    return new Error(\"Could not parse ttml timestamp \" + node);\n  }\n  function parseTtmlTime(timeAttributeValue, rateInfo) {\n    if (!timeAttributeValue) {\n      return null;\n    }\n    var seconds = parseTimeStamp(timeAttributeValue);\n    if (seconds === null) {\n      if (HMSF_REGEX.test(timeAttributeValue)) {\n        seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);\n      } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {\n        seconds = parseTimeUnits(timeAttributeValue, rateInfo);\n      }\n    }\n    return seconds;\n  }\n  function parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {\n    var m = HMSF_REGEX.exec(timeAttributeValue);\n    var frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;\n    return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;\n  }\n  function parseTimeUnits(timeAttributeValue, rateInfo) {\n    var m = TIME_UNIT_REGEX.exec(timeAttributeValue);\n    var value = Number(m[1]);\n    var unit = m[2];\n    switch (unit) {\n      case 'h':\n        return value * 3600;\n      case 'm':\n        return value * 60;\n      case 'ms':\n        return value * 1000;\n      case 'f':\n        return value / rateInfo.frameRate;\n      case 't':\n        return value / rateInfo.tickRate;\n    }\n    return value;\n  }\n\n  var TimelineController = /*#__PURE__*/function () {\n    function TimelineController(hls) {\n      this.hls = void 0;\n      this.media = null;\n      this.config = void 0;\n      this.enabled = true;\n      this.Cues = void 0;\n      this.textTracks = [];\n      this.tracks = [];\n      this.initPTS = [];\n      this.unparsedVttFrags = [];\n      this.captionsTracks = {};\n      this.nonNativeCaptionsTracks = {};\n      this.cea608Parser1 = void 0;\n      this.cea608Parser2 = void 0;\n      this.lastCc = -1;\n      // Last video (CEA-608) fragment CC\n      this.lastSn = -1;\n      // Last video (CEA-608) fragment MSN\n      this.lastPartIndex = -1;\n      // Last video (CEA-608) fragment Part Index\n      this.prevCC = -1;\n      // Last subtitle fragment CC\n      this.vttCCs = newVTTCCs();\n      this.captionsProperties = void 0;\n      this.hls = hls;\n      this.config = hls.config;\n      this.Cues = hls.config.cueHandler;\n      this.captionsProperties = {\n        textTrack1: {\n          label: this.config.captionsTextTrack1Label,\n          languageCode: this.config.captionsTextTrack1LanguageCode\n        },\n        textTrack2: {\n          label: this.config.captionsTextTrack2Label,\n          languageCode: this.config.captionsTextTrack2LanguageCode\n        },\n        textTrack3: {\n          label: this.config.captionsTextTrack3Label,\n          languageCode: this.config.captionsTextTrack3LanguageCode\n        },\n        textTrack4: {\n          label: this.config.captionsTextTrack4Label,\n          languageCode: this.config.captionsTextTrack4LanguageCode\n        }\n      };\n      hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n      hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n      hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n      hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n      hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n      hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n      hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    }\n    var _proto = TimelineController.prototype;\n    _proto.destroy = function destroy() {\n      var hls = this.hls;\n      hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n      hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n      hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n      hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n      hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n      hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n      hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      // @ts-ignore\n      this.hls = this.config = null;\n      this.cea608Parser1 = this.cea608Parser2 = undefined;\n    };\n    _proto.initCea608Parsers = function initCea608Parsers() {\n      if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) {\n        var channel1 = new OutputFilter(this, 'textTrack1');\n        var channel2 = new OutputFilter(this, 'textTrack2');\n        var channel3 = new OutputFilter(this, 'textTrack3');\n        var channel4 = new OutputFilter(this, 'textTrack4');\n        this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);\n        this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);\n      }\n    };\n    _proto.addCues = function addCues(trackName, startTime, endTime, screen, cueRanges) {\n      // skip cues which overlap more than 50% with previously parsed time ranges\n      var merged = false;\n      for (var i = cueRanges.length; i--;) {\n        var cueRange = cueRanges[i];\n        var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n        if (overlap >= 0) {\n          cueRange[0] = Math.min(cueRange[0], startTime);\n          cueRange[1] = Math.max(cueRange[1], endTime);\n          merged = true;\n          if (overlap / (endTime - startTime) > 0.5) {\n            return;\n          }\n        }\n      }\n      if (!merged) {\n        cueRanges.push([startTime, endTime]);\n      }\n      if (this.config.renderTextTracksNatively) {\n        var track = this.captionsTracks[trackName];\n        this.Cues.newCue(track, startTime, endTime, screen);\n      } else {\n        var cues = this.Cues.newCue(null, startTime, endTime, screen);\n        this.hls.trigger(Events.CUES_PARSED, {\n          type: 'captions',\n          cues: cues,\n          track: trackName\n        });\n      }\n    }\n\n    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n    ;\n    _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {\n      var _this = this;\n      var frag = _ref.frag,\n        id = _ref.id,\n        initPTS = _ref.initPTS,\n        timescale = _ref.timescale;\n      var unparsedVttFrags = this.unparsedVttFrags;\n      if (id === 'main') {\n        this.initPTS[frag.cc] = {\n          baseTime: initPTS,\n          timescale: timescale\n        };\n      }\n\n      // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.\n      // Parse any unparsed fragments upon receiving the initial PTS.\n      if (unparsedVttFrags.length) {\n        this.unparsedVttFrags = [];\n        unparsedVttFrags.forEach(function (frag) {\n          _this.onFragLoaded(Events.FRAG_LOADED, frag);\n        });\n      }\n    };\n    _proto.getExistingTrack = function getExistingTrack(label, language) {\n      var media = this.media;\n      if (media) {\n        for (var i = 0; i < media.textTracks.length; i++) {\n          var textTrack = media.textTracks[i];\n          if (canReuseVttTextTrack(textTrack, {\n            name: label,\n            lang: language,\n            attrs: {}\n          })) {\n            return textTrack;\n          }\n        }\n      }\n      return null;\n    };\n    _proto.createCaptionsTrack = function createCaptionsTrack(trackName) {\n      if (this.config.renderTextTracksNatively) {\n        this.createNativeTrack(trackName);\n      } else {\n        this.createNonNativeTrack(trackName);\n      }\n    };\n    _proto.createNativeTrack = function createNativeTrack(trackName) {\n      if (this.captionsTracks[trackName]) {\n        return;\n      }\n      var captionsProperties = this.captionsProperties,\n        captionsTracks = this.captionsTracks,\n        media = this.media;\n      var _captionsProperties$t = captionsProperties[trackName],\n        label = _captionsProperties$t.label,\n        languageCode = _captionsProperties$t.languageCode;\n      // Enable reuse of existing text track.\n      var existingTrack = this.getExistingTrack(label, languageCode);\n      if (!existingTrack) {\n        var textTrack = this.createTextTrack('captions', label, languageCode);\n        if (textTrack) {\n          // Set a special property on the track so we know it's managed by Hls.js\n          textTrack[trackName] = true;\n          captionsTracks[trackName] = textTrack;\n        }\n      } else {\n        captionsTracks[trackName] = existingTrack;\n        clearCurrentCues(captionsTracks[trackName]);\n        sendAddTrackEvent(captionsTracks[trackName], media);\n      }\n    };\n    _proto.createNonNativeTrack = function createNonNativeTrack(trackName) {\n      if (this.nonNativeCaptionsTracks[trackName]) {\n        return;\n      }\n      // Create a list of a single track for the provider to consume\n      var trackProperties = this.captionsProperties[trackName];\n      if (!trackProperties) {\n        return;\n      }\n      var label = trackProperties.label;\n      var track = {\n        _id: trackName,\n        label: label,\n        kind: 'captions',\n        default: trackProperties.media ? !!trackProperties.media.default : false,\n        closedCaptions: trackProperties.media\n      };\n      this.nonNativeCaptionsTracks[trackName] = track;\n      this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n        tracks: [track]\n      });\n    };\n    _proto.createTextTrack = function createTextTrack(kind, label, lang) {\n      var media = this.media;\n      if (!media) {\n        return;\n      }\n      return media.addTextTrack(kind, label, lang);\n    };\n    _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n      this.media = data.media;\n      this._cleanTracks();\n    };\n    _proto.onMediaDetaching = function onMediaDetaching() {\n      var captionsTracks = this.captionsTracks;\n      Object.keys(captionsTracks).forEach(function (trackName) {\n        clearCurrentCues(captionsTracks[trackName]);\n        delete captionsTracks[trackName];\n      });\n      this.nonNativeCaptionsTracks = {};\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      // Detect discontinuity in video fragment (CEA-608) parsing\n      this.lastCc = -1;\n      this.lastSn = -1;\n      this.lastPartIndex = -1;\n      // Detect discontinuity in subtitle manifests\n      this.prevCC = -1;\n      this.vttCCs = newVTTCCs();\n      // Reset tracks\n      this._cleanTracks();\n      this.tracks = [];\n      this.captionsTracks = {};\n      this.nonNativeCaptionsTracks = {};\n      this.textTracks = [];\n      this.unparsedVttFrags = [];\n      this.initPTS = [];\n      if (this.cea608Parser1 && this.cea608Parser2) {\n        this.cea608Parser1.reset();\n        this.cea608Parser2.reset();\n      }\n    };\n    _proto._cleanTracks = function _cleanTracks() {\n      // clear outdated subtitles\n      var media = this.media;\n      if (!media) {\n        return;\n      }\n      var textTracks = media.textTracks;\n      if (textTracks) {\n        for (var i = 0; i < textTracks.length; i++) {\n          clearCurrentCues(textTracks[i]);\n        }\n      }\n    };\n    _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, data) {\n      var _this2 = this;\n      var tracks = data.subtitleTracks || [];\n      var hasIMSC1 = tracks.some(function (track) {\n        return track.textCodec === IMSC1_CODEC;\n      });\n      if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {\n        var listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);\n        if (listIsIdentical) {\n          this.tracks = tracks;\n          return;\n        }\n        this.textTracks = [];\n        this.tracks = tracks;\n        if (this.config.renderTextTracksNatively) {\n          var media = this.media;\n          var inUseTracks = media ? filterSubtitleTracks(media.textTracks) : null;\n          this.tracks.forEach(function (track, index) {\n            // Reuse tracks with the same label and lang, but do not reuse 608/708 tracks\n            var textTrack;\n            if (inUseTracks) {\n              var inUseTrack = null;\n              for (var i = 0; i < inUseTracks.length; i++) {\n                if (inUseTracks[i] && canReuseVttTextTrack(inUseTracks[i], track)) {\n                  inUseTrack = inUseTracks[i];\n                  inUseTracks[i] = null;\n                  break;\n                }\n              }\n              if (inUseTrack) {\n                textTrack = inUseTrack;\n              }\n            }\n            if (textTrack) {\n              clearCurrentCues(textTrack);\n            } else {\n              var textTrackKind = captionsOrSubtitlesFromCharacteristics(track);\n              textTrack = _this2.createTextTrack(textTrackKind, track.name, track.lang);\n              if (textTrack) {\n                textTrack.mode = 'disabled';\n              }\n            }\n            if (textTrack) {\n              _this2.textTracks.push(textTrack);\n            }\n          });\n          // Warn when video element has captions or subtitle TextTracks carried over from another source\n          if (inUseTracks != null && inUseTracks.length) {\n            var unusedTextTracks = inUseTracks.filter(function (t) {\n              return t !== null;\n            }).map(function (t) {\n              return t.label;\n            });\n            if (unusedTextTracks.length) {\n              logger.warn(\"Media element contains unused subtitle tracks: \" + unusedTextTracks.join(', ') + \". Replace media element for each source to clear TextTracks and captions menu.\");\n            }\n          }\n        } else if (this.tracks.length) {\n          // Create a list of tracks for the provider to consume\n          var tracksList = this.tracks.map(function (track) {\n            return {\n              label: track.name,\n              kind: track.type.toLowerCase(),\n              default: track.default,\n              subtitleTrack: track\n            };\n          });\n          this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n            tracks: tracksList\n          });\n        }\n      }\n    };\n    _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n      var _this3 = this;\n      if (this.config.enableCEA708Captions && data.captions) {\n        data.captions.forEach(function (captionsTrack) {\n          var instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);\n          if (!instreamIdMatch) {\n            return;\n          }\n          var trackName = \"textTrack\" + instreamIdMatch[1];\n          var trackProperties = _this3.captionsProperties[trackName];\n          if (!trackProperties) {\n            return;\n          }\n          trackProperties.label = captionsTrack.name;\n          if (captionsTrack.lang) {\n            // optional attribute\n            trackProperties.languageCode = captionsTrack.lang;\n          }\n          trackProperties.media = captionsTrack;\n        });\n      }\n    };\n    _proto.closedCaptionsForLevel = function closedCaptionsForLevel(frag) {\n      var level = this.hls.levels[frag.level];\n      return level == null ? void 0 : level.attrs['CLOSED-CAPTIONS'];\n    };\n    _proto.onFragLoading = function onFragLoading(event, data) {\n      // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n      if (this.enabled && data.frag.type === PlaylistLevelType.MAIN) {\n        var _data$part$index, _data$part;\n        var cea608Parser1 = this.cea608Parser1,\n          cea608Parser2 = this.cea608Parser2,\n          lastSn = this.lastSn;\n        var _data$frag = data.frag,\n          cc = _data$frag.cc,\n          sn = _data$frag.sn;\n        var partIndex = (_data$part$index = (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;\n        if (cea608Parser1 && cea608Parser2) {\n          if (sn !== lastSn + 1 || sn === lastSn && partIndex !== this.lastPartIndex + 1 || cc !== this.lastCc) {\n            cea608Parser1.reset();\n            cea608Parser2.reset();\n          }\n        }\n        this.lastCc = cc;\n        this.lastSn = sn;\n        this.lastPartIndex = partIndex;\n      }\n    };\n    _proto.onFragLoaded = function onFragLoaded(event, data) {\n      var frag = data.frag,\n        payload = data.payload;\n      if (frag.type === PlaylistLevelType.SUBTITLE) {\n        // If fragment is subtitle type, parse as WebVTT.\n        if (payload.byteLength) {\n          var decryptData = frag.decryptdata;\n          // fragment after decryption has a stats object\n          var decrypted = ('stats' in data);\n          // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.\n          if (decryptData == null || !decryptData.encrypted || decrypted) {\n            var trackPlaylistMedia = this.tracks[frag.level];\n            var vttCCs = this.vttCCs;\n            if (!vttCCs[frag.cc]) {\n              vttCCs[frag.cc] = {\n                start: frag.start,\n                prevCC: this.prevCC,\n                new: true\n              };\n              this.prevCC = frag.cc;\n            }\n            if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {\n              this._parseIMSC1(frag, payload);\n            } else {\n              this._parseVTTs(data);\n            }\n          }\n        } else {\n          // In case there is no payload, finish unsuccessfully.\n          this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n            success: false,\n            frag: frag,\n            error: new Error('Empty subtitle payload')\n          });\n        }\n      }\n    };\n    _proto._parseIMSC1 = function _parseIMSC1(frag, payload) {\n      var _this4 = this;\n      var hls = this.hls;\n      parseIMSC1(payload, this.initPTS[frag.cc], function (cues) {\n        _this4._appendCues(cues, frag.level);\n        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n          success: true,\n          frag: frag\n        });\n      }, function (error) {\n        logger.log(\"Failed to parse IMSC1: \" + error);\n        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n          success: false,\n          frag: frag,\n          error: error\n        });\n      });\n    };\n    _proto._parseVTTs = function _parseVTTs(data) {\n      var _frag$initSegment,\n        _this5 = this;\n      var frag = data.frag,\n        payload = data.payload;\n      // We need an initial synchronisation PTS. Store fragments as long as none has arrived\n      var initPTS = this.initPTS,\n        unparsedVttFrags = this.unparsedVttFrags;\n      var maxAvCC = initPTS.length - 1;\n      if (!initPTS[frag.cc] && maxAvCC === -1) {\n        unparsedVttFrags.push(data);\n        return;\n      }\n      var hls = this.hls;\n      // Parse the WebVTT file contents.\n      var payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)) : payload;\n      parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, function (cues) {\n        _this5._appendCues(cues, frag.level);\n        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n          success: true,\n          frag: frag\n        });\n      }, function (error) {\n        var missingInitPTS = error.message === 'Missing initPTS for VTT MPEGTS';\n        if (missingInitPTS) {\n          unparsedVttFrags.push(data);\n        } else {\n          _this5._fallbackToIMSC1(frag, payload);\n        }\n        // Something went wrong while parsing. Trigger event with success false.\n        logger.log(\"Failed to parse VTT cue: \" + error);\n        if (missingInitPTS && maxAvCC > frag.cc) {\n          return;\n        }\n        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n          success: false,\n          frag: frag,\n          error: error\n        });\n      });\n    };\n    _proto._fallbackToIMSC1 = function _fallbackToIMSC1(frag, payload) {\n      var _this6 = this;\n      // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result\n      var trackPlaylistMedia = this.tracks[frag.level];\n      if (!trackPlaylistMedia.textCodec) {\n        parseIMSC1(payload, this.initPTS[frag.cc], function () {\n          trackPlaylistMedia.textCodec = IMSC1_CODEC;\n          _this6._parseIMSC1(frag, payload);\n        }, function () {\n          trackPlaylistMedia.textCodec = 'wvtt';\n        });\n      }\n    };\n    _proto._appendCues = function _appendCues(cues, fragLevel) {\n      var hls = this.hls;\n      if (this.config.renderTextTracksNatively) {\n        var textTrack = this.textTracks[fragLevel];\n        // WebVTTParser.parse is an async method and if the currently selected text track mode is set to \"disabled\"\n        // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null\n        // and trying to access getCueById method of cues will throw an exception\n        // Because we check if the mode is disabled, we can force check `cues` below. They can't be null.\n        if (!textTrack || textTrack.mode === 'disabled') {\n          return;\n        }\n        cues.forEach(function (cue) {\n          return addCueToTrack(textTrack, cue);\n        });\n      } else {\n        var currentTrack = this.tracks[fragLevel];\n        if (!currentTrack) {\n          return;\n        }\n        var track = currentTrack.default ? 'default' : 'subtitles' + fragLevel;\n        hls.trigger(Events.CUES_PARSED, {\n          type: 'subtitles',\n          cues: cues,\n          track: track\n        });\n      }\n    };\n    _proto.onFragDecrypted = function onFragDecrypted(event, data) {\n      var frag = data.frag;\n      if (frag.type === PlaylistLevelType.SUBTITLE) {\n        this.onFragLoaded(Events.FRAG_LOADED, data);\n      }\n    };\n    _proto.onSubtitleTracksCleared = function onSubtitleTracksCleared() {\n      this.tracks = [];\n      this.captionsTracks = {};\n    };\n    _proto.onFragParsingUserdata = function onFragParsingUserdata(event, data) {\n      this.initCea608Parsers();\n      var cea608Parser1 = this.cea608Parser1,\n        cea608Parser2 = this.cea608Parser2;\n      if (!this.enabled || !cea608Parser1 || !cea608Parser2) {\n        return;\n      }\n      var frag = data.frag,\n        samples = data.samples;\n      if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === 'NONE') {\n        return;\n      }\n      // If the event contains captions (found in the bytes property), push all bytes into the parser immediately\n      // It will create the proper timestamps based on the PTS value\n      for (var i = 0; i < samples.length; i++) {\n        var ccBytes = samples[i].bytes;\n        if (ccBytes) {\n          var ccdatas = this.extractCea608Data(ccBytes);\n          cea608Parser1.addData(samples[i].pts, ccdatas[0]);\n          cea608Parser2.addData(samples[i].pts, ccdatas[1]);\n        }\n      }\n    };\n    _proto.onBufferFlushing = function onBufferFlushing(event, _ref2) {\n      var startOffset = _ref2.startOffset,\n        endOffset = _ref2.endOffset,\n        endOffsetSubtitles = _ref2.endOffsetSubtitles,\n        type = _ref2.type;\n      var media = this.media;\n      if (!media || media.currentTime < endOffset) {\n        return;\n      }\n      // Clear 608 caption cues from the captions TextTracks when the video back buffer is flushed\n      // Forward cues are never removed because we can loose streamed 608 content from recent fragments\n      if (!type || type === 'video') {\n        var captionsTracks = this.captionsTracks;\n        Object.keys(captionsTracks).forEach(function (trackName) {\n          return removeCuesInRange(captionsTracks[trackName], startOffset, endOffset);\n        });\n      }\n      if (this.config.renderTextTracksNatively) {\n        // Clear VTT/IMSC1 subtitle cues from the subtitle TextTracks when the back buffer is flushed\n        if (startOffset === 0 && endOffsetSubtitles !== undefined) {\n          var textTracks = this.textTracks;\n          Object.keys(textTracks).forEach(function (trackName) {\n            return removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles);\n          });\n        }\n      }\n    };\n    _proto.extractCea608Data = function extractCea608Data(byteArray) {\n      var actualCCBytes = [[], []];\n      var count = byteArray[0] & 0x1f;\n      var position = 2;\n      for (var j = 0; j < count; j++) {\n        var tmpByte = byteArray[position++];\n        var ccbyte1 = 0x7f & byteArray[position++];\n        var ccbyte2 = 0x7f & byteArray[position++];\n        if (ccbyte1 === 0 && ccbyte2 === 0) {\n          continue;\n        }\n        var ccValid = (0x04 & tmpByte) !== 0; // Support all four channels\n        if (ccValid) {\n          var ccType = 0x03 & tmpByte;\n          if (0x00 /* CEA608 field1*/ === ccType || 0x01 /* CEA608 field2*/ === ccType) {\n            // Exclude CEA708 CC data.\n            actualCCBytes[ccType].push(ccbyte1);\n            actualCCBytes[ccType].push(ccbyte2);\n          }\n        }\n      }\n      return actualCCBytes;\n    };\n    return TimelineController;\n  }();\n  function captionsOrSubtitlesFromCharacteristics(track) {\n    if (track.characteristics) {\n      if (/transcribes-spoken-dialog/gi.test(track.characteristics) && /describes-music-and-sound/gi.test(track.characteristics)) {\n        return 'captions';\n      }\n    }\n    return 'subtitles';\n  }\n  function canReuseVttTextTrack(inUseTrack, manifestTrack) {\n    return !!inUseTrack && inUseTrack.kind === captionsOrSubtitlesFromCharacteristics(manifestTrack) && subtitleTrackMatchesTextTrack(manifestTrack, inUseTrack);\n  }\n  function intersection(x1, x2, y1, y2) {\n    return Math.min(x2, y2) - Math.max(x1, y1);\n  }\n  function newVTTCCs() {\n    return {\n      ccOffset: 0,\n      presentationOffset: 0,\n      0: {\n        start: 0,\n        prevCC: -1,\n        new: true\n      }\n    };\n  }\n\n  var CapLevelController = /*#__PURE__*/function () {\n    function CapLevelController(hls) {\n      this.hls = void 0;\n      this.autoLevelCapping = void 0;\n      this.firstLevel = void 0;\n      this.media = void 0;\n      this.restrictedLevels = void 0;\n      this.timer = void 0;\n      this.clientRect = void 0;\n      this.streamController = void 0;\n      this.hls = hls;\n      this.autoLevelCapping = Number.POSITIVE_INFINITY;\n      this.firstLevel = -1;\n      this.media = null;\n      this.restrictedLevels = [];\n      this.timer = undefined;\n      this.clientRect = null;\n      this.registerListeners();\n    }\n    var _proto = CapLevelController.prototype;\n    _proto.setStreamController = function setStreamController(streamController) {\n      this.streamController = streamController;\n    };\n    _proto.destroy = function destroy() {\n      if (this.hls) {\n        this.unregisterListener();\n      }\n      if (this.timer) {\n        this.stopCapping();\n      }\n      this.media = null;\n      this.clientRect = null;\n      // @ts-ignore\n      this.hls = this.streamController = null;\n    };\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n      hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    };\n    _proto.unregisterListener = function unregisterListener() {\n      var hls = this.hls;\n      hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n      hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    };\n    _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(event, data) {\n      // Don't add a restricted level more than once\n      var level = this.hls.levels[data.droppedLevel];\n      if (this.isLevelAllowed(level)) {\n        this.restrictedLevels.push({\n          bitrate: level.bitrate,\n          height: level.height,\n          width: level.width\n        });\n      }\n    };\n    _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n      this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n      this.clientRect = null;\n      if (this.timer && this.hls.levels.length) {\n        this.detectPlayerSize();\n      }\n    };\n    _proto.onManifestParsed = function onManifestParsed(event, data) {\n      var hls = this.hls;\n      this.restrictedLevels = [];\n      this.firstLevel = data.firstLevel;\n      if (hls.config.capLevelToPlayerSize && data.video) {\n        // Start capping immediately if the manifest has signaled video codecs\n        this.startCapping();\n      }\n    };\n    _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {\n      if (this.timer && isFiniteNumber(this.autoLevelCapping)) {\n        this.detectPlayerSize();\n      }\n    }\n\n    // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n    // to the first level\n    ;\n    _proto.onBufferCodecs = function onBufferCodecs(event, data) {\n      var hls = this.hls;\n      if (hls.config.capLevelToPlayerSize && data.video) {\n        // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n        this.startCapping();\n      }\n    };\n    _proto.onMediaDetaching = function onMediaDetaching() {\n      this.stopCapping();\n    };\n    _proto.detectPlayerSize = function detectPlayerSize() {\n      if (this.media) {\n        if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {\n          this.clientRect = null;\n          return;\n        }\n        var levels = this.hls.levels;\n        if (levels.length) {\n          var hls = this.hls;\n          var maxLevel = this.getMaxLevel(levels.length - 1);\n          if (maxLevel !== this.autoLevelCapping) {\n            logger.log(\"Setting autoLevelCapping to \" + maxLevel + \": \" + levels[maxLevel].height + \"p@\" + levels[maxLevel].bitrate + \" for media \" + this.mediaWidth + \"x\" + this.mediaHeight);\n          }\n          hls.autoLevelCapping = maxLevel;\n          if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n            // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n            // usually happen when the user go to the fullscreen mode.\n            this.streamController.nextLevelSwitch();\n          }\n          this.autoLevelCapping = hls.autoLevelCapping;\n        }\n      }\n    }\n\n    /*\n     * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n     */;\n    _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {\n      var _this = this;\n      var levels = this.hls.levels;\n      if (!levels.length) {\n        return -1;\n      }\n      var validLevels = levels.filter(function (level, index) {\n        return _this.isLevelAllowed(level) && index <= capLevelIndex;\n      });\n      this.clientRect = null;\n      return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n    };\n    _proto.startCapping = function startCapping() {\n      if (this.timer) {\n        // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n        return;\n      }\n      this.autoLevelCapping = Number.POSITIVE_INFINITY;\n      self.clearInterval(this.timer);\n      this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n      this.detectPlayerSize();\n    };\n    _proto.stopCapping = function stopCapping() {\n      this.restrictedLevels = [];\n      this.firstLevel = -1;\n      this.autoLevelCapping = Number.POSITIVE_INFINITY;\n      if (this.timer) {\n        self.clearInterval(this.timer);\n        this.timer = undefined;\n      }\n    };\n    _proto.getDimensions = function getDimensions() {\n      if (this.clientRect) {\n        return this.clientRect;\n      }\n      var media = this.media;\n      var boundsRect = {\n        width: 0,\n        height: 0\n      };\n      if (media) {\n        var clientRect = media.getBoundingClientRect();\n        boundsRect.width = clientRect.width;\n        boundsRect.height = clientRect.height;\n        if (!boundsRect.width && !boundsRect.height) {\n          // When the media element has no width or height (equivalent to not being in the DOM),\n          // then use its width and height attributes (media.width, media.height)\n          boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n          boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n        }\n      }\n      this.clientRect = boundsRect;\n      return boundsRect;\n    };\n    _proto.isLevelAllowed = function isLevelAllowed(level) {\n      var restrictedLevels = this.restrictedLevels;\n      return !restrictedLevels.some(function (restrictedLevel) {\n        return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;\n      });\n    };\n    CapLevelController.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {\n      if (!(levels != null && levels.length)) {\n        return -1;\n      }\n\n      // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n      // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n      var atGreatestBandwidth = function atGreatestBandwidth(curLevel, nextLevel) {\n        if (!nextLevel) {\n          return true;\n        }\n        return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n      };\n\n      // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n      // the max level\n      var maxLevelIndex = levels.length - 1;\n      // Prevent changes in aspect-ratio from causing capping to toggle back and forth\n      var squareSize = Math.max(width, height);\n      for (var i = 0; i < levels.length; i += 1) {\n        var level = levels[i];\n        if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {\n          maxLevelIndex = i;\n          break;\n        }\n      }\n      return maxLevelIndex;\n    };\n    _createClass(CapLevelController, [{\n      key: \"mediaWidth\",\n      get: function get() {\n        return this.getDimensions().width * this.contentScaleFactor;\n      }\n    }, {\n      key: \"mediaHeight\",\n      get: function get() {\n        return this.getDimensions().height * this.contentScaleFactor;\n      }\n    }, {\n      key: \"contentScaleFactor\",\n      get: function get() {\n        var pixelRatio = 1;\n        if (!this.hls.config.ignoreDevicePixelRatio) {\n          try {\n            pixelRatio = self.devicePixelRatio;\n          } catch (e) {\n            /* no-op */\n          }\n        }\n        return pixelRatio;\n      }\n    }]);\n    return CapLevelController;\n  }();\n\n  var FPSController = /*#__PURE__*/function () {\n    function FPSController(hls) {\n      this.hls = void 0;\n      this.isVideoPlaybackQualityAvailable = false;\n      this.timer = void 0;\n      this.media = null;\n      this.lastTime = void 0;\n      this.lastDroppedFrames = 0;\n      this.lastDecodedFrames = 0;\n      // stream controller must be provided as a dependency!\n      this.streamController = void 0;\n      this.hls = hls;\n      this.registerListeners();\n    }\n    var _proto = FPSController.prototype;\n    _proto.setStreamController = function setStreamController(streamController) {\n      this.streamController = streamController;\n    };\n    _proto.registerListeners = function registerListeners() {\n      this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    };\n    _proto.destroy = function destroy() {\n      if (this.timer) {\n        clearInterval(this.timer);\n      }\n      this.unregisterListeners();\n      this.isVideoPlaybackQualityAvailable = false;\n      this.media = null;\n    };\n    _proto.onMediaAttaching = function onMediaAttaching(event, data) {\n      var config = this.hls.config;\n      if (config.capLevelOnFPSDrop) {\n        var media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n        this.media = media;\n        if (media && typeof media.getVideoPlaybackQuality === 'function') {\n          this.isVideoPlaybackQualityAvailable = true;\n        }\n        self.clearInterval(this.timer);\n        this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n      }\n    };\n    _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {\n      var currentTime = performance.now();\n      if (decodedFrames) {\n        if (this.lastTime) {\n          var currentPeriod = currentTime - this.lastTime;\n          var currentDropped = droppedFrames - this.lastDroppedFrames;\n          var currentDecoded = decodedFrames - this.lastDecodedFrames;\n          var droppedFPS = 1000 * currentDropped / currentPeriod;\n          var hls = this.hls;\n          hls.trigger(Events.FPS_DROP, {\n            currentDropped: currentDropped,\n            currentDecoded: currentDecoded,\n            totalDroppedFrames: droppedFrames\n          });\n          if (droppedFPS > 0) {\n            // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n              var currentLevel = hls.currentLevel;\n              logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n                currentLevel = currentLevel - 1;\n                hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {\n                  level: currentLevel,\n                  droppedLevel: hls.currentLevel\n                });\n                hls.autoLevelCapping = currentLevel;\n                this.streamController.nextLevelSwitch();\n              }\n            }\n          }\n        }\n        this.lastTime = currentTime;\n        this.lastDroppedFrames = droppedFrames;\n        this.lastDecodedFrames = decodedFrames;\n      }\n    };\n    _proto.checkFPSInterval = function checkFPSInterval() {\n      var video = this.media;\n      if (video) {\n        if (this.isVideoPlaybackQualityAvailable) {\n          var videoPlaybackQuality = video.getVideoPlaybackQuality();\n          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n        } else {\n          // HTMLVideoElement doesn't include the webkit types\n          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n        }\n      }\n    };\n    return FPSController;\n  }();\n\n  var LOGGER_PREFIX = '[eme]';\n  /**\n   * Controller to deal with encrypted media extensions (EME)\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API\n   *\n   * @class\n   * @constructor\n   */\n  var EMEController = /*#__PURE__*/function () {\n    function EMEController(hls) {\n      this.hls = void 0;\n      this.config = void 0;\n      this.media = null;\n      this.keyFormatPromise = null;\n      this.keySystemAccessPromises = {};\n      this._requestLicenseFailureCount = 0;\n      this.mediaKeySessions = [];\n      this.keyIdToKeySessionPromise = {};\n      this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [EMEController.CDMCleanupPromise] : [];\n      this.onMediaEncrypted = this._onMediaEncrypted.bind(this);\n      this.onWaitingForKey = this._onWaitingForKey.bind(this);\n      this.debug = logger.debug.bind(logger, LOGGER_PREFIX);\n      this.log = logger.log.bind(logger, LOGGER_PREFIX);\n      this.warn = logger.warn.bind(logger, LOGGER_PREFIX);\n      this.error = logger.error.bind(logger, LOGGER_PREFIX);\n      this.hls = hls;\n      this.config = hls.config;\n      this.registerListeners();\n    }\n    var _proto = EMEController.prototype;\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.onMediaDetached();\n      // Remove any references that could be held in config options or callbacks\n      var config = this.config;\n      config.requestMediaKeySystemAccessFunc = null;\n      config.licenseXhrSetup = config.licenseResponseCallback = undefined;\n      config.drmSystems = config.drmSystemOptions = {};\n      // @ts-ignore\n      this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;\n      // @ts-ignore\n      this.config = null;\n    };\n    _proto.registerListeners = function registerListeners() {\n      this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n      this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n      this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    };\n    _proto.getLicenseServerUrl = function getLicenseServerUrl(keySystem) {\n      var _this$config = this.config,\n        drmSystems = _this$config.drmSystems,\n        widevineLicenseUrl = _this$config.widevineLicenseUrl;\n      var keySystemConfiguration = drmSystems[keySystem];\n      if (keySystemConfiguration) {\n        return keySystemConfiguration.licenseUrl;\n      }\n\n      // For backward compatibility\n      if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {\n        return widevineLicenseUrl;\n      }\n      throw new Error(\"no license server URL configured for key-system \\\"\" + keySystem + \"\\\"\");\n    };\n    _proto.getServerCertificateUrl = function getServerCertificateUrl(keySystem) {\n      var drmSystems = this.config.drmSystems;\n      var keySystemConfiguration = drmSystems[keySystem];\n      if (keySystemConfiguration) {\n        return keySystemConfiguration.serverCertificateUrl;\n      } else {\n        this.log(\"No Server Certificate in config.drmSystems[\\\"\" + keySystem + \"\\\"]\");\n      }\n    };\n    _proto.attemptKeySystemAccess = function attemptKeySystemAccess(keySystemsToAttempt) {\n      var _this = this;\n      var levels = this.hls.levels;\n      var uniqueCodec = function uniqueCodec(value, i, a) {\n        return !!value && a.indexOf(value) === i;\n      };\n      var audioCodecs = levels.map(function (level) {\n        return level.audioCodec;\n      }).filter(uniqueCodec);\n      var videoCodecs = levels.map(function (level) {\n        return level.videoCodec;\n      }).filter(uniqueCodec);\n      if (audioCodecs.length + videoCodecs.length === 0) {\n        videoCodecs.push('avc1.42e01e');\n      }\n      return new Promise(function (resolve, reject) {\n        var attempt = function attempt(keySystems) {\n          var keySystem = keySystems.shift();\n          _this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then(function (mediaKeys) {\n            return resolve({\n              keySystem: keySystem,\n              mediaKeys: mediaKeys\n            });\n          }).catch(function (error) {\n            if (keySystems.length) {\n              attempt(keySystems);\n            } else if (error instanceof EMEKeyError) {\n              reject(error);\n            } else {\n              reject(new EMEKeyError({\n                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,\n                error: error,\n                fatal: true\n              }, error.message));\n            }\n          });\n        };\n        attempt(keySystemsToAttempt);\n      });\n    };\n    _proto.requestMediaKeySystemAccess = function requestMediaKeySystemAccess$1(keySystem, supportedConfigurations) {\n      var requestMediaKeySystemAccessFunc = this.config.requestMediaKeySystemAccessFunc;\n      if (!(typeof requestMediaKeySystemAccessFunc === 'function')) {\n        var errMessage = \"Configured requestMediaKeySystemAccess is not a function \" + requestMediaKeySystemAccessFunc;\n        if (requestMediaKeySystemAccess === null && self.location.protocol === 'http:') {\n          errMessage = \"navigator.requestMediaKeySystemAccess is not available over insecure protocol \" + location.protocol;\n        }\n        return Promise.reject(new Error(errMessage));\n      }\n      return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);\n    };\n    _proto.getMediaKeysPromise = function getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {\n      var _this2 = this;\n      // This can throw, but is caught in event handler callpath\n      var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);\n      var keySystemAccessPromises = this.keySystemAccessPromises[keySystem];\n      var keySystemAccess = keySystemAccessPromises == null ? void 0 : keySystemAccessPromises.keySystemAccess;\n      if (!keySystemAccess) {\n        this.log(\"Requesting encrypted media \\\"\" + keySystem + \"\\\" key-system access with config: \" + JSON.stringify(mediaKeySystemConfigs));\n        keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);\n        var _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {\n          keySystemAccess: keySystemAccess\n        };\n        keySystemAccess.catch(function (error) {\n          _this2.log(\"Failed to obtain access to key-system \\\"\" + keySystem + \"\\\": \" + error);\n        });\n        return keySystemAccess.then(function (mediaKeySystemAccess) {\n          _this2.log(\"Access for key-system \\\"\" + mediaKeySystemAccess.keySystem + \"\\\" obtained\");\n          var certificateRequest = _this2.fetchServerCertificate(keySystem);\n          _this2.log(\"Create media-keys for \\\"\" + keySystem + \"\\\"\");\n          _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then(function (mediaKeys) {\n            _this2.log(\"Media-keys created for \\\"\" + keySystem + \"\\\"\");\n            return certificateRequest.then(function (certificate) {\n              if (certificate) {\n                return _this2.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);\n              }\n              return mediaKeys;\n            });\n          });\n          _keySystemAccessPromises.mediaKeys.catch(function (error) {\n            _this2.error(\"Failed to create media-keys for \\\"\" + keySystem + \"\\\"}: \" + error);\n          });\n          return _keySystemAccessPromises.mediaKeys;\n        });\n      }\n      return keySystemAccess.then(function () {\n        return keySystemAccessPromises.mediaKeys;\n      });\n    };\n    _proto.createMediaKeySessionContext = function createMediaKeySessionContext(_ref) {\n      var decryptdata = _ref.decryptdata,\n        keySystem = _ref.keySystem,\n        mediaKeys = _ref.mediaKeys;\n      this.log(\"Creating key-system session \\\"\" + keySystem + \"\\\" keyId: \" + Hex.hexDump(decryptdata.keyId || []));\n      var mediaKeysSession = mediaKeys.createSession();\n      var mediaKeySessionContext = {\n        decryptdata: decryptdata,\n        keySystem: keySystem,\n        mediaKeys: mediaKeys,\n        mediaKeysSession: mediaKeysSession,\n        keyStatus: 'status-pending'\n      };\n      this.mediaKeySessions.push(mediaKeySessionContext);\n      return mediaKeySessionContext;\n    };\n    _proto.renewKeySession = function renewKeySession(mediaKeySessionContext) {\n      var decryptdata = mediaKeySessionContext.decryptdata;\n      if (decryptdata.pssh) {\n        var keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);\n        var _keyId = this.getKeyIdString(decryptdata);\n        var scheme = 'cenc';\n        this.keyIdToKeySessionPromise[_keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, 'expired');\n      } else {\n        this.warn(\"Could not renew expired session. Missing pssh initData.\");\n      }\n      this.removeSession(mediaKeySessionContext);\n    };\n    _proto.getKeyIdString = function getKeyIdString(decryptdata) {\n      if (!decryptdata) {\n        throw new Error('Could not read keyId of undefined decryptdata');\n      }\n      if (decryptdata.keyId === null) {\n        throw new Error('keyId is null');\n      }\n      return Hex.hexDump(decryptdata.keyId);\n    };\n    _proto.updateKeySession = function updateKeySession(mediaKeySessionContext, data) {\n      var _mediaKeySessionConte;\n      var keySession = mediaKeySessionContext.mediaKeysSession;\n      this.log(\"Updating key-session \\\"\" + keySession.sessionId + \"\\\" for keyID \" + Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? void 0 : _mediaKeySessionConte.keyId) || []) + \"\\n      } (data length: \" + (data ? data.byteLength : data) + \")\");\n      return keySession.update(data);\n    };\n    _proto.selectKeySystemFormat = function selectKeySystemFormat(frag) {\n      var keyFormats = Object.keys(frag.levelkeys || {});\n      if (!this.keyFormatPromise) {\n        this.log(\"Selecting key-system from fragment (sn: \" + frag.sn + \" \" + frag.type + \": \" + frag.level + \") key formats \" + keyFormats.join(', '));\n        this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n      }\n      return this.keyFormatPromise;\n    };\n    _proto.getKeyFormatPromise = function getKeyFormatPromise(keyFormats) {\n      var _this3 = this;\n      return new Promise(function (resolve, reject) {\n        var keySystemsInConfig = getKeySystemsForConfig(_this3.config);\n        var keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter(function (value) {\n          return !!value && keySystemsInConfig.indexOf(value) !== -1;\n        });\n        return _this3.getKeySystemSelectionPromise(keySystemsToAttempt).then(function (_ref2) {\n          var keySystem = _ref2.keySystem;\n          var keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);\n          if (keySystemFormat) {\n            resolve(keySystemFormat);\n          } else {\n            reject(new Error(\"Unable to find format for key-system \\\"\" + keySystem + \"\\\"\"));\n          }\n        }).catch(reject);\n      });\n    };\n    _proto.loadKey = function loadKey(data) {\n      var _this4 = this;\n      var decryptdata = data.keyInfo.decryptdata;\n      var keyId = this.getKeyIdString(decryptdata);\n      var keyDetails = \"(keyId: \" + keyId + \" format: \\\"\" + decryptdata.keyFormat + \"\\\" method: \" + decryptdata.method + \" uri: \" + decryptdata.uri + \")\";\n      this.log(\"Starting session for key \" + keyDetails);\n      var keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];\n      if (!keySessionContextPromise) {\n        keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(function (_ref3) {\n          var keySystem = _ref3.keySystem,\n            mediaKeys = _ref3.mediaKeys;\n          _this4.throwIfDestroyed();\n          _this4.log(\"Handle encrypted media sn: \" + data.frag.sn + \" \" + data.frag.type + \": \" + data.frag.level + \" using key \" + keyDetails);\n          return _this4.attemptSetMediaKeys(keySystem, mediaKeys).then(function () {\n            _this4.throwIfDestroyed();\n            var keySessionContext = _this4.createMediaKeySessionContext({\n              keySystem: keySystem,\n              mediaKeys: mediaKeys,\n              decryptdata: decryptdata\n            });\n            var scheme = 'cenc';\n            return _this4.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, 'playlist-key');\n          });\n        });\n        keySessionContextPromise.catch(function (error) {\n          return _this4.handleError(error);\n        });\n      }\n      return keySessionContextPromise;\n    };\n    _proto.throwIfDestroyed = function throwIfDestroyed(message) {\n      if (!this.hls) {\n        throw new Error('invalid state');\n      }\n    };\n    _proto.handleError = function handleError(error) {\n      if (!this.hls) {\n        return;\n      }\n      this.error(error.message);\n      if (error instanceof EMEKeyError) {\n        this.hls.trigger(Events.ERROR, error.data);\n      } else {\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_NO_KEYS,\n          error: error,\n          fatal: true\n        });\n      }\n    };\n    _proto.getKeySystemForKeyPromise = function getKeySystemForKeyPromise(decryptdata) {\n      var keyId = this.getKeyIdString(decryptdata);\n      var mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];\n      if (!mediaKeySessionContext) {\n        var keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);\n        var keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);\n        return this.attemptKeySystemAccess(keySystemsToAttempt);\n      }\n      return mediaKeySessionContext;\n    };\n    _proto.getKeySystemSelectionPromise = function getKeySystemSelectionPromise(keySystemsToAttempt) {\n      if (!keySystemsToAttempt.length) {\n        keySystemsToAttempt = getKeySystemsForConfig(this.config);\n      }\n      if (keySystemsToAttempt.length === 0) {\n        throw new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,\n          fatal: true\n        }, \"Missing key-system license configuration options \" + JSON.stringify({\n          drmSystems: this.config.drmSystems\n        }));\n      }\n      return this.attemptKeySystemAccess(keySystemsToAttempt);\n    };\n    _proto._onMediaEncrypted = function _onMediaEncrypted(event) {\n      var _this5 = this;\n      var initDataType = event.initDataType,\n        initData = event.initData;\n      var logMessage = \"\\\"\" + event.type + \"\\\" event: init data type: \\\"\" + initDataType + \"\\\"\";\n      this.debug(logMessage);\n\n      // Ignore event when initData is null\n      if (initData === null) {\n        return;\n      }\n      var keyId;\n      var keySystemDomain;\n      if (initDataType === 'sinf' && this.config.drmSystems[KeySystems.FAIRPLAY]) {\n        // Match sinf keyId to playlist skd://keyId=\n        var json = bin2str(new Uint8Array(initData));\n        try {\n          var sinf = base64Decode(JSON.parse(json).sinf);\n          var tenc = parseSinf(new Uint8Array(sinf));\n          if (!tenc) {\n            throw new Error(\"'schm' box missing or not cbcs/cenc with schi > tenc\");\n          }\n          keyId = tenc.subarray(8, 24);\n          keySystemDomain = KeySystems.FAIRPLAY;\n        } catch (error) {\n          this.warn(logMessage + \" Failed to parse sinf: \" + error);\n          return;\n        }\n      } else {\n        // Support Widevine clear-lead key-session creation (otherwise depend on playlist keys)\n        var psshResults = parseMultiPssh(initData);\n        var psshInfo = psshResults.filter(function (pssh) {\n          return pssh.systemId === KeySystemIds.WIDEVINE;\n        })[0];\n        if (!psshInfo) {\n          if (psshResults.length === 0 || psshResults.some(function (pssh) {\n            return !pssh.systemId;\n          })) {\n            this.warn(logMessage + \" contains incomplete or invalid pssh data\");\n          } else {\n            this.log(\"ignoring \" + logMessage + \" for \" + psshResults.map(function (pssh) {\n              return keySystemIdToKeySystemDomain(pssh.systemId);\n            }).join(',') + \" pssh data in favor of playlist keys\");\n          }\n          return;\n        }\n        keySystemDomain = keySystemIdToKeySystemDomain(psshInfo.systemId);\n        if (psshInfo.version === 0 && psshInfo.data) {\n          var offset = psshInfo.data.length - 22;\n          keyId = psshInfo.data.subarray(offset, offset + 16);\n        }\n      }\n      if (!keySystemDomain || !keyId) {\n        return;\n      }\n      var keyIdHex = Hex.hexDump(keyId);\n      var keyIdToKeySessionPromise = this.keyIdToKeySessionPromise,\n        mediaKeySessions = this.mediaKeySessions;\n      var keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];\n      var _loop = function _loop() {\n          // Match playlist key\n          var keyContext = mediaKeySessions[i];\n          var decryptdata = keyContext.decryptdata;\n          if (!decryptdata.keyId) {\n            return 0; // continue\n          }\n          var oldKeyIdHex = Hex.hexDump(decryptdata.keyId);\n          if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, '').indexOf(keyIdHex) !== -1) {\n            keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];\n            if (decryptdata.pssh) {\n              return 1; // break\n            }\n            delete keyIdToKeySessionPromise[oldKeyIdHex];\n            decryptdata.pssh = new Uint8Array(initData);\n            decryptdata.keyId = keyId;\n            keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(function () {\n              return _this5.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, 'encrypted-event-key-match');\n            });\n            return 1; // break\n          }\n        },\n        _ret;\n      for (var i = 0; i < mediaKeySessions.length; i++) {\n        _ret = _loop();\n        if (_ret === 0) continue;\n        if (_ret === 1) break;\n      }\n      if (!keySessionContextPromise) {\n        // Clear-lead key (not encountered in playlist)\n        keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([keySystemDomain]).then(function (_ref4) {\n          var _keySystemToKeySystem;\n          var keySystem = _ref4.keySystem,\n            mediaKeys = _ref4.mediaKeys;\n          _this5.throwIfDestroyed();\n          var decryptdata = new LevelKey('ISO-23001-7', keyIdHex, (_keySystemToKeySystem = keySystemDomainToKeySystemFormat(keySystem)) != null ? _keySystemToKeySystem : '');\n          decryptdata.pssh = new Uint8Array(initData);\n          decryptdata.keyId = keyId;\n          return _this5.attemptSetMediaKeys(keySystem, mediaKeys).then(function () {\n            _this5.throwIfDestroyed();\n            var keySessionContext = _this5.createMediaKeySessionContext({\n              decryptdata: decryptdata,\n              keySystem: keySystem,\n              mediaKeys: mediaKeys\n            });\n            return _this5.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, 'encrypted-event-no-match');\n          });\n        });\n      }\n      keySessionContextPromise.catch(function (error) {\n        return _this5.handleError(error);\n      });\n    };\n    _proto._onWaitingForKey = function _onWaitingForKey(event) {\n      this.log(\"\\\"\" + event.type + \"\\\" event\");\n    };\n    _proto.attemptSetMediaKeys = function attemptSetMediaKeys(keySystem, mediaKeys) {\n      var _this6 = this;\n      var queue = this.setMediaKeysQueue.slice();\n      this.log(\"Setting media-keys for \\\"\" + keySystem + \"\\\"\");\n      // Only one setMediaKeys() can run at one time, and multiple setMediaKeys() operations\n      // can be queued for execution for multiple key sessions.\n      var setMediaKeysPromise = Promise.all(queue).then(function () {\n        if (!_this6.media) {\n          throw new Error('Attempted to set mediaKeys without media element attached');\n        }\n        return _this6.media.setMediaKeys(mediaKeys);\n      });\n      this.setMediaKeysQueue.push(setMediaKeysPromise);\n      return setMediaKeysPromise.then(function () {\n        _this6.log(\"Media-keys set for \\\"\" + keySystem + \"\\\"\");\n        queue.push(setMediaKeysPromise);\n        _this6.setMediaKeysQueue = _this6.setMediaKeysQueue.filter(function (p) {\n          return queue.indexOf(p) === -1;\n        });\n      });\n    };\n    _proto.generateRequestWithPreferredKeySession = function generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {\n      var _this$config$drmSyste,\n        _this$config$drmSyste2,\n        _this7 = this;\n      var generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? void 0 : _this$config$drmSyste2.generateRequest;\n      if (generateRequestFilter) {\n        try {\n          var mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);\n          if (!mappedInitData) {\n            throw new Error('Invalid response from configured generateRequest filter');\n          }\n          initDataType = mappedInitData.initDataType;\n          initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;\n        } catch (error) {\n          var _this$hls;\n          this.warn(error.message);\n          if ((_this$hls = this.hls) != null && _this$hls.config.debug) {\n            throw error;\n          }\n        }\n      }\n      if (initData === null) {\n        this.log(\"Skipping key-session request for \\\"\" + reason + \"\\\" (no initData)\");\n        return Promise.resolve(context);\n      }\n      var keyId = this.getKeyIdString(context.decryptdata);\n      this.log(\"Generating key-session request for \\\"\" + reason + \"\\\": \" + keyId + \" (init data type: \" + initDataType + \" length: \" + (initData ? initData.byteLength : null) + \")\");\n      var licenseStatus = new EventEmitter();\n      var onmessage = context._onmessage = function (event) {\n        var keySession = context.mediaKeysSession;\n        if (!keySession) {\n          licenseStatus.emit('error', new Error('invalid state'));\n          return;\n        }\n        var messageType = event.messageType,\n          message = event.message;\n        _this7.log(\"\\\"\" + messageType + \"\\\" message event for session \\\"\" + keySession.sessionId + \"\\\" message size: \" + message.byteLength);\n        if (messageType === 'license-request' || messageType === 'license-renewal') {\n          _this7.renewLicense(context, message).catch(function (error) {\n            _this7.handleError(error);\n            licenseStatus.emit('error', error);\n          });\n        } else if (messageType === 'license-release') {\n          if (context.keySystem === KeySystems.FAIRPLAY) {\n            _this7.updateKeySession(context, strToUtf8array('acknowledged'));\n            _this7.removeSession(context);\n          }\n        } else {\n          _this7.warn(\"unhandled media key message type \\\"\" + messageType + \"\\\"\");\n        }\n      };\n      var onkeystatuseschange = context._onkeystatuseschange = function (event) {\n        var keySession = context.mediaKeysSession;\n        if (!keySession) {\n          licenseStatus.emit('error', new Error('invalid state'));\n          return;\n        }\n        _this7.onKeyStatusChange(context);\n        var keyStatus = context.keyStatus;\n        licenseStatus.emit('keyStatus', keyStatus);\n        if (keyStatus === 'expired') {\n          _this7.warn(context.keySystem + \" expired for key \" + keyId);\n          _this7.renewKeySession(context);\n        }\n      };\n      context.mediaKeysSession.addEventListener('message', onmessage);\n      context.mediaKeysSession.addEventListener('keystatuseschange', onkeystatuseschange);\n      var keyUsablePromise = new Promise(function (resolve, reject) {\n        licenseStatus.on('error', reject);\n        licenseStatus.on('keyStatus', function (keyStatus) {\n          if (keyStatus.startsWith('usable')) {\n            resolve();\n          } else if (keyStatus === 'output-restricted') {\n            reject(new EMEKeyError({\n              type: ErrorTypes.KEY_SYSTEM_ERROR,\n              details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,\n              fatal: false\n            }, 'HDCP level output restricted'));\n          } else if (keyStatus === 'internal-error') {\n            reject(new EMEKeyError({\n              type: ErrorTypes.KEY_SYSTEM_ERROR,\n              details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,\n              fatal: true\n            }, \"key status changed to \\\"\" + keyStatus + \"\\\"\"));\n          } else if (keyStatus === 'expired') {\n            reject(new Error('key expired while generating request'));\n          } else {\n            _this7.warn(\"unhandled key status change \\\"\" + keyStatus + \"\\\"\");\n          }\n        });\n      });\n      return context.mediaKeysSession.generateRequest(initDataType, initData).then(function () {\n        var _context$mediaKeysSes;\n        _this7.log(\"Request generated for key-session \\\"\" + ((_context$mediaKeysSes = context.mediaKeysSession) == null ? void 0 : _context$mediaKeysSes.sessionId) + \"\\\" keyId: \" + keyId);\n      }).catch(function (error) {\n        throw new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_NO_SESSION,\n          error: error,\n          fatal: false\n        }, \"Error generating key-session request: \" + error);\n      }).then(function () {\n        return keyUsablePromise;\n      }).catch(function (error) {\n        licenseStatus.removeAllListeners();\n        _this7.removeSession(context);\n        throw error;\n      }).then(function () {\n        licenseStatus.removeAllListeners();\n        return context;\n      });\n    };\n    _proto.onKeyStatusChange = function onKeyStatusChange(mediaKeySessionContext) {\n      var _this8 = this;\n      mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach(function (status, keyId) {\n        _this8.log(\"key status change \\\"\" + status + \"\\\" for keyStatuses keyId: \" + Hex.hexDump('buffer' in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId)) + \" session keyId: \" + Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || [])) + \" uri: \" + mediaKeySessionContext.decryptdata.uri);\n        mediaKeySessionContext.keyStatus = status;\n      });\n    };\n    _proto.fetchServerCertificate = function fetchServerCertificate(keySystem) {\n      var config = this.config;\n      var Loader = config.loader;\n      var certLoader = new Loader(config);\n      var url = this.getServerCertificateUrl(keySystem);\n      if (!url) {\n        return Promise.resolve();\n      }\n      this.log(\"Fetching server certificate for \\\"\" + keySystem + \"\\\"\");\n      return new Promise(function (resolve, reject) {\n        var loaderContext = {\n          responseType: 'arraybuffer',\n          url: url\n        };\n        var loadPolicy = config.certLoadPolicy.default;\n        var loaderConfig = {\n          loadPolicy: loadPolicy,\n          timeout: loadPolicy.maxLoadTimeMs,\n          maxRetry: 0,\n          retryDelay: 0,\n          maxRetryDelay: 0\n        };\n        var loaderCallbacks = {\n          onSuccess: function onSuccess(response, stats, context, networkDetails) {\n            resolve(response.data);\n          },\n          onError: function onError(response, contex, networkDetails, stats) {\n            reject(new EMEKeyError({\n              type: ErrorTypes.KEY_SYSTEM_ERROR,\n              details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n              fatal: true,\n              networkDetails: networkDetails,\n              response: _objectSpread2({\n                url: loaderContext.url,\n                data: undefined\n              }, response)\n            }, \"\\\"\" + keySystem + \"\\\" certificate request failed (\" + url + \"). Status: \" + response.code + \" (\" + response.text + \")\"));\n          },\n          onTimeout: function onTimeout(stats, context, networkDetails) {\n            reject(new EMEKeyError({\n              type: ErrorTypes.KEY_SYSTEM_ERROR,\n              details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n              fatal: true,\n              networkDetails: networkDetails,\n              response: {\n                url: loaderContext.url,\n                data: undefined\n              }\n            }, \"\\\"\" + keySystem + \"\\\" certificate request timed out (\" + url + \")\"));\n          },\n          onAbort: function onAbort(stats, context, networkDetails) {\n            reject(new Error('aborted'));\n          }\n        };\n        certLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n      });\n    };\n    _proto.setMediaKeysServerCertificate = function setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {\n      var _this9 = this;\n      return new Promise(function (resolve, reject) {\n        mediaKeys.setServerCertificate(cert).then(function (success) {\n          _this9.log(\"setServerCertificate \" + (success ? 'success' : 'not supported by CDM') + \" (\" + (cert == null ? void 0 : cert.byteLength) + \") on \\\"\" + keySystem + \"\\\"\");\n          resolve(mediaKeys);\n        }).catch(function (error) {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,\n            error: error,\n            fatal: true\n          }, error.message));\n        });\n      });\n    };\n    _proto.renewLicense = function renewLicense(context, keyMessage) {\n      var _this10 = this;\n      return this.requestLicense(context, new Uint8Array(keyMessage)).then(function (data) {\n        return _this10.updateKeySession(context, new Uint8Array(data)).catch(function (error) {\n          throw new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,\n            error: error,\n            fatal: true\n          }, error.message);\n        });\n      });\n    };\n    _proto.unpackPlayReadyKeyMessage = function unpackPlayReadyKeyMessage(xhr, licenseChallenge) {\n      // On Edge, the raw license message is UTF-16-encoded XML.  We need\n      // to unpack the Challenge element (base64-encoded string containing the\n      // actual license request) and any HttpHeader elements (sent as request\n      // headers).\n      // For PlayReady CDMs, we need to dig the Challenge out of the XML.\n      var xmlString = String.fromCharCode.apply(null, new Uint16Array(licenseChallenge.buffer));\n      if (!xmlString.includes('PlayReadyKeyMessage')) {\n        // This does not appear to be a wrapped message as on Edge.  Some\n        // clients do not need this unwrapping, so we will assume this is one of\n        // them.  Note that \"xml\" at this point probably looks like random\n        // garbage, since we interpreted UTF-8 as UTF-16.\n        xhr.setRequestHeader('Content-Type', 'text/xml; charset=utf-8');\n        return licenseChallenge;\n      }\n      var keyMessageXml = new DOMParser().parseFromString(xmlString, 'application/xml');\n      // Set request headers.\n      var headers = keyMessageXml.querySelectorAll('HttpHeader');\n      if (headers.length > 0) {\n        var header;\n        for (var i = 0, len = headers.length; i < len; i++) {\n          var _header$querySelector, _header$querySelector2;\n          header = headers[i];\n          var name = (_header$querySelector = header.querySelector('name')) == null ? void 0 : _header$querySelector.textContent;\n          var _value = (_header$querySelector2 = header.querySelector('value')) == null ? void 0 : _header$querySelector2.textContent;\n          if (name && _value) {\n            xhr.setRequestHeader(name, _value);\n          }\n        }\n      }\n      var challengeElement = keyMessageXml.querySelector('Challenge');\n      var challengeText = challengeElement == null ? void 0 : challengeElement.textContent;\n      if (!challengeText) {\n        throw new Error(\"Cannot find <Challenge> in key message\");\n      }\n      return strToUtf8array(atob(challengeText));\n    };\n    _proto.setupLicenseXHR = function setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {\n      var _this11 = this;\n      var licenseXhrSetup = this.config.licenseXhrSetup;\n      if (!licenseXhrSetup) {\n        xhr.open('POST', url, true);\n        return Promise.resolve({\n          xhr: xhr,\n          licenseChallenge: licenseChallenge\n        });\n      }\n      return Promise.resolve().then(function () {\n        if (!keysListItem.decryptdata) {\n          throw new Error('Key removed');\n        }\n        return licenseXhrSetup.call(_this11.hls, xhr, url, keysListItem, licenseChallenge);\n      }).catch(function (error) {\n        if (!keysListItem.decryptdata) {\n          // Key session removed. Cancel license request.\n          throw error;\n        }\n        // let's try to open before running setup\n        xhr.open('POST', url, true);\n        return licenseXhrSetup.call(_this11.hls, xhr, url, keysListItem, licenseChallenge);\n      }).then(function (licenseXhrSetupResult) {\n        // if licenseXhrSetup did not yet call open, let's do it now\n        if (!xhr.readyState) {\n          xhr.open('POST', url, true);\n        }\n        var finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;\n        return {\n          xhr: xhr,\n          licenseChallenge: finalLicenseChallenge\n        };\n      });\n    };\n    _proto.requestLicense = function requestLicense(keySessionContext, licenseChallenge) {\n      var _this12 = this;\n      var keyLoadPolicy = this.config.keyLoadPolicy.default;\n      return new Promise(function (resolve, reject) {\n        var url = _this12.getLicenseServerUrl(keySessionContext.keySystem);\n        _this12.log(\"Sending license request to URL: \" + url);\n        var xhr = new XMLHttpRequest();\n        xhr.responseType = 'arraybuffer';\n        xhr.onreadystatechange = function () {\n          if (!_this12.hls || !keySessionContext.mediaKeysSession) {\n            return reject(new Error('invalid state'));\n          }\n          if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n              _this12._requestLicenseFailureCount = 0;\n              var data = xhr.response;\n              _this12.log(\"License received \" + (data instanceof ArrayBuffer ? data.byteLength : data));\n              var licenseResponseCallback = _this12.config.licenseResponseCallback;\n              if (licenseResponseCallback) {\n                try {\n                  data = licenseResponseCallback.call(_this12.hls, xhr, url, keySessionContext);\n                } catch (error) {\n                  _this12.error(error);\n                }\n              }\n              resolve(data);\n            } else {\n              var retryConfig = keyLoadPolicy.errorRetry;\n              var maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;\n              _this12._requestLicenseFailureCount++;\n              if (_this12._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {\n                reject(new EMEKeyError({\n                  type: ErrorTypes.KEY_SYSTEM_ERROR,\n                  details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n                  fatal: true,\n                  networkDetails: xhr,\n                  response: {\n                    url: url,\n                    data: undefined,\n                    code: xhr.status,\n                    text: xhr.statusText\n                  }\n                }, \"License Request XHR failed (\" + url + \"). Status: \" + xhr.status + \" (\" + xhr.statusText + \")\"));\n              } else {\n                var attemptsLeft = maxNumRetry - _this12._requestLicenseFailureCount + 1;\n                _this12.warn(\"Retrying license request, \" + attemptsLeft + \" attempts left\");\n                _this12.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);\n              }\n            }\n          }\n        };\n        if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {\n          keySessionContext.licenseXhr.abort();\n        }\n        keySessionContext.licenseXhr = xhr;\n        _this12.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(function (_ref5) {\n          var xhr = _ref5.xhr,\n            licenseChallenge = _ref5.licenseChallenge;\n          if (keySessionContext.keySystem == KeySystems.PLAYREADY) {\n            licenseChallenge = _this12.unpackPlayReadyKeyMessage(xhr, licenseChallenge);\n          }\n          xhr.send(licenseChallenge);\n        });\n      });\n    };\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      if (!this.config.emeEnabled) {\n        return;\n      }\n      var media = data.media;\n\n      // keep reference of media\n      this.media = media;\n      media.addEventListener('encrypted', this.onMediaEncrypted);\n      media.addEventListener('waitingforkey', this.onWaitingForKey);\n    };\n    _proto.onMediaDetached = function onMediaDetached() {\n      var _this13 = this;\n      var media = this.media;\n      var mediaKeysList = this.mediaKeySessions;\n      if (media) {\n        media.removeEventListener('encrypted', this.onMediaEncrypted);\n        media.removeEventListener('waitingforkey', this.onWaitingForKey);\n        this.media = null;\n      }\n      this._requestLicenseFailureCount = 0;\n      this.setMediaKeysQueue = [];\n      this.mediaKeySessions = [];\n      this.keyIdToKeySessionPromise = {};\n      LevelKey.clearKeyUriToKeyIdMap();\n\n      // Close all sessions and remove media keys from the video element.\n      var keySessionCount = mediaKeysList.length;\n      EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map(function (mediaKeySessionContext) {\n        return _this13.removeSession(mediaKeySessionContext);\n      }).concat(media == null ? void 0 : media.setMediaKeys(null).catch(function (error) {\n        _this13.log(\"Could not clear media keys: \" + error);\n      }))).then(function () {\n        if (keySessionCount) {\n          _this13.log('finished closing key sessions and clearing media keys');\n          mediaKeysList.length = 0;\n        }\n      }).catch(function (error) {\n        _this13.log(\"Could not close sessions and clear media keys: \" + error);\n      });\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.keyFormatPromise = null;\n    };\n    _proto.onManifestLoaded = function onManifestLoaded(event, _ref6) {\n      var sessionKeys = _ref6.sessionKeys;\n      if (!sessionKeys || !this.config.emeEnabled) {\n        return;\n      }\n      if (!this.keyFormatPromise) {\n        var keyFormats = sessionKeys.reduce(function (formats, sessionKey) {\n          if (formats.indexOf(sessionKey.keyFormat) === -1) {\n            formats.push(sessionKey.keyFormat);\n          }\n          return formats;\n        }, []);\n        this.log(\"Selecting key-system from session-keys \" + keyFormats.join(', '));\n        this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n      }\n    };\n    _proto.removeSession = function removeSession(mediaKeySessionContext) {\n      var _this14 = this;\n      var mediaKeysSession = mediaKeySessionContext.mediaKeysSession,\n        licenseXhr = mediaKeySessionContext.licenseXhr;\n      if (mediaKeysSession) {\n        this.log(\"Remove licenses and keys and close session \" + mediaKeysSession.sessionId);\n        if (mediaKeySessionContext._onmessage) {\n          mediaKeysSession.removeEventListener('message', mediaKeySessionContext._onmessage);\n          mediaKeySessionContext._onmessage = undefined;\n        }\n        if (mediaKeySessionContext._onkeystatuseschange) {\n          mediaKeysSession.removeEventListener('keystatuseschange', mediaKeySessionContext._onkeystatuseschange);\n          mediaKeySessionContext._onkeystatuseschange = undefined;\n        }\n        if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {\n          licenseXhr.abort();\n        }\n        mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = undefined;\n        var index = this.mediaKeySessions.indexOf(mediaKeySessionContext);\n        if (index > -1) {\n          this.mediaKeySessions.splice(index, 1);\n        }\n        return mediaKeysSession.remove().catch(function (error) {\n          _this14.log(\"Could not remove session: \" + error);\n        }).then(function () {\n          return mediaKeysSession.close();\n        }).catch(function (error) {\n          _this14.log(\"Could not close session: \" + error);\n        });\n      }\n    };\n    return EMEController;\n  }();\n  EMEController.CDMCleanupPromise = void 0;\n  var EMEKeyError = /*#__PURE__*/function (_Error) {\n    _inheritsLoose(EMEKeyError, _Error);\n    function EMEKeyError(data, message) {\n      var _this15;\n      _this15 = _Error.call(this, message) || this;\n      _this15.data = void 0;\n      data.error || (data.error = new Error(message));\n      _this15.data = data;\n      data.err = data.error;\n      return _this15;\n    }\n    return EMEKeyError;\n  }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n  /**\n   * Common Media Object Type\n   *\n   * @group CMCD\n   * @group CMSD\n   *\n   * @beta\n   */\n  var CmObjectType;\n  (function (CmObjectType) {\n    /**\n     * text file, such as a manifest or playlist\n     */\n    CmObjectType[\"MANIFEST\"] = \"m\";\n    /**\n     * audio only\n     */\n    CmObjectType[\"AUDIO\"] = \"a\";\n    /**\n     * video only\n     */\n    CmObjectType[\"VIDEO\"] = \"v\";\n    /**\n     * muxed audio and video\n     */\n    CmObjectType[\"MUXED\"] = \"av\";\n    /**\n     * init segment\n     */\n    CmObjectType[\"INIT\"] = \"i\";\n    /**\n     * caption or subtitle\n     */\n    CmObjectType[\"CAPTION\"] = \"c\";\n    /**\n     * ISOBMFF timed text track\n     */\n    CmObjectType[\"TIMED_TEXT\"] = \"tt\";\n    /**\n     * cryptographic key, license or certificate.\n     */\n    CmObjectType[\"KEY\"] = \"k\";\n    /**\n     * other\n     */\n    CmObjectType[\"OTHER\"] = \"o\";\n  })(CmObjectType || (CmObjectType = {}));\n\n  /**\n   * Common Media Streaming Format\n   *\n   * @group CMCD\n   * @group CMSD\n   *\n   * @beta\n   */\n  var CmStreamingFormat;\n  (function (CmStreamingFormat) {\n    /**\n     * MPEG DASH\n     */\n    CmStreamingFormat[\"DASH\"] = \"d\";\n    /**\n     * HTTP Live Streaming (HLS)\n     */\n    CmStreamingFormat[\"HLS\"] = \"h\";\n    /**\n     * Smooth Streaming\n     */\n    CmStreamingFormat[\"SMOOTH\"] = \"s\";\n    /**\n     * Other\n     */\n    CmStreamingFormat[\"OTHER\"] = \"o\";\n  })(CmStreamingFormat || (CmStreamingFormat = {}));\n\n  /**\n   * CMCD header fields.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CmcdHeaderField;\n  (function (CmcdHeaderField) {\n    /**\n     * keys whose values vary with the object being requested.\n     */\n    CmcdHeaderField[\"OBJECT\"] = \"CMCD-Object\";\n    /**\n     * keys whose values vary with each request.\n     */\n    CmcdHeaderField[\"REQUEST\"] = \"CMCD-Request\";\n    /**\n     * keys whose values are expected to be invariant over the life of the session.\n     */\n    CmcdHeaderField[\"SESSION\"] = \"CMCD-Session\";\n    /**\n     * keys whose values do not vary with every request or object.\n     */\n    CmcdHeaderField[\"STATUS\"] = \"CMCD-Status\";\n  })(CmcdHeaderField || (CmcdHeaderField = {}));\n\n  var _CmcdHeaderMap;\n  /**\n   * The map of CMCD header fields to official CMCD keys.\n   *\n   * @internal\n   *\n   * @group CMCD\n   */\n  var CmcdHeaderMap = (_CmcdHeaderMap = {}, _CmcdHeaderMap[CmcdHeaderField.OBJECT] = ['br', 'd', 'ot', 'tb'], _CmcdHeaderMap[CmcdHeaderField.REQUEST] = ['bl', 'dl', 'mtp', 'nor', 'nrr', 'su'], _CmcdHeaderMap[CmcdHeaderField.SESSION] = ['cid', 'pr', 'sf', 'sid', 'st', 'v'], _CmcdHeaderMap[CmcdHeaderField.STATUS] = ['bs', 'rtp'], _CmcdHeaderMap);\n\n  /**\n   * Structured Field Item\n   *\n   * @group Structured Field\n   *\n   * @beta\n   */\n  var SfItem = function SfItem(value, params) {\n    this.value = void 0;\n    this.params = void 0;\n    if (Array.isArray(value)) {\n      value = value.map(function (v) {\n        return v instanceof SfItem ? v : new SfItem(v);\n      });\n    }\n    this.value = value;\n    this.params = params;\n  };\n\n  /**\n   * A class to represent structured field tokens when `Symbol` is not available.\n   *\n   * @group Structured Field\n   *\n   * @beta\n   */\n  var SfToken = function SfToken(description) {\n    this.description = void 0;\n    this.description = description;\n  };\n\n  var DICT = 'Dict';\n\n  function format(value) {\n    if (Array.isArray(value)) {\n      return JSON.stringify(value);\n    }\n    if (value instanceof Map) {\n      return 'Map{}';\n    }\n    if (value instanceof Set) {\n      return 'Set{}';\n    }\n    if (typeof value === 'object') {\n      return JSON.stringify(value);\n    }\n    return String(value);\n  }\n  function throwError(action, src, type, cause) {\n    return new Error(\"failed to \" + action + \" \\\"\" + format(src) + \"\\\" as \" + type, {\n      cause: cause\n    });\n  }\n\n  var BARE_ITEM = 'Bare Item';\n\n  var BOOLEAN = 'Boolean';\n\n  var BYTES = 'Byte Sequence';\n\n  var DECIMAL = 'Decimal';\n\n  var INTEGER = 'Integer';\n\n  function isInvalidInt(value) {\n    return value < -999999999999999 || 999999999999999 < value;\n  }\n\n  var STRING_REGEX = /[\\x00-\\x1f\\x7f]+/; // eslint-disable-line no-control-regex\n\n  var TOKEN = 'Token';\n\n  var KEY = 'Key';\n\n  function serializeError(src, type, cause) {\n    return throwError('serialize', src, type, cause);\n  }\n\n  // 4.1.9.  Serializing a Boolean\n  //\n  // Given a Boolean as input_boolean, return an ASCII string suitable for\n  // use in a HTTP field value.\n  //\n  // 1.  If input_boolean is not a boolean, fail serialization.\n  //\n  // 2.  Let output be an empty string.\n  //\n  // 3.  Append \"?\" to output.\n  //\n  // 4.  If input_boolean is true, append \"1\" to output.\n  //\n  // 5.  If input_boolean is false, append \"0\" to output.\n  //\n  // 6.  Return output.\n  function serializeBoolean(value) {\n    if (typeof value !== 'boolean') {\n      throw serializeError(value, BOOLEAN);\n    }\n    return value ? '?1' : '?0';\n  }\n\n  /**\n   * Encodes binary data to base64\n   *\n   * @param binary - The binary data to encode\n   * @returns The base64 encoded string\n   *\n   * @group Utils\n   *\n   * @beta\n   */\n  function base64encode(binary) {\n    return btoa(String.fromCharCode.apply(String, binary));\n  }\n\n  // 4.1.8.  Serializing a Byte Sequence\n  //\n  // Given a Byte Sequence as input_bytes, return an ASCII string suitable\n  // for use in a HTTP field value.\n  //\n  // 1.  If input_bytes is not a sequence of bytes, fail serialization.\n  //\n  // 2.  Let output be an empty string.\n  //\n  // 3.  Append \":\" to output.\n  //\n  // 4.  Append the result of base64-encoding input_bytes as per\n  //     [RFC4648], Section 4, taking account of the requirements below.\n  //\n  // 5.  Append \":\" to output.\n  //\n  // 6.  Return output.\n  //\n  // The encoded data is required to be padded with \"=\", as per [RFC4648],\n  // Section 3.2.\n  //\n  // Likewise, encoded data SHOULD have pad bits set to zero, as per\n  // [RFC4648], Section 3.5, unless it is not possible to do so due to\n  // implementation constraints.\n  function serializeByteSequence(value) {\n    if (ArrayBuffer.isView(value) === false) {\n      throw serializeError(value, BYTES);\n    }\n    return \":\" + base64encode(value) + \":\";\n  }\n\n  // 4.1.4.  Serializing an Integer\n  //\n  // Given an Integer as input_integer, return an ASCII string suitable\n  // for use in a HTTP field value.\n  //\n  // 1.  If input_integer is not an integer in the range of\n  //     -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail\n  //     serialization.\n  //\n  // 2.  Let output be an empty string.\n  //\n  // 3.  If input_integer is less than (but not equal to) 0, append \"-\" to\n  //     output.\n  //\n  // 4.  Append input_integer's numeric value represented in base 10 using\n  //     only decimal digits to output.\n  //\n  // 5.  Return output.\n  function serializeInteger(value) {\n    if (isInvalidInt(value)) {\n      throw serializeError(value, INTEGER);\n    }\n    return value.toString();\n  }\n\n  // 4.1.10.  Serializing a Date\n  //\n  // Given a Date as input_integer, return an ASCII string suitable for\n  // use in an HTTP field value.\n  // 1.  Let output be \"@\".\n  // 2.  Append to output the result of running Serializing an Integer\n  //     with input_date (Section 4.1.4).\n  // 3.  Return output.\n  function serializeDate(value) {\n    return \"@\" + serializeInteger(value.getTime() / 1000);\n  }\n\n  /**\n   * This implements the rounding procedure described in step 2 of the \"Serializing a Decimal\" specification.\n   * This rounding style is known as \"even rounding\", \"banker's rounding\", or \"commercial rounding\".\n   *\n   * @param value - The value to round\n   * @param precision - The number of decimal places to round to\n   * @returns The rounded value\n   *\n   * @group Utils\n   *\n   * @beta\n   */\n  function roundToEven(value, precision) {\n    if (value < 0) {\n      return -roundToEven(-value, precision);\n    }\n    var decimalShift = Math.pow(10, precision);\n    var isEquidistant = Math.abs(value * decimalShift % 1 - 0.5) < Number.EPSILON;\n    if (isEquidistant) {\n      // If the tail of the decimal place is 'equidistant' we round to the nearest even value\n      var flooredValue = Math.floor(value * decimalShift);\n      return (flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift;\n    } else {\n      // Otherwise, proceed as normal\n      return Math.round(value * decimalShift) / decimalShift;\n    }\n  }\n\n  // 4.1.5.  Serializing a Decimal\n  //\n  // Given a decimal number as input_decimal, return an ASCII string\n  // suitable for use in a HTTP field value.\n  //\n  // 1.   If input_decimal is not a decimal number, fail serialization.\n  //\n  // 2.   If input_decimal has more than three significant digits to the\n  //      right of the decimal point, round it to three decimal places,\n  //      rounding the final digit to the nearest value, or to the even\n  //      value if it is equidistant.\n  //\n  // 3.   If input_decimal has more than 12 significant digits to the left\n  //      of the decimal point after rounding, fail serialization.\n  //\n  // 4.   Let output be an empty string.\n  //\n  // 5.   If input_decimal is less than (but not equal to) 0, append \"-\"\n  //      to output.\n  //\n  // 6.   Append input_decimal's integer component represented in base 10\n  //      (using only decimal digits) to output; if it is zero, append\n  //      \"0\".\n  //\n  // 7.   Append \".\" to output.\n  //\n  // 8.   If input_decimal's fractional component is zero, append \"0\" to\n  //      output.\n  //\n  // 9.   Otherwise, append the significant digits of input_decimal's\n  //      fractional component represented in base 10 (using only decimal\n  //      digits) to output.\n  //\n  // 10.  Return output.\n  function serializeDecimal(value) {\n    var roundedValue = roundToEven(value, 3); // round to 3 decimal places\n    if (Math.floor(Math.abs(roundedValue)).toString().length > 12) {\n      throw serializeError(value, DECIMAL);\n    }\n    var stringValue = roundedValue.toString();\n    return stringValue.includes('.') ? stringValue : stringValue + \".0\";\n  }\n\n  var STRING = 'String';\n\n  // 4.1.6.  Serializing a String\n  //\n  // Given a String as input_string, return an ASCII string suitable for\n  // use in a HTTP field value.\n  //\n  // 1.  Convert input_string into a sequence of ASCII characters; if\n  //     conversion fails, fail serialization.\n  //\n  // 2.  If input_string contains characters in the range %x00-1f or %x7f\n  //     (i.e., not in VCHAR or SP), fail serialization.\n  //\n  // 3.  Let output be the string DQUOTE.\n  //\n  // 4.  For each character char in input_string:\n  //\n  //     1.  If char is \"\\\" or DQUOTE:\n  //\n  //         1.  Append \"\\\" to output.\n  //\n  //     2.  Append char to output.\n  //\n  // 5.  Append DQUOTE to output.\n  //\n  // 6.  Return output.\n  function serializeString(value) {\n    if (STRING_REGEX.test(value)) {\n      throw serializeError(value, STRING);\n    }\n    return \"\\\"\" + value.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\") + \"\\\"\";\n  }\n\n  function symbolToStr(symbol) {\n    return symbol.description || symbol.toString().slice(7, -1);\n  }\n\n  function serializeToken(token) {\n    var value = symbolToStr(token);\n    if (/^([a-zA-Z*])([!#$%&'*+\\-.^_`|~\\w:/]*)$/.test(value) === false) {\n      throw serializeError(value, TOKEN);\n    }\n    return value;\n  }\n\n  // 4.1.3.1.  Serializing a Bare Item\n  //\n  // Given an Item as input_item, return an ASCII string suitable for use\n  // in a HTTP field value.\n  //\n  // 1.  If input_item is an Integer, return the result of running\n  //     Serializing an Integer (Section 4.1.4) with input_item.\n  //\n  // 2.  If input_item is a Decimal, return the result of running\n  //     Serializing a Decimal (Section 4.1.5) with input_item.\n  //\n  // 3.  If input_item is a String, return the result of running\n  //     Serializing a String (Section 4.1.6) with input_item.\n  //\n  // 4.  If input_item is a Token, return the result of running\n  //     Serializing a Token (Section 4.1.7) with input_item.\n  //\n  // 5.  If input_item is a Boolean, return the result of running\n  //     Serializing a Boolean (Section 4.1.9) with input_item.\n  //\n  // 6.  If input_item is a Byte Sequence, return the result of running\n  //     Serializing a Byte Sequence (Section 4.1.8) with input_item.\n  //\n  // 7.  If input_item is a Date, return the result of running Serializing\n  //     a Date (Section 4.1.10) with input_item.\n  //\n  // 8.  Otherwise, fail serialization.\n  function serializeBareItem(value) {\n    switch (typeof value) {\n      case 'number':\n        if (!isFiniteNumber(value)) {\n          throw serializeError(value, BARE_ITEM);\n        }\n        if (Number.isInteger(value)) {\n          return serializeInteger(value);\n        }\n        return serializeDecimal(value);\n      case 'string':\n        return serializeString(value);\n      case 'symbol':\n        return serializeToken(value);\n      case 'boolean':\n        return serializeBoolean(value);\n      case 'object':\n        if (value instanceof Date) {\n          return serializeDate(value);\n        }\n        if (value instanceof Uint8Array) {\n          return serializeByteSequence(value);\n        }\n        if (value instanceof SfToken) {\n          return serializeToken(value);\n        }\n      default:\n        // fail\n        throw serializeError(value, BARE_ITEM);\n    }\n  }\n\n  // 4.1.1.3.  Serializing a Key\n  //\n  // Given a key as input_key, return an ASCII string suitable for use in\n  // a HTTP field value.\n  //\n  // 1.  Convert input_key into a sequence of ASCII characters; if\n  //     conversion fails, fail serialization.\n  //\n  // 2.  If input_key contains characters not in lcalpha, DIGIT, \"_\", \"-\",\n  //     \".\", or \"*\" fail serialization.\n  //\n  // 3.  If the first character of input_key is not lcalpha or \"*\", fail\n  //     serialization.\n  //\n  // 4.  Let output be an empty string.\n  //\n  // 5.  Append input_key to output.\n  //\n  // 6.  Return output.\n  function serializeKey(value) {\n    if (/^[a-z*][a-z0-9\\-_.*]*$/.test(value) === false) {\n      throw serializeError(value, KEY);\n    }\n    return value;\n  }\n\n  // 4.1.1.2.  Serializing Parameters\n  //\n  // Given an ordered Dictionary as input_parameters (each member having a\n  // param_name and a param_value), return an ASCII string suitable for\n  // use in a HTTP field value.\n  //\n  // 1.  Let output be an empty string.\n  //\n  // 2.  For each param_name with a value of param_value in\n  //     input_parameters:\n  //\n  //     1.  Append \";\" to output.\n  //\n  //     2.  Append the result of running Serializing a Key\n  //         (Section 4.1.1.3) with param_name to output.\n  //\n  //     3.  If param_value is not Boolean true:\n  //\n  //         1.  Append \"=\" to output.\n  //\n  //         2.  Append the result of running Serializing a bare Item\n  //             (Section 4.1.3.1) with param_value to output.\n  //\n  // 3.  Return output.\n  function serializeParams(params) {\n    if (params == null) {\n      return '';\n    }\n    return Object.entries(params).map(function (_ref) {\n      var key = _ref[0],\n        value = _ref[1];\n      if (value === true) {\n        return \";\" + serializeKey(key); // omit true\n      }\n      return \";\" + serializeKey(key) + \"=\" + serializeBareItem(value);\n    }).join('');\n  }\n\n  // 4.1.3.  Serializing an Item\n  //\n  // Given an Item as bare_item and Parameters as item_parameters, return\n  // an ASCII string suitable for use in a HTTP field value.\n  //\n  // 1.  Let output be an empty string.\n  //\n  // 2.  Append the result of running Serializing a Bare Item\n  //     Section 4.1.3.1 with bare_item to output.\n  //\n  // 3.  Append the result of running Serializing Parameters\n  //     Section 4.1.1.2 with item_parameters to output.\n  //\n  // 4.  Return output.\n  function serializeItem(value) {\n    if (value instanceof SfItem) {\n      return \"\" + serializeBareItem(value.value) + serializeParams(value.params);\n    } else {\n      return serializeBareItem(value);\n    }\n  }\n\n  // 4.1.1.1.  Serializing an Inner List\n  //\n  // Given an array of (member_value, parameters) tuples as inner_list,\n  // and parameters as list_parameters, return an ASCII string suitable\n  // for use in a HTTP field value.\n  //\n  // 1.  Let output be the string \"(\".\n  //\n  // 2.  For each (member_value, parameters) of inner_list:\n  //\n  //     1.  Append the result of running Serializing an Item\n  //         (Section 4.1.3) with (member_value, parameters) to output.\n  //\n  //     2.  If more values remain in inner_list, append a single SP to\n  //         output.\n  //\n  // 3.  Append \")\" to output.\n  //\n  // 4.  Append the result of running Serializing Parameters\n  //     (Section 4.1.1.2) with list_parameters to output.\n  //\n  // 5.  Return output.\n  function serializeInnerList(value) {\n    return \"(\" + value.value.map(serializeItem).join(' ') + \")\" + serializeParams(value.params);\n  }\n\n  // 4.1.2.  Serializing a Dictionary\n  //\n  // Given an ordered Dictionary as input_dictionary (each member having a\n  // member_name and a tuple value of (member_value, parameters)), return\n  // an ASCII string suitable for use in a HTTP field value.\n  //\n  // 1.  Let output be an empty string.\n  //\n  // 2.  For each member_name with a value of (member_value, parameters)\n  //     in input_dictionary:\n  //\n  //     1.  Append the result of running Serializing a Key\n  //         (Section 4.1.1.3) with member's member_name to output.\n  //\n  //     2.  If member_value is Boolean true:\n  //\n  //         1.  Append the result of running Serializing Parameters\n  //             (Section 4.1.1.2) with parameters to output.\n  //\n  //     3.  Otherwise:\n  //\n  //         1.  Append \"=\" to output.\n  //\n  //         2.  If member_value is an array, append the result of running\n  //             Serializing an Inner List (Section 4.1.1.1) with\n  //             (member_value, parameters) to output.\n  //\n  //         3.  Otherwise, append the result of running Serializing an\n  //             Item (Section 4.1.3) with (member_value, parameters) to\n  //             output.\n  //\n  //     4.  If more members remain in input_dictionary:\n  //\n  //         1.  Append \",\" to output.\n  //\n  //         2.  Append a single SP to output.\n  //\n  // 3.  Return output.\n  function serializeDict(dict, options) {\n    var _options;\n    if (options === void 0) {\n      options = {\n        whitespace: true\n      };\n    }\n    if (typeof dict !== 'object') {\n      throw serializeError(dict, DICT);\n    }\n    var entries = dict instanceof Map ? dict.entries() : Object.entries(dict);\n    var optionalWhiteSpace = (_options = options) != null && _options.whitespace ? ' ' : '';\n    return Array.from(entries).map(function (_ref) {\n      var key = _ref[0],\n        item = _ref[1];\n      if (item instanceof SfItem === false) {\n        item = new SfItem(item);\n      }\n      var output = serializeKey(key);\n      if (item.value === true) {\n        output += serializeParams(item.params);\n      } else {\n        output += '=';\n        if (Array.isArray(item.value)) {\n          output += serializeInnerList(item);\n        } else {\n          output += serializeItem(item);\n        }\n      }\n      return output;\n    }).join(\",\" + optionalWhiteSpace);\n  }\n\n  /**\n   * Encode an object into a structured field dictionary\n   *\n   * @param input - The structured field dictionary to encode\n   * @returns The structured field string\n   *\n   * @group Structured Field\n   *\n   * @beta\n   */\n  function encodeSfDict(value, options) {\n    return serializeDict(value, options);\n  }\n\n  /**\n   * Checks if the given key is a token field.\n   *\n   * @param key - The key to check.\n   *\n   * @returns `true` if the key is a token field.\n   *\n   * @internal\n   *\n   * @group CMCD\n   */\n  var isTokenField = function isTokenField(key) {\n    return key === 'ot' || key === 'sf' || key === 'st';\n  };\n\n  var isValid = function isValid(value) {\n    if (typeof value === 'number') {\n      return isFiniteNumber(value);\n    }\n    return value != null && value !== '' && value !== false;\n  };\n\n  /**\n   * Constructs a relative path from a URL.\n   *\n   * @param url - The destination URL\n   * @param base - The base URL\n   * @returns The relative path\n   *\n   * @group Utils\n   *\n   * @beta\n   */\n  function urlToRelativePath(url, base) {\n    var to = new URL(url);\n    var from = new URL(base);\n    if (to.origin !== from.origin) {\n      return url;\n    }\n    var toPath = to.pathname.split('/').slice(1);\n    var fromPath = from.pathname.split('/').slice(1, -1);\n    // remove common parents\n    while (toPath[0] === fromPath[0]) {\n      toPath.shift();\n      fromPath.shift();\n    }\n    // add back paths\n    while (fromPath.length) {\n      fromPath.shift();\n      toPath.unshift('..');\n    }\n    return toPath.join('/');\n  }\n\n  /**\n   * Generate a random v4 UUID\n   *\n   * @returns A random v4 UUID\n   *\n   * @group Utils\n   *\n   * @beta\n   */\n  function uuid() {\n    try {\n      return crypto.randomUUID();\n    } catch (error) {\n      try {\n        var url = URL.createObjectURL(new Blob());\n        var _uuid = url.toString();\n        URL.revokeObjectURL(url);\n        return _uuid.slice(_uuid.lastIndexOf('/') + 1);\n      } catch (error) {\n        var dt = new Date().getTime();\n        var _uuid2 = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n          var r = (dt + Math.random() * 16) % 16 | 0;\n          dt = Math.floor(dt / 16);\n          return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n        });\n        return _uuid2;\n      }\n    }\n  }\n\n  var toRounded = function toRounded(value) {\n    return Math.round(value);\n  };\n  var toUrlSafe = function toUrlSafe(value, options) {\n    if (options != null && options.baseUrl) {\n      value = urlToRelativePath(value, options.baseUrl);\n    }\n    return encodeURIComponent(value);\n  };\n  var toHundred = function toHundred(value) {\n    return toRounded(value / 100) * 100;\n  };\n  /**\n   * The default formatters for CMCD values.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CmcdFormatters = {\n    /**\n     * Bitrate (kbps) rounded integer\n     */\n    br: toRounded,\n    /**\n     * Duration (milliseconds) rounded integer\n     */\n    d: toRounded,\n    /**\n     * Buffer Length (milliseconds) rounded nearest 100ms\n     */\n    bl: toHundred,\n    /**\n     * Deadline (milliseconds) rounded nearest 100ms\n     */\n    dl: toHundred,\n    /**\n     * Measured Throughput (kbps) rounded nearest 100kbps\n     */\n    mtp: toHundred,\n    /**\n     * Next Object Request URL encoded\n     */\n    nor: toUrlSafe,\n    /**\n     * Requested maximum throughput (kbps) rounded nearest 100kbps\n     */\n    rtp: toHundred,\n    /**\n     * Top Bitrate (kbps) rounded integer\n     */\n    tb: toRounded\n  };\n\n  /**\n   * Internal CMCD processing function.\n   *\n   * @param obj - The CMCD object to process.\n   * @param map - The mapping function to use.\n   * @param options - Options for encoding.\n   *\n   * @internal\n   *\n   * @group CMCD\n   */\n  function processCmcd(obj, options) {\n    var results = {};\n    if (obj == null || typeof obj !== 'object') {\n      return results;\n    }\n    var keys = Object.keys(obj).sort();\n    var formatters = _extends({}, CmcdFormatters, options == null ? void 0 : options.formatters);\n    var filter = options == null ? void 0 : options.filter;\n    keys.forEach(function (key) {\n      if (filter != null && filter(key)) {\n        return;\n      }\n      var value = obj[key];\n      var formatter = formatters[key];\n      if (formatter) {\n        value = formatter(value, options);\n      }\n      // Version should only be reported if not equal to 1.\n      if (key === 'v' && value === 1) {\n        return;\n      }\n      // Playback rate should only be sent if not equal to 1.\n      if (key == 'pr' && value === 1) {\n        return;\n      }\n      // ignore invalid values\n      if (!isValid(value)) {\n        return;\n      }\n      if (isTokenField(key) && typeof value === 'string') {\n        value = new SfToken(value);\n      }\n      results[key] = value;\n    });\n    return results;\n  }\n\n  /**\n   * Encode a CMCD object to a string.\n   *\n   * @param cmcd - The CMCD object to encode.\n   * @param options - Options for encoding.\n   *\n   * @returns The encoded CMCD string.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  function encodeCmcd(cmcd, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (!cmcd) {\n      return '';\n    }\n    return encodeSfDict(processCmcd(cmcd, options), _extends({\n      whitespace: false\n    }, options));\n  }\n\n  /**\n   * Convert a CMCD data object to request headers\n   *\n   * @param cmcd - The CMCD data object to convert.\n   * @param options - Options for encoding the CMCD object.\n   *\n   * @returns The CMCD header shards.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  function toCmcdHeaders(cmcd, options) {\n    var _options;\n    if (options === void 0) {\n      options = {};\n    }\n    if (!cmcd) {\n      return {};\n    }\n    var entries = Object.entries(cmcd);\n    var headerMap = Object.entries(CmcdHeaderMap).concat(Object.entries(((_options = options) == null ? void 0 : _options.customHeaderMap) || {}));\n    var shards = entries.reduce(function (acc, entry) {\n      var _headerMap$find, _acc$field;\n      var key = entry[0],\n        value = entry[1];\n      var field = ((_headerMap$find = headerMap.find(function (entry) {\n        return entry[1].includes(key);\n      })) == null ? void 0 : _headerMap$find[0]) || CmcdHeaderField.REQUEST;\n      (_acc$field = acc[field]) != null ? _acc$field : acc[field] = {};\n      acc[field][key] = value;\n      return acc;\n    }, {});\n    return Object.entries(shards).reduce(function (acc, _ref) {\n      var field = _ref[0],\n        value = _ref[1];\n      acc[field] = encodeCmcd(value, options);\n      return acc;\n    }, {});\n  }\n\n  /**\n   * Append CMCD query args to a header object.\n   *\n   * @param headers - The headers to append to.\n   * @param cmcd - The CMCD object to append.\n   * @param customHeaderMap - A map of custom CMCD keys to header fields.\n   *\n   * @returns The headers with the CMCD header shards appended.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  function appendCmcdHeaders(headers, cmcd, options) {\n    return _extends(headers, toCmcdHeaders(cmcd, options));\n  }\n\n  /**\n   * CMCD parameter name.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  var CMCD_PARAM = 'CMCD';\n\n  /**\n   * Convert a CMCD data object to a query arg.\n   *\n   * @param cmcd - The CMCD object to convert.\n   * @param options - Options for encoding the CMCD object.\n   *\n   * @returns The CMCD query arg.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  function toCmcdQuery(cmcd, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (!cmcd) {\n      return '';\n    }\n    var params = encodeCmcd(cmcd, options);\n    return CMCD_PARAM + \"=\" + encodeURIComponent(params);\n  }\n\n  var REGEX = /CMCD=[^&#]+/;\n  /**\n   * Append CMCD query args to a URL.\n   *\n   * @param url - The URL to append to.\n   * @param cmcd - The CMCD object to append.\n   * @param options - Options for encoding the CMCD object.\n   *\n   * @returns The URL with the CMCD query args appended.\n   *\n   * @group CMCD\n   *\n   * @beta\n   */\n  function appendCmcdQuery(url, cmcd, options) {\n    // TODO: Replace with URLSearchParams once we drop Safari < 10.1 & Chrome < 49 support.\n    // https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n    var query = toCmcdQuery(cmcd, options);\n    if (!query) {\n      return url;\n    }\n    if (REGEX.test(url)) {\n      return url.replace(REGEX, query);\n    }\n    var separator = url.includes('?') ? '&' : '?';\n    return \"\" + url + separator + query;\n  }\n\n  /**\n   * Controller to deal with Common Media Client Data (CMCD)\n   * @see https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf\n   */\n  var CMCDController = /*#__PURE__*/function () {\n    // eslint-disable-line no-restricted-globals\n\n    function CMCDController(hls) {\n      var _this = this;\n      this.hls = void 0;\n      this.config = void 0;\n      this.media = void 0;\n      this.sid = void 0;\n      this.cid = void 0;\n      this.useHeaders = false;\n      this.includeKeys = void 0;\n      this.initialized = false;\n      this.starved = false;\n      this.buffering = true;\n      this.audioBuffer = void 0;\n      // eslint-disable-line no-restricted-globals\n      this.videoBuffer = void 0;\n      this.onWaiting = function () {\n        if (_this.initialized) {\n          _this.starved = true;\n        }\n        _this.buffering = true;\n      };\n      this.onPlaying = function () {\n        if (!_this.initialized) {\n          _this.initialized = true;\n        }\n        _this.buffering = false;\n      };\n      /**\n       * Apply CMCD data to a manifest request.\n       */\n      this.applyPlaylistData = function (context) {\n        try {\n          _this.apply(context, {\n            ot: CmObjectType.MANIFEST,\n            su: !_this.initialized\n          });\n        } catch (error) {\n          logger.warn('Could not generate manifest CMCD data.', error);\n        }\n      };\n      /**\n       * Apply CMCD data to a segment request\n       */\n      this.applyFragmentData = function (context) {\n        try {\n          var fragment = context.frag;\n          var level = _this.hls.levels[fragment.level];\n          var ot = _this.getObjectType(fragment);\n          var data = {\n            d: fragment.duration * 1000,\n            ot: ot\n          };\n          if (ot === CmObjectType.VIDEO || ot === CmObjectType.AUDIO || ot == CmObjectType.MUXED) {\n            data.br = level.bitrate / 1000;\n            data.tb = _this.getTopBandwidth(ot) / 1000;\n            data.bl = _this.getBufferLength(ot);\n          }\n          _this.apply(context, data);\n        } catch (error) {\n          logger.warn('Could not generate segment CMCD data.', error);\n        }\n      };\n      this.hls = hls;\n      var config = this.config = hls.config;\n      var cmcd = config.cmcd;\n      if (cmcd != null) {\n        config.pLoader = this.createPlaylistLoader();\n        config.fLoader = this.createFragmentLoader();\n        this.sid = cmcd.sessionId || uuid();\n        this.cid = cmcd.contentId;\n        this.useHeaders = cmcd.useHeaders === true;\n        this.includeKeys = cmcd.includeKeys;\n        this.registerListeners();\n      }\n    }\n    var _proto = CMCDController.prototype;\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n      hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n      hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    };\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.onMediaDetached();\n\n      // @ts-ignore\n      this.hls = this.config = this.audioBuffer = this.videoBuffer = null;\n      // @ts-ignore\n      this.onWaiting = this.onPlaying = null;\n    };\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      this.media = data.media;\n      this.media.addEventListener('waiting', this.onWaiting);\n      this.media.addEventListener('playing', this.onPlaying);\n    };\n    _proto.onMediaDetached = function onMediaDetached() {\n      if (!this.media) {\n        return;\n      }\n      this.media.removeEventListener('waiting', this.onWaiting);\n      this.media.removeEventListener('playing', this.onPlaying);\n\n      // @ts-ignore\n      this.media = null;\n    };\n    _proto.onBufferCreated = function onBufferCreated(event, data) {\n      var _data$tracks$audio, _data$tracks$video;\n      this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;\n      this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;\n    };\n    /**\n     * Create baseline CMCD data\n     */\n    _proto.createData = function createData() {\n      var _this$media;\n      return {\n        v: 1,\n        sf: CmStreamingFormat.HLS,\n        sid: this.sid,\n        cid: this.cid,\n        pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,\n        mtp: this.hls.bandwidthEstimate / 1000\n      };\n    }\n\n    /**\n     * Apply CMCD data to a request.\n     */;\n    _proto.apply = function apply(context, data) {\n      if (data === void 0) {\n        data = {};\n      }\n      // apply baseline data\n      _extends(data, this.createData());\n      var isVideo = data.ot === CmObjectType.INIT || data.ot === CmObjectType.VIDEO || data.ot === CmObjectType.MUXED;\n      if (this.starved && isVideo) {\n        data.bs = true;\n        data.su = true;\n        this.starved = false;\n      }\n      if (data.su == null) {\n        data.su = this.buffering;\n      }\n\n      // TODO: Implement rtp, nrr, nor, dl\n\n      var includeKeys = this.includeKeys;\n      if (includeKeys) {\n        data = Object.keys(data).reduce(function (acc, key) {\n          includeKeys.includes(key) && (acc[key] = data[key]);\n          return acc;\n        }, {});\n      }\n      if (this.useHeaders) {\n        if (!context.headers) {\n          context.headers = {};\n        }\n        appendCmcdHeaders(context.headers, data);\n      } else {\n        context.url = appendCmcdQuery(context.url, data);\n      }\n    };\n    /**\n     * The CMCD object type.\n     */\n    _proto.getObjectType = function getObjectType(fragment) {\n      var type = fragment.type;\n      if (type === 'subtitle') {\n        return CmObjectType.TIMED_TEXT;\n      }\n      if (fragment.sn === 'initSegment') {\n        return CmObjectType.INIT;\n      }\n      if (type === 'audio') {\n        return CmObjectType.AUDIO;\n      }\n      if (type === 'main') {\n        if (!this.hls.audioTracks.length) {\n          return CmObjectType.MUXED;\n        }\n        return CmObjectType.VIDEO;\n      }\n      return undefined;\n    }\n\n    /**\n     * Get the highest bitrate.\n     */;\n    _proto.getTopBandwidth = function getTopBandwidth(type) {\n      var bitrate = 0;\n      var levels;\n      var hls = this.hls;\n      if (type === CmObjectType.AUDIO) {\n        levels = hls.audioTracks;\n      } else {\n        var max = hls.maxAutoLevel;\n        var len = max > -1 ? max + 1 : hls.levels.length;\n        levels = hls.levels.slice(0, len);\n      }\n      for (var _iterator = _createForOfIteratorHelperLoose(levels), _step; !(_step = _iterator()).done;) {\n        var level = _step.value;\n        if (level.bitrate > bitrate) {\n          bitrate = level.bitrate;\n        }\n      }\n      return bitrate > 0 ? bitrate : NaN;\n    }\n\n    /**\n     * Get the buffer length for a media type in milliseconds\n     */;\n    _proto.getBufferLength = function getBufferLength(type) {\n      var media = this.hls.media;\n      var buffer = type === CmObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;\n      if (!buffer || !media) {\n        return NaN;\n      }\n      var info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);\n      return info.len * 1000;\n    }\n\n    /**\n     * Create a playlist loader\n     */;\n    _proto.createPlaylistLoader = function createPlaylistLoader() {\n      var pLoader = this.config.pLoader;\n      var apply = this.applyPlaylistData;\n      var Ctor = pLoader || this.config.loader;\n      return /*#__PURE__*/function () {\n        function CmcdPlaylistLoader(config) {\n          this.loader = void 0;\n          this.loader = new Ctor(config);\n        }\n        var _proto2 = CmcdPlaylistLoader.prototype;\n        _proto2.destroy = function destroy() {\n          this.loader.destroy();\n        };\n        _proto2.abort = function abort() {\n          this.loader.abort();\n        };\n        _proto2.load = function load(context, config, callbacks) {\n          apply(context);\n          this.loader.load(context, config, callbacks);\n        };\n        _createClass(CmcdPlaylistLoader, [{\n          key: \"stats\",\n          get: function get() {\n            return this.loader.stats;\n          }\n        }, {\n          key: \"context\",\n          get: function get() {\n            return this.loader.context;\n          }\n        }]);\n        return CmcdPlaylistLoader;\n      }();\n    }\n\n    /**\n     * Create a playlist loader\n     */;\n    _proto.createFragmentLoader = function createFragmentLoader() {\n      var fLoader = this.config.fLoader;\n      var apply = this.applyFragmentData;\n      var Ctor = fLoader || this.config.loader;\n      return /*#__PURE__*/function () {\n        function CmcdFragmentLoader(config) {\n          this.loader = void 0;\n          this.loader = new Ctor(config);\n        }\n        var _proto3 = CmcdFragmentLoader.prototype;\n        _proto3.destroy = function destroy() {\n          this.loader.destroy();\n        };\n        _proto3.abort = function abort() {\n          this.loader.abort();\n        };\n        _proto3.load = function load(context, config, callbacks) {\n          apply(context);\n          this.loader.load(context, config, callbacks);\n        };\n        _createClass(CmcdFragmentLoader, [{\n          key: \"stats\",\n          get: function get() {\n            return this.loader.stats;\n          }\n        }, {\n          key: \"context\",\n          get: function get() {\n            return this.loader.context;\n          }\n        }]);\n        return CmcdFragmentLoader;\n      }();\n    };\n    return CMCDController;\n  }();\n\n  var PATHWAY_PENALTY_DURATION_MS = 300000;\n  var ContentSteeringController = /*#__PURE__*/function () {\n    function ContentSteeringController(hls) {\n      this.hls = void 0;\n      this.log = void 0;\n      this.loader = null;\n      this.uri = null;\n      this.pathwayId = '.';\n      this.pathwayPriority = null;\n      this.timeToLoad = 300;\n      this.reloadTimer = -1;\n      this.updated = 0;\n      this.started = false;\n      this.enabled = true;\n      this.levels = null;\n      this.audioTracks = null;\n      this.subtitleTracks = null;\n      this.penalizedPathways = {};\n      this.hls = hls;\n      this.log = logger.log.bind(logger, \"[content-steering]:\");\n      this.registerListeners();\n    }\n    var _proto = ContentSteeringController.prototype;\n    _proto.registerListeners = function registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto.unregisterListeners = function unregisterListeners() {\n      var hls = this.hls;\n      if (!hls) {\n        return;\n      }\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.off(Events.ERROR, this.onError, this);\n    };\n    _proto.startLoad = function startLoad() {\n      this.started = true;\n      this.clearTimeout();\n      if (this.enabled && this.uri) {\n        if (this.updated) {\n          var ttl = this.timeToLoad * 1000 - (performance.now() - this.updated);\n          if (ttl > 0) {\n            this.scheduleRefresh(this.uri, ttl);\n            return;\n          }\n        }\n        this.loadSteeringManifest(this.uri);\n      }\n    };\n    _proto.stopLoad = function stopLoad() {\n      this.started = false;\n      if (this.loader) {\n        this.loader.destroy();\n        this.loader = null;\n      }\n      this.clearTimeout();\n    };\n    _proto.clearTimeout = function clearTimeout() {\n      if (this.reloadTimer !== -1) {\n        self.clearTimeout(this.reloadTimer);\n        this.reloadTimer = -1;\n      }\n    };\n    _proto.destroy = function destroy() {\n      this.unregisterListeners();\n      this.stopLoad();\n      // @ts-ignore\n      this.hls = null;\n      this.levels = this.audioTracks = this.subtitleTracks = null;\n    };\n    _proto.removeLevel = function removeLevel(levelToRemove) {\n      var levels = this.levels;\n      if (levels) {\n        this.levels = levels.filter(function (level) {\n          return level !== levelToRemove;\n        });\n      }\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      this.stopLoad();\n      this.enabled = true;\n      this.timeToLoad = 300;\n      this.updated = 0;\n      this.uri = null;\n      this.pathwayId = '.';\n      this.levels = this.audioTracks = this.subtitleTracks = null;\n    };\n    _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n      var contentSteering = data.contentSteering;\n      if (contentSteering === null) {\n        return;\n      }\n      this.pathwayId = contentSteering.pathwayId;\n      this.uri = contentSteering.uri;\n      if (this.started) {\n        this.startLoad();\n      }\n    };\n    _proto.onManifestParsed = function onManifestParsed(event, data) {\n      this.audioTracks = data.audioTracks;\n      this.subtitleTracks = data.subtitleTracks;\n    };\n    _proto.onError = function onError(event, data) {\n      var errorAction = data.errorAction;\n      if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {\n        var levels = this.levels;\n        var pathwayPriority = this.pathwayPriority;\n        var errorPathway = this.pathwayId;\n        if (data.context) {\n          var _data$context = data.context,\n            groupId = _data$context.groupId,\n            _pathwayId = _data$context.pathwayId,\n            type = _data$context.type;\n          if (groupId && levels) {\n            errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);\n          } else if (_pathwayId) {\n            errorPathway = _pathwayId;\n          }\n        }\n        if (!(errorPathway in this.penalizedPathways)) {\n          this.penalizedPathways[errorPathway] = performance.now();\n        }\n        if (!pathwayPriority && levels) {\n          // If PATHWAY-PRIORITY was not provided, list pathways for error handling\n          pathwayPriority = levels.reduce(function (pathways, level) {\n            if (pathways.indexOf(level.pathwayId) === -1) {\n              pathways.push(level.pathwayId);\n            }\n            return pathways;\n          }, []);\n        }\n        if (pathwayPriority && pathwayPriority.length > 1) {\n          this.updatePathwayPriority(pathwayPriority);\n          errorAction.resolved = this.pathwayId !== errorPathway;\n        }\n        if (!errorAction.resolved) {\n          logger.warn(\"Could not resolve \" + data.details + \" (\\\"\" + data.error.message + \"\\\") with content-steering for Pathway: \" + errorPathway + \" levels: \" + (levels ? levels.length : levels) + \" priorities: \" + JSON.stringify(pathwayPriority) + \" penalized: \" + JSON.stringify(this.penalizedPathways));\n        }\n      }\n    };\n    _proto.filterParsedLevels = function filterParsedLevels(levels) {\n      // Filter levels to only include those that are in the initial pathway\n      this.levels = levels;\n      var pathwayLevels = this.getLevelsForPathway(this.pathwayId);\n      if (pathwayLevels.length === 0) {\n        var _pathwayId2 = levels[0].pathwayId;\n        this.log(\"No levels found in Pathway \" + this.pathwayId + \". Setting initial Pathway to \\\"\" + _pathwayId2 + \"\\\"\");\n        pathwayLevels = this.getLevelsForPathway(_pathwayId2);\n        this.pathwayId = _pathwayId2;\n      }\n      if (pathwayLevels.length !== levels.length) {\n        this.log(\"Found \" + pathwayLevels.length + \"/\" + levels.length + \" levels in Pathway \\\"\" + this.pathwayId + \"\\\"\");\n      }\n      return pathwayLevels;\n    };\n    _proto.getLevelsForPathway = function getLevelsForPathway(pathwayId) {\n      if (this.levels === null) {\n        return [];\n      }\n      return this.levels.filter(function (level) {\n        return pathwayId === level.pathwayId;\n      });\n    };\n    _proto.updatePathwayPriority = function updatePathwayPriority(pathwayPriority) {\n      this.pathwayPriority = pathwayPriority;\n      var levels;\n\n      // Evaluate if we should remove the pathway from the penalized list\n      var penalizedPathways = this.penalizedPathways;\n      var now = performance.now();\n      Object.keys(penalizedPathways).forEach(function (pathwayId) {\n        if (now - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {\n          delete penalizedPathways[pathwayId];\n        }\n      });\n      for (var i = 0; i < pathwayPriority.length; i++) {\n        var _pathwayId3 = pathwayPriority[i];\n        if (_pathwayId3 in penalizedPathways) {\n          continue;\n        }\n        if (_pathwayId3 === this.pathwayId) {\n          return;\n        }\n        var selectedIndex = this.hls.nextLoadLevel;\n        var selectedLevel = this.hls.levels[selectedIndex];\n        levels = this.getLevelsForPathway(_pathwayId3);\n        if (levels.length > 0) {\n          this.log(\"Setting Pathway to \\\"\" + _pathwayId3 + \"\\\"\");\n          this.pathwayId = _pathwayId3;\n          reassignFragmentLevelIndexes(levels);\n          this.hls.trigger(Events.LEVELS_UPDATED, {\n            levels: levels\n          });\n          // Set LevelController's level to trigger LEVEL_SWITCHING which loads playlist if needed\n          var levelAfterChange = this.hls.levels[selectedIndex];\n          if (selectedLevel && levelAfterChange && this.levels) {\n            if (levelAfterChange.attrs['STABLE-VARIANT-ID'] !== selectedLevel.attrs['STABLE-VARIANT-ID'] && levelAfterChange.bitrate !== selectedLevel.bitrate) {\n              this.log(\"Unstable Pathways change from bitrate \" + selectedLevel.bitrate + \" to \" + levelAfterChange.bitrate);\n            }\n            this.hls.nextLoadLevel = selectedIndex;\n          }\n          break;\n        }\n      }\n    };\n    _proto.getPathwayForGroupId = function getPathwayForGroupId(groupId, type, defaultPathway) {\n      var levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);\n      for (var i = 0; i < levels.length; i++) {\n        if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {\n          return levels[i].pathwayId;\n        }\n      }\n      return defaultPathway;\n    };\n    _proto.clonePathways = function clonePathways(pathwayClones) {\n      var _this = this;\n      var levels = this.levels;\n      if (!levels) {\n        return;\n      }\n      var audioGroupCloneMap = {};\n      var subtitleGroupCloneMap = {};\n      pathwayClones.forEach(function (pathwayClone) {\n        var cloneId = pathwayClone.ID,\n          baseId = pathwayClone['BASE-ID'],\n          uriReplacement = pathwayClone['URI-REPLACEMENT'];\n        if (levels.some(function (level) {\n          return level.pathwayId === cloneId;\n        })) {\n          return;\n        }\n        var clonedVariants = _this.getLevelsForPathway(baseId).map(function (baseLevel) {\n          var attributes = new AttrList(baseLevel.attrs);\n          attributes['PATHWAY-ID'] = cloneId;\n          var clonedAudioGroupId = attributes.AUDIO && attributes.AUDIO + \"_clone_\" + cloneId;\n          var clonedSubtitleGroupId = attributes.SUBTITLES && attributes.SUBTITLES + \"_clone_\" + cloneId;\n          if (clonedAudioGroupId) {\n            audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;\n            attributes.AUDIO = clonedAudioGroupId;\n          }\n          if (clonedSubtitleGroupId) {\n            subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;\n            attributes.SUBTITLES = clonedSubtitleGroupId;\n          }\n          var url = performUriReplacement(baseLevel.uri, attributes['STABLE-VARIANT-ID'], 'PER-VARIANT-URIS', uriReplacement);\n          var clonedLevel = new Level({\n            attrs: attributes,\n            audioCodec: baseLevel.audioCodec,\n            bitrate: baseLevel.bitrate,\n            height: baseLevel.height,\n            name: baseLevel.name,\n            url: url,\n            videoCodec: baseLevel.videoCodec,\n            width: baseLevel.width\n          });\n          if (baseLevel.audioGroups) {\n            for (var i = 1; i < baseLevel.audioGroups.length; i++) {\n              clonedLevel.addGroupId('audio', baseLevel.audioGroups[i] + \"_clone_\" + cloneId);\n            }\n          }\n          if (baseLevel.subtitleGroups) {\n            for (var _i = 1; _i < baseLevel.subtitleGroups.length; _i++) {\n              clonedLevel.addGroupId('text', baseLevel.subtitleGroups[_i] + \"_clone_\" + cloneId);\n            }\n          }\n          return clonedLevel;\n        });\n        levels.push.apply(levels, clonedVariants);\n        cloneRenditionGroups(_this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);\n        cloneRenditionGroups(_this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);\n      });\n    };\n    _proto.loadSteeringManifest = function loadSteeringManifest(uri) {\n      var _this2 = this;\n      var config = this.hls.config;\n      var Loader = config.loader;\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      this.loader = new Loader(config);\n      var url;\n      try {\n        url = new self.URL(uri);\n      } catch (error) {\n        this.enabled = false;\n        this.log(\"Failed to parse Steering Manifest URI: \" + uri);\n        return;\n      }\n      if (url.protocol !== 'data:') {\n        var throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;\n        url.searchParams.set('_HLS_pathway', this.pathwayId);\n        url.searchParams.set('_HLS_throughput', '' + throughput);\n      }\n      var context = {\n        responseType: 'json',\n        url: url.href\n      };\n      var loadPolicy = config.steeringManifestLoadPolicy.default;\n      var legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n      var loaderConfig = {\n        loadPolicy: loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n        retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n        maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n      };\n      var callbacks = {\n        onSuccess: function onSuccess(response, stats, context, networkDetails) {\n          _this2.log(\"Loaded steering manifest: \\\"\" + url + \"\\\"\");\n          var steeringData = response.data;\n          if (steeringData.VERSION !== 1) {\n            _this2.log(\"Steering VERSION \" + steeringData.VERSION + \" not supported!\");\n            return;\n          }\n          _this2.updated = performance.now();\n          _this2.timeToLoad = steeringData.TTL;\n          var reloadUri = steeringData['RELOAD-URI'],\n            pathwayClones = steeringData['PATHWAY-CLONES'],\n            pathwayPriority = steeringData['PATHWAY-PRIORITY'];\n          if (reloadUri) {\n            try {\n              _this2.uri = new self.URL(reloadUri, url).href;\n            } catch (error) {\n              _this2.enabled = false;\n              _this2.log(\"Failed to parse Steering Manifest RELOAD-URI: \" + reloadUri);\n              return;\n            }\n          }\n          _this2.scheduleRefresh(_this2.uri || context.url);\n          if (pathwayClones) {\n            _this2.clonePathways(pathwayClones);\n          }\n          var loadedSteeringData = {\n            steeringManifest: steeringData,\n            url: url.toString()\n          };\n          _this2.hls.trigger(Events.STEERING_MANIFEST_LOADED, loadedSteeringData);\n          if (pathwayPriority) {\n            _this2.updatePathwayPriority(pathwayPriority);\n          }\n        },\n        onError: function onError(error, context, networkDetails, stats) {\n          _this2.log(\"Error loading steering manifest: \" + error.code + \" \" + error.text + \" (\" + context.url + \")\");\n          _this2.stopLoad();\n          if (error.code === 410) {\n            _this2.enabled = false;\n            _this2.log(\"Steering manifest \" + context.url + \" no longer available\");\n            return;\n          }\n          var ttl = _this2.timeToLoad * 1000;\n          if (error.code === 429) {\n            var loader = _this2.loader;\n            if (typeof (loader == null ? void 0 : loader.getResponseHeader) === 'function') {\n              var retryAfter = loader.getResponseHeader('Retry-After');\n              if (retryAfter) {\n                ttl = parseFloat(retryAfter) * 1000;\n              }\n            }\n            _this2.log(\"Steering manifest \" + context.url + \" rate limited\");\n            return;\n          }\n          _this2.scheduleRefresh(_this2.uri || context.url, ttl);\n        },\n        onTimeout: function onTimeout(stats, context, networkDetails) {\n          _this2.log(\"Timeout loading steering manifest (\" + context.url + \")\");\n          _this2.scheduleRefresh(_this2.uri || context.url);\n        }\n      };\n      this.log(\"Requesting steering manifest: \" + url);\n      this.loader.load(context, loaderConfig, callbacks);\n    };\n    _proto.scheduleRefresh = function scheduleRefresh(uri, ttlMs) {\n      var _this3 = this;\n      if (ttlMs === void 0) {\n        ttlMs = this.timeToLoad * 1000;\n      }\n      this.clearTimeout();\n      this.reloadTimer = self.setTimeout(function () {\n        var _this3$hls;\n        var media = (_this3$hls = _this3.hls) == null ? void 0 : _this3$hls.media;\n        if (media && !media.ended) {\n          _this3.loadSteeringManifest(uri);\n          return;\n        }\n        _this3.scheduleRefresh(uri, _this3.timeToLoad * 1000);\n      }, ttlMs);\n    };\n    return ContentSteeringController;\n  }();\n  function cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {\n    if (!tracks) {\n      return;\n    }\n    Object.keys(groupCloneMap).forEach(function (audioGroupId) {\n      var clonedTracks = tracks.filter(function (track) {\n        return track.groupId === audioGroupId;\n      }).map(function (track) {\n        var clonedTrack = _extends({}, track);\n        clonedTrack.details = undefined;\n        clonedTrack.attrs = new AttrList(clonedTrack.attrs);\n        clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs['STABLE-RENDITION-ID'], 'PER-RENDITION-URIS', uriReplacement);\n        clonedTrack.groupId = clonedTrack.attrs['GROUP-ID'] = groupCloneMap[audioGroupId];\n        clonedTrack.attrs['PATHWAY-ID'] = cloneId;\n        return clonedTrack;\n      });\n      tracks.push.apply(tracks, clonedTracks);\n    });\n  }\n  function performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {\n    var host = uriReplacement.HOST,\n      params = uriReplacement.PARAMS,\n      perOptionUris = uriReplacement[perOptionKey];\n    var perVariantUri;\n    if (stableId) {\n      perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];\n      if (perVariantUri) {\n        uri = perVariantUri;\n      }\n    }\n    var url = new self.URL(uri);\n    if (host && !perVariantUri) {\n      url.host = host;\n    }\n    if (params) {\n      Object.keys(params).sort().forEach(function (key) {\n        if (key) {\n          url.searchParams.set(key, params[key]);\n        }\n      });\n    }\n    return url.href;\n  }\n\n  var AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/im;\n  var XhrLoader = /*#__PURE__*/function () {\n    function XhrLoader(config) {\n      this.xhrSetup = void 0;\n      this.requestTimeout = void 0;\n      this.retryTimeout = void 0;\n      this.retryDelay = void 0;\n      this.config = null;\n      this.callbacks = null;\n      this.context = null;\n      this.loader = null;\n      this.stats = void 0;\n      this.xhrSetup = config ? config.xhrSetup || null : null;\n      this.stats = new LoadStats();\n      this.retryDelay = 0;\n    }\n    var _proto = XhrLoader.prototype;\n    _proto.destroy = function destroy() {\n      this.callbacks = null;\n      this.abortInternal();\n      this.loader = null;\n      this.config = null;\n      this.context = null;\n      this.xhrSetup = null;\n    };\n    _proto.abortInternal = function abortInternal() {\n      var loader = this.loader;\n      self.clearTimeout(this.requestTimeout);\n      self.clearTimeout(this.retryTimeout);\n      if (loader) {\n        loader.onreadystatechange = null;\n        loader.onprogress = null;\n        if (loader.readyState !== 4) {\n          this.stats.aborted = true;\n          loader.abort();\n        }\n      }\n    };\n    _proto.abort = function abort() {\n      var _this$callbacks;\n      this.abortInternal();\n      if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n        this.callbacks.onAbort(this.stats, this.context, this.loader);\n      }\n    };\n    _proto.load = function load(context, config, callbacks) {\n      if (this.stats.loading.start) {\n        throw new Error('Loader can only be used once.');\n      }\n      this.stats.loading.start = self.performance.now();\n      this.context = context;\n      this.config = config;\n      this.callbacks = callbacks;\n      this.loadInternal();\n    };\n    _proto.loadInternal = function loadInternal() {\n      var _this = this;\n      var config = this.config,\n        context = this.context;\n      if (!config || !context) {\n        return;\n      }\n      var xhr = this.loader = new self.XMLHttpRequest();\n      var stats = this.stats;\n      stats.loading.first = 0;\n      stats.loaded = 0;\n      stats.aborted = false;\n      var xhrSetup = this.xhrSetup;\n      if (xhrSetup) {\n        Promise.resolve().then(function () {\n          if (_this.loader !== xhr || _this.stats.aborted) return;\n          return xhrSetup(xhr, context.url);\n        }).catch(function (error) {\n          if (_this.loader !== xhr || _this.stats.aborted) return;\n          xhr.open('GET', context.url, true);\n          return xhrSetup(xhr, context.url);\n        }).then(function () {\n          if (_this.loader !== xhr || _this.stats.aborted) return;\n          _this.openAndSendXhr(xhr, context, config);\n        }).catch(function (error) {\n          // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n          _this.callbacks.onError({\n            code: xhr.status,\n            text: error.message\n          }, context, xhr, stats);\n          return;\n        });\n      } else {\n        this.openAndSendXhr(xhr, context, config);\n      }\n    };\n    _proto.openAndSendXhr = function openAndSendXhr(xhr, context, config) {\n      if (!xhr.readyState) {\n        xhr.open('GET', context.url, true);\n      }\n      var headers = context.headers;\n      var _config$loadPolicy = config.loadPolicy,\n        maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs,\n        maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;\n      if (headers) {\n        for (var header in headers) {\n          xhr.setRequestHeader(header, headers[header]);\n        }\n      }\n      if (context.rangeEnd) {\n        xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n      }\n      xhr.onreadystatechange = this.readystatechange.bind(this);\n      xhr.onprogress = this.loadprogress.bind(this);\n      xhr.responseType = context.responseType;\n      // setup timeout before we perform request\n      self.clearTimeout(this.requestTimeout);\n      config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n      this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n      xhr.send();\n    };\n    _proto.readystatechange = function readystatechange() {\n      var context = this.context,\n        xhr = this.loader,\n        stats = this.stats;\n      if (!context || !xhr) {\n        return;\n      }\n      var readyState = xhr.readyState;\n      var config = this.config;\n\n      // don't proceed if xhr has been aborted\n      if (stats.aborted) {\n        return;\n      }\n\n      // >= HEADERS_RECEIVED\n      if (readyState >= 2) {\n        if (stats.loading.first === 0) {\n          stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n          // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n          if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {\n            self.clearTimeout(this.requestTimeout);\n            config.timeout = config.loadPolicy.maxLoadTimeMs;\n            this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));\n          }\n        }\n        if (readyState === 4) {\n          self.clearTimeout(this.requestTimeout);\n          xhr.onreadystatechange = null;\n          xhr.onprogress = null;\n          var _status = xhr.status;\n          // http status between 200 to 299 are all successful\n          var useResponse = xhr.responseType !== 'text';\n          if (_status >= 200 && _status < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {\n            stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n            var data = useResponse ? xhr.response : xhr.responseText;\n            var len = xhr.responseType === 'arraybuffer' ? data.byteLength : data.length;\n            stats.loaded = stats.total = len;\n            stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);\n            if (!this.callbacks) {\n              return;\n            }\n            var onProgress = this.callbacks.onProgress;\n            if (onProgress) {\n              onProgress(stats, context, data, xhr);\n            }\n            if (!this.callbacks) {\n              return;\n            }\n            var response = {\n              url: xhr.responseURL,\n              data: data,\n              code: _status\n            };\n            this.callbacks.onSuccess(response, stats, context, xhr);\n          } else {\n            var retryConfig = config.loadPolicy.errorRetry;\n            var retryCount = stats.retry;\n            // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n            var _response = {\n              url: context.url,\n              data: undefined,\n              code: _status\n            };\n            if (shouldRetry(retryConfig, retryCount, false, _response)) {\n              this.retry(retryConfig);\n            } else {\n              logger.error(_status + \" while loading \" + context.url);\n              this.callbacks.onError({\n                code: _status,\n                text: xhr.statusText\n              }, context, xhr, stats);\n            }\n          }\n        }\n      }\n    };\n    _proto.loadtimeout = function loadtimeout() {\n      if (!this.config) return;\n      var retryConfig = this.config.loadPolicy.timeoutRetry;\n      var retryCount = this.stats.retry;\n      if (shouldRetry(retryConfig, retryCount, true)) {\n        this.retry(retryConfig);\n      } else {\n        var _this$context;\n        logger.warn(\"timeout while loading \" + ((_this$context = this.context) == null ? void 0 : _this$context.url));\n        var callbacks = this.callbacks;\n        if (callbacks) {\n          this.abortInternal();\n          callbacks.onTimeout(this.stats, this.context, this.loader);\n        }\n      }\n    };\n    _proto.retry = function retry(retryConfig) {\n      var context = this.context,\n        stats = this.stats;\n      this.retryDelay = getRetryDelay(retryConfig, stats.retry);\n      stats.retry++;\n      logger.warn((status ? 'HTTP Status ' + status : 'Timeout') + \" while loading \" + (context == null ? void 0 : context.url) + \", retrying \" + stats.retry + \"/\" + retryConfig.maxNumRetry + \" in \" + this.retryDelay + \"ms\");\n      // abort and reset internal state\n      this.abortInternal();\n      this.loader = null;\n      // schedule retry\n      self.clearTimeout(this.retryTimeout);\n      this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n    };\n    _proto.loadprogress = function loadprogress(event) {\n      var stats = this.stats;\n      stats.loaded = event.loaded;\n      if (event.lengthComputable) {\n        stats.total = event.total;\n      }\n    };\n    _proto.getCacheAge = function getCacheAge() {\n      var result = null;\n      if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n        var ageHeader = this.loader.getResponseHeader('age');\n        result = ageHeader ? parseFloat(ageHeader) : null;\n      }\n      return result;\n    };\n    _proto.getResponseHeader = function getResponseHeader(name) {\n      if (this.loader && new RegExp(\"^\" + name + \":\\\\s*[\\\\d.]+\\\\s*$\", 'im').test(this.loader.getAllResponseHeaders())) {\n        return this.loader.getResponseHeader(name);\n      }\n      return null;\n    };\n    return XhrLoader;\n  }();\n\n  function fetchSupported() {\n    if (\n    // @ts-ignore\n    self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n      try {\n        new self.ReadableStream({}); // eslint-disable-line no-new\n        return true;\n      } catch (e) {\n        /* noop */\n      }\n    }\n    return false;\n  }\n  var BYTERANGE = /(\\d+)-(\\d+)\\/(\\d+)/;\n  var FetchLoader = /*#__PURE__*/function () {\n    function FetchLoader(config /* HlsConfig */) {\n      this.fetchSetup = void 0;\n      this.requestTimeout = void 0;\n      this.request = null;\n      this.response = null;\n      this.controller = void 0;\n      this.context = null;\n      this.config = null;\n      this.callbacks = null;\n      this.stats = void 0;\n      this.loader = null;\n      this.fetchSetup = config.fetchSetup || getRequest;\n      this.controller = new self.AbortController();\n      this.stats = new LoadStats();\n    }\n    var _proto = FetchLoader.prototype;\n    _proto.destroy = function destroy() {\n      this.loader = this.callbacks = this.context = this.config = this.request = null;\n      this.abortInternal();\n      this.response = null;\n      // @ts-ignore\n      this.fetchSetup = this.controller = this.stats = null;\n    };\n    _proto.abortInternal = function abortInternal() {\n      if (this.controller && !this.stats.loading.end) {\n        this.stats.aborted = true;\n        this.controller.abort();\n      }\n    };\n    _proto.abort = function abort() {\n      var _this$callbacks;\n      this.abortInternal();\n      if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n        this.callbacks.onAbort(this.stats, this.context, this.response);\n      }\n    };\n    _proto.load = function load(context, config, callbacks) {\n      var _this = this;\n      var stats = this.stats;\n      if (stats.loading.start) {\n        throw new Error('Loader can only be used once.');\n      }\n      stats.loading.start = self.performance.now();\n      var initParams = getRequestParameters(context, this.controller.signal);\n      var onProgress = callbacks.onProgress;\n      var isArrayBuffer = context.responseType === 'arraybuffer';\n      var LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n      var _config$loadPolicy = config.loadPolicy,\n        maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs,\n        maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;\n      this.context = context;\n      this.config = config;\n      this.callbacks = callbacks;\n      this.request = this.fetchSetup(context, initParams);\n      self.clearTimeout(this.requestTimeout);\n      config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n      this.requestTimeout = self.setTimeout(function () {\n        _this.abortInternal();\n        callbacks.onTimeout(stats, context, _this.response);\n      }, config.timeout);\n      self.fetch(this.request).then(function (response) {\n        _this.response = _this.loader = response;\n        var first = Math.max(self.performance.now(), stats.loading.start);\n        self.clearTimeout(_this.requestTimeout);\n        config.timeout = maxLoadTimeMs;\n        _this.requestTimeout = self.setTimeout(function () {\n          _this.abortInternal();\n          callbacks.onTimeout(stats, context, _this.response);\n        }, maxLoadTimeMs - (first - stats.loading.start));\n        if (!response.ok) {\n          var status = response.status,\n            statusText = response.statusText;\n          throw new FetchError(statusText || 'fetch, bad network response', status, response);\n        }\n        stats.loading.first = first;\n        stats.total = getContentLength(response.headers) || stats.total;\n        if (onProgress && isFiniteNumber(config.highWaterMark)) {\n          return _this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n        }\n        if (isArrayBuffer) {\n          return response.arrayBuffer();\n        }\n        if (context.responseType === 'json') {\n          return response.json();\n        }\n        return response.text();\n      }).then(function (responseData) {\n        var response = _this.response;\n        if (!response) {\n          throw new Error('loader destroyed');\n        }\n        self.clearTimeout(_this.requestTimeout);\n        stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n        var total = responseData[LENGTH];\n        if (total) {\n          stats.loaded = stats.total = total;\n        }\n        var loaderResponse = {\n          url: response.url,\n          data: responseData,\n          code: response.status\n        };\n        if (onProgress && !isFiniteNumber(config.highWaterMark)) {\n          onProgress(stats, context, responseData, response);\n        }\n        callbacks.onSuccess(loaderResponse, stats, context, response);\n      }).catch(function (error) {\n        self.clearTimeout(_this.requestTimeout);\n        if (stats.aborted) {\n          return;\n        }\n        // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n        // when destroying, 'error' itself can be undefined\n        var code = !error ? 0 : error.code || 0;\n        var text = !error ? null : error.message;\n        callbacks.onError({\n          code: code,\n          text: text\n        }, context, error ? error.details : null, stats);\n      });\n    };\n    _proto.getCacheAge = function getCacheAge() {\n      var result = null;\n      if (this.response) {\n        var ageHeader = this.response.headers.get('age');\n        result = ageHeader ? parseFloat(ageHeader) : null;\n      }\n      return result;\n    };\n    _proto.getResponseHeader = function getResponseHeader(name) {\n      return this.response ? this.response.headers.get(name) : null;\n    };\n    _proto.loadProgressively = function loadProgressively(response, stats, context, highWaterMark, onProgress) {\n      if (highWaterMark === void 0) {\n        highWaterMark = 0;\n      }\n      var chunkCache = new ChunkCache();\n      var reader = response.body.getReader();\n      var pump = function pump() {\n        return reader.read().then(function (data) {\n          if (data.done) {\n            if (chunkCache.dataLength) {\n              onProgress(stats, context, chunkCache.flush(), response);\n            }\n            return Promise.resolve(new ArrayBuffer(0));\n          }\n          var chunk = data.value;\n          var len = chunk.length;\n          stats.loaded += len;\n          if (len < highWaterMark || chunkCache.dataLength) {\n            // The current chunk is too small to to be emitted or the cache already has data\n            // Push it to the cache\n            chunkCache.push(chunk);\n            if (chunkCache.dataLength >= highWaterMark) {\n              // flush in order to join the typed arrays\n              onProgress(stats, context, chunkCache.flush(), response);\n            }\n          } else {\n            // If there's nothing cached already, and the chache is large enough\n            // just emit the progress event\n            onProgress(stats, context, chunk, response);\n          }\n          return pump();\n        }).catch(function () {\n          /* aborted */\n          return Promise.reject();\n        });\n      };\n      return pump();\n    };\n    return FetchLoader;\n  }();\n  function getRequestParameters(context, signal) {\n    var initParams = {\n      method: 'GET',\n      mode: 'cors',\n      credentials: 'same-origin',\n      signal: signal,\n      headers: new self.Headers(_extends({}, context.headers))\n    };\n    if (context.rangeEnd) {\n      initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));\n    }\n    return initParams;\n  }\n  function getByteRangeLength(byteRangeHeader) {\n    var result = BYTERANGE.exec(byteRangeHeader);\n    if (result) {\n      return parseInt(result[2]) - parseInt(result[1]) + 1;\n    }\n  }\n  function getContentLength(headers) {\n    var contentRange = headers.get('Content-Range');\n    if (contentRange) {\n      var byteRangeLength = getByteRangeLength(contentRange);\n      if (isFiniteNumber(byteRangeLength)) {\n        return byteRangeLength;\n      }\n    }\n    var contentLength = headers.get('Content-Length');\n    if (contentLength) {\n      return parseInt(contentLength);\n    }\n  }\n  function getRequest(context, initParams) {\n    return new self.Request(context.url, initParams);\n  }\n  var FetchError = /*#__PURE__*/function (_Error) {\n    _inheritsLoose(FetchError, _Error);\n    function FetchError(message, code, details) {\n      var _this2;\n      _this2 = _Error.call(this, message) || this;\n      _this2.code = void 0;\n      _this2.details = void 0;\n      _this2.code = code;\n      _this2.details = details;\n      return _this2;\n    }\n    return FetchError;\n  }( /*#__PURE__*/_wrapNativeSuper(Error));\n\n  var WHITESPACE_CHAR = /\\s/;\n  var Cues = {\n    newCue: function newCue(track, startTime, endTime, captionScreen) {\n      var result = [];\n      var row;\n      // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers\n      var cue;\n      var indenting;\n      var indent;\n      var text;\n      var Cue = self.VTTCue || self.TextTrackCue;\n      for (var r = 0; r < captionScreen.rows.length; r++) {\n        row = captionScreen.rows[r];\n        indenting = true;\n        indent = 0;\n        text = '';\n        if (!row.isEmpty()) {\n          var _track$cues;\n          for (var c = 0; c < row.chars.length; c++) {\n            if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {\n              indent++;\n            } else {\n              text += row.chars[c].uchar;\n              indenting = false;\n            }\n          }\n          // To be used for cleaning-up orphaned roll-up captions\n          row.cueStartTime = startTime;\n\n          // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE\n          if (startTime === endTime) {\n            endTime += 0.0001;\n          }\n          if (indent >= 16) {\n            indent--;\n          } else {\n            indent++;\n          }\n          var cueText = fixLineBreaks(text.trim());\n          var id = generateCueId(startTime, endTime, cueText);\n\n          // If this cue already exists in the track do not push it\n          if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {\n            cue = new Cue(startTime, endTime, cueText);\n            cue.id = id;\n            cue.line = r + 1;\n            cue.align = 'left';\n            // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)\n            // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608\n            // Firefox throws an exception and captions break with out of bounds 0-100 values\n            cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);\n            result.push(cue);\n          }\n        }\n      }\n      if (track && result.length) {\n        // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome\n        result.sort(function (cueA, cueB) {\n          if (cueA.line === 'auto' || cueB.line === 'auto') {\n            return 0;\n          }\n          if (cueA.line > 8 && cueB.line > 8) {\n            return cueB.line - cueA.line;\n          }\n          return cueA.line - cueB.line;\n        });\n        result.forEach(function (cue) {\n          return addCueToTrack(track, cue);\n        });\n      }\n      return result;\n    }\n  };\n\n  /**\n   * @deprecated use fragLoadPolicy.default\n   */\n\n  /**\n   * @deprecated use manifestLoadPolicy.default and playlistLoadPolicy.default\n   */\n\n  var defaultLoadPolicy = {\n    maxTimeToFirstByteMs: 8000,\n    maxLoadTimeMs: 20000,\n    timeoutRetry: null,\n    errorRetry: null\n  };\n\n  /**\n   * @ignore\n   * If possible, keep hlsDefaultConfig shallow\n   * It is cloned whenever a new Hls instance is created, by keeping the config\n   * shallow the properties are cloned, and we don't end up manipulating the default\n   */\n  var hlsDefaultConfig = _objectSpread2(_objectSpread2({\n    autoStartLoad: true,\n    // used by stream-controller\n    startPosition: -1,\n    // used by stream-controller\n    defaultAudioCodec: undefined,\n    // used by stream-controller\n    debug: false,\n    // used by logger\n    capLevelOnFPSDrop: false,\n    // used by fps-controller\n    capLevelToPlayerSize: false,\n    // used by cap-level-controller\n    ignoreDevicePixelRatio: false,\n    // used by cap-level-controller\n    preferManagedMediaSource: true,\n    initialLiveManifestSize: 1,\n    // used by stream-controller\n    maxBufferLength: 30,\n    // used by stream-controller\n    backBufferLength: Infinity,\n    // used by buffer-controller\n    frontBufferFlushThreshold: Infinity,\n    maxBufferSize: 60 * 1000 * 1000,\n    // used by stream-controller\n    maxBufferHole: 0.1,\n    // used by stream-controller\n    highBufferWatchdogPeriod: 2,\n    // used by stream-controller\n    nudgeOffset: 0.1,\n    // used by stream-controller\n    nudgeMaxRetry: 3,\n    // used by stream-controller\n    maxFragLookUpTolerance: 0.25,\n    // used by stream-controller\n    liveSyncDurationCount: 3,\n    // used by latency-controller\n    liveMaxLatencyDurationCount: Infinity,\n    // used by latency-controller\n    liveSyncDuration: undefined,\n    // used by latency-controller\n    liveMaxLatencyDuration: undefined,\n    // used by latency-controller\n    maxLiveSyncPlaybackRate: 1,\n    // used by latency-controller\n    liveDurationInfinity: false,\n    // used by buffer-controller\n    /**\n     * @deprecated use backBufferLength\n     */\n    liveBackBufferLength: null,\n    // used by buffer-controller\n    maxMaxBufferLength: 600,\n    // used by stream-controller\n    enableWorker: true,\n    // used by transmuxer\n    workerPath: null,\n    // used by transmuxer\n    enableSoftwareAES: true,\n    // used by decrypter\n    startLevel: undefined,\n    // used by level-controller\n    startFragPrefetch: false,\n    // used by stream-controller\n    fpsDroppedMonitoringPeriod: 5000,\n    // used by fps-controller\n    fpsDroppedMonitoringThreshold: 0.2,\n    // used by fps-controller\n    appendErrorMaxRetry: 3,\n    // used by buffer-controller\n    loader: XhrLoader,\n    // loader: FetchLoader,\n    fLoader: undefined,\n    // used by fragment-loader\n    pLoader: undefined,\n    // used by playlist-loader\n    xhrSetup: undefined,\n    // used by xhr-loader\n    licenseXhrSetup: undefined,\n    // used by eme-controller\n    licenseResponseCallback: undefined,\n    // used by eme-controller\n    abrController: AbrController,\n    bufferController: BufferController,\n    capLevelController: CapLevelController,\n    errorController: ErrorController,\n    fpsController: FPSController,\n    stretchShortVideoTrack: false,\n    // used by mp4-remuxer\n    maxAudioFramesDrift: 1,\n    // used by mp4-remuxer\n    forceKeyFrameOnDiscontinuity: true,\n    // used by ts-demuxer\n    abrEwmaFastLive: 3,\n    // used by abr-controller\n    abrEwmaSlowLive: 9,\n    // used by abr-controller\n    abrEwmaFastVoD: 3,\n    // used by abr-controller\n    abrEwmaSlowVoD: 9,\n    // used by abr-controller\n    abrEwmaDefaultEstimate: 5e5,\n    // 500 kbps  // used by abr-controller\n    abrEwmaDefaultEstimateMax: 5e6,\n    // 5 mbps\n    abrBandWidthFactor: 0.95,\n    // used by abr-controller\n    abrBandWidthUpFactor: 0.7,\n    // used by abr-controller\n    abrMaxWithRealBitrate: false,\n    // used by abr-controller\n    maxStarvationDelay: 4,\n    // used by abr-controller\n    maxLoadingDelay: 4,\n    // used by abr-controller\n    minAutoBitrate: 0,\n    // used by hls\n    emeEnabled: false,\n    // used by eme-controller\n    widevineLicenseUrl: undefined,\n    // used by eme-controller\n    drmSystems: {},\n    // used by eme-controller\n    drmSystemOptions: {},\n    // used by eme-controller\n    requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess ,\n    // used by eme-controller\n    testBandwidth: true,\n    progressive: false,\n    lowLatencyMode: true,\n    cmcd: undefined,\n    enableDateRangeMetadataCues: true,\n    enableEmsgMetadataCues: true,\n    enableID3MetadataCues: true,\n    useMediaCapabilities: true,\n    certLoadPolicy: {\n      default: defaultLoadPolicy\n    },\n    keyLoadPolicy: {\n      default: {\n        maxTimeToFirstByteMs: 8000,\n        maxLoadTimeMs: 20000,\n        timeoutRetry: {\n          maxNumRetry: 1,\n          retryDelayMs: 1000,\n          maxRetryDelayMs: 20000,\n          backoff: 'linear'\n        },\n        errorRetry: {\n          maxNumRetry: 8,\n          retryDelayMs: 1000,\n          maxRetryDelayMs: 20000,\n          backoff: 'linear'\n        }\n      }\n    },\n    manifestLoadPolicy: {\n      default: {\n        maxTimeToFirstByteMs: Infinity,\n        maxLoadTimeMs: 20000,\n        timeoutRetry: {\n          maxNumRetry: 2,\n          retryDelayMs: 0,\n          maxRetryDelayMs: 0\n        },\n        errorRetry: {\n          maxNumRetry: 1,\n          retryDelayMs: 1000,\n          maxRetryDelayMs: 8000\n        }\n      }\n    },\n    playlistLoadPolicy: {\n      default: {\n        maxTimeToFirstByteMs: 10000,\n        maxLoadTimeMs: 20000,\n        timeoutRetry: {\n          maxNumRetry: 2,\n          retryDelayMs: 0,\n          maxRetryDelayMs: 0\n        },\n        errorRetry: {\n          maxNumRetry: 2,\n          retryDelayMs: 1000,\n          maxRetryDelayMs: 8000\n        }\n      }\n    },\n    fragLoadPolicy: {\n      default: {\n        maxTimeToFirstByteMs: 10000,\n        maxLoadTimeMs: 120000,\n        timeoutRetry: {\n          maxNumRetry: 4,\n          retryDelayMs: 0,\n          maxRetryDelayMs: 0\n        },\n        errorRetry: {\n          maxNumRetry: 6,\n          retryDelayMs: 1000,\n          maxRetryDelayMs: 8000\n        }\n      }\n    },\n    steeringManifestLoadPolicy: {\n      default: {\n        maxTimeToFirstByteMs: 10000,\n        maxLoadTimeMs: 20000,\n        timeoutRetry: {\n          maxNumRetry: 2,\n          retryDelayMs: 0,\n          maxRetryDelayMs: 0\n        },\n        errorRetry: {\n          maxNumRetry: 1,\n          retryDelayMs: 1000,\n          maxRetryDelayMs: 8000\n        }\n      } \n    },\n    // These default settings are deprecated in favor of the above policies\n    // and are maintained for backwards compatibility\n    manifestLoadingTimeOut: 10000,\n    manifestLoadingMaxRetry: 1,\n    manifestLoadingRetryDelay: 1000,\n    manifestLoadingMaxRetryTimeout: 64000,\n    levelLoadingTimeOut: 10000,\n    levelLoadingMaxRetry: 4,\n    levelLoadingRetryDelay: 1000,\n    levelLoadingMaxRetryTimeout: 64000,\n    fragLoadingTimeOut: 20000,\n    fragLoadingMaxRetry: 6,\n    fragLoadingRetryDelay: 1000,\n    fragLoadingMaxRetryTimeout: 64000\n  }, timelineConfig()), {}, {\n    subtitleStreamController: SubtitleStreamController ,\n    subtitleTrackController: SubtitleTrackController ,\n    timelineController: TimelineController ,\n    audioStreamController: AudioStreamController ,\n    audioTrackController: AudioTrackController ,\n    emeController: EMEController ,\n    cmcdController: CMCDController ,\n    contentSteeringController: ContentSteeringController \n  });\n  function timelineConfig() {\n    return {\n      cueHandler: Cues,\n      // used by timeline-controller\n      enableWebVTT: true,\n      // used by timeline-controller\n      enableIMSC1: true,\n      // used by timeline-controller\n      enableCEA708Captions: true,\n      // used by timeline-controller\n      captionsTextTrack1Label: 'English',\n      // used by timeline-controller\n      captionsTextTrack1LanguageCode: 'en',\n      // used by timeline-controller\n      captionsTextTrack2Label: 'Spanish',\n      // used by timeline-controller\n      captionsTextTrack2LanguageCode: 'es',\n      // used by timeline-controller\n      captionsTextTrack3Label: 'Unknown CC',\n      // used by timeline-controller\n      captionsTextTrack3LanguageCode: '',\n      // used by timeline-controller\n      captionsTextTrack4Label: 'Unknown CC',\n      // used by timeline-controller\n      captionsTextTrack4LanguageCode: '',\n      // used by timeline-controller\n      renderTextTracksNatively: true\n    };\n  }\n\n  /**\n   * @ignore\n   */\n  function mergeConfig(defaultConfig, userConfig) {\n    if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n      throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n    }\n    if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n      throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n    }\n    if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n      throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n    }\n    var defaultsCopy = deepCpy(defaultConfig);\n\n    // Backwards compatibility with deprecated config values\n    var deprecatedSettingTypes = ['manifest', 'level', 'frag'];\n    var deprecatedSettings = ['TimeOut', 'MaxRetry', 'RetryDelay', 'MaxRetryTimeout'];\n    deprecatedSettingTypes.forEach(function (type) {\n      var policyName = (type === 'level' ? 'playlist' : type) + \"LoadPolicy\";\n      var policyNotSet = userConfig[policyName] === undefined;\n      var report = [];\n      deprecatedSettings.forEach(function (setting) {\n        var deprecatedSetting = type + \"Loading\" + setting;\n        var value = userConfig[deprecatedSetting];\n        if (value !== undefined && policyNotSet) {\n          report.push(deprecatedSetting);\n          var settings = defaultsCopy[policyName].default;\n          userConfig[policyName] = {\n            default: settings\n          };\n          switch (setting) {\n            case 'TimeOut':\n              settings.maxLoadTimeMs = value;\n              settings.maxTimeToFirstByteMs = value;\n              break;\n            case 'MaxRetry':\n              settings.errorRetry.maxNumRetry = value;\n              settings.timeoutRetry.maxNumRetry = value;\n              break;\n            case 'RetryDelay':\n              settings.errorRetry.retryDelayMs = value;\n              settings.timeoutRetry.retryDelayMs = value;\n              break;\n            case 'MaxRetryTimeout':\n              settings.errorRetry.maxRetryDelayMs = value;\n              settings.timeoutRetry.maxRetryDelayMs = value;\n              break;\n          }\n        }\n      });\n      if (report.length) {\n        logger.warn(\"hls.js config: \\\"\" + report.join('\", \"') + \"\\\" setting(s) are deprecated, use \\\"\" + policyName + \"\\\": \" + JSON.stringify(userConfig[policyName]));\n      }\n    });\n    return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);\n  }\n  function deepCpy(obj) {\n    if (obj && typeof obj === 'object') {\n      if (Array.isArray(obj)) {\n        return obj.map(deepCpy);\n      }\n      return Object.keys(obj).reduce(function (result, key) {\n        result[key] = deepCpy(obj[key]);\n        return result;\n      }, {});\n    }\n    return obj;\n  }\n\n  /**\n   * @ignore\n   */\n  function enableStreamingMode(config) {\n    var currentLoader = config.loader;\n    if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {\n      // If a developer has configured their own loader, respect that choice\n      logger.log('[config]: Custom loader detected, cannot enable progressive streaming');\n      config.progressive = false;\n    } else {\n      var canStreamProgressively = fetchSupported();\n      if (canStreamProgressively) {\n        config.loader = FetchLoader;\n        config.progressive = true;\n        config.enableSoftwareAES = true;\n        logger.log('[config]: Progressive streaming enabled, using FetchLoader');\n      }\n    }\n  }\n\n  var chromeOrFirefox;\n  var LevelController = /*#__PURE__*/function (_BasePlaylistControll) {\n    _inheritsLoose(LevelController, _BasePlaylistControll);\n    function LevelController(hls, contentSteeringController) {\n      var _this;\n      _this = _BasePlaylistControll.call(this, hls, '[level-controller]') || this;\n      _this._levels = [];\n      _this._firstLevel = -1;\n      _this._maxAutoLevel = -1;\n      _this._startLevel = void 0;\n      _this.currentLevel = null;\n      _this.currentLevelIndex = -1;\n      _this.manualLevelIndex = -1;\n      _this.steering = void 0;\n      _this.onParsedComplete = void 0;\n      _this.steering = contentSteeringController;\n      _this._registerListeners();\n      return _this;\n    }\n    var _proto = LevelController.prototype;\n    _proto._registerListeners = function _registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      hls.on(Events.ERROR, this.onError, this);\n    };\n    _proto._unregisterListeners = function _unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n      hls.off(Events.ERROR, this.onError, this);\n    };\n    _proto.destroy = function destroy() {\n      this._unregisterListeners();\n      this.steering = null;\n      this.resetLevels();\n      _BasePlaylistControll.prototype.destroy.call(this);\n    };\n    _proto.stopLoad = function stopLoad() {\n      var levels = this._levels;\n\n      // clean up live level details to force reload them, and reset load errors\n      levels.forEach(function (level) {\n        level.loadError = 0;\n        level.fragmentError = 0;\n      });\n      _BasePlaylistControll.prototype.stopLoad.call(this);\n    };\n    _proto.resetLevels = function resetLevels() {\n      this._startLevel = undefined;\n      this.manualLevelIndex = -1;\n      this.currentLevelIndex = -1;\n      this.currentLevel = null;\n      this._levels = [];\n      this._maxAutoLevel = -1;\n    };\n    _proto.onManifestLoading = function onManifestLoading(event, data) {\n      this.resetLevels();\n    };\n    _proto.onManifestLoaded = function onManifestLoaded(event, data) {\n      var preferManagedMediaSource = this.hls.config.preferManagedMediaSource;\n      var levels = [];\n      var redundantSet = {};\n      var generatePathwaySet = {};\n      var resolutionFound = false;\n      var videoCodecFound = false;\n      var audioCodecFound = false;\n      data.levels.forEach(function (levelParsed) {\n        var _audioCodec, _videoCodec;\n        var attributes = levelParsed.attrs;\n\n        // erase audio codec info if browser does not support mp4a.40.34.\n        // demuxer will autodetect codec and fallback to mpeg/audio\n        var audioCodec = levelParsed.audioCodec,\n          videoCodec = levelParsed.videoCodec;\n        if (((_audioCodec = audioCodec) == null ? void 0 : _audioCodec.indexOf('mp4a.40.34')) !== -1) {\n          chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));\n          if (chromeOrFirefox) {\n            levelParsed.audioCodec = audioCodec = undefined;\n          }\n        }\n        if (audioCodec) {\n          levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource);\n        }\n        if (((_videoCodec = videoCodec) == null ? void 0 : _videoCodec.indexOf('avc1')) === 0) {\n          videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);\n        }\n\n        // only keep levels with supported audio/video codecs\n        var width = levelParsed.width,\n          height = levelParsed.height,\n          unknownCodecs = levelParsed.unknownCodecs;\n        resolutionFound || (resolutionFound = !!(width && height));\n        videoCodecFound || (videoCodecFound = !!videoCodec);\n        audioCodecFound || (audioCodecFound = !!audioCodec);\n        if (unknownCodecs != null && unknownCodecs.length || audioCodec && !areCodecsMediaSourceSupported(audioCodec, 'audio', preferManagedMediaSource) || videoCodec && !areCodecsMediaSourceSupported(videoCodec, 'video', preferManagedMediaSource)) {\n          return;\n        }\n        var CODECS = attributes.CODECS,\n          FRAMERATE = attributes['FRAME-RATE'],\n          HDCP = attributes['HDCP-LEVEL'],\n          PATHWAY = attributes['PATHWAY-ID'],\n          RESOLUTION = attributes.RESOLUTION,\n          VIDEO_RANGE = attributes['VIDEO-RANGE'];\n        var contentSteeringPrefix = (PATHWAY || '.') + \"-\";\n        var levelKey = \"\" + contentSteeringPrefix + levelParsed.bitrate + \"-\" + RESOLUTION + \"-\" + FRAMERATE + \"-\" + CODECS + \"-\" + VIDEO_RANGE + \"-\" + HDCP;\n        if (!redundantSet[levelKey]) {\n          var level = new Level(levelParsed);\n          redundantSet[levelKey] = level;\n          generatePathwaySet[levelKey] = 1;\n          levels.push(level);\n        } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs['PATHWAY-ID']) {\n          // Assign Pathway IDs to Redundant Streams (default Pathways is \".\". Redundant Streams \"..\", \"...\", and so on.)\n          // Content Steering controller to handles Pathway fallback on error\n          var pathwayCount = generatePathwaySet[levelKey] += 1;\n          levelParsed.attrs['PATHWAY-ID'] = new Array(pathwayCount + 1).join('.');\n          var _level = new Level(levelParsed);\n          redundantSet[levelKey] = _level;\n          levels.push(_level);\n        } else {\n          redundantSet[levelKey].addGroupId('audio', attributes.AUDIO);\n          redundantSet[levelKey].addGroupId('text', attributes.SUBTITLES);\n        }\n      });\n      this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);\n    };\n    _proto.filterAndSortMediaOptions = function filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {\n      var _this2 = this;\n      var audioTracks = [];\n      var subtitleTracks = [];\n      var levels = filteredLevels;\n\n      // remove audio-only and invalid video-range levels if we also have levels with video codecs or RESOLUTION signalled\n      if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n        levels = levels.filter(function (_ref) {\n          var videoCodec = _ref.videoCodec,\n            videoRange = _ref.videoRange,\n            width = _ref.width,\n            height = _ref.height;\n          return (!!videoCodec || !!(width && height)) && isVideoRange(videoRange);\n        });\n      }\n      if (levels.length === 0) {\n        // Dispatch error after MANIFEST_LOADED is done propagating\n        Promise.resolve().then(function () {\n          if (_this2.hls) {\n            if (data.levels.length) {\n              _this2.warn(\"One or more CODECS in variant not supported: \" + JSON.stringify(data.levels[0].attrs));\n            }\n            var error = new Error('no level with compatible codecs found in manifest');\n            _this2.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n              fatal: true,\n              url: data.url,\n              error: error,\n              reason: error.message\n            });\n          }\n        });\n        return;\n      }\n      if (data.audioTracks) {\n        var preferManagedMediaSource = this.hls.config.preferManagedMediaSource;\n        audioTracks = data.audioTracks.filter(function (track) {\n          return !track.audioCodec || areCodecsMediaSourceSupported(track.audioCodec, 'audio', preferManagedMediaSource);\n        });\n        // Assign ids after filtering as array indices by group-id\n        assignTrackIdsByGroup(audioTracks);\n      }\n      if (data.subtitles) {\n        subtitleTracks = data.subtitles;\n        assignTrackIdsByGroup(subtitleTracks);\n      }\n      // start bitrate is the first bitrate of the manifest\n      var unsortedLevels = levels.slice(0);\n      // sort levels from lowest to highest\n      levels.sort(function (a, b) {\n        if (a.attrs['HDCP-LEVEL'] !== b.attrs['HDCP-LEVEL']) {\n          return (a.attrs['HDCP-LEVEL'] || '') > (b.attrs['HDCP-LEVEL'] || '') ? 1 : -1;\n        }\n        // sort on height before bitrate for cap-level-controller\n        if (resolutionFound && a.height !== b.height) {\n          return a.height - b.height;\n        }\n        if (a.frameRate !== b.frameRate) {\n          return a.frameRate - b.frameRate;\n        }\n        if (a.videoRange !== b.videoRange) {\n          return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);\n        }\n        if (a.videoCodec !== b.videoCodec) {\n          var valueA = videoCodecPreferenceValue(a.videoCodec);\n          var valueB = videoCodecPreferenceValue(b.videoCodec);\n          if (valueA !== valueB) {\n            return valueB - valueA;\n          }\n        }\n        if (a.uri === b.uri && a.codecSet !== b.codecSet) {\n          var _valueA = codecsSetSelectionPreferenceValue(a.codecSet);\n          var _valueB = codecsSetSelectionPreferenceValue(b.codecSet);\n          if (_valueA !== _valueB) {\n            return _valueB - _valueA;\n          }\n        }\n        if (a.averageBitrate !== b.averageBitrate) {\n          return a.averageBitrate - b.averageBitrate;\n        }\n        return 0;\n      });\n      var firstLevelInPlaylist = unsortedLevels[0];\n      if (this.steering) {\n        levels = this.steering.filterParsedLevels(levels);\n        if (levels.length !== unsortedLevels.length) {\n          for (var i = 0; i < unsortedLevels.length; i++) {\n            if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {\n              firstLevelInPlaylist = unsortedLevels[i];\n              break;\n            }\n          }\n        }\n      }\n      this._levels = levels;\n\n      // find index of first level in sorted levels\n      for (var _i = 0; _i < levels.length; _i++) {\n        if (levels[_i] === firstLevelInPlaylist) {\n          var _this$hls$userConfig;\n          this._firstLevel = _i;\n          var firstLevelBitrate = firstLevelInPlaylist.bitrate;\n          var bandwidthEstimate = this.hls.bandwidthEstimate;\n          this.log(\"manifest loaded, \" + levels.length + \" level(s) found, first bitrate: \" + firstLevelBitrate);\n          // Update default bwe to first variant bitrate as long it has not been configured or set\n          if (((_this$hls$userConfig = this.hls.userConfig) == null ? void 0 : _this$hls$userConfig.abrEwmaDefaultEstimate) === undefined) {\n            var startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);\n            if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === hlsDefaultConfig.abrEwmaDefaultEstimate) {\n              this.hls.bandwidthEstimate = startingBwEstimate;\n            }\n          }\n          break;\n        }\n      }\n\n      // Audio is only alternate if manifest include a URI along with the audio group tag,\n      // and this is not an audio-only stream where levels contain audio-only\n      var audioOnly = audioCodecFound && !videoCodecFound;\n      var edata = {\n        levels: levels,\n        audioTracks: audioTracks,\n        subtitleTracks: subtitleTracks,\n        sessionData: data.sessionData,\n        sessionKeys: data.sessionKeys,\n        firstLevel: this._firstLevel,\n        stats: data.stats,\n        audio: audioCodecFound,\n        video: videoCodecFound,\n        altAudio: !audioOnly && audioTracks.some(function (t) {\n          return !!t.url;\n        })\n      };\n      this.hls.trigger(Events.MANIFEST_PARSED, edata);\n\n      // Initiate loading after all controllers have received MANIFEST_PARSED\n      if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {\n        this.hls.startLoad(this.hls.config.startPosition);\n      }\n    };\n    _proto.onError = function onError(event, data) {\n      if (data.fatal || !data.context) {\n        return;\n      }\n      if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {\n        this.checkRetry(data);\n      }\n    }\n\n    // reset errors on the successful load of a fragment\n    ;\n    _proto.onFragBuffered = function onFragBuffered(event, _ref2) {\n      var frag = _ref2.frag;\n      if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {\n        var el = frag.elementaryStreams;\n        if (!Object.keys(el).some(function (type) {\n          return !!el[type];\n        })) {\n          return;\n        }\n        var level = this._levels[frag.level];\n        if (level != null && level.loadError) {\n          this.log(\"Resetting level error count of \" + level.loadError + \" on frag buffered\");\n          level.loadError = 0;\n        }\n      }\n    };\n    _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n      var _data$deliveryDirecti2;\n      var level = data.level,\n        details = data.details;\n      var curLevel = this._levels[level];\n      if (!curLevel) {\n        var _data$deliveryDirecti;\n        this.warn(\"Invalid level index \" + level);\n        if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {\n          details.deltaUpdateFailed = true;\n        }\n        return;\n      }\n\n      // only process level loaded events matching with expected level\n      if (level === this.currentLevelIndex) {\n        // reset level load error counter on successful level loaded only if there is no issues with fragments\n        if (curLevel.fragmentError === 0) {\n          curLevel.loadError = 0;\n        }\n        this.playlistLoaded(level, data, curLevel.details);\n      } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {\n        // received a delta playlist update that cannot be merged\n        details.deltaUpdateFailed = true;\n      }\n    };\n    _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {\n      _BasePlaylistControll.prototype.loadPlaylist.call(this);\n      var currentLevelIndex = this.currentLevelIndex;\n      var currentLevel = this.currentLevel;\n      if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {\n        var url = currentLevel.uri;\n        if (hlsUrlParameters) {\n          try {\n            url = hlsUrlParameters.addDirectives(url);\n          } catch (error) {\n            this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + error);\n          }\n        }\n        var pathwayId = currentLevel.attrs['PATHWAY-ID'];\n        this.log(\"Loading level index \" + currentLevelIndex + ((hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : '') + \" with\" + (pathwayId ? ' Pathway ' + pathwayId : '') + \" \" + url);\n\n        // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);\n        // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);\n        this.clearTimer();\n        this.hls.trigger(Events.LEVEL_LOADING, {\n          url: url,\n          level: currentLevelIndex,\n          pathwayId: currentLevel.attrs['PATHWAY-ID'],\n          id: 0,\n          // Deprecated Level urlId\n          deliveryDirectives: hlsUrlParameters || null\n        });\n      }\n    };\n    _proto.removeLevel = function removeLevel(levelIndex) {\n      var _this3 = this,\n        _this$currentLevel;\n      var levels = this._levels.filter(function (level, index) {\n        if (index !== levelIndex) {\n          return true;\n        }\n        if (_this3.steering) {\n          _this3.steering.removeLevel(level);\n        }\n        if (level === _this3.currentLevel) {\n          _this3.currentLevel = null;\n          _this3.currentLevelIndex = -1;\n          if (level.details) {\n            level.details.fragments.forEach(function (f) {\n              return f.level = -1;\n            });\n          }\n        }\n        return false;\n      });\n      reassignFragmentLevelIndexes(levels);\n      this._levels = levels;\n      if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {\n        this.currentLevelIndex = this.currentLevel.details.fragments[0].level;\n      }\n      this.hls.trigger(Events.LEVELS_UPDATED, {\n        levels: levels\n      });\n    };\n    _proto.onLevelsUpdated = function onLevelsUpdated(event, _ref3) {\n      var levels = _ref3.levels;\n      this._levels = levels;\n    };\n    _proto.checkMaxAutoUpdated = function checkMaxAutoUpdated() {\n      var _this$hls = this.hls,\n        autoLevelCapping = _this$hls.autoLevelCapping,\n        maxAutoLevel = _this$hls.maxAutoLevel,\n        maxHdcpLevel = _this$hls.maxHdcpLevel;\n      if (this._maxAutoLevel !== maxAutoLevel) {\n        this._maxAutoLevel = maxAutoLevel;\n        this.hls.trigger(Events.MAX_AUTO_LEVEL_UPDATED, {\n          autoLevelCapping: autoLevelCapping,\n          levels: this.levels,\n          maxAutoLevel: maxAutoLevel,\n          minAutoLevel: this.hls.minAutoLevel,\n          maxHdcpLevel: maxHdcpLevel\n        });\n      }\n    };\n    _createClass(LevelController, [{\n      key: \"levels\",\n      get: function get() {\n        if (this._levels.length === 0) {\n          return null;\n        }\n        return this._levels;\n      }\n    }, {\n      key: \"level\",\n      get: function get() {\n        return this.currentLevelIndex;\n      },\n      set: function set(newLevel) {\n        var levels = this._levels;\n        if (levels.length === 0) {\n          return;\n        }\n        // check if level idx is valid\n        if (newLevel < 0 || newLevel >= levels.length) {\n          // invalid level id given, trigger error\n          var error = new Error('invalid level idx');\n          var fatal = newLevel < 0;\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.OTHER_ERROR,\n            details: ErrorDetails.LEVEL_SWITCH_ERROR,\n            level: newLevel,\n            fatal: fatal,\n            error: error,\n            reason: error.message\n          });\n          if (fatal) {\n            return;\n          }\n          newLevel = Math.min(newLevel, levels.length - 1);\n        }\n        var lastLevelIndex = this.currentLevelIndex;\n        var lastLevel = this.currentLevel;\n        var lastPathwayId = lastLevel ? lastLevel.attrs['PATHWAY-ID'] : undefined;\n        var level = levels[newLevel];\n        var pathwayId = level.attrs['PATHWAY-ID'];\n        this.currentLevelIndex = newLevel;\n        this.currentLevel = level;\n        if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {\n          return;\n        }\n        this.log(\"Switching to level \" + newLevel + \" (\" + (level.height ? level.height + 'p ' : '') + (level.videoRange ? level.videoRange + ' ' : '') + (level.codecSet ? level.codecSet + ' ' : '') + \"@\" + level.bitrate + \")\" + (pathwayId ? ' with Pathway ' + pathwayId : '') + \" from level \" + lastLevelIndex + (lastPathwayId ? ' with Pathway ' + lastPathwayId : ''));\n        var levelSwitchingData = {\n          level: newLevel,\n          attrs: level.attrs,\n          details: level.details,\n          bitrate: level.bitrate,\n          averageBitrate: level.averageBitrate,\n          maxBitrate: level.maxBitrate,\n          realBitrate: level.realBitrate,\n          width: level.width,\n          height: level.height,\n          codecSet: level.codecSet,\n          audioCodec: level.audioCodec,\n          videoCodec: level.videoCodec,\n          audioGroups: level.audioGroups,\n          subtitleGroups: level.subtitleGroups,\n          loaded: level.loaded,\n          loadError: level.loadError,\n          fragmentError: level.fragmentError,\n          name: level.name,\n          id: level.id,\n          uri: level.uri,\n          url: level.url,\n          urlId: 0,\n          audioGroupIds: level.audioGroupIds,\n          textGroupIds: level.textGroupIds\n        };\n        this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);\n        // check if we need to load playlist for this level\n        var levelDetails = level.details;\n        if (!levelDetails || levelDetails.live) {\n          // level not retrieved yet, or live playlist we need to (re)load it\n          var hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details, levelDetails);\n          this.loadPlaylist(hlsUrlParameters);\n        }\n      }\n    }, {\n      key: \"manualLevel\",\n      get: function get() {\n        return this.manualLevelIndex;\n      },\n      set: function set(newLevel) {\n        this.manualLevelIndex = newLevel;\n        if (this._startLevel === undefined) {\n          this._startLevel = newLevel;\n        }\n        if (newLevel !== -1) {\n          this.level = newLevel;\n        }\n      }\n    }, {\n      key: \"firstLevel\",\n      get: function get() {\n        return this._firstLevel;\n      },\n      set: function set(newLevel) {\n        this._firstLevel = newLevel;\n      }\n    }, {\n      key: \"startLevel\",\n      get: function get() {\n        // Setting hls.startLevel (this._startLevel) overrides config.startLevel\n        if (this._startLevel === undefined) {\n          var configStartLevel = this.hls.config.startLevel;\n          if (configStartLevel !== undefined) {\n            return configStartLevel;\n          }\n          return this.hls.firstAutoLevel;\n        }\n        return this._startLevel;\n      },\n      set: function set(newLevel) {\n        this._startLevel = newLevel;\n      }\n    }, {\n      key: \"nextLoadLevel\",\n      get: function get() {\n        if (this.manualLevelIndex !== -1) {\n          return this.manualLevelIndex;\n        } else {\n          return this.hls.nextAutoLevel;\n        }\n      },\n      set: function set(nextLevel) {\n        this.level = nextLevel;\n        if (this.manualLevelIndex === -1) {\n          this.hls.nextAutoLevel = nextLevel;\n        }\n      }\n    }]);\n    return LevelController;\n  }(BasePlaylistController);\n  function assignTrackIdsByGroup(tracks) {\n    var groups = {};\n    tracks.forEach(function (track) {\n      var groupId = track.groupId || '';\n      track.id = groups[groupId] = groups[groupId] || 0;\n      groups[groupId]++;\n    });\n  }\n\n  var KeyLoader = /*#__PURE__*/function () {\n    function KeyLoader(config) {\n      this.config = void 0;\n      this.keyUriToKeyInfo = {};\n      this.emeController = null;\n      this.config = config;\n    }\n    var _proto = KeyLoader.prototype;\n    _proto.abort = function abort(type) {\n      for (var uri in this.keyUriToKeyInfo) {\n        var loader = this.keyUriToKeyInfo[uri].loader;\n        if (loader) {\n          var _loader$context;\n          if (type && type !== ((_loader$context = loader.context) == null ? void 0 : _loader$context.frag.type)) {\n            return;\n          }\n          loader.abort();\n        }\n      }\n    };\n    _proto.detach = function detach() {\n      for (var uri in this.keyUriToKeyInfo) {\n        var keyInfo = this.keyUriToKeyInfo[uri];\n        // Remove cached EME keys on detach\n        if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {\n          delete this.keyUriToKeyInfo[uri];\n        }\n      }\n    };\n    _proto.destroy = function destroy() {\n      this.detach();\n      for (var uri in this.keyUriToKeyInfo) {\n        var loader = this.keyUriToKeyInfo[uri].loader;\n        if (loader) {\n          loader.destroy();\n        }\n      }\n      this.keyUriToKeyInfo = {};\n    };\n    _proto.createKeyLoadError = function createKeyLoadError(frag, details, error, networkDetails, response) {\n      if (details === void 0) {\n        details = ErrorDetails.KEY_LOAD_ERROR;\n      }\n      return new LoadError({\n        type: ErrorTypes.NETWORK_ERROR,\n        details: details,\n        fatal: false,\n        frag: frag,\n        response: response,\n        error: error,\n        networkDetails: networkDetails\n      });\n    };\n    _proto.loadClear = function loadClear(loadingFrag, encryptedFragments) {\n      var _this = this;\n      if (this.emeController && this.config.emeEnabled) {\n        // access key-system with nearest key on start (loaidng frag is unencrypted)\n        var sn = loadingFrag.sn,\n          cc = loadingFrag.cc;\n        var _loop = function _loop() {\n          var frag = encryptedFragments[i];\n          if (cc <= frag.cc && (sn === 'initSegment' || frag.sn === 'initSegment' || sn < frag.sn)) {\n            _this.emeController.selectKeySystemFormat(frag).then(function (keySystemFormat) {\n              frag.setKeyFormat(keySystemFormat);\n            });\n            return 1; // break\n          }\n        };\n        for (var i = 0; i < encryptedFragments.length; i++) {\n          if (_loop()) break;\n        }\n      }\n    };\n    _proto.load = function load(frag) {\n      var _this2 = this;\n      if (!frag.decryptdata && frag.encrypted && this.emeController) {\n        // Multiple keys, but none selected, resolve in eme-controller\n        return this.emeController.selectKeySystemFormat(frag).then(function (keySystemFormat) {\n          return _this2.loadInternal(frag, keySystemFormat);\n        });\n      }\n      return this.loadInternal(frag);\n    };\n    _proto.loadInternal = function loadInternal(frag, keySystemFormat) {\n      var _keyInfo, _keyInfo2;\n      if (keySystemFormat) {\n        frag.setKeyFormat(keySystemFormat);\n      }\n      var decryptdata = frag.decryptdata;\n      if (!decryptdata) {\n        var error = new Error(keySystemFormat ? \"Expected frag.decryptdata to be defined after setting format \" + keySystemFormat : 'Missing decryption data on fragment in onKeyLoading');\n        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));\n      }\n      var uri = decryptdata.uri;\n      if (!uri) {\n        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"Invalid key URI: \\\"\" + uri + \"\\\"\")));\n      }\n      var keyInfo = this.keyUriToKeyInfo[uri];\n      if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {\n        decryptdata.key = keyInfo.decryptdata.key;\n        return Promise.resolve({\n          frag: frag,\n          keyInfo: keyInfo\n        });\n      }\n      // Return key load promise as long as it does not have a mediakey session with an unusable key status\n      if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {\n        var _keyInfo$mediaKeySess;\n        switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {\n          case undefined:\n          case 'status-pending':\n          case 'usable':\n          case 'usable-in-future':\n            return keyInfo.keyLoadPromise.then(function (keyLoadedData) {\n              // Return the correct fragment with updated decryptdata key and loaded keyInfo\n              decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;\n              return {\n                frag: frag,\n                keyInfo: keyInfo\n              };\n            });\n        }\n        // If we have a key session and status and it is not pending or usable, continue\n        // This will go back to the eme-controller for expired keys to get a new keyLoadPromise\n      }\n\n      // Load the key or return the loading promise\n      keyInfo = this.keyUriToKeyInfo[uri] = {\n        decryptdata: decryptdata,\n        keyLoadPromise: null,\n        loader: null,\n        mediaKeySessionContext: null\n      };\n      switch (decryptdata.method) {\n        case 'ISO-23001-7':\n        case 'SAMPLE-AES':\n        case 'SAMPLE-AES-CENC':\n        case 'SAMPLE-AES-CTR':\n          if (decryptdata.keyFormat === 'identity') {\n            // loadKeyHTTP handles http(s) and data URLs\n            return this.loadKeyHTTP(keyInfo, frag);\n          }\n          return this.loadKeyEME(keyInfo, frag);\n        case 'AES-128':\n          return this.loadKeyHTTP(keyInfo, frag);\n        default:\n          return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"Key supplied with unsupported METHOD: \\\"\" + decryptdata.method + \"\\\"\")));\n      }\n    };\n    _proto.loadKeyEME = function loadKeyEME(keyInfo, frag) {\n      var keyLoadedData = {\n        frag: frag,\n        keyInfo: keyInfo\n      };\n      if (this.emeController && this.config.emeEnabled) {\n        var keySessionContextPromise = this.emeController.loadKey(keyLoadedData);\n        if (keySessionContextPromise) {\n          return (keyInfo.keyLoadPromise = keySessionContextPromise.then(function (keySessionContext) {\n            keyInfo.mediaKeySessionContext = keySessionContext;\n            return keyLoadedData;\n          })).catch(function (error) {\n            // Remove promise for license renewal or retry\n            keyInfo.keyLoadPromise = null;\n            throw error;\n          });\n        }\n      }\n      return Promise.resolve(keyLoadedData);\n    };\n    _proto.loadKeyHTTP = function loadKeyHTTP(keyInfo, frag) {\n      var _this3 = this;\n      var config = this.config;\n      var Loader = config.loader;\n      var keyLoader = new Loader(config);\n      frag.keyLoader = keyInfo.loader = keyLoader;\n      return keyInfo.keyLoadPromise = new Promise(function (resolve, reject) {\n        var loaderContext = {\n          keyInfo: keyInfo,\n          frag: frag,\n          responseType: 'arraybuffer',\n          url: keyInfo.decryptdata.uri\n        };\n\n        // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n        // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n        // this will also align retry logic with fragment-loader\n        var loadPolicy = config.keyLoadPolicy.default;\n        var loaderConfig = {\n          loadPolicy: loadPolicy,\n          timeout: loadPolicy.maxLoadTimeMs,\n          maxRetry: 0,\n          retryDelay: 0,\n          maxRetryDelay: 0\n        };\n        var loaderCallbacks = {\n          onSuccess: function onSuccess(response, stats, context, networkDetails) {\n            var frag = context.frag,\n              keyInfo = context.keyInfo,\n              uri = context.url;\n            if (!frag.decryptdata || keyInfo !== _this3.keyUriToKeyInfo[uri]) {\n              return reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('after key load, decryptdata unset or changed'), networkDetails));\n            }\n            keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);\n\n            // detach fragment key loader on load success\n            frag.keyLoader = null;\n            keyInfo.loader = null;\n            resolve({\n              frag: frag,\n              keyInfo: keyInfo\n            });\n          },\n          onError: function onError(response, context, networkDetails, stats) {\n            _this3.resetLoader(context);\n            reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"HTTP Error \" + response.code + \" loading key \" + response.text), networkDetails, _objectSpread2({\n              url: loaderContext.url,\n              data: undefined\n            }, response)));\n          },\n          onTimeout: function onTimeout(stats, context, networkDetails) {\n            _this3.resetLoader(context);\n            reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error('key loading timed out'), networkDetails));\n          },\n          onAbort: function onAbort(stats, context, networkDetails) {\n            _this3.resetLoader(context);\n            reject(_this3.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error('key loading aborted'), networkDetails));\n          }\n        };\n        keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n      });\n    };\n    _proto.resetLoader = function resetLoader(context) {\n      var frag = context.frag,\n        keyInfo = context.keyInfo,\n        uri = context.url;\n      var loader = keyInfo.loader;\n      if (frag.keyLoader === loader) {\n        frag.keyLoader = null;\n        keyInfo.loader = null;\n      }\n      delete this.keyUriToKeyInfo[uri];\n      if (loader) {\n        loader.destroy();\n      }\n    };\n    return KeyLoader;\n  }();\n\n  function getSourceBuffer() {\n    return self.SourceBuffer || self.WebKitSourceBuffer;\n  }\n  function isMSESupported() {\n    var mediaSource = getMediaSource();\n    if (!mediaSource) {\n      return false;\n    }\n\n    // if SourceBuffer is exposed ensure its API is valid\n    // Older browsers do not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n    var sourceBuffer = getSourceBuffer();\n    return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n  }\n  function isSupported() {\n    if (!isMSESupported()) {\n      return false;\n    }\n    var mediaSource = getMediaSource();\n    return typeof (mediaSource == null ? void 0 : mediaSource.isTypeSupported) === 'function' && (['avc1.42E01E,mp4a.40.2', 'av01.0.01M.08', 'vp09.00.50.08'].some(function (codecsForVideoContainer) {\n      return mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, 'video'));\n    }) || ['mp4a.40.2', 'fLaC'].some(function (codecForAudioContainer) {\n      return mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, 'audio'));\n    }));\n  }\n  function changeTypeSupported() {\n    var _sourceBuffer$prototy;\n    var sourceBuffer = getSourceBuffer();\n    return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === 'function';\n  }\n\n  var STALL_MINIMUM_DURATION_MS = 250;\n  var MAX_START_GAP_JUMP = 2.0;\n  var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\n  var SKIP_BUFFER_RANGE_START = 0.05;\n  var GapController = /*#__PURE__*/function () {\n    function GapController(config, media, fragmentTracker, hls) {\n      this.config = void 0;\n      this.media = null;\n      this.fragmentTracker = void 0;\n      this.hls = void 0;\n      this.nudgeRetry = 0;\n      this.stallReported = false;\n      this.stalled = null;\n      this.moved = false;\n      this.seeking = false;\n      this.config = config;\n      this.media = media;\n      this.fragmentTracker = fragmentTracker;\n      this.hls = hls;\n    }\n    var _proto = GapController.prototype;\n    _proto.destroy = function destroy() {\n      this.media = null;\n      // @ts-ignore\n      this.hls = this.fragmentTracker = null;\n    }\n\n    /**\n     * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n     * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n     *\n     * @param lastCurrentTime - Previously read playhead position\n     */;\n    _proto.poll = function poll(lastCurrentTime, activeFrag) {\n      var config = this.config,\n        media = this.media,\n        stalled = this.stalled;\n      if (media === null) {\n        return;\n      }\n      var currentTime = media.currentTime,\n        seeking = media.seeking;\n      var seeked = this.seeking && !seeking;\n      var beginSeek = !this.seeking && seeking;\n      this.seeking = seeking;\n\n      // The playhead is moving, no-op\n      if (currentTime !== lastCurrentTime) {\n        this.moved = true;\n        if (!seeking) {\n          this.nudgeRetry = 0;\n        }\n        if (stalled !== null) {\n          // The playhead is now moving, but was previously stalled\n          if (this.stallReported) {\n            var _stalledDuration = self.performance.now() - stalled;\n            logger.warn(\"playback not stuck anymore @\" + currentTime + \", after \" + Math.round(_stalledDuration) + \"ms\");\n            this.stallReported = false;\n          }\n          this.stalled = null;\n        }\n        return;\n      }\n\n      // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n      if (beginSeek || seeked) {\n        this.stalled = null;\n        return;\n      }\n\n      // The playhead should not be moving\n      if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {\n        this.nudgeRetry = 0;\n        return;\n      }\n      var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n      var nextStart = bufferInfo.nextStart || 0;\n      if (seeking) {\n        // Waiting for seeking in a buffered range to complete\n        var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;\n        // Next buffered range is too far ahead to jump to while still seeking\n        var noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);\n        if (hasEnoughBuffer || noBufferGap) {\n          return;\n        }\n        // Reset moved state when seeking to a point in or before a gap\n        this.moved = false;\n      }\n\n      // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n      // The addition poll gives the browser a chance to jump the gap for us\n      if (!this.moved && this.stalled !== null) {\n        var _level$details;\n        // There is no playable buffer (seeked, waiting for buffer)\n        var isBuffered = bufferInfo.len > 0;\n        if (!isBuffered && !nextStart) {\n          return;\n        }\n        // Jump start gaps within jump threshold\n        var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;\n\n        // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n        // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n        // that begins over 1 target duration after the video start position.\n        var level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;\n        var isLive = level == null ? void 0 : (_level$details = level.details) == null ? void 0 : _level$details.live;\n        var maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;\n        var partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);\n        if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {\n          if (!media.paused) {\n            this._trySkipBufferHole(partialOrGap);\n          }\n          return;\n        }\n      }\n\n      // Start tracking stall time\n      var tnow = self.performance.now();\n      if (stalled === null) {\n        this.stalled = tnow;\n        return;\n      }\n      var stalledDuration = tnow - stalled;\n      if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {\n        // Report stalling after trying to fix\n        this._reportStall(bufferInfo);\n        if (!this.media) {\n          return;\n        }\n      }\n      var bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);\n      this._tryFixBufferStall(bufferedWithHoles, stalledDuration);\n    }\n\n    /**\n     * Detects and attempts to fix known buffer stalling issues.\n     * @param bufferInfo - The properties of the current buffer.\n     * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n     * @private\n     */;\n    _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs) {\n      var config = this.config,\n        fragmentTracker = this.fragmentTracker,\n        media = this.media;\n      if (media === null) {\n        return;\n      }\n      var currentTime = media.currentTime;\n      var partial = fragmentTracker.getPartialFragment(currentTime);\n      if (partial) {\n        // Try to skip over the buffer hole caused by a partial fragment\n        // This method isn't limited by the size of the gap between buffered ranges\n        var targetTime = this._trySkipBufferHole(partial);\n        // we return here in this case, meaning\n        // the branch below only executes when we haven't seeked to a new position\n        if (targetTime || !this.media) {\n          return;\n        }\n      }\n\n      // if we haven't had to skip over a buffer hole of a partial fragment\n      // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n      // needs to cross some sort of threshold covering all source-buffers content\n      // to start playing properly.\n      if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {\n        logger.warn('Trying to nudge playhead over buffer-hole');\n        // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n        // We only try to jump the hole if it's under the configured size\n        // Reset stalled so to rearm watchdog timer\n        this.stalled = null;\n        this._tryNudgeBuffer();\n      }\n    }\n\n    /**\n     * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n     * @param bufferLen - The playhead distance from the end of the current buffer segment.\n     * @private\n     */;\n    _proto._reportStall = function _reportStall(bufferInfo) {\n      var hls = this.hls,\n        media = this.media,\n        stallReported = this.stallReported;\n      if (!stallReported && media) {\n        // Report stalled error once\n        this.stallReported = true;\n        var error = new Error(\"Playback stalling at @\" + media.currentTime + \" due to low buffer (\" + JSON.stringify(bufferInfo) + \")\");\n        logger.warn(error.message);\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_STALLED_ERROR,\n          fatal: false,\n          error: error,\n          buffer: bufferInfo.len\n        });\n      }\n    }\n\n    /**\n     * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n     * @param partial - The partial fragment found at the current time (where playback is stalling).\n     * @private\n     */;\n    _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {\n      var config = this.config,\n        hls = this.hls,\n        media = this.media;\n      if (media === null) {\n        return 0;\n      }\n\n      // Check if currentTime is between unbuffered regions of partial fragments\n      var currentTime = media.currentTime;\n      var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n      var startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;\n      if (startTime) {\n        var bufferStarved = bufferInfo.len <= config.maxBufferHole;\n        var waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;\n        var gapLength = startTime - currentTime;\n        if (gapLength > 0 && (bufferStarved || waiting)) {\n          // Only allow large gaps to be skipped if it is a start gap, or all fragments in skip range are partial\n          if (gapLength > config.maxBufferHole) {\n            var fragmentTracker = this.fragmentTracker;\n            var startGap = false;\n            if (currentTime === 0) {\n              var startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);\n              if (startFrag && startTime < startFrag.end) {\n                startGap = true;\n              }\n            }\n            if (!startGap) {\n              var startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);\n              if (startProvisioned) {\n                var moreToLoad = false;\n                var pos = startProvisioned.end;\n                while (pos < startTime) {\n                  var provisioned = fragmentTracker.getPartialFragment(pos);\n                  if (provisioned) {\n                    pos += provisioned.duration;\n                  } else {\n                    moreToLoad = true;\n                    break;\n                  }\n                }\n                if (moreToLoad) {\n                  return 0;\n                }\n              }\n            }\n          }\n          var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n          logger.warn(\"skipping hole, adjusting currentTime from \" + currentTime + \" to \" + targetTime);\n          this.moved = true;\n          this.stalled = null;\n          media.currentTime = targetTime;\n          if (partial && !partial.gap) {\n            var error = new Error(\"fragment loaded with buffer holes, seeking from \" + currentTime + \" to \" + targetTime);\n            hls.trigger(Events.ERROR, {\n              type: ErrorTypes.MEDIA_ERROR,\n              details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n              fatal: false,\n              error: error,\n              reason: error.message,\n              frag: partial\n            });\n          }\n          return targetTime;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n     * @private\n     */;\n    _proto._tryNudgeBuffer = function _tryNudgeBuffer() {\n      var config = this.config,\n        hls = this.hls,\n        media = this.media,\n        nudgeRetry = this.nudgeRetry;\n      if (media === null) {\n        return;\n      }\n      var currentTime = media.currentTime;\n      this.nudgeRetry++;\n      if (nudgeRetry < config.nudgeMaxRetry) {\n        var targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;\n        // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n        var error = new Error(\"Nudging 'currentTime' from \" + currentTime + \" to \" + targetTime);\n        logger.warn(error.message);\n        media.currentTime = targetTime;\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n          error: error,\n          fatal: false\n        });\n      } else {\n        var _error = new Error(\"Playhead still not moving while enough data buffered @\" + currentTime + \" after \" + config.nudgeMaxRetry + \" nudges\");\n        logger.error(_error.message);\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_STALLED_ERROR,\n          error: _error,\n          fatal: true\n        });\n      }\n    };\n    return GapController;\n  }();\n\n  var TICK_INTERVAL = 100; // how often to tick in ms\n  var StreamController = /*#__PURE__*/function (_BaseStreamController) {\n    _inheritsLoose(StreamController, _BaseStreamController);\n    function StreamController(hls, fragmentTracker, keyLoader) {\n      var _this;\n      _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, '[stream-controller]', PlaylistLevelType.MAIN) || this;\n      _this.audioCodecSwap = false;\n      _this.gapController = null;\n      _this.level = -1;\n      _this._forceStartLoad = false;\n      _this.altAudio = false;\n      _this.audioOnly = false;\n      _this.fragPlaying = null;\n      _this.onvplaying = null;\n      _this.onvseeked = null;\n      _this.fragLastKbps = 0;\n      _this.couldBacktrack = false;\n      _this.backtrackFragment = null;\n      _this.audioCodecSwitch = false;\n      _this.videoBuffer = null;\n      _this._registerListeners();\n      return _this;\n    }\n    var _proto = StreamController.prototype;\n    _proto._registerListeners = function _registerListeners() {\n      var hls = this.hls;\n      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n      hls.on(Events.ERROR, this.onError, this);\n      hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n      hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n      hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n      hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    };\n    _proto._unregisterListeners = function _unregisterListeners() {\n      var hls = this.hls;\n      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n      hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n      hls.off(Events.ERROR, this.onError, this);\n      hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n      hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n      hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n      hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    };\n    _proto.onHandlerDestroying = function onHandlerDestroying() {\n      this._unregisterListeners();\n      _BaseStreamController.prototype.onHandlerDestroying.call(this);\n    };\n    _proto.startLoad = function startLoad(startPosition) {\n      if (this.levels) {\n        var lastCurrentTime = this.lastCurrentTime,\n          hls = this.hls;\n        this.stopLoad();\n        this.setInterval(TICK_INTERVAL);\n        this.level = -1;\n        if (!this.startFragRequested) {\n          // determine load level\n          var startLevel = hls.startLevel;\n          if (startLevel === -1) {\n            if (hls.config.testBandwidth && this.levels.length > 1) {\n              // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n              startLevel = 0;\n              this.bitrateTest = true;\n            } else {\n              startLevel = hls.firstAutoLevel;\n            }\n          }\n          // set new level to playlist loader : this will trigger start level load\n          // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n          hls.nextLoadLevel = startLevel;\n          this.level = hls.loadLevel;\n          this.loadedmetadata = false;\n        }\n        // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n        if (lastCurrentTime > 0 && startPosition === -1) {\n          this.log(\"Override startPosition with lastCurrentTime @\" + lastCurrentTime.toFixed(3));\n          startPosition = lastCurrentTime;\n        }\n        this.state = State.IDLE;\n        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n        this.tick();\n      } else {\n        this._forceStartLoad = true;\n        this.state = State.STOPPED;\n      }\n    };\n    _proto.stopLoad = function stopLoad() {\n      this._forceStartLoad = false;\n      _BaseStreamController.prototype.stopLoad.call(this);\n    };\n    _proto.doTick = function doTick() {\n      switch (this.state) {\n        case State.WAITING_LEVEL:\n          {\n            var levels = this.levels,\n              level = this.level;\n            var currentLevel = levels == null ? void 0 : levels[level];\n            var details = currentLevel == null ? void 0 : currentLevel.details;\n            if (details && (!details.live || this.levelLastLoaded === currentLevel)) {\n              if (this.waitForCdnTuneIn(details)) {\n                break;\n              }\n              this.state = State.IDLE;\n              break;\n            } else if (this.hls.nextLoadLevel !== this.level) {\n              this.state = State.IDLE;\n              break;\n            }\n            break;\n          }\n        case State.FRAG_LOADING_WAITING_RETRY:\n          {\n            var _this$media;\n            var now = self.performance.now();\n            var retryDate = this.retryDate;\n            // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n            if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n              var _levels = this.levels,\n                _level = this.level;\n              var _currentLevel = _levels == null ? void 0 : _levels[_level];\n              this.resetStartWhenNotLoaded(_currentLevel || null);\n              this.state = State.IDLE;\n            }\n          }\n          break;\n      }\n      if (this.state === State.IDLE) {\n        this.doTickIdle();\n      }\n      this.onTickEnd();\n    };\n    _proto.onTickEnd = function onTickEnd() {\n      _BaseStreamController.prototype.onTickEnd.call(this);\n      this.checkBuffer();\n      this.checkFragmentChanged();\n    };\n    _proto.doTickIdle = function doTickIdle() {\n      var hls = this.hls,\n        levelLastLoaded = this.levelLastLoaded,\n        levels = this.levels,\n        media = this.media;\n\n      // if start level not parsed yet OR\n      // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n      // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n      if (levelLastLoaded === null || !media && (this.startFragRequested || !hls.config.startFragPrefetch)) {\n        return;\n      }\n\n      // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n      if (this.altAudio && this.audioOnly) {\n        return;\n      }\n      var level = hls.nextLoadLevel;\n      if (!(levels != null && levels[level])) {\n        return;\n      }\n      var levelInfo = levels[level];\n\n      // if buffer length is less than maxBufLen try to load a new fragment\n\n      var bufferInfo = this.getMainFwdBufferInfo();\n      if (bufferInfo === null) {\n        return;\n      }\n      var lastDetails = this.getLevelDetails();\n      if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {\n        var data = {};\n        if (this.altAudio) {\n          data.type = 'video';\n        }\n        this.hls.trigger(Events.BUFFER_EOS, data);\n        this.state = State.ENDED;\n        return;\n      }\n\n      // set next load level : this will trigger a playlist load if needed\n      if (hls.loadLevel !== level && hls.manualLevel === -1) {\n        this.log(\"Adapting to level \" + level + \" from level \" + this.level);\n      }\n      this.level = hls.nextLoadLevel = level;\n      var levelDetails = levelInfo.details;\n      // if level info not retrieved yet, switch state and wait for level retrieval\n      // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n      // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n      if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== levelInfo) {\n        this.level = level;\n        this.state = State.WAITING_LEVEL;\n        return;\n      }\n      var bufferLen = bufferInfo.len;\n\n      // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n      var maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);\n\n      // Stay idle if we are still with buffer margins\n      if (bufferLen >= maxBufLen) {\n        return;\n      }\n      if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n        this.backtrackFragment = null;\n      }\n      var targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n      var frag = this.getNextFragment(targetBufferTime, levelDetails);\n      // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n      if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== 'initSegment' && this.fragmentTracker.getState(frag) !== FragmentState.OK) {\n        var _this$backtrackFragme;\n        var backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n        var fragIdx = backtrackSn - levelDetails.startSN;\n        var backtrackFrag = levelDetails.fragments[fragIdx - 1];\n        if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n          frag = backtrackFrag;\n          this.fragmentTracker.removeFragment(backtrackFrag);\n        }\n      } else if (this.backtrackFragment && bufferInfo.len) {\n        this.backtrackFragment = null;\n      }\n      // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n      if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n        var gapStart = frag.gap;\n        if (!gapStart) {\n          // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n          var type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;\n          var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n          if (mediaBuffer) {\n            this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n          }\n        }\n        frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n      }\n      if (!frag) {\n        return;\n      }\n      if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n        frag = frag.initSegment;\n      }\n      this.loadFragment(frag, levelInfo, targetBufferTime);\n    };\n    _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {\n      // Check if fragment is not loaded\n      var fragState = this.fragmentTracker.getState(frag);\n      this.fragCurrent = frag;\n      if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n        if (frag.sn === 'initSegment') {\n          this._loadInitSegment(frag, level);\n        } else if (this.bitrateTest) {\n          this.log(\"Fragment \" + frag.sn + \" of level \" + frag.level + \" is being downloaded to test bitrate and will not be buffered\");\n          this._loadBitrateTestFrag(frag, level);\n        } else {\n          this.startFragRequested = true;\n          _BaseStreamController.prototype.loadFragment.call(this, frag, level, targetBufferTime);\n        }\n      } else {\n        this.clearTrackerIfNeeded(frag);\n      }\n    };\n    _proto.getBufferedFrag = function getBufferedFrag(position) {\n      return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);\n    };\n    _proto.followingBufferedFrag = function followingBufferedFrag(frag) {\n      if (frag) {\n        // try to get range of next fragment (500ms after this range)\n        return this.getBufferedFrag(frag.end + 0.5);\n      }\n      return null;\n    }\n\n    /*\n      on immediate level switch :\n       - pause playback if playing\n       - cancel any pending load request\n       - and trigger a buffer flush\n    */;\n    _proto.immediateLevelSwitch = function immediateLevelSwitch() {\n      this.abortCurrentFrag();\n      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n    }\n\n    /**\n     * try to switch ASAP without breaking video playback:\n     * in order to ensure smooth but quick level switching,\n     * we need to find the next flushable buffer range\n     * we should take into account new segment fetch time\n     */;\n    _proto.nextLevelSwitch = function nextLevelSwitch() {\n      var levels = this.levels,\n        media = this.media;\n      // ensure that media is defined and that metadata are available (to retrieve currentTime)\n      if (media != null && media.readyState) {\n        var fetchdelay;\n        var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n        if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n          // flush buffer preceding current fragment (flush until current fragment start offset)\n          // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n          this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n        }\n        var levelDetails = this.getLevelDetails();\n        if (levelDetails != null && levelDetails.live) {\n          var bufferInfo = this.getMainFwdBufferInfo();\n          // Do not flush in live stream with low buffer\n          if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {\n            return;\n          }\n        }\n        if (!media.paused && levels) {\n          // add a safety delay of 1s\n          var nextLevelId = this.hls.nextLoadLevel;\n          var nextLevel = levels[nextLevelId];\n          var fragLastKbps = this.fragLastKbps;\n          if (fragLastKbps && this.fragCurrent) {\n            fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n          } else {\n            fetchdelay = 0;\n          }\n        } else {\n          fetchdelay = 0;\n        }\n        // this.log('fetchdelay:'+fetchdelay);\n        // find buffer range that will be reached once new fragment will be fetched\n        var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n        if (bufferedFrag) {\n          // we can flush buffer range following this one without stalling playback\n          var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n          if (nextBufferedFrag) {\n            // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n            this.abortCurrentFrag();\n            // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n            var maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n            var fragDuration = nextBufferedFrag.duration;\n            var startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));\n            this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n          }\n        }\n      }\n    };\n    _proto.abortCurrentFrag = function abortCurrentFrag() {\n      var fragCurrent = this.fragCurrent;\n      this.fragCurrent = null;\n      this.backtrackFragment = null;\n      if (fragCurrent) {\n        fragCurrent.abortRequests();\n        this.fragmentTracker.removeFragment(fragCurrent);\n      }\n      switch (this.state) {\n        case State.KEY_LOADING:\n        case State.FRAG_LOADING:\n        case State.FRAG_LOADING_WAITING_RETRY:\n        case State.PARSING:\n        case State.PARSED:\n          this.state = State.IDLE;\n          break;\n      }\n      this.nextLoadPosition = this.getLoadPosition();\n    };\n    _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {\n      _BaseStreamController.prototype.flushMainBuffer.call(this, startOffset, endOffset, this.altAudio ? 'video' : null);\n    };\n    _proto.onMediaAttached = function onMediaAttached(event, data) {\n      _BaseStreamController.prototype.onMediaAttached.call(this, event, data);\n      var media = data.media;\n      this.onvplaying = this.onMediaPlaying.bind(this);\n      this.onvseeked = this.onMediaSeeked.bind(this);\n      media.addEventListener('playing', this.onvplaying);\n      media.addEventListener('seeked', this.onvseeked);\n      this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);\n    };\n    _proto.onMediaDetaching = function onMediaDetaching() {\n      var media = this.media;\n      if (media && this.onvplaying && this.onvseeked) {\n        media.removeEventListener('playing', this.onvplaying);\n        media.removeEventListener('seeked', this.onvseeked);\n        this.onvplaying = this.onvseeked = null;\n        this.videoBuffer = null;\n      }\n      this.fragPlaying = null;\n      if (this.gapController) {\n        this.gapController.destroy();\n        this.gapController = null;\n      }\n      _BaseStreamController.prototype.onMediaDetaching.call(this);\n    };\n    _proto.onMediaPlaying = function onMediaPlaying() {\n      // tick to speed up FRAG_CHANGED triggering\n      this.tick();\n    };\n    _proto.onMediaSeeked = function onMediaSeeked() {\n      var media = this.media;\n      var currentTime = media ? media.currentTime : null;\n      if (isFiniteNumber(currentTime)) {\n        this.log(\"Media seeked to \" + currentTime.toFixed(3));\n      }\n\n      // If seeked was issued before buffer was appended do not tick immediately\n      var bufferInfo = this.getMainFwdBufferInfo();\n      if (bufferInfo === null || bufferInfo.len === 0) {\n        this.warn(\"Main forward buffer length on \\\"seeked\\\" event \" + (bufferInfo ? bufferInfo.len : 'empty') + \")\");\n        return;\n      }\n\n      // tick to speed up FRAG_CHANGED triggering\n      this.tick();\n    };\n    _proto.onManifestLoading = function onManifestLoading() {\n      // reset buffer on manifest loading\n      this.log('Trigger BUFFER_RESET');\n      this.hls.trigger(Events.BUFFER_RESET, undefined);\n      this.fragmentTracker.removeAllFragments();\n      this.couldBacktrack = false;\n      this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0;\n      this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null;\n      this.altAudio = this.audioOnly = this.startFragRequested = false;\n    };\n    _proto.onManifestParsed = function onManifestParsed(event, data) {\n      // detect if we have different kind of audio codecs used amongst playlists\n      var aac = false;\n      var heaac = false;\n      data.levels.forEach(function (level) {\n        var codec = level.audioCodec;\n        if (codec) {\n          aac = aac || codec.indexOf('mp4a.40.2') !== -1;\n          heaac = heaac || codec.indexOf('mp4a.40.5') !== -1;\n        }\n      });\n      this.audioCodecSwitch = aac && heaac && !changeTypeSupported();\n      if (this.audioCodecSwitch) {\n        this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n      }\n      this.levels = data.levels;\n      this.startFragRequested = false;\n    };\n    _proto.onLevelLoading = function onLevelLoading(event, data) {\n      var levels = this.levels;\n      if (!levels || this.state !== State.IDLE) {\n        return;\n      }\n      var level = levels[data.level];\n      if (!level.details || level.details.live && this.levelLastLoaded !== level || this.waitForCdnTuneIn(level.details)) {\n        this.state = State.WAITING_LEVEL;\n      }\n    };\n    _proto.onLevelLoaded = function onLevelLoaded(event, data) {\n      var _curLevel$details;\n      var levels = this.levels;\n      var newLevelId = data.level;\n      var newDetails = data.details;\n      var duration = newDetails.totalduration;\n      if (!levels) {\n        this.warn(\"Levels were reset while loading level \" + newLevelId);\n        return;\n      }\n      this.log(\"Level \" + newLevelId + \" loaded [\" + newDetails.startSN + \",\" + newDetails.endSN + \"]\" + (newDetails.lastPartSn ? \"[part-\" + newDetails.lastPartSn + \"-\" + newDetails.lastPartIndex + \"]\" : '') + \", cc [\" + newDetails.startCC + \", \" + newDetails.endCC + \"] duration:\" + duration);\n      var curLevel = levels[newLevelId];\n      var fragCurrent = this.fragCurrent;\n      if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {\n        if (fragCurrent.level !== data.level && fragCurrent.loader) {\n          this.abortCurrentFrag();\n        }\n      }\n      var sliding = 0;\n      if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {\n        var _this$levelLastLoaded;\n        this.checkLiveUpdate(newDetails);\n        if (newDetails.deltaUpdateFailed) {\n          return;\n        }\n        sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n      }\n      // override level info\n      curLevel.details = newDetails;\n      this.levelLastLoaded = curLevel;\n      this.hls.trigger(Events.LEVEL_UPDATED, {\n        details: newDetails,\n        level: newLevelId\n      });\n\n      // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n      if (this.state === State.WAITING_LEVEL) {\n        if (this.waitForCdnTuneIn(newDetails)) {\n          // Wait for Low-Latency CDN Tune-in\n          return;\n        }\n        this.state = State.IDLE;\n      }\n      if (!this.startFragRequested) {\n        this.setStartPosition(newDetails, sliding);\n      } else if (newDetails.live) {\n        this.synchronizeToLiveEdge(newDetails);\n      }\n\n      // trigger handler right now\n      this.tick();\n    };\n    _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {\n      var _frag$initSegment;\n      var frag = data.frag,\n        part = data.part,\n        payload = data.payload;\n      var levels = this.levels;\n      if (!levels) {\n        this.warn(\"Levels were reset while fragment load was in progress. Fragment \" + frag.sn + \" of level \" + frag.level + \" will not be buffered\");\n        return;\n      }\n      var currentLevel = levels[frag.level];\n      var details = currentLevel.details;\n      if (!details) {\n        this.warn(\"Dropping fragment \" + frag.sn + \" of level \" + frag.level + \" after level details were reset\");\n        this.fragmentTracker.removeFragment(frag);\n        return;\n      }\n      var videoCodec = currentLevel.videoCodec;\n\n      // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n      var accurateTimeOffset = details.PTSKnown || !details.live;\n      var initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n      var audioCodec = this._getAudioCodec(currentLevel);\n\n      // transmux the MPEG-TS data to ISO-BMFF segments\n      // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n      var transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n      var partIndex = part ? part.index : -1;\n      var partial = partIndex !== -1;\n      var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n      var initPTS = this.initPTS[frag.cc];\n      transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n    };\n    _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {\n      // if any URL found on new audio track, it is an alternate audio track\n      var fromAltAudio = this.altAudio;\n      var altAudio = !!data.url;\n      // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n      // don't do anything if we switch to alt audio: audio stream controller is handling it.\n      // we will just have to change buffer scheduling on audioTrackSwitched\n      if (!altAudio) {\n        if (this.mediaBuffer !== this.media) {\n          this.log('Switching on main audio, use media.buffered to schedule main fragment loading');\n          this.mediaBuffer = this.media;\n          var fragCurrent = this.fragCurrent;\n          // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n          if (fragCurrent) {\n            this.log('Switching to main audio track, cancel main fragment load');\n            fragCurrent.abortRequests();\n            this.fragmentTracker.removeFragment(fragCurrent);\n          }\n          // destroy transmuxer to force init segment generation (following audio switch)\n          this.resetTransmuxer();\n          // switch to IDLE state to load new fragment\n          this.resetLoadingState();\n        } else if (this.audioOnly) {\n          // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n          this.resetTransmuxer();\n        }\n        var hls = this.hls;\n        // If switching from alt to main audio, flush all audio and trigger track switched\n        if (fromAltAudio) {\n          hls.trigger(Events.BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: Number.POSITIVE_INFINITY,\n            type: null\n          });\n          this.fragmentTracker.removeAllFragments();\n        }\n        hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n      }\n    };\n    _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {\n      var trackId = data.id;\n      var altAudio = !!this.hls.audioTracks[trackId].url;\n      if (altAudio) {\n        var videoBuffer = this.videoBuffer;\n        // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n        if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n          this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');\n          this.mediaBuffer = videoBuffer;\n        }\n      }\n      this.altAudio = altAudio;\n      this.tick();\n    };\n    _proto.onBufferCreated = function onBufferCreated(event, data) {\n      var tracks = data.tracks;\n      var mediaTrack;\n      var name;\n      var alternate = false;\n      for (var type in tracks) {\n        var track = tracks[type];\n        if (track.id === 'main') {\n          name = type;\n          mediaTrack = track;\n          // keep video source buffer reference\n          if (type === 'video') {\n            var videoTrack = tracks[type];\n            if (videoTrack) {\n              this.videoBuffer = videoTrack.buffer;\n            }\n          }\n        } else {\n          alternate = true;\n        }\n      }\n      if (alternate && mediaTrack) {\n        this.log(\"Alternate track found, use \" + name + \".buffered to schedule main fragment loading\");\n        this.mediaBuffer = mediaTrack.buffer;\n      } else {\n        this.mediaBuffer = this.media;\n      }\n    };\n    _proto.onFragBuffered = function onFragBuffered(event, data) {\n      var frag = data.frag,\n        part = data.part;\n      if (frag && frag.type !== PlaylistLevelType.MAIN) {\n        return;\n      }\n      if (this.fragContextChanged(frag)) {\n        // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n        // Avoid setting state back to IDLE, since that will interfere with a level switch\n        this.warn(\"Fragment \" + frag.sn + (part ? ' p: ' + part.index : '') + \" of level \" + frag.level + \" finished buffering, but was aborted. state: \" + this.state);\n        if (this.state === State.PARSED) {\n          this.state = State.IDLE;\n        }\n        return;\n      }\n      var stats = part ? part.stats : frag.stats;\n      this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n      if (frag.sn !== 'initSegment') {\n        this.fragPrevious = frag;\n      }\n      this.fragBufferedComplete(frag, part);\n    };\n    _proto.onError = function onError(event, data) {\n      var _data$context;\n      if (data.fatal) {\n        this.state = State.ERROR;\n        return;\n      }\n      switch (data.details) {\n        case ErrorDetails.FRAG_GAP:\n        case ErrorDetails.FRAG_PARSING_ERROR:\n        case ErrorDetails.FRAG_DECRYPT_ERROR:\n        case ErrorDetails.FRAG_LOAD_ERROR:\n        case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case ErrorDetails.KEY_LOAD_ERROR:\n        case ErrorDetails.KEY_LOAD_TIMEOUT:\n          this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);\n          break;\n        case ErrorDetails.LEVEL_LOAD_ERROR:\n        case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        case ErrorDetails.LEVEL_PARSING_ERROR:\n          // in case of non fatal error while loading level, if level controller is not retrying to load level, switch back to IDLE\n          if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {\n            this.state = State.IDLE;\n          }\n          break;\n        case ErrorDetails.BUFFER_APPEND_ERROR:\n        case ErrorDetails.BUFFER_FULL_ERROR:\n          if (!data.parent || data.parent !== 'main') {\n            return;\n          }\n          if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {\n            this.resetLoadingState();\n            return;\n          }\n          if (this.reduceLengthAndFlushBuffer(data)) {\n            this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n          }\n          break;\n        case ErrorDetails.INTERNAL_EXCEPTION:\n          this.recoverWorkerError(data);\n          break;\n      }\n    }\n\n    // Checks the health of the buffer and attempts to resolve playback stalls.\n    ;\n    _proto.checkBuffer = function checkBuffer() {\n      var media = this.media,\n        gapController = this.gapController;\n      if (!media || !gapController || !media.readyState) {\n        // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n        return;\n      }\n      if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {\n        // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n        var activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;\n        gapController.poll(this.lastCurrentTime, activeFrag);\n      }\n      this.lastCurrentTime = media.currentTime;\n    };\n    _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {\n      this.state = State.IDLE;\n      // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n      // in that case, reset startFragRequested flag\n      if (!this.loadedmetadata) {\n        this.startFragRequested = false;\n        this.nextLoadPosition = this.startPosition;\n      }\n      this.tickImmediate();\n    };\n    _proto.onBufferFlushed = function onBufferFlushed(event, _ref) {\n      var type = _ref.type;\n      if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {\n        var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n        this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n        this.tick();\n      }\n    };\n    _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {\n      if (this.level > -1 && this.fragCurrent) {\n        this.level = this.fragCurrent.level;\n      }\n      this.levels = data.levels;\n    };\n    _proto.swapAudioCodec = function swapAudioCodec() {\n      this.audioCodecSwap = !this.audioCodecSwap;\n    }\n\n    /**\n     * Seeks to the set startPosition if not equal to the mediaElement's current time.\n     */;\n    _proto.seekToStartPos = function seekToStartPos() {\n      var media = this.media;\n      if (!media) {\n        return;\n      }\n      var currentTime = media.currentTime;\n      var startPosition = this.startPosition;\n      // only adjust currentTime if different from startPosition or if startPosition not buffered\n      // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n      if (startPosition >= 0 && currentTime < startPosition) {\n        if (media.seeking) {\n          this.log(\"could not seek to \" + startPosition + \", already seeking at \" + currentTime);\n          return;\n        }\n        var buffered = BufferHelper.getBuffered(media);\n        var bufferStart = buffered.length ? buffered.start(0) : 0;\n        var delta = bufferStart - startPosition;\n        if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {\n          this.log(\"adjusting start position by \" + delta + \" to match buffer start\");\n          startPosition += delta;\n          this.startPosition = startPosition;\n        }\n        this.log(\"seek to target start position \" + startPosition + \" from current time \" + currentTime);\n        media.currentTime = startPosition;\n      }\n    };\n    _proto._getAudioCodec = function _getAudioCodec(currentLevel) {\n      var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n      if (this.audioCodecSwap && audioCodec) {\n        this.log('Swapping audio codec');\n        if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n          audioCodec = 'mp4a.40.2';\n        } else {\n          audioCodec = 'mp4a.40.5';\n        }\n      }\n      return audioCodec;\n    };\n    _proto._loadBitrateTestFrag = function _loadBitrateTestFrag(frag, level) {\n      var _this2 = this;\n      frag.bitrateTest = true;\n      this._doFragLoad(frag, level).then(function (data) {\n        var hls = _this2.hls;\n        if (!data || _this2.fragContextChanged(frag)) {\n          return;\n        }\n        level.fragmentError = 0;\n        _this2.state = State.IDLE;\n        _this2.startFragRequested = false;\n        _this2.bitrateTest = false;\n        var stats = frag.stats;\n        // Bitrate tests fragments are neither parsed nor buffered\n        stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n        hls.trigger(Events.FRAG_LOADED, data);\n        frag.bitrateTest = false;\n      });\n    };\n    _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {\n      var _id3$samples;\n      var id = 'main';\n      var hls = this.hls;\n      var remuxResult = transmuxResult.remuxResult,\n        chunkMeta = transmuxResult.chunkMeta;\n      var context = this.getCurrentContext(chunkMeta);\n      if (!context) {\n        this.resetWhenMissingContext(chunkMeta);\n        return;\n      }\n      var frag = context.frag,\n        part = context.part,\n        level = context.level;\n      var video = remuxResult.video,\n        text = remuxResult.text,\n        id3 = remuxResult.id3,\n        initSegment = remuxResult.initSegment;\n      var details = level.details;\n      // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n      var audio = this.altAudio ? undefined : remuxResult.audio;\n\n      // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n      // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n      if (this.fragContextChanged(frag)) {\n        this.fragmentTracker.removeFragment(frag);\n        return;\n      }\n      this.state = State.PARSING;\n      if (initSegment) {\n        if (initSegment != null && initSegment.tracks) {\n          var mapFragment = frag.initSegment || frag;\n          this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n          hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n            frag: mapFragment,\n            id: id,\n            tracks: initSegment.tracks\n          });\n        }\n\n        // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n        var initPTS = initSegment.initPTS;\n        var timescale = initSegment.timescale;\n        if (isFiniteNumber(initPTS)) {\n          this.initPTS[frag.cc] = {\n            baseTime: initPTS,\n            timescale: timescale\n          };\n          hls.trigger(Events.INIT_PTS_FOUND, {\n            frag: frag,\n            id: id,\n            initPTS: initPTS,\n            timescale: timescale\n          });\n        }\n      }\n\n      // Avoid buffering if backtracking this fragment\n      if (video && details && frag.sn !== 'initSegment') {\n        var prevFrag = details.fragments[frag.sn - 1 - details.startSN];\n        var isFirstFragment = frag.sn === details.startSN;\n        var isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;\n        if (remuxResult.independent !== false) {\n          var startPTS = video.startPTS,\n            endPTS = video.endPTS,\n            startDTS = video.startDTS,\n            endDTS = video.endDTS;\n          if (part) {\n            part.elementaryStreams[video.type] = {\n              startPTS: startPTS,\n              endPTS: endPTS,\n              startDTS: startDTS,\n              endDTS: endDTS\n            };\n          } else {\n            if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {\n              this.couldBacktrack = true;\n            }\n            if (video.dropped && video.independent) {\n              // Backtrack if dropped frames create a gap after currentTime\n\n              var bufferInfo = this.getMainFwdBufferInfo();\n              var targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n              var startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n              if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {\n                this.backtrack(frag);\n                return;\n              } else if (isFirstInDiscontinuity) {\n                // Mark segment with a gap to avoid loop loading\n                frag.gap = true;\n              }\n              // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n              frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n            } else if (isFirstFragment && startPTS > MAX_START_GAP_JUMP) {\n              // Mark segment with a gap to skip large start gap\n              frag.gap = true;\n            }\n          }\n          frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n          if (this.backtrackFragment) {\n            this.backtrackFragment = frag;\n          }\n          this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);\n        } else if (isFirstFragment || isFirstInDiscontinuity) {\n          // Mark segment with a gap to avoid loop loading\n          frag.gap = true;\n        } else {\n          this.backtrack(frag);\n          return;\n        }\n      }\n      if (audio) {\n        var _startPTS = audio.startPTS,\n          _endPTS = audio.endPTS,\n          _startDTS = audio.startDTS,\n          _endDTS = audio.endDTS;\n        if (part) {\n          part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n            startPTS: _startPTS,\n            endPTS: _endPTS,\n            startDTS: _startDTS,\n            endDTS: _endDTS\n          };\n        }\n        frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, _startPTS, _endPTS, _startDTS, _endDTS);\n        this.bufferFragmentData(audio, frag, part, chunkMeta);\n      }\n      if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n        var emittedID3 = {\n          id: id,\n          frag: frag,\n          details: details,\n          samples: id3.samples\n        };\n        hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n      }\n      if (details && text) {\n        var emittedText = {\n          id: id,\n          frag: frag,\n          details: details,\n          samples: text.samples\n        };\n        hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n      }\n    };\n    _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n      var _this3 = this;\n      if (this.state !== State.PARSING) {\n        return;\n      }\n      this.audioOnly = !!tracks.audio && !tracks.video;\n\n      // if audio track is expected to come from audio stream controller, discard any coming from main\n      if (this.altAudio && !this.audioOnly) {\n        delete tracks.audio;\n      }\n      // include levelCodec in audio and video tracks\n      var audio = tracks.audio,\n        video = tracks.video,\n        audiovideo = tracks.audiovideo;\n      if (audio) {\n        var audioCodec = currentLevel.audioCodec;\n        var ua = navigator.userAgent.toLowerCase();\n        if (this.audioCodecSwitch) {\n          if (audioCodec) {\n            if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n              audioCodec = 'mp4a.40.2';\n            } else {\n              audioCodec = 'mp4a.40.5';\n            }\n          }\n          // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n          // force HE-AAC, as it seems that most browsers prefers it.\n          // don't force HE-AAC if mono stream, or in Firefox\n          var audioMetadata = audio.metadata;\n          if (audioMetadata && 'channelCount' in audioMetadata && (audioMetadata.channelCount || 1) !== 1 && ua.indexOf('firefox') === -1) {\n            audioCodec = 'mp4a.40.5';\n          }\n        }\n        // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n        if (audioCodec && audioCodec.indexOf('mp4a.40.5') !== -1 && ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {\n          // Exclude mpeg audio\n          audioCodec = 'mp4a.40.2';\n          this.log(\"Android: force audio codec to \" + audioCodec);\n        }\n        if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {\n          this.log(\"Swapping manifest audio codec \\\"\" + currentLevel.audioCodec + \"\\\" for \\\"\" + audioCodec + \"\\\"\");\n        }\n        audio.levelCodec = audioCodec;\n        audio.id = 'main';\n        this.log(\"Init audio buffer, container:\" + audio.container + \", codecs[selected/level/parsed]=[\" + (audioCodec || '') + \"/\" + (currentLevel.audioCodec || '') + \"/\" + audio.codec + \"]\");\n      }\n      if (video) {\n        video.levelCodec = currentLevel.videoCodec;\n        video.id = 'main';\n        this.log(\"Init video buffer, container:\" + video.container + \", codecs[level/parsed]=[\" + (currentLevel.videoCodec || '') + \"/\" + video.codec + \"]\");\n      }\n      if (audiovideo) {\n        this.log(\"Init audiovideo buffer, container:\" + audiovideo.container + \", codecs[level/parsed]=[\" + currentLevel.codecs + \"/\" + audiovideo.codec + \"]\");\n      }\n      this.hls.trigger(Events.BUFFER_CODECS, tracks);\n      // loop through tracks that are going to be provided to bufferController\n      Object.keys(tracks).forEach(function (trackName) {\n        var track = tracks[trackName];\n        var initSegment = track.initSegment;\n        if (initSegment != null && initSegment.byteLength) {\n          _this3.hls.trigger(Events.BUFFER_APPENDING, {\n            type: trackName,\n            data: initSegment,\n            frag: frag,\n            part: null,\n            chunkMeta: chunkMeta,\n            parent: frag.type\n          });\n        }\n      });\n      // trigger handler right now\n      this.tickImmediate();\n    };\n    _proto.getMainFwdBufferInfo = function getMainFwdBufferInfo() {\n      return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);\n    };\n    _proto.backtrack = function backtrack(frag) {\n      this.couldBacktrack = true;\n      // Causes findFragments to backtrack through fragments to find the keyframe\n      this.backtrackFragment = frag;\n      this.resetTransmuxer();\n      this.flushBufferGap(frag);\n      this.fragmentTracker.removeFragment(frag);\n      this.fragPrevious = null;\n      this.nextLoadPosition = frag.start;\n      this.state = State.IDLE;\n    };\n    _proto.checkFragmentChanged = function checkFragmentChanged() {\n      var video = this.media;\n      var fragPlayingCurrent = null;\n      if (video && video.readyState > 1 && video.seeking === false) {\n        var currentTime = video.currentTime;\n        /* if video element is in seeked state, currentTime can only increase.\n          (assuming that playback rate is positive ...)\n          As sometimes currentTime jumps back to zero after a\n          media decode error, check this, to avoid seeking back to\n          wrong position after a media decode error\n        */\n\n        if (BufferHelper.isBuffered(video, currentTime)) {\n          fragPlayingCurrent = this.getAppendedFrag(currentTime);\n        } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {\n          /* ensure that FRAG_CHANGED event is triggered at startup,\n            when first video frame is displayed and playback is paused.\n            add a tolerance of 100ms, in case current position is not buffered,\n            check if current pos+100ms is buffered and use that buffer range\n            for FRAG_CHANGED event reporting */\n          fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n        }\n        if (fragPlayingCurrent) {\n          this.backtrackFragment = null;\n          var fragPlaying = this.fragPlaying;\n          var fragCurrentLevel = fragPlayingCurrent.level;\n          if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {\n            this.fragPlaying = fragPlayingCurrent;\n            this.hls.trigger(Events.FRAG_CHANGED, {\n              frag: fragPlayingCurrent\n            });\n            if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n              this.hls.trigger(Events.LEVEL_SWITCHED, {\n                level: fragCurrentLevel\n              });\n            }\n          }\n        }\n      }\n    };\n    _createClass(StreamController, [{\n      key: \"nextLevel\",\n      get: function get() {\n        var frag = this.nextBufferedFrag;\n        if (frag) {\n          return frag.level;\n        }\n        return -1;\n      }\n    }, {\n      key: \"currentFrag\",\n      get: function get() {\n        var media = this.media;\n        if (media) {\n          return this.fragPlaying || this.getAppendedFrag(media.currentTime);\n        }\n        return null;\n      }\n    }, {\n      key: \"currentProgramDateTime\",\n      get: function get() {\n        var media = this.media;\n        if (media) {\n          var currentTime = media.currentTime;\n          var frag = this.currentFrag;\n          if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {\n            var epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;\n            return new Date(epocMs);\n          }\n        }\n        return null;\n      }\n    }, {\n      key: \"currentLevel\",\n      get: function get() {\n        var frag = this.currentFrag;\n        if (frag) {\n          return frag.level;\n        }\n        return -1;\n      }\n    }, {\n      key: \"nextBufferedFrag\",\n      get: function get() {\n        var frag = this.currentFrag;\n        if (frag) {\n          return this.followingBufferedFrag(frag);\n        }\n        return null;\n      }\n    }, {\n      key: \"forceStartLoad\",\n      get: function get() {\n        return this._forceStartLoad;\n      }\n    }]);\n    return StreamController;\n  }(BaseStreamController);\n\n  /**\n   * The `Hls` class is the core of the HLS.js library used to instantiate player instances.\n   * @public\n   */\n  var Hls = /*#__PURE__*/function () {\n    /**\n     * Check if the required MediaSource Extensions are available.\n     */\n    Hls.isMSESupported = function isMSESupported$1() {\n      return isMSESupported();\n    }\n\n    /**\n     * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.\n     */;\n    Hls.isSupported = function isSupported$1() {\n      return isSupported();\n    }\n\n    /**\n     * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).\n     */;\n    Hls.getMediaSource = function getMediaSource$1() {\n      return getMediaSource();\n    };\n    /**\n     * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n     * @param userConfig - Configuration options applied over `Hls.DefaultConfig`\n     */\n    function Hls(userConfig) {\n      if (userConfig === void 0) {\n        userConfig = {};\n      }\n      /**\n       * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.\n       */\n      this.config = void 0;\n      /**\n       * The configuration object provided on player instantiation.\n       */\n      this.userConfig = void 0;\n      this.coreComponents = void 0;\n      this.networkControllers = void 0;\n      this.started = false;\n      this._emitter = new EventEmitter();\n      this._autoLevelCapping = -1;\n      this._maxHdcpLevel = null;\n      this.abrController = void 0;\n      this.bufferController = void 0;\n      this.capLevelController = void 0;\n      this.latencyController = void 0;\n      this.levelController = void 0;\n      this.streamController = void 0;\n      this.audioTrackController = void 0;\n      this.subtitleTrackController = void 0;\n      this.emeController = void 0;\n      this.cmcdController = void 0;\n      this._media = null;\n      this.url = null;\n      this.triggeringException = void 0;\n      enableLogs(userConfig.debug || false, 'Hls instance');\n      var config = this.config = mergeConfig(Hls.DefaultConfig, userConfig);\n      this.userConfig = userConfig;\n      if (config.progressive) {\n        enableStreamingMode(config);\n      }\n\n      // core controllers and network loaders\n      var ConfigAbrController = config.abrController,\n        ConfigBufferController = config.bufferController,\n        ConfigCapLevelController = config.capLevelController,\n        ConfigErrorController = config.errorController,\n        ConfigFpsController = config.fpsController;\n      var errorController = new ConfigErrorController(this);\n      var abrController = this.abrController = new ConfigAbrController(this);\n      var bufferController = this.bufferController = new ConfigBufferController(this);\n      var capLevelController = this.capLevelController = new ConfigCapLevelController(this);\n      var fpsController = new ConfigFpsController(this);\n      var playListLoader = new PlaylistLoader(this);\n      var id3TrackController = new ID3TrackController(this);\n      var ConfigContentSteeringController = config.contentSteeringController;\n      // ConentSteeringController is defined before LevelController to receive Multivariant Playlist events first\n      var contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;\n      var levelController = this.levelController = new LevelController(this, contentSteering);\n      // FragmentTracker must be defined before StreamController because the order of event handling is important\n      var fragmentTracker = new FragmentTracker(this);\n      var keyLoader = new KeyLoader(this.config);\n      var streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);\n\n      // Cap level controller uses streamController to flush the buffer\n      capLevelController.setStreamController(streamController);\n      // fpsController uses streamController to switch when frames are being dropped\n      fpsController.setStreamController(streamController);\n      var networkControllers = [playListLoader, levelController, streamController];\n      if (contentSteering) {\n        networkControllers.splice(1, 0, contentSteering);\n      }\n      this.networkControllers = networkControllers;\n      var coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];\n      this.audioTrackController = this.createController(config.audioTrackController, networkControllers);\n      var AudioStreamControllerClass = config.audioStreamController;\n      if (AudioStreamControllerClass) {\n        networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));\n      }\n      // subtitleTrackController must be defined before subtitleStreamController because the order of event handling is important\n      this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);\n      var SubtitleStreamControllerClass = config.subtitleStreamController;\n      if (SubtitleStreamControllerClass) {\n        networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));\n      }\n      this.createController(config.timelineController, coreComponents);\n      keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);\n      this.cmcdController = this.createController(config.cmcdController, coreComponents);\n      this.latencyController = this.createController(LatencyController, coreComponents);\n      this.coreComponents = coreComponents;\n\n      // Error controller handles errors before and after all other controllers\n      // This listener will be invoked after all other controllers error listeners\n      networkControllers.push(errorController);\n      var onErrorOut = errorController.onErrorOut;\n      if (typeof onErrorOut === 'function') {\n        this.on(Events.ERROR, onErrorOut, errorController);\n      }\n    }\n    var _proto = Hls.prototype;\n    _proto.createController = function createController(ControllerClass, components) {\n      if (ControllerClass) {\n        var controllerInstance = new ControllerClass(this);\n        if (components) {\n          components.push(controllerInstance);\n        }\n        return controllerInstance;\n      }\n      return null;\n    }\n\n    // Delegate the EventEmitter through the public API of Hls.js\n    ;\n    _proto.on = function on(event, listener, context) {\n      if (context === void 0) {\n        context = this;\n      }\n      this._emitter.on(event, listener, context);\n    };\n    _proto.once = function once(event, listener, context) {\n      if (context === void 0) {\n        context = this;\n      }\n      this._emitter.once(event, listener, context);\n    };\n    _proto.removeAllListeners = function removeAllListeners(event) {\n      this._emitter.removeAllListeners(event);\n    };\n    _proto.off = function off(event, listener, context, once) {\n      if (context === void 0) {\n        context = this;\n      }\n      this._emitter.off(event, listener, context, once);\n    };\n    _proto.listeners = function listeners(event) {\n      return this._emitter.listeners(event);\n    };\n    _proto.emit = function emit(event, name, eventObject) {\n      return this._emitter.emit(event, name, eventObject);\n    };\n    _proto.trigger = function trigger(event, eventObject) {\n      if (this.config.debug) {\n        return this.emit(event, event, eventObject);\n      } else {\n        try {\n          return this.emit(event, event, eventObject);\n        } catch (error) {\n          logger.error('An internal error happened while handling event ' + event + '. Error message: \"' + error.message + '\". Here is a stacktrace:', error);\n          // Prevent recursion in error event handlers that throw #5497\n          if (!this.triggeringException) {\n            this.triggeringException = true;\n            var fatal = event === Events.ERROR;\n            this.trigger(Events.ERROR, {\n              type: ErrorTypes.OTHER_ERROR,\n              details: ErrorDetails.INTERNAL_EXCEPTION,\n              fatal: fatal,\n              event: event,\n              error: error\n            });\n            this.triggeringException = false;\n          }\n        }\n      }\n      return false;\n    };\n    _proto.listenerCount = function listenerCount(event) {\n      return this._emitter.listenerCount(event);\n    }\n\n    /**\n     * Dispose of the instance\n     */;\n    _proto.destroy = function destroy() {\n      logger.log('destroy');\n      this.trigger(Events.DESTROYING, undefined);\n      this.detachMedia();\n      this.removeAllListeners();\n      this._autoLevelCapping = -1;\n      this.url = null;\n      this.networkControllers.forEach(function (component) {\n        return component.destroy();\n      });\n      this.networkControllers.length = 0;\n      this.coreComponents.forEach(function (component) {\n        return component.destroy();\n      });\n      this.coreComponents.length = 0;\n      // Remove any references that could be held in config options or callbacks\n      var config = this.config;\n      config.xhrSetup = config.fetchSetup = undefined;\n      // @ts-ignore\n      this.userConfig = null;\n    }\n\n    /**\n     * Attaches Hls.js to a media element\n     */;\n    _proto.attachMedia = function attachMedia(media) {\n      logger.log('attachMedia');\n      this._media = media;\n      this.trigger(Events.MEDIA_ATTACHING, {\n        media: media\n      });\n    }\n\n    /**\n     * Detach Hls.js from the media\n     */;\n    _proto.detachMedia = function detachMedia() {\n      logger.log('detachMedia');\n      this.trigger(Events.MEDIA_DETACHING, undefined);\n      this._media = null;\n    }\n\n    /**\n     * Set the source URL. Can be relative or absolute.\n     */;\n    _proto.loadSource = function loadSource(url) {\n      this.stopLoad();\n      var media = this.media;\n      var loadedSource = this.url;\n      var loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {\n        alwaysNormalize: true\n      });\n      this._autoLevelCapping = -1;\n      this._maxHdcpLevel = null;\n      logger.log(\"loadSource:\" + loadingSource);\n      if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {\n        this.detachMedia();\n        this.attachMedia(media);\n      }\n      // when attaching to a source URL, trigger a playlist load\n      this.trigger(Events.MANIFEST_LOADING, {\n        url: url\n      });\n    }\n\n    /**\n     * Start loading data from the stream source.\n     * Depending on default config, client starts loading automatically when a source is set.\n     *\n     * @param startPosition - Set the start position to stream from.\n     * Defaults to -1 (None: starts from earliest point)\n     */;\n    _proto.startLoad = function startLoad(startPosition) {\n      if (startPosition === void 0) {\n        startPosition = -1;\n      }\n      logger.log(\"startLoad(\" + startPosition + \")\");\n      this.started = true;\n      this.networkControllers.forEach(function (controller) {\n        controller.startLoad(startPosition);\n      });\n    }\n\n    /**\n     * Stop loading of any stream data.\n     */;\n    _proto.stopLoad = function stopLoad() {\n      logger.log('stopLoad');\n      this.started = false;\n      this.networkControllers.forEach(function (controller) {\n        controller.stopLoad();\n      });\n    }\n\n    /**\n     * Resumes stream controller segment loading if previously started.\n     */;\n    _proto.resumeBuffering = function resumeBuffering() {\n      if (this.started) {\n        this.networkControllers.forEach(function (controller) {\n          if ('fragmentLoader' in controller) {\n            controller.startLoad(-1);\n          }\n        });\n      }\n    }\n\n    /**\n     * Stops stream controller segment loading without changing 'started' state like stopLoad().\n     * This allows for media buffering to be paused without interupting playlist loading.\n     */;\n    _proto.pauseBuffering = function pauseBuffering() {\n      this.networkControllers.forEach(function (controller) {\n        if ('fragmentLoader' in controller) {\n          controller.stopLoad();\n        }\n      });\n    }\n\n    /**\n     * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n     */;\n    _proto.swapAudioCodec = function swapAudioCodec() {\n      logger.log('swapAudioCodec');\n      this.streamController.swapAudioCodec();\n    }\n\n    /**\n     * When the media-element fails, this allows to detach and then re-attach it\n     * as one call (convenience method).\n     *\n     * Automatic recovery of media-errors by this process is configurable.\n     */;\n    _proto.recoverMediaError = function recoverMediaError() {\n      logger.log('recoverMediaError');\n      var media = this._media;\n      this.detachMedia();\n      if (media) {\n        this.attachMedia(media);\n      }\n    };\n    _proto.removeLevel = function removeLevel(levelIndex) {\n      this.levelController.removeLevel(levelIndex);\n    }\n\n    /**\n     * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH\n     */;\n    /**\n     * Find and select the best matching audio track, making a level switch when a Group change is necessary.\n     * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.\n     */\n    _proto.setAudioOption = function setAudioOption(audioOption) {\n      var _this$audioTrackContr;\n      return (_this$audioTrackContr = this.audioTrackController) == null ? void 0 : _this$audioTrackContr.setAudioOption(audioOption);\n    }\n    /**\n     * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.\n     * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.\n     */;\n    _proto.setSubtitleOption = function setSubtitleOption(subtitleOption) {\n      var _this$subtitleTrackCo;\n      (_this$subtitleTrackCo = this.subtitleTrackController) == null ? void 0 : _this$subtitleTrackCo.setSubtitleOption(subtitleOption);\n      return null;\n    }\n\n    /**\n     * Get the complete list of audio tracks across all media groups\n     */;\n    _createClass(Hls, [{\n      key: \"levels\",\n      get: function get() {\n        var levels = this.levelController.levels;\n        return levels ? levels : [];\n      }\n\n      /**\n       * Index of quality level (variant) currently played\n       */\n    }, {\n      key: \"currentLevel\",\n      get: function get() {\n        return this.streamController.currentLevel;\n      }\n\n      /**\n       * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.\n       */,\n      set: function set(newLevel) {\n        logger.log(\"set currentLevel:\" + newLevel);\n        this.levelController.manualLevel = newLevel;\n        this.streamController.immediateLevelSwitch();\n      }\n\n      /**\n       * Index of next quality level loaded as scheduled by stream controller.\n       */\n    }, {\n      key: \"nextLevel\",\n      get: function get() {\n        return this.streamController.nextLevel;\n      }\n\n      /**\n       * Set quality level index for next loaded data.\n       * This will switch the video quality asap, without interrupting playback.\n       * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n       * @param newLevel - Pass -1 for automatic level selection\n       */,\n      set: function set(newLevel) {\n        logger.log(\"set nextLevel:\" + newLevel);\n        this.levelController.manualLevel = newLevel;\n        this.streamController.nextLevelSwitch();\n      }\n\n      /**\n       * Return the quality level of the currently or last (of none is loaded currently) segment\n       */\n    }, {\n      key: \"loadLevel\",\n      get: function get() {\n        return this.levelController.level;\n      }\n\n      /**\n       * Set quality level index for next loaded data in a conservative way.\n       * This will switch the quality without flushing, but interrupt current loading.\n       * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n       * @param newLevel - Pass -1 for automatic level selection\n       */,\n      set: function set(newLevel) {\n        logger.log(\"set loadLevel:\" + newLevel);\n        this.levelController.manualLevel = newLevel;\n      }\n\n      /**\n       * get next quality level loaded\n       */\n    }, {\n      key: \"nextLoadLevel\",\n      get: function get() {\n        return this.levelController.nextLoadLevel;\n      }\n\n      /**\n       * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n       * Same as `loadLevel` but will wait for next switch (until current loading is done).\n       */,\n      set: function set(level) {\n        this.levelController.nextLoadLevel = level;\n      }\n\n      /**\n       * Return \"first level\": like a default level, if not set,\n       * falls back to index of first level referenced in manifest\n       */\n    }, {\n      key: \"firstLevel\",\n      get: function get() {\n        return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n      }\n\n      /**\n       * Sets \"first-level\", see getter.\n       */,\n      set: function set(newLevel) {\n        logger.log(\"set firstLevel:\" + newLevel);\n        this.levelController.firstLevel = newLevel;\n      }\n\n      /**\n       * Return the desired start level for the first fragment that will be loaded.\n       * The default value of -1 indicates automatic start level selection.\n       * Setting hls.nextAutoLevel without setting a startLevel will result in\n       * the nextAutoLevel value being used for one fragment load.\n       */\n    }, {\n      key: \"startLevel\",\n      get: function get() {\n        var startLevel = this.levelController.startLevel;\n        if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {\n          return this.abrController.forcedAutoLevel;\n        }\n        return startLevel;\n      }\n\n      /**\n       * set  start level (level of first fragment that will be played back)\n       * if not overrided by user, first level appearing in manifest will be used as start level\n       * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n       * (determined from download of first segment)\n       */,\n      set: function set(newLevel) {\n        logger.log(\"set startLevel:\" + newLevel);\n        // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n        if (newLevel !== -1) {\n          newLevel = Math.max(newLevel, this.minAutoLevel);\n        }\n        this.levelController.startLevel = newLevel;\n      }\n\n      /**\n       * Whether level capping is enabled.\n       * Default value is set via `config.capLevelToPlayerSize`.\n       */\n    }, {\n      key: \"capLevelToPlayerSize\",\n      get: function get() {\n        return this.config.capLevelToPlayerSize;\n      }\n\n      /**\n       * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.\n       */,\n      set: function set(shouldStartCapping) {\n        var newCapLevelToPlayerSize = !!shouldStartCapping;\n        if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n          if (newCapLevelToPlayerSize) {\n            this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n          } else {\n            this.capLevelController.stopCapping();\n            this.autoLevelCapping = -1;\n            this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n          }\n          this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n        }\n      }\n\n      /**\n       * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n       */\n    }, {\n      key: \"autoLevelCapping\",\n      get: function get() {\n        return this._autoLevelCapping;\n      }\n\n      /**\n       * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.\n       */,\n      set:\n      /**\n       * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n       */\n      function set(newLevel) {\n        if (this._autoLevelCapping !== newLevel) {\n          logger.log(\"set autoLevelCapping:\" + newLevel);\n          this._autoLevelCapping = newLevel;\n          this.levelController.checkMaxAutoUpdated();\n        }\n      }\n    }, {\n      key: \"bandwidthEstimate\",\n      get: function get() {\n        var bwEstimator = this.abrController.bwEstimator;\n        if (!bwEstimator) {\n          return NaN;\n        }\n        return bwEstimator.getEstimate();\n      },\n      set: function set(abrEwmaDefaultEstimate) {\n        this.abrController.resetEstimator(abrEwmaDefaultEstimate);\n      }\n\n      /**\n       * get time to first byte estimate\n       * @type {number}\n       */\n    }, {\n      key: \"ttfbEstimate\",\n      get: function get() {\n        var bwEstimator = this.abrController.bwEstimator;\n        if (!bwEstimator) {\n          return NaN;\n        }\n        return bwEstimator.getEstimateTTFB();\n      }\n    }, {\n      key: \"maxHdcpLevel\",\n      get: function get() {\n        return this._maxHdcpLevel;\n      },\n      set: function set(value) {\n        if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {\n          this._maxHdcpLevel = value;\n          this.levelController.checkMaxAutoUpdated();\n        }\n      }\n\n      /**\n       * True when automatic level selection enabled\n       */\n    }, {\n      key: \"autoLevelEnabled\",\n      get: function get() {\n        return this.levelController.manualLevel === -1;\n      }\n\n      /**\n       * Level set manually (if any)\n       */\n    }, {\n      key: \"manualLevel\",\n      get: function get() {\n        return this.levelController.manualLevel;\n      }\n\n      /**\n       * min level selectable in auto mode according to config.minAutoBitrate\n       */\n    }, {\n      key: \"minAutoLevel\",\n      get: function get() {\n        var levels = this.levels,\n          minAutoBitrate = this.config.minAutoBitrate;\n        if (!levels) return 0;\n        var len = levels.length;\n        for (var i = 0; i < len; i++) {\n          if (levels[i].maxBitrate >= minAutoBitrate) {\n            return i;\n          }\n        }\n        return 0;\n      }\n\n      /**\n       * max level selectable in auto mode according to autoLevelCapping\n       */\n    }, {\n      key: \"maxAutoLevel\",\n      get: function get() {\n        var levels = this.levels,\n          autoLevelCapping = this.autoLevelCapping,\n          maxHdcpLevel = this.maxHdcpLevel;\n        var maxAutoLevel;\n        if (autoLevelCapping === -1 && levels != null && levels.length) {\n          maxAutoLevel = levels.length - 1;\n        } else {\n          maxAutoLevel = autoLevelCapping;\n        }\n        if (maxHdcpLevel) {\n          for (var i = maxAutoLevel; i--;) {\n            var hdcpLevel = levels[i].attrs['HDCP-LEVEL'];\n            if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {\n              return i;\n            }\n          }\n        }\n        return maxAutoLevel;\n      }\n    }, {\n      key: \"firstAutoLevel\",\n      get: function get() {\n        return this.abrController.firstAutoLevel;\n      }\n\n      /**\n       * next automatically selected quality level\n       */\n    }, {\n      key: \"nextAutoLevel\",\n      get: function get() {\n        return this.abrController.nextAutoLevel;\n      }\n\n      /**\n       * this setter is used to force next auto level.\n       * this is useful to force a switch down in auto mode:\n       * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n       * forced value is valid for one fragment. upon successful frag loading at forced level,\n       * this value will be resetted to -1 by ABR controller.\n       */,\n      set: function set(nextLevel) {\n        this.abrController.nextAutoLevel = nextLevel;\n      }\n\n      /**\n       * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n       */\n    }, {\n      key: \"playingDate\",\n      get: function get() {\n        return this.streamController.currentProgramDateTime;\n      }\n    }, {\n      key: \"mainForwardBufferInfo\",\n      get: function get() {\n        return this.streamController.getMainFwdBufferInfo();\n      }\n    }, {\n      key: \"allAudioTracks\",\n      get: function get() {\n        var audioTrackController = this.audioTrackController;\n        return audioTrackController ? audioTrackController.allAudioTracks : [];\n      }\n\n      /**\n       * Get the list of selectable audio tracks\n       */\n    }, {\n      key: \"audioTracks\",\n      get: function get() {\n        var audioTrackController = this.audioTrackController;\n        return audioTrackController ? audioTrackController.audioTracks : [];\n      }\n\n      /**\n       * index of the selected audio track (index in audio track lists)\n       */\n    }, {\n      key: \"audioTrack\",\n      get: function get() {\n        var audioTrackController = this.audioTrackController;\n        return audioTrackController ? audioTrackController.audioTrack : -1;\n      }\n\n      /**\n       * selects an audio track, based on its index in audio track lists\n       */,\n      set: function set(audioTrackId) {\n        var audioTrackController = this.audioTrackController;\n        if (audioTrackController) {\n          audioTrackController.audioTrack = audioTrackId;\n        }\n      }\n\n      /**\n       * get the complete list of subtitle tracks across all media groups\n       */\n    }, {\n      key: \"allSubtitleTracks\",\n      get: function get() {\n        var subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];\n      }\n\n      /**\n       * get alternate subtitle tracks list from playlist\n       */\n    }, {\n      key: \"subtitleTracks\",\n      get: function get() {\n        var subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n      }\n\n      /**\n       * index of the selected subtitle track (index in subtitle track lists)\n       */\n    }, {\n      key: \"subtitleTrack\",\n      get: function get() {\n        var subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n      },\n      set:\n      /**\n       * select an subtitle track, based on its index in subtitle track lists\n       */\n      function set(subtitleTrackId) {\n        var subtitleTrackController = this.subtitleTrackController;\n        if (subtitleTrackController) {\n          subtitleTrackController.subtitleTrack = subtitleTrackId;\n        }\n      }\n\n      /**\n       * Whether subtitle display is enabled or not\n       */\n    }, {\n      key: \"media\",\n      get: function get() {\n        return this._media;\n      }\n    }, {\n      key: \"subtitleDisplay\",\n      get: function get() {\n        var subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n      }\n\n      /**\n       * Enable/disable subtitle display rendering\n       */,\n      set: function set(value) {\n        var subtitleTrackController = this.subtitleTrackController;\n        if (subtitleTrackController) {\n          subtitleTrackController.subtitleDisplay = value;\n        }\n      }\n\n      /**\n       * get mode for Low-Latency HLS loading\n       */\n    }, {\n      key: \"lowLatencyMode\",\n      get: function get() {\n        return this.config.lowLatencyMode;\n      }\n\n      /**\n       * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n       */,\n      set: function set(mode) {\n        this.config.lowLatencyMode = mode;\n      }\n\n      /**\n       * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n       * @returns null prior to loading live Playlist\n       */\n    }, {\n      key: \"liveSyncPosition\",\n      get: function get() {\n        return this.latencyController.liveSyncPosition;\n      }\n\n      /**\n       * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n       * @returns 0 before first playlist is loaded\n       */\n    }, {\n      key: \"latency\",\n      get: function get() {\n        return this.latencyController.latency;\n      }\n\n      /**\n       * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n       * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n       * @returns 0 before first playlist is loaded\n       */\n    }, {\n      key: \"maxLatency\",\n      get: function get() {\n        return this.latencyController.maxLatency;\n      }\n\n      /**\n       * target distance from the edge as calculated by the latency controller\n       */\n    }, {\n      key: \"targetLatency\",\n      get: function get() {\n        return this.latencyController.targetLatency;\n      }\n\n      /**\n       * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n       */\n    }, {\n      key: \"drift\",\n      get: function get() {\n        return this.latencyController.drift;\n      }\n\n      /**\n       * set to true when startLoad is called before MANIFEST_PARSED event\n       */\n    }, {\n      key: \"forceStartLoad\",\n      get: function get() {\n        return this.streamController.forceStartLoad;\n      }\n    }], [{\n      key: \"version\",\n      get:\n      /**\n       * Get the video-dev/hls.js package version.\n       */\n      function get() {\n        return \"1.5.17\";\n      }\n    }, {\n      key: \"Events\",\n      get: function get() {\n        return Events;\n      }\n    }, {\n      key: \"ErrorTypes\",\n      get: function get() {\n        return ErrorTypes;\n      }\n    }, {\n      key: \"ErrorDetails\",\n      get: function get() {\n        return ErrorDetails;\n      }\n\n      /**\n       * Get the default configuration applied to new instances.\n       */\n    }, {\n      key: \"DefaultConfig\",\n      get: function get() {\n        if (!Hls.defaultConfig) {\n          return hlsDefaultConfig;\n        }\n        return Hls.defaultConfig;\n      }\n\n      /**\n       * Replace the default configuration applied to new instances.\n       */,\n      set: function set(defaultConfig) {\n        Hls.defaultConfig = defaultConfig;\n      }\n    }]);\n    return Hls;\n  }();\n  Hls.defaultConfig = void 0;\n\n  return Hls;\n\n}));\n})(false);\n//# sourceMappingURL=hls.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDczLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDa0c7QUFDcEcsQ0FBQyx1QkFBdUI7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RkFBeUYsaUJBQWlCO0FBQzFHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQSxJQUFJO0FBQ0osSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0EsaUVBQWlFLDhCQUE4QjtBQUMvRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsR0FBRztBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLGFBQWE7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0VBQW9FLG9DQUFvQztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDRFQUE0RSxtQ0FBbUM7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQSwyRUFBMkUsMkJBQTJCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWUsWUFBWSxHQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWUsWUFBWSxHQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixhQUFhO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLG9CQUFvQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUVBQXFFLGFBQWEsV0FBVyxjQUFjLFFBQVEsV0FBVzs7QUFFOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzRkFBc0YsWUFBWTs7QUFFbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE1BQU0sR0FBRyxhQUFhLEdBQUcsZ0JBQWdCLEdBQUcscUNBQXFDLEdBQUcsVUFBVTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsV0FBVztBQUNYO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw4QkFBOEIsNEJBQTRCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQTBDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUZBQWlGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsOEJBQThCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRJQUE0STtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNPQUFzTztBQUN0TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxvQkFBb0IsR0FBRyxZQUFZLEdBQUcsZ0JBQWdCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVyxRQUFRLE9BQU8sdUJBQXVCLFlBQVksR0FBRyxvQkFBb0IsR0FBRyxpQkFBaUIsV0FBVyxRQUFRO0FBQzVKO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLGlDQUFpQyx1Q0FBdUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsUUFBUTtBQUNSLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUTtBQUNSLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBLFVBQVU7QUFDVjtBQUNBLGlCQUFpQjtBQUNqQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQ0FBcUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGNBQWM7QUFDL0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEMsNkRBQTZEO0FBQzdELHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csYUFBYTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEUsdUJBQXVCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLCtCQUErQiwwQkFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxlQUFlO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGtIQUFrSDtBQUNsSCxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVc7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGtCQUFrQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QixjQUFjLEdBQUc7QUFDakIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsVUFBVTtBQUN4QixjQUFjLEdBQUc7QUFDakIsY0FBYyxTQUFTO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUIsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkRBQTZELE9BQU87QUFDcEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0IsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxtQkFBbUIsWUFBWTtBQUMvQjs7QUFFQTtBQUNBLCtEQUErRDtBQUMvRCxtRUFBbUU7QUFDbkUsdUVBQXVFO0FBQ3ZFLDJFQUEyRTtBQUMzRTtBQUNBLDhEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixjQUFjLFVBQVU7QUFDeEIsY0FBYyxHQUFHO0FBQ2pCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsR0FBRztBQUNqQixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsVUFBVTtBQUN4QixjQUFjLEdBQUc7QUFDakIsY0FBYyxTQUFTO0FBQ3ZCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwrREFBK0QsWUFBWTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZLGlCQUFpQixtQkFBbUIsS0FBSyxnQkFBZ0IsaURBQWlEO0FBQ3BLO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUksTUFBTSxpQkFBaUIsR0FBRyxjQUFjLFVBQVUsUUFBUTtBQUNqRztBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSCw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQ0FBc0M7QUFDdEMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQsU0FBUztBQUNUO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxrQkFBa0IsS0FBSyxnQkFBZ0IsTUFBTSxNQUFNO0FBQ3hILFdBQVc7QUFDWDtBQUNBLHNFQUFzRSxrQkFBa0IsS0FBSyxnQkFBZ0IsTUFBTSxNQUFNO0FBQ3pIO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJFQUEyRSxhQUFhLFNBQVM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3QkFBd0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1Q0FBdUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGFBQWE7QUFDMUc7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFLE1BQU0sRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5QixHQUFHLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLGdGQUFnRjtBQUNoRixXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtPQUFrTztBQUNsTztBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBLFNBQVM7QUFDVDtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQ0FBb0M7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDhDQUE4Qzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDBDQUEwQzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7O0FBRXpDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdKQUFnSjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsNEJBQTRCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNDQUFzQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRztBQUNyQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx1QkFBdUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsU0FBUyxNQUFNLGlCQUFpQixHQUFHLGNBQWMsVUFBVSxXQUFXLE9BQU8sUUFBUTtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsWUFBWTtBQUNaO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLENBQUM7QUFDRCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ydHNwLXN0cmVhbS12aWV3ZXIvLi9ub2RlX21vZHVsZXMvaGxzLmpzL2Rpc3QvaGxzLmpzP2JhNTYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIF9fSExTX1dPUktFUl9CVU5ETEVfXyhfX0lOX1dPUktFUl9fKXtcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkhscyA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG4gICAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgICB9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICAgIGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG4gICAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7XG4gICAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIGZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICAgIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xuICB9XG4gIGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBTdHJpbmcoaSk7XG4gIH1cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgICBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICB9XG4gIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbiAgfVxuICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xuICB9XG4gIGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QuYmluZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcbiAgICBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcbiAgICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcbiAgICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICAgIH07XG4gICAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xuICB9XG4gIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB9XG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xuICB9XG4gIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgICBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG4gIFx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbiAgfVxuXG4gIHZhciB1cmxUb29sa2l0ID0ge2V4cG9ydHM6IHt9fTtcblxuICAoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICBcdC8vIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTgwOFxuXG4gIFx0KGZ1bmN0aW9uIChyb290KSB7XG4gIFx0ICB2YXIgVVJMX1JFR0VYID1cbiAgXHQgICAgL14oPz0oKD86W2EtekEtWjAtOStcXC0uXSs6KT8pKVxcMSg/PSgoPzpcXC9cXC9bXlxcLz8jXSopPykpXFwyKD89KCg/Oig/OltePyNcXC9dKlxcLykqW147PyNcXC9dKik/KSlcXDMoKD86O1tePyNdKik/KShcXD9bXiNdKik/KCNbXl0qKT8kLztcbiAgXHQgIHZhciBGSVJTVF9TRUdNRU5UX1JFR0VYID0gL14oPz0oW15cXC8/I10qKSlcXDEoW15dKikkLztcbiAgXHQgIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xuICBcdCAgdmFyIFNMQVNIX0RPVF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuXFwuXFwvKD8hXFwuXFwuXFwvKVteXFwvXSooPz1cXC8pL2c7XG5cbiAgXHQgIHZhciBVUkxUb29sa2l0ID0ge1xuICBcdCAgICAvLyBJZiBvcHRzLmFsd2F5c05vcm1hbGl6ZSBpcyB0cnVlIHRoZW4gdGhlIHBhdGggd2lsbCBhbHdheXMgYmUgbm9ybWFsaXplZCBldmVuIHdoZW4gaXQgc3RhcnRzIHdpdGggLyBvciAvL1xuICBcdCAgICAvLyBFLmdcbiAgXHQgICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IGZhbHNlIChkZWZhdWx0LCBzcGVjIGNvbXBsaWFudClcbiAgXHQgICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZi8uLi9nXG4gIFx0ICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSB0cnVlIChub3Qgc3BlYyBjb21wbGlhbnQpXG4gIFx0ICAgIC8vIGh0dHA6Ly9hLmNvbS9iL2NkICsgL2UvZi8uLi9nID0+IGh0dHA6Ly9hLmNvbS9lL2dcbiAgXHQgICAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24gKGJhc2VVUkwsIHJlbGF0aXZlVVJMLCBvcHRzKSB7XG4gIFx0ICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gIFx0ICAgICAgLy8gcmVtb3ZlIGFueSByZW1haW5pbmcgc3BhY2UgYW5kIENSTEZcbiAgXHQgICAgICBiYXNlVVJMID0gYmFzZVVSTC50cmltKCk7XG4gIFx0ICAgICAgcmVsYXRpdmVVUkwgPSByZWxhdGl2ZVVSTC50cmltKCk7XG4gIFx0ICAgICAgaWYgKCFyZWxhdGl2ZVVSTCkge1xuICBcdCAgICAgICAgLy8gMmEpIElmIHRoZSBlbWJlZGRlZCBVUkwgaXMgZW50aXJlbHkgZW1wdHksIGl0IGluaGVyaXRzIHRoZVxuICBcdCAgICAgICAgLy8gZW50aXJlIGJhc2UgVVJMIChpLmUuLCBpcyBzZXQgZXF1YWwgdG8gdGhlIGJhc2UgVVJMKVxuICBcdCAgICAgICAgLy8gYW5kIHdlIGFyZSBkb25lLlxuICBcdCAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICBcdCAgICAgICAgICByZXR1cm4gYmFzZVVSTDtcbiAgXHQgICAgICAgIH1cbiAgXHQgICAgICAgIHZhciBiYXNlUGFydHNGb3JOb3JtYWxpc2UgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuICBcdCAgICAgICAgaWYgKCFiYXNlUGFydHNGb3JOb3JtYWxpc2UpIHtcbiAgXHQgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gIFx0ICAgICAgICB9XG4gIFx0ICAgICAgICBiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChcbiAgXHQgICAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGhcbiAgXHQgICAgICAgICk7XG4gIFx0ICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhiYXNlUGFydHNGb3JOb3JtYWxpc2UpO1xuICBcdCAgICAgIH1cbiAgXHQgICAgICB2YXIgcmVsYXRpdmVQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwocmVsYXRpdmVVUkwpO1xuICBcdCAgICAgIGlmICghcmVsYXRpdmVQYXJ0cykge1xuICBcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgcmVsYXRpdmUgVVJMLicpO1xuICBcdCAgICAgIH1cbiAgXHQgICAgICBpZiAocmVsYXRpdmVQYXJ0cy5zY2hlbWUpIHtcbiAgXHQgICAgICAgIC8vIDJiKSBJZiB0aGUgZW1iZWRkZWQgVVJMIHN0YXJ0cyB3aXRoIGEgc2NoZW1lIG5hbWUsIGl0IGlzXG4gIFx0ICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyBhbiBhYnNvbHV0ZSBVUkwgYW5kIHdlIGFyZSBkb25lLlxuICBcdCAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICBcdCAgICAgICAgICByZXR1cm4gcmVsYXRpdmVVUkw7XG4gIFx0ICAgICAgICB9XG4gIFx0ICAgICAgICByZWxhdGl2ZVBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKTtcbiAgXHQgICAgICAgIHJldHVybiBVUkxUb29sa2l0LmJ1aWxkVVJMRnJvbVBhcnRzKHJlbGF0aXZlUGFydHMpO1xuICBcdCAgICAgIH1cbiAgXHQgICAgICB2YXIgYmFzZVBhcnRzID0gVVJMVG9vbGtpdC5wYXJzZVVSTChiYXNlVVJMKTtcbiAgXHQgICAgICBpZiAoIWJhc2VQYXJ0cykge1xuICBcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG4gIFx0ICAgICAgfVxuICBcdCAgICAgIGlmICghYmFzZVBhcnRzLm5ldExvYyAmJiBiYXNlUGFydHMucGF0aCAmJiBiYXNlUGFydHMucGF0aFswXSAhPT0gJy8nKSB7XG4gIFx0ICAgICAgICAvLyBJZiBuZXRMb2MgbWlzc2luZyBhbmQgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggJy8nLCBhc3N1bWUgZXZlcnRoaW5nIGJlZm9yZSB0aGUgZmlyc3QgJy8nIGlzIHRoZSBuZXRMb2NcbiAgXHQgICAgICAgIC8vIFRoaXMgY2F1c2VzICdleGFtcGxlLmNvbS9hJyB0byBiZSBoYW5kbGVkIGFzICcvL2V4YW1wbGUuY29tL2EnIGluc3RlYWQgb2YgJy9leGFtcGxlLmNvbS9hJ1xuICBcdCAgICAgICAgdmFyIHBhdGhQYXJ0cyA9IEZJUlNUX1NFR01FTlRfUkVHRVguZXhlYyhiYXNlUGFydHMucGF0aCk7XG4gIFx0ICAgICAgICBiYXNlUGFydHMubmV0TG9jID0gcGF0aFBhcnRzWzFdO1xuICBcdCAgICAgICAgYmFzZVBhcnRzLnBhdGggPSBwYXRoUGFydHNbMl07XG4gIFx0ICAgICAgfVxuICBcdCAgICAgIGlmIChiYXNlUGFydHMubmV0TG9jICYmICFiYXNlUGFydHMucGF0aCkge1xuICBcdCAgICAgICAgYmFzZVBhcnRzLnBhdGggPSAnLyc7XG4gIFx0ICAgICAgfVxuICBcdCAgICAgIHZhciBidWlsdFBhcnRzID0ge1xuICBcdCAgICAgICAgLy8gMmMpIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgc2NoZW1lIG9mXG4gIFx0ICAgICAgICAvLyB0aGUgYmFzZSBVUkwuXG4gIFx0ICAgICAgICBzY2hlbWU6IGJhc2VQYXJ0cy5zY2hlbWUsXG4gIFx0ICAgICAgICBuZXRMb2M6IHJlbGF0aXZlUGFydHMubmV0TG9jLFxuICBcdCAgICAgICAgcGF0aDogbnVsbCxcbiAgXHQgICAgICAgIHBhcmFtczogcmVsYXRpdmVQYXJ0cy5wYXJhbXMsXG4gIFx0ICAgICAgICBxdWVyeTogcmVsYXRpdmVQYXJ0cy5xdWVyeSxcbiAgXHQgICAgICAgIGZyYWdtZW50OiByZWxhdGl2ZVBhcnRzLmZyYWdtZW50LFxuICBcdCAgICAgIH07XG4gIFx0ICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLm5ldExvYykge1xuICBcdCAgICAgICAgLy8gMykgSWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxuZXRfbG9jPiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgXHQgICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XG4gIFx0ICAgICAgICAvLyAoaWYgYW55KSBvZiB0aGUgYmFzZSBVUkwuXG4gIFx0ICAgICAgICBidWlsdFBhcnRzLm5ldExvYyA9IGJhc2VQYXJ0cy5uZXRMb2M7XG4gIFx0ICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXG4gIFx0ICAgICAgICAvLyBwYXRoIGlzIG5vdCByZWxhdGl2ZSBhbmQgd2Ugc2tpcCB0byBTdGVwIDcuXG4gIFx0ICAgICAgICBpZiAocmVsYXRpdmVQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcbiAgXHQgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcbiAgXHQgICAgICAgICAgICAvLyA1KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgZW1wdHkgKGFuZCBub3QgcHJlY2VkZWQgYnkgYVxuICBcdCAgICAgICAgICAgIC8vIHNsYXNoKSwgdGhlbiB0aGUgZW1iZWRkZWQgVVJMIGluaGVyaXRzIHRoZSBiYXNlIFVSTCBwYXRoXG4gIFx0ICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XG4gIFx0ICAgICAgICAgICAgLy8gNWEpIGlmIHRoZSBlbWJlZGRlZCBVUkwncyA8cGFyYW1zPiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgXHQgICAgICAgICAgICAvLyBzdGVwIDc7IG90aGVyd2lzZSwgaXQgaW5oZXJpdHMgdGhlIDxwYXJhbXM+IG9mIHRoZSBiYXNlXG4gIFx0ICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxuICBcdCAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5wYXJhbXMpIHtcbiAgXHQgICAgICAgICAgICAgIGJ1aWx0UGFydHMucGFyYW1zID0gYmFzZVBhcnRzLnBhcmFtcztcbiAgXHQgICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgXHQgICAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHF1ZXJ5PiBvZiB0aGUgYmFzZVxuICBcdCAgICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZCB3ZSBza2lwIHRvIHN0ZXAgNy5cbiAgXHQgICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xuICBcdCAgICAgICAgICAgICAgICBidWlsdFBhcnRzLnF1ZXJ5ID0gYmFzZVBhcnRzLnF1ZXJ5O1xuICBcdCAgICAgICAgICAgICAgfVxuICBcdCAgICAgICAgICAgIH1cbiAgXHQgICAgICAgICAgfSBlbHNlIHtcbiAgXHQgICAgICAgICAgICAvLyA2KSBUaGUgbGFzdCBzZWdtZW50IG9mIHRoZSBiYXNlIFVSTCdzIHBhdGggKGFueXRoaW5nXG4gIFx0ICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xuICBcdCAgICAgICAgICAgIC8vIHNsYXNoIGlzIHByZXNlbnQpIGlzIHJlbW92ZWQgYW5kIHRoZSBlbWJlZGRlZCBVUkwncyBwYXRoIGlzXG4gIFx0ICAgICAgICAgICAgLy8gYXBwZW5kZWQgaW4gaXRzIHBsYWNlLlxuICBcdCAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICBcdCAgICAgICAgICAgIHZhciBuZXdQYXRoID1cbiAgXHQgICAgICAgICAgICAgIGJhc2VVUkxQYXRoLnN1YnN0cmluZygwLCBiYXNlVVJMUGF0aC5sYXN0SW5kZXhPZignLycpICsgMSkgK1xuICBcdCAgICAgICAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICBcdCAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChuZXdQYXRoKTtcbiAgXHQgICAgICAgICAgfVxuICBcdCAgICAgICAgfVxuICBcdCAgICAgIH1cbiAgXHQgICAgICBpZiAoYnVpbHRQYXJ0cy5wYXRoID09PSBudWxsKSB7XG4gIFx0ICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZVxuICBcdCAgICAgICAgICA/IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpXG4gIFx0ICAgICAgICAgIDogcmVsYXRpdmVQYXJ0cy5wYXRoO1xuICBcdCAgICAgIH1cbiAgXHQgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhidWlsdFBhcnRzKTtcbiAgXHQgICAgfSxcbiAgXHQgICAgcGFyc2VVUkw6IGZ1bmN0aW9uICh1cmwpIHtcbiAgXHQgICAgICB2YXIgcGFydHMgPSBVUkxfUkVHRVguZXhlYyh1cmwpO1xuICBcdCAgICAgIGlmICghcGFydHMpIHtcbiAgXHQgICAgICAgIHJldHVybiBudWxsO1xuICBcdCAgICAgIH1cbiAgXHQgICAgICByZXR1cm4ge1xuICBcdCAgICAgICAgc2NoZW1lOiBwYXJ0c1sxXSB8fCAnJyxcbiAgXHQgICAgICAgIG5ldExvYzogcGFydHNbMl0gfHwgJycsXG4gIFx0ICAgICAgICBwYXRoOiBwYXJ0c1szXSB8fCAnJyxcbiAgXHQgICAgICAgIHBhcmFtczogcGFydHNbNF0gfHwgJycsXG4gIFx0ICAgICAgICBxdWVyeTogcGFydHNbNV0gfHwgJycsXG4gIFx0ICAgICAgICBmcmFnbWVudDogcGFydHNbNl0gfHwgJycsXG4gIFx0ICAgICAgfTtcbiAgXHQgICAgfSxcbiAgXHQgICAgbm9ybWFsaXplUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgXHQgICAgICAvLyBUaGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlXG4gIFx0ICAgICAgLy8gdGhlbiBhcHBsaWVkLCBpbiBvcmRlciwgdG8gdGhlIG5ldyBwYXRoOlxuICBcdCAgICAgIC8vIDZhKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCIuL1wiLCB3aGVyZSBcIi5cIiBpcyBhIGNvbXBsZXRlIHBhdGhcbiAgXHQgICAgICAvLyBzZWdtZW50LCBhcmUgcmVtb3ZlZC5cbiAgXHQgICAgICAvLyA2YikgSWYgdGhlIHBhdGggZW5kcyB3aXRoIFwiLlwiIGFzIGEgY29tcGxldGUgcGF0aCBzZWdtZW50LFxuICBcdCAgICAgIC8vIHRoYXQgXCIuXCIgaXMgcmVtb3ZlZC5cbiAgXHQgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpLnJlcGxhY2UoU0xBU0hfRE9UX1JFR0VYLCAnJyk7XG4gIFx0ICAgICAgLy8gNmMpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIjxzZWdtZW50Pi8uLi9cIiwgd2hlcmUgPHNlZ21lbnQ+IGlzIGFcbiAgXHQgICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgYXJlIHJlbW92ZWQuXG4gIFx0ICAgICAgLy8gUmVtb3ZhbCBvZiB0aGVzZSBwYXRoIHNlZ21lbnRzIGlzIHBlcmZvcm1lZCBpdGVyYXRpdmVseSxcbiAgXHQgICAgICAvLyByZW1vdmluZyB0aGUgbGVmdG1vc3QgbWF0Y2hpbmcgcGF0dGVybiBvbiBlYWNoIGl0ZXJhdGlvbixcbiAgXHQgICAgICAvLyB1bnRpbCBubyBtYXRjaGluZyBwYXR0ZXJuIHJlbWFpbnMuXG4gIFx0ICAgICAgLy8gNmQpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIjxzZWdtZW50Pi8uLlwiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuICBcdCAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCB0aGF0XG4gIFx0ICAgICAgLy8gXCI8c2VnbWVudD4vLi5cIiBpcyByZW1vdmVkLlxuICBcdCAgICAgIHdoaWxlIChcbiAgXHQgICAgICAgIHBhdGgubGVuZ3RoICE9PSAocGF0aCA9IHBhdGgucmVwbGFjZShTTEFTSF9ET1RfRE9UX1JFR0VYLCAnJykpLmxlbmd0aFxuICBcdCAgICAgICkge31cbiAgXHQgICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuICBcdCAgICB9LFxuICBcdCAgICBidWlsZFVSTEZyb21QYXJ0czogZnVuY3Rpb24gKHBhcnRzKSB7XG4gIFx0ICAgICAgcmV0dXJuIChcbiAgXHQgICAgICAgIHBhcnRzLnNjaGVtZSArXG4gIFx0ICAgICAgICBwYXJ0cy5uZXRMb2MgK1xuICBcdCAgICAgICAgcGFydHMucGF0aCArXG4gIFx0ICAgICAgICBwYXJ0cy5wYXJhbXMgK1xuICBcdCAgICAgICAgcGFydHMucXVlcnkgK1xuICBcdCAgICAgICAgcGFydHMuZnJhZ21lbnRcbiAgXHQgICAgICApO1xuICBcdCAgICB9LFxuICBcdCAgfTtcblxuICBcdCAgbW9kdWxlLmV4cG9ydHMgPSBVUkxUb29sa2l0O1xuICBcdH0pKCk7IFxuICB9ICh1cmxUb29sa2l0KSk7XG5cbiAgdmFyIHVybFRvb2xraXRFeHBvcnRzID0gdXJsVG9vbGtpdC5leHBvcnRzO1xuXG4gIC8vIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfbnVtYmVyX2lzZmluaXRlXG4gIHZhciBpc0Zpbml0ZU51bWJlciA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19udW1iZXJfaXNzYWZlaW50ZWdlclxuICB2YXIgaXNTYWZlSW50ZWdlciA9IE51bWJlci5pc1NhZmVJbnRlZ2VyIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIE1hdGguYWJzKHZhbHVlKSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICB9O1xuICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbiAgdmFyIEV2ZW50cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRXZlbnRzKSB7XG4gICAgRXZlbnRzW1wiTUVESUFfQVRUQUNISU5HXCJdID0gXCJobHNNZWRpYUF0dGFjaGluZ1wiO1xuICAgIEV2ZW50c1tcIk1FRElBX0FUVEFDSEVEXCJdID0gXCJobHNNZWRpYUF0dGFjaGVkXCI7XG4gICAgRXZlbnRzW1wiTUVESUFfREVUQUNISU5HXCJdID0gXCJobHNNZWRpYURldGFjaGluZ1wiO1xuICAgIEV2ZW50c1tcIk1FRElBX0RFVEFDSEVEXCJdID0gXCJobHNNZWRpYURldGFjaGVkXCI7XG4gICAgRXZlbnRzW1wiQlVGRkVSX1JFU0VUXCJdID0gXCJobHNCdWZmZXJSZXNldFwiO1xuICAgIEV2ZW50c1tcIkJVRkZFUl9DT0RFQ1NcIl0gPSBcImhsc0J1ZmZlckNvZGVjc1wiO1xuICAgIEV2ZW50c1tcIkJVRkZFUl9DUkVBVEVEXCJdID0gXCJobHNCdWZmZXJDcmVhdGVkXCI7XG4gICAgRXZlbnRzW1wiQlVGRkVSX0FQUEVORElOR1wiXSA9IFwiaGxzQnVmZmVyQXBwZW5kaW5nXCI7XG4gICAgRXZlbnRzW1wiQlVGRkVSX0FQUEVOREVEXCJdID0gXCJobHNCdWZmZXJBcHBlbmRlZFwiO1xuICAgIEV2ZW50c1tcIkJVRkZFUl9FT1NcIl0gPSBcImhsc0J1ZmZlckVvc1wiO1xuICAgIEV2ZW50c1tcIkJVRkZFUl9GTFVTSElOR1wiXSA9IFwiaGxzQnVmZmVyRmx1c2hpbmdcIjtcbiAgICBFdmVudHNbXCJCVUZGRVJfRkxVU0hFRFwiXSA9IFwiaGxzQnVmZmVyRmx1c2hlZFwiO1xuICAgIEV2ZW50c1tcIk1BTklGRVNUX0xPQURJTkdcIl0gPSBcImhsc01hbmlmZXN0TG9hZGluZ1wiO1xuICAgIEV2ZW50c1tcIk1BTklGRVNUX0xPQURFRFwiXSA9IFwiaGxzTWFuaWZlc3RMb2FkZWRcIjtcbiAgICBFdmVudHNbXCJNQU5JRkVTVF9QQVJTRURcIl0gPSBcImhsc01hbmlmZXN0UGFyc2VkXCI7XG4gICAgRXZlbnRzW1wiTEVWRUxfU1dJVENISU5HXCJdID0gXCJobHNMZXZlbFN3aXRjaGluZ1wiO1xuICAgIEV2ZW50c1tcIkxFVkVMX1NXSVRDSEVEXCJdID0gXCJobHNMZXZlbFN3aXRjaGVkXCI7XG4gICAgRXZlbnRzW1wiTEVWRUxfTE9BRElOR1wiXSA9IFwiaGxzTGV2ZWxMb2FkaW5nXCI7XG4gICAgRXZlbnRzW1wiTEVWRUxfTE9BREVEXCJdID0gXCJobHNMZXZlbExvYWRlZFwiO1xuICAgIEV2ZW50c1tcIkxFVkVMX1VQREFURURcIl0gPSBcImhsc0xldmVsVXBkYXRlZFwiO1xuICAgIEV2ZW50c1tcIkxFVkVMX1BUU19VUERBVEVEXCJdID0gXCJobHNMZXZlbFB0c1VwZGF0ZWRcIjtcbiAgICBFdmVudHNbXCJMRVZFTFNfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxzVXBkYXRlZFwiO1xuICAgIEV2ZW50c1tcIkFVRElPX1RSQUNLU19VUERBVEVEXCJdID0gXCJobHNBdWRpb1RyYWNrc1VwZGF0ZWRcIjtcbiAgICBFdmVudHNbXCJBVURJT19UUkFDS19TV0lUQ0hJTkdcIl0gPSBcImhsc0F1ZGlvVHJhY2tTd2l0Y2hpbmdcIjtcbiAgICBFdmVudHNbXCJBVURJT19UUkFDS19TV0lUQ0hFRFwiXSA9IFwiaGxzQXVkaW9UcmFja1N3aXRjaGVkXCI7XG4gICAgRXZlbnRzW1wiQVVESU9fVFJBQ0tfTE9BRElOR1wiXSA9IFwiaGxzQXVkaW9UcmFja0xvYWRpbmdcIjtcbiAgICBFdmVudHNbXCJBVURJT19UUkFDS19MT0FERURcIl0gPSBcImhsc0F1ZGlvVHJhY2tMb2FkZWRcIjtcbiAgICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja3NVcGRhdGVkXCI7XG4gICAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tTX0NMRUFSRURcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tzQ2xlYXJlZFwiO1xuICAgIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX1NXSVRDSFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja1N3aXRjaFwiO1xuICAgIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX0xPQURJTkdcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tMb2FkaW5nXCI7XG4gICAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tfTE9BREVEXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrTG9hZGVkXCI7XG4gICAgRXZlbnRzW1wiU1VCVElUTEVfRlJBR19QUk9DRVNTRURcIl0gPSBcImhsc1N1YnRpdGxlRnJhZ1Byb2Nlc3NlZFwiO1xuICAgIEV2ZW50c1tcIkNVRVNfUEFSU0VEXCJdID0gXCJobHNDdWVzUGFyc2VkXCI7XG4gICAgRXZlbnRzW1wiTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORFwiXSA9IFwiaGxzTm9uTmF0aXZlVGV4dFRyYWNrc0ZvdW5kXCI7XG4gICAgRXZlbnRzW1wiSU5JVF9QVFNfRk9VTkRcIl0gPSBcImhsc0luaXRQdHNGb3VuZFwiO1xuICAgIEV2ZW50c1tcIkZSQUdfTE9BRElOR1wiXSA9IFwiaGxzRnJhZ0xvYWRpbmdcIjtcbiAgICBFdmVudHNbXCJGUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURURcIl0gPSBcImhsc0ZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZFwiO1xuICAgIEV2ZW50c1tcIkZSQUdfTE9BREVEXCJdID0gXCJobHNGcmFnTG9hZGVkXCI7XG4gICAgRXZlbnRzW1wiRlJBR19ERUNSWVBURURcIl0gPSBcImhsc0ZyYWdEZWNyeXB0ZWRcIjtcbiAgICBFdmVudHNbXCJGUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UXCJdID0gXCJobHNGcmFnUGFyc2luZ0luaXRTZWdtZW50XCI7XG4gICAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX1VTRVJEQVRBXCJdID0gXCJobHNGcmFnUGFyc2luZ1VzZXJkYXRhXCI7XG4gICAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX01FVEFEQVRBXCJdID0gXCJobHNGcmFnUGFyc2luZ01ldGFkYXRhXCI7XG4gICAgRXZlbnRzW1wiRlJBR19QQVJTRURcIl0gPSBcImhsc0ZyYWdQYXJzZWRcIjtcbiAgICBFdmVudHNbXCJGUkFHX0JVRkZFUkVEXCJdID0gXCJobHNGcmFnQnVmZmVyZWRcIjtcbiAgICBFdmVudHNbXCJGUkFHX0NIQU5HRURcIl0gPSBcImhsc0ZyYWdDaGFuZ2VkXCI7XG4gICAgRXZlbnRzW1wiRlBTX0RST1BcIl0gPSBcImhsc0Zwc0Ryb3BcIjtcbiAgICBFdmVudHNbXCJGUFNfRFJPUF9MRVZFTF9DQVBQSU5HXCJdID0gXCJobHNGcHNEcm9wTGV2ZWxDYXBwaW5nXCI7XG4gICAgRXZlbnRzW1wiTUFYX0FVVE9fTEVWRUxfVVBEQVRFRFwiXSA9IFwiaGxzTWF4QXV0b0xldmVsVXBkYXRlZFwiO1xuICAgIEV2ZW50c1tcIkVSUk9SXCJdID0gXCJobHNFcnJvclwiO1xuICAgIEV2ZW50c1tcIkRFU1RST1lJTkdcIl0gPSBcImhsc0Rlc3Ryb3lpbmdcIjtcbiAgICBFdmVudHNbXCJLRVlfTE9BRElOR1wiXSA9IFwiaGxzS2V5TG9hZGluZ1wiO1xuICAgIEV2ZW50c1tcIktFWV9MT0FERURcIl0gPSBcImhsc0tleUxvYWRlZFwiO1xuICAgIEV2ZW50c1tcIkxJVkVfQkFDS19CVUZGRVJfUkVBQ0hFRFwiXSA9IFwiaGxzTGl2ZUJhY2tCdWZmZXJSZWFjaGVkXCI7XG4gICAgRXZlbnRzW1wiQkFDS19CVUZGRVJfUkVBQ0hFRFwiXSA9IFwiaGxzQmFja0J1ZmZlclJlYWNoZWRcIjtcbiAgICBFdmVudHNbXCJTVEVFUklOR19NQU5JRkVTVF9MT0FERURcIl0gPSBcImhsc1N0ZWVyaW5nTWFuaWZlc3RMb2FkZWRcIjtcbiAgICByZXR1cm4gRXZlbnRzO1xuICB9KHt9KTtcblxuICAvKipcbiAgICogRGVmaW5lcyBlYWNoIEV2ZW50IHR5cGUgYW5kIHBheWxvYWQgYnkgRXZlbnQgbmFtZS4gVXNlZCBpbiB7QGxpbmsgaGxzLmpzI0hsc0V2ZW50RW1pdHRlcn0gdG8gc3Ryb25nbHkgdHlwZSB0aGUgZXZlbnQgbGlzdGVuZXIgQVBJLlxuICAgKi9cblxuICB2YXIgRXJyb3JUeXBlcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRXJyb3JUeXBlcykge1xuICAgIEVycm9yVHlwZXNbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJuZXR3b3JrRXJyb3JcIjtcbiAgICBFcnJvclR5cGVzW1wiTUVESUFfRVJST1JcIl0gPSBcIm1lZGlhRXJyb3JcIjtcbiAgICBFcnJvclR5cGVzW1wiS0VZX1NZU1RFTV9FUlJPUlwiXSA9IFwia2V5U3lzdGVtRXJyb3JcIjtcbiAgICBFcnJvclR5cGVzW1wiTVVYX0VSUk9SXCJdID0gXCJtdXhFcnJvclwiO1xuICAgIEVycm9yVHlwZXNbXCJPVEhFUl9FUlJPUlwiXSA9IFwib3RoZXJFcnJvclwiO1xuICAgIHJldHVybiBFcnJvclR5cGVzO1xuICB9KHt9KTtcbiAgdmFyIEVycm9yRGV0YWlscyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRXJyb3JEZXRhaWxzKSB7XG4gICAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9OT19LRVlTXCJdID0gXCJrZXlTeXN0ZW1Ob0tleXNcIjtcbiAgICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX05PX0FDQ0VTU1wiXSA9IFwia2V5U3lzdGVtTm9BY2Nlc3NcIjtcbiAgICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX05PX1NFU1NJT05cIl0gPSBcImtleVN5c3RlbU5vU2Vzc2lvblwiO1xuICAgIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fQ09ORklHVVJFRF9MSUNFTlNFXCJdID0gXCJrZXlTeXN0ZW1Ob0NvbmZpZ3VyZWRMaWNlbnNlXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9MSUNFTlNFX1JFUVVFU1RfRkFJTEVEXCJdID0gXCJrZXlTeXN0ZW1MaWNlbnNlUmVxdWVzdEZhaWxlZFwiO1xuICAgIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVEXCJdID0gXCJrZXlTeXN0ZW1TZXJ2ZXJDZXJ0aWZpY2F0ZVJlcXVlc3RGYWlsZWRcIjtcbiAgICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NFUlZFUl9DRVJUSUZJQ0FURV9VUERBVEVfRkFJTEVEXCJdID0gXCJrZXlTeXN0ZW1TZXJ2ZXJDZXJ0aWZpY2F0ZVVwZGF0ZUZhaWxlZFwiO1xuICAgIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fU0VTU0lPTl9VUERBVEVfRkFJTEVEXCJdID0gXCJrZXlTeXN0ZW1TZXNzaW9uVXBkYXRlRmFpbGVkXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURURcIl0gPSBcImtleVN5c3RlbVN0YXR1c091dHB1dFJlc3RyaWN0ZWRcIjtcbiAgICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX1NUQVRVU19JTlRFUk5BTF9FUlJPUlwiXSA9IFwia2V5U3lzdGVtU3RhdHVzSW50ZXJuYWxFcnJvclwiO1xuICAgIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX0xPQURfRVJST1JcIl0gPSBcIm1hbmlmZXN0TG9hZEVycm9yXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfTE9BRF9USU1FT1VUXCJdID0gXCJtYW5pZmVzdExvYWRUaW1lT3V0XCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfUEFSU0lOR19FUlJPUlwiXSA9IFwibWFuaWZlc3RQYXJzaW5nRXJyb3JcIjtcbiAgICBFcnJvckRldGFpbHNbXCJNQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SXCJdID0gXCJtYW5pZmVzdEluY29tcGF0aWJsZUNvZGVjc0Vycm9yXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfRU1QVFlfRVJST1JcIl0gPSBcImxldmVsRW1wdHlFcnJvclwiO1xuICAgIEVycm9yRGV0YWlsc1tcIkxFVkVMX0xPQURfRVJST1JcIl0gPSBcImxldmVsTG9hZEVycm9yXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfTE9BRF9USU1FT1VUXCJdID0gXCJsZXZlbExvYWRUaW1lT3V0XCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfUEFSU0lOR19FUlJPUlwiXSA9IFwibGV2ZWxQYXJzaW5nRXJyb3JcIjtcbiAgICBFcnJvckRldGFpbHNbXCJMRVZFTF9TV0lUQ0hfRVJST1JcIl0gPSBcImxldmVsU3dpdGNoRXJyb3JcIjtcbiAgICBFcnJvckRldGFpbHNbXCJBVURJT19UUkFDS19MT0FEX0VSUk9SXCJdID0gXCJhdWRpb1RyYWNrTG9hZEVycm9yXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUXCJdID0gXCJhdWRpb1RyYWNrTG9hZFRpbWVPdXRcIjtcbiAgICBFcnJvckRldGFpbHNbXCJTVUJUSVRMRV9MT0FEX0VSUk9SXCJdID0gXCJzdWJ0aXRsZVRyYWNrTG9hZEVycm9yXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUXCJdID0gXCJzdWJ0aXRsZVRyYWNrTG9hZFRpbWVPdXRcIjtcbiAgICBFcnJvckRldGFpbHNbXCJGUkFHX0xPQURfRVJST1JcIl0gPSBcImZyYWdMb2FkRXJyb3JcIjtcbiAgICBFcnJvckRldGFpbHNbXCJGUkFHX0xPQURfVElNRU9VVFwiXSA9IFwiZnJhZ0xvYWRUaW1lT3V0XCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiRlJBR19ERUNSWVBUX0VSUk9SXCJdID0gXCJmcmFnRGVjcnlwdEVycm9yXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiRlJBR19QQVJTSU5HX0VSUk9SXCJdID0gXCJmcmFnUGFyc2luZ0Vycm9yXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiRlJBR19HQVBcIl0gPSBcImZyYWdHYXBcIjtcbiAgICBFcnJvckRldGFpbHNbXCJSRU1VWF9BTExPQ19FUlJPUlwiXSA9IFwicmVtdXhBbGxvY0Vycm9yXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiS0VZX0xPQURfRVJST1JcIl0gPSBcImtleUxvYWRFcnJvclwiO1xuICAgIEVycm9yRGV0YWlsc1tcIktFWV9MT0FEX1RJTUVPVVRcIl0gPSBcImtleUxvYWRUaW1lT3V0XCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0FERF9DT0RFQ19FUlJPUlwiXSA9IFwiYnVmZmVyQWRkQ29kZWNFcnJvclwiO1xuICAgIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SXCJdID0gXCJidWZmZXJJbmNvbXBhdGlibGVDb2RlY3NFcnJvclwiO1xuICAgIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9BUFBFTkRfRVJST1JcIl0gPSBcImJ1ZmZlckFwcGVuZEVycm9yXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0FQUEVORElOR19FUlJPUlwiXSA9IFwiYnVmZmVyQXBwZW5kaW5nRXJyb3JcIjtcbiAgICBFcnJvckRldGFpbHNbXCJCVUZGRVJfU1RBTExFRF9FUlJPUlwiXSA9IFwiYnVmZmVyU3RhbGxlZEVycm9yXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX0ZVTExfRVJST1JcIl0gPSBcImJ1ZmZlckZ1bGxFcnJvclwiO1xuICAgIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9TRUVLX09WRVJfSE9MRVwiXSA9IFwiYnVmZmVyU2Vla092ZXJIb2xlXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX05VREdFX09OX1NUQUxMXCJdID0gXCJidWZmZXJOdWRnZU9uU3RhbGxcIjtcbiAgICBFcnJvckRldGFpbHNbXCJJTlRFUk5BTF9FWENFUFRJT05cIl0gPSBcImludGVybmFsRXhjZXB0aW9uXCI7XG4gICAgRXJyb3JEZXRhaWxzW1wiSU5URVJOQUxfQUJPUlRFRFwiXSA9IFwiYWJvcnRlZFwiO1xuICAgIEVycm9yRGV0YWlsc1tcIlVOS05PV05cIl0gPSBcInVua25vd25cIjtcbiAgICByZXR1cm4gRXJyb3JEZXRhaWxzO1xuICB9KHt9KTtcblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbiAgdmFyIGZha2VMb2dnZXIgPSB7XG4gICAgdHJhY2U6IG5vb3AsXG4gICAgZGVidWc6IG5vb3AsXG4gICAgbG9nOiBub29wLFxuICAgIHdhcm46IG5vb3AsXG4gICAgaW5mbzogbm9vcCxcbiAgICBlcnJvcjogbm9vcFxuICB9O1xuICB2YXIgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuXG4gIC8vIGxldCBsYXN0Q2FsbFRpbWU7XG4gIC8vIGZ1bmN0aW9uIGZvcm1hdE1zZ1dpdGhUaW1lSW5mbyh0eXBlLCBtc2cpIHtcbiAgLy8gICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAvLyAgIGNvbnN0IGRpZmYgPSBsYXN0Q2FsbFRpbWUgPyAnKycgKyAobm93IC0gbGFzdENhbGxUaW1lKSA6ICcwJztcbiAgLy8gICBsYXN0Q2FsbFRpbWUgPSBub3c7XG4gIC8vICAgbXNnID0gKG5ldyBEYXRlKG5vdykpLnRvSVNPU3RyaW5nKCkgKyAnIHwgWycgKyAgdHlwZSArICddID4gJyArIG1zZyArICcgKCAnICsgZGlmZiArICcgbXMgKSc7XG4gIC8vICAgcmV0dXJuIG1zZztcbiAgLy8gfVxuXG4gIGZ1bmN0aW9uIGNvbnNvbGVQcmludEZuKHR5cGUpIHtcbiAgICB2YXIgZnVuYyA9IHNlbGYuY29uc29sZVt0eXBlXTtcbiAgICBpZiAoZnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmMuYmluZChzZWxmLmNvbnNvbGUsIFwiW1wiICsgdHlwZSArIFwiXSA+XCIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9vcDtcbiAgfVxuICBmdW5jdGlvbiBleHBvcnRMb2dnZXJGdW5jdGlvbnMoZGVidWdDb25maWcpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3Rpb25zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGZ1bmN0aW9uc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBleHBvcnRlZExvZ2dlclt0eXBlXSA9IGRlYnVnQ29uZmlnW3R5cGVdID8gZGVidWdDb25maWdbdHlwZV0uYmluZChkZWJ1Z0NvbmZpZykgOiBjb25zb2xlUHJpbnRGbih0eXBlKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBlbmFibGVMb2dzKGRlYnVnQ29uZmlnLCBpZCkge1xuICAgIC8vIGNoZWNrIHRoYXQgY29uc29sZSBpcyBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmIGRlYnVnQ29uZmlnID09PSB0cnVlIHx8IHR5cGVvZiBkZWJ1Z0NvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZyxcbiAgICAgIC8vIFJlbW92ZSBvdXQgZnJvbSBsaXN0IGhlcmUgdG8gaGFyZC1kaXNhYmxlIGEgbG9nLWxldmVsXG4gICAgICAvLyAndHJhY2UnLFxuICAgICAgJ2RlYnVnJywgJ2xvZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InKTtcbiAgICAgIC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3QgYWxsb3cgdG8gdXNlIGJpbmQgb24gY29uc29sZSBvYmplY3QgYW55d2F5XG4gICAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0IGlmIG5lZWRlZFxuICAgICAgdHJ5IHtcbiAgICAgICAgZXhwb3J0ZWRMb2dnZXIubG9nKFwiRGVidWcgbG9ncyBlbmFibGVkIGZvciBcXFwiXCIgKyBpZCArIFwiXFxcIiBpbiBobHMuanMgdmVyc2lvbiBcIiArIFwiMS41LjE3XCIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgICB9XG4gIH1cbiAgdmFyIGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuXG4gIHZhciBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLztcbiAgdmFyIEFUVFJfTElTVF9SRUdFWCA9IC8oLis/KT0oXCIuKj9cInwuKj8pKD86LHwkKS9nO1xuXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20va2Fub25naWwvbm9kZS1tM3U4cGFyc2UvYmxvYi9tYXN0ZXIvYXR0cmxpc3QuanNcbiAgdmFyIEF0dHJMaXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdHRyTGlzdChhdHRycykge1xuICAgICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXR0cnMgPSBBdHRyTGlzdC5wYXJzZUF0dHJMaXN0KGF0dHJzKTtcbiAgICAgIH1cbiAgICAgIF9leHRlbmRzKHRoaXMsIGF0dHJzKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IEF0dHJMaXN0LnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVjaW1hbEludGVnZXIgPSBmdW5jdGlvbiBkZWNpbWFsSW50ZWdlcihhdHRyTmFtZSkge1xuICAgICAgdmFyIGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcbiAgICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5oZXhhZGVjaW1hbEludGVnZXIgPSBmdW5jdGlvbiBoZXhhZGVjaW1hbEludGVnZXIoYXR0ck5hbWUpIHtcbiAgICAgIGlmICh0aGlzW2F0dHJOYW1lXSkge1xuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSAodGhpc1thdHRyTmFtZV0gfHwgJzB4Jykuc2xpY2UoMik7XG4gICAgICAgIHN0cmluZ1ZhbHVlID0gKHN0cmluZ1ZhbHVlLmxlbmd0aCAmIDEgPyAnMCcgOiAnJykgKyBzdHJpbmdWYWx1ZTtcbiAgICAgICAgdmFyIHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nVmFsdWUubGVuZ3RoIC8gMik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmhleGFkZWNpbWFsSW50ZWdlckFzTnVtYmVyID0gZnVuY3Rpb24gaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIoYXR0ck5hbWUpIHtcbiAgICAgIHZhciBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxNik7XG4gICAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW50VmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjaW1hbEZsb2F0aW5nUG9pbnQgPSBmdW5jdGlvbiBkZWNpbWFsRmxvYXRpbmdQb2ludChhdHRyTmFtZSkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpc1thdHRyTmFtZV0pO1xuICAgIH07XG4gICAgX3Byb3RvLm9wdGlvbmFsRmxvYXQgPSBmdW5jdGlvbiBvcHRpb25hbEZsb2F0KGF0dHJOYW1lLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXNbYXR0ck5hbWVdO1xuICAgICAgcmV0dXJuIHZhbHVlID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiBkZWZhdWx0VmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8uZW51bWVyYXRlZFN0cmluZyA9IGZ1bmN0aW9uIGVudW1lcmF0ZWRTdHJpbmcoYXR0ck5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXTtcbiAgICB9O1xuICAgIF9wcm90by5ib29sID0gZnVuY3Rpb24gYm9vbChhdHRyTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdID09PSAnWUVTJztcbiAgICB9O1xuICAgIF9wcm90by5kZWNpbWFsUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGRlY2ltYWxSZXNvbHV0aW9uKGF0dHJOYW1lKSB7XG4gICAgICB2YXIgcmVzID0gREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYLmV4ZWModGhpc1thdHRyTmFtZV0pO1xuICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHBhcnNlSW50KHJlc1sxXSwgMTApLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KHJlc1syXSwgMTApXG4gICAgICB9O1xuICAgIH07XG4gICAgQXR0ckxpc3QucGFyc2VBdHRyTGlzdCA9IGZ1bmN0aW9uIHBhcnNlQXR0ckxpc3QoaW5wdXQpIHtcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHZhciBhdHRycyA9IHt9O1xuICAgICAgdmFyIHF1b3RlID0gJ1wiJztcbiAgICAgIEFUVFJfTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgICAgd2hpbGUgKChtYXRjaCA9IEFUVFJfTElTVF9SRUdFWC5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbMl07XG4gICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKHF1b3RlKSA9PT0gMCAmJiB2YWx1ZS5sYXN0SW5kZXhPZihxdW90ZSkgPT09IHZhbHVlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRycztcbiAgICB9O1xuICAgIF9jcmVhdGVDbGFzcyhBdHRyTGlzdCwgW3tcbiAgICAgIGtleTogXCJjbGllbnRBdHRyc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzKS5maWx0ZXIoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gYXR0ci5zdWJzdHJpbmcoMCwgMikgPT09ICdYLSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQXR0ckxpc3Q7XG4gIH0oKTtcblxuICAvLyBBdm9pZCBleHBvcnRpbmcgY29uc3QgZW51bSBzbyB0aGF0IHRoZXNlIHZhbHVlcyBjYW4gYmUgaW5saW5lZFxuXG4gIGZ1bmN0aW9uIGlzRGF0ZVJhbmdlQ3VlQXR0cmlidXRlKGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIGF0dHJOYW1lICE9PSBcIklEXCIgJiYgYXR0ck5hbWUgIT09IFwiQ0xBU1NcIiAmJiBhdHRyTmFtZSAhPT0gXCJTVEFSVC1EQVRFXCIgJiYgYXR0ck5hbWUgIT09IFwiRFVSQVRJT05cIiAmJiBhdHRyTmFtZSAhPT0gXCJFTkQtREFURVwiICYmIGF0dHJOYW1lICE9PSBcIkVORC1PTi1ORVhUXCI7XG4gIH1cbiAgZnVuY3Rpb24gaXNTQ1RFMzVBdHRyaWJ1dGUoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gYXR0ck5hbWUgPT09IFwiU0NURTM1LU9VVFwiIHx8IGF0dHJOYW1lID09PSBcIlNDVEUzNS1JTlwiO1xuICB9XG4gIHZhciBEYXRlUmFuZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGVSYW5nZShkYXRlUmFuZ2VBdHRyLCBkYXRlUmFuZ2VXaXRoU2FtZUlkKSB7XG4gICAgICB0aGlzLmF0dHIgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9zdGFydERhdGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9lbmREYXRlID0gdm9pZCAwO1xuICAgICAgdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgPSB2b2lkIDA7XG4gICAgICBpZiAoZGF0ZVJhbmdlV2l0aFNhbWVJZCkge1xuICAgICAgICB2YXIgcHJldmlvdXNBdHRyID0gZGF0ZVJhbmdlV2l0aFNhbWVJZC5hdHRyO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJldmlvdXNBdHRyKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRlUmFuZ2VBdHRyLCBrZXkpICYmIGRhdGVSYW5nZUF0dHJba2V5XSAhPT0gcHJldmlvdXNBdHRyW2tleV0pIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiREFURVJBTkdFIHRhZyBhdHRyaWJ1dGU6IFxcXCJcIiArIGtleSArIFwiXFxcIiBkb2VzIG5vdCBtYXRjaCBmb3IgdGFncyB3aXRoIElEOiBcXFwiXCIgKyBkYXRlUmFuZ2VBdHRyLklEICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgPSBrZXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWVyZ2UgRGF0ZVJhbmdlIHRhZ3Mgd2l0aCB0aGUgc2FtZSBJRFxuICAgICAgICBkYXRlUmFuZ2VBdHRyID0gX2V4dGVuZHMobmV3IEF0dHJMaXN0KHt9KSwgcHJldmlvdXNBdHRyLCBkYXRlUmFuZ2VBdHRyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXR0ciA9IGRhdGVSYW5nZUF0dHI7XG4gICAgICB0aGlzLl9zdGFydERhdGUgPSBuZXcgRGF0ZShkYXRlUmFuZ2VBdHRyW1wiU1RBUlQtREFURVwiXSk7XG4gICAgICBpZiAoXCJFTkQtREFURVwiIGluIHRoaXMuYXR0cikge1xuICAgICAgICB2YXIgZW5kRGF0ZSA9IG5ldyBEYXRlKHRoaXMuYXR0cltcIkVORC1EQVRFXCJdKTtcbiAgICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGVuZERhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgIHRoaXMuX2VuZERhdGUgPSBlbmREYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhEYXRlUmFuZ2UsIFt7XG4gICAgICBrZXk6IFwiaWRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyLklEO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbGFzc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIuQ0xBU1M7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInN0YXJ0RGF0ZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydERhdGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVuZERhdGVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fZW5kRGF0ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9lbmREYXRlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgIGlmIChkdXJhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9zdGFydERhdGUuZ2V0VGltZSgpICsgZHVyYXRpb24gKiAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAoXCJEVVJBVElPTlwiIGluIHRoaXMuYXR0cikge1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuYXR0ci5kZWNpbWFsRmxvYXRpbmdQb2ludChcIkRVUkFUSU9OXCIpO1xuICAgICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZW5kRGF0ZSkge1xuICAgICAgICAgIHJldHVybiAodGhpcy5fZW5kRGF0ZS5nZXRUaW1lKCkgLSB0aGlzLl9zdGFydERhdGUuZ2V0VGltZSgpKSAvIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBsYW5uZWREdXJhdGlvblwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmIChcIlBMQU5ORUQtRFVSQVRJT05cIiBpbiB0aGlzLmF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyLmRlY2ltYWxGbG9hdGluZ1BvaW50KFwiUExBTk5FRC1EVVJBVElPTlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZW5kT25OZXh0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ci5ib29sKFwiRU5ELU9OLU5FWFRcIik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImlzVmFsaWRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmlkICYmICF0aGlzLl9iYWRWYWx1ZUZvclNhbWVJZCAmJiBpc0Zpbml0ZU51bWJlcih0aGlzLnN0YXJ0RGF0ZS5nZXRUaW1lKCkpICYmICh0aGlzLmR1cmF0aW9uID09PSBudWxsIHx8IHRoaXMuZHVyYXRpb24gPj0gMCkgJiYgKCF0aGlzLmVuZE9uTmV4dCB8fCAhIXRoaXMuY2xhc3MpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gRGF0ZVJhbmdlO1xuICB9KCk7XG5cbiAgdmFyIExvYWRTdGF0cyA9IGZ1bmN0aW9uIExvYWRTdGF0cygpIHtcbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxvYWRlZCA9IDA7XG4gICAgdGhpcy5yZXRyeSA9IDA7XG4gICAgdGhpcy50b3RhbCA9IDA7XG4gICAgdGhpcy5jaHVua0NvdW50ID0gMDtcbiAgICB0aGlzLmJ3RXN0aW1hdGUgPSAwO1xuICAgIHRoaXMubG9hZGluZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZmlyc3Q6IDAsXG4gICAgICBlbmQ6IDBcbiAgICB9O1xuICAgIHRoaXMucGFyc2luZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgICB0aGlzLmJ1ZmZlcmluZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZmlyc3Q6IDAsXG4gICAgICBlbmQ6IDBcbiAgICB9O1xuICB9O1xuXG4gIHZhciBFbGVtZW50YXJ5U3RyZWFtVHlwZXMgPSB7XG4gICAgQVVESU86IFwiYXVkaW9cIixcbiAgICBWSURFTzogXCJ2aWRlb1wiLFxuICAgIEFVRElPVklERU86IFwiYXVkaW92aWRlb1wiXG4gIH07XG4gIHZhciBCYXNlU2VnbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZVNlZ21lbnQoYmFzZXVybCkge1xuICAgICAgdmFyIF90aGlzJGVsZW1lbnRhcnlTdHJlYTtcbiAgICAgIHRoaXMuX2J5dGVSYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl91cmwgPSBudWxsO1xuICAgICAgLy8gYmFzZXVybCBpcyB0aGUgVVJMIHRvIHRoZSBwbGF5bGlzdFxuICAgICAgdGhpcy5iYXNldXJsID0gdm9pZCAwO1xuICAgICAgLy8gcmVsdXJsIGlzIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgdGhhdCBjb21lcyBmcm9tIGluc2lkZSB0aGUgcGxheWxpc3QuXG4gICAgICB0aGlzLnJlbHVybCA9IHZvaWQgMDtcbiAgICAgIC8vIEhvbGRzIHRoZSB0eXBlcyBvZiBkYXRhIHRoaXMgZnJhZ21lbnQgc3VwcG9ydHNcbiAgICAgIHRoaXMuZWxlbWVudGFyeVN0cmVhbXMgPSAoX3RoaXMkZWxlbWVudGFyeVN0cmVhID0ge30sIF90aGlzJGVsZW1lbnRhcnlTdHJlYVtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0gbnVsbCwgX3RoaXMkZWxlbWVudGFyeVN0cmVhW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10gPSBudWxsLCBfdGhpcyRlbGVtZW50YXJ5U3RyZWFbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dID0gbnVsbCwgX3RoaXMkZWxlbWVudGFyeVN0cmVhKTtcbiAgICAgIHRoaXMuYmFzZXVybCA9IGJhc2V1cmw7XG4gICAgfVxuXG4gICAgLy8gc2V0Qnl0ZVJhbmdlIGNvbnZlcnRzIGEgRVhULVgtQllURVJBTkdFIGF0dHJpYnV0ZSBpbnRvIGEgdHdvIGVsZW1lbnQgYXJyYXlcbiAgICB2YXIgX3Byb3RvID0gQmFzZVNlZ21lbnQucHJvdG90eXBlO1xuICAgIF9wcm90by5zZXRCeXRlUmFuZ2UgPSBmdW5jdGlvbiBzZXRCeXRlUmFuZ2UodmFsdWUsIHByZXZpb3VzKSB7XG4gICAgICB2YXIgcGFyYW1zID0gdmFsdWUuc3BsaXQoJ0AnLCAyKTtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5ieXRlUmFuZ2VFbmRPZmZzZXQpIHx8IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHBhcmFtc1sxXSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ieXRlUmFuZ2UgPSBbc3RhcnQsIHBhcnNlSW50KHBhcmFtc1swXSkgKyBzdGFydF07XG4gICAgfTtcbiAgICBfY3JlYXRlQ2xhc3MoQmFzZVNlZ21lbnQsIFt7XG4gICAgICBrZXk6IFwiYnl0ZVJhbmdlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5dGVSYW5nZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYnl0ZVJhbmdlU3RhcnRPZmZzZXRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMF07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImJ5dGVSYW5nZUVuZE9mZnNldFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidXJsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5iYXNldXJsICYmIHRoaXMucmVsdXJsKSB7XG4gICAgICAgICAgdGhpcy5fdXJsID0gdXJsVG9vbGtpdEV4cG9ydHMuYnVpbGRBYnNvbHV0ZVVSTCh0aGlzLmJhc2V1cmwsIHRoaXMucmVsdXJsLCB7XG4gICAgICAgICAgICBhbHdheXNOb3JtYWxpemU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXJsIHx8ICcnO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3VybCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQmFzZVNlZ21lbnQ7XG4gIH0oKTtcblxuICAvKipcbiAgICogT2JqZWN0IHJlcHJlc2VudGluZyBwYXJzZWQgZGF0YSBmcm9tIGFuIEhMUyBTZWdtZW50LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsRGV0YWlscy5mcmFnbWVudHN9LlxuICAgKi9cbiAgdmFyIEZyYWdtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVNlZ21lbnQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShGcmFnbWVudCwgX0Jhc2VTZWdtZW50KTtcbiAgICBmdW5jdGlvbiBGcmFnbWVudCh0eXBlLCBiYXNldXJsKSB7XG4gICAgICB2YXIgX3RoaXM7XG4gICAgICBfdGhpcyA9IF9CYXNlU2VnbWVudC5jYWxsKHRoaXMsIGJhc2V1cmwpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5fZGVjcnlwdGRhdGEgPSBudWxsO1xuICAgICAgX3RoaXMucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICAgIF90aGlzLnByb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgICBfdGhpcy50YWdMaXN0ID0gW107XG4gICAgICAvLyBFWFRJTkYgaGFzIHRvIGJlIHByZXNlbnQgZm9yIGEgbTN1OCB0byBiZSBjb25zaWRlcmVkIHZhbGlkXG4gICAgICBfdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgICAvLyBzbiBub3RhdGVzIHRoZSBzZXF1ZW5jZSBudW1iZXIgZm9yIGEgc2VnbWVudCwgYW5kIGlmIHNldCB0byBhIHN0cmluZyBjYW4gYmUgJ2luaXRTZWdtZW50J1xuICAgICAgX3RoaXMuc24gPSAwO1xuICAgICAgLy8gbGV2ZWxrZXlzIGFyZSB0aGUgRVhULVgtS0VZIHRhZ3MgdGhhdCBhcHBseSB0byB0aGlzIHNlZ21lbnQgZm9yIGRlY3J5cHRpb25cbiAgICAgIC8vIGNvcmUgZGlmZmVyZW5jZSBmcm9tIHRoZSBwcml2YXRlIGZpZWxkIF9kZWNyeXB0ZGF0YSBpcyB0aGUgbGFjayBvZiB0aGUgaW5pdGlhbGl6ZWQgSVZcbiAgICAgIC8vIF9kZWNyeXB0ZGF0YSB3aWxsIHNldCB0aGUgSVYgZm9yIHRoaXMgc2VnbWVudCBiYXNlZCBvbiB0aGUgc2VnbWVudCBudW1iZXIgaW4gdGhlIGZyYWdtZW50XG4gICAgICBfdGhpcy5sZXZlbGtleXMgPSB2b2lkIDA7XG4gICAgICAvLyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZyYWdtZW50IHR5cGVcbiAgICAgIF90aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgbG9hZGVyLiBTZXQgd2hpbGUgdGhlIGZyYWdtZW50IGlzIGxvYWRpbmcsIGFuZCByZW1vdmVkIGFmdGVyd2FyZHMuIFVzZWQgdG8gYWJvcnQgZnJhZ21lbnQgbG9hZGluZ1xuICAgICAgX3RoaXMubG9hZGVyID0gbnVsbDtcbiAgICAgIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBrZXkgbG9hZGVyLiBTZXQgd2hpbGUgdGhlIGtleSBpcyBsb2FkaW5nLCBhbmQgcmVtb3ZlZCBhZnRlcndhcmRzLiBVc2VkIHRvIGFib3J0IGtleSBsb2FkaW5nXG4gICAgICBfdGhpcy5rZXlMb2FkZXIgPSBudWxsO1xuICAgICAgLy8gVGhlIGxldmVsL3RyYWNrIGluZGV4IHRvIHdoaWNoIHRoZSBmcmFnbWVudCBiZWxvbmdzXG4gICAgICBfdGhpcy5sZXZlbCA9IC0xO1xuICAgICAgLy8gVGhlIGNvbnRpbnVpdHkgY291bnRlciBvZiB0aGUgZnJhZ21lbnRcbiAgICAgIF90aGlzLmNjID0gMDtcbiAgICAgIC8vIFRoZSBzdGFydGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICAgIF90aGlzLnN0YXJ0UFRTID0gdm9pZCAwO1xuICAgICAgLy8gVGhlIGVuZGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICAgIF90aGlzLmVuZFBUUyA9IHZvaWQgMDtcbiAgICAgIC8vIFRoZSBzdGFydGluZyBEZWNvZGUgVGltZSBTdGFtcCAoRFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICAgIF90aGlzLnN0YXJ0RFRTID0gdm9pZCAwO1xuICAgICAgLy8gVGhlIGVuZGluZyBEZWNvZGUgVGltZSBTdGFtcCAoRFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICAgIF90aGlzLmVuZERUUyA9IHZvaWQgMDtcbiAgICAgIC8vIFRoZSBzdGFydCB0aW1lIG9mIHRoZSBmcmFnbWVudCwgYXMgbGlzdGVkIGluIHRoZSBtYW5pZmVzdC4gVXBkYXRlZCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICAgIF90aGlzLnN0YXJ0ID0gMDtcbiAgICAgIC8vIFNldCBieSBgdXBkYXRlRnJhZ1BUU0RUU2AgaW4gbGV2ZWwtaGVscGVyXG4gICAgICBfdGhpcy5kZWx0YVBUUyA9IHZvaWQgMDtcbiAgICAgIC8vIFRoZSBtYXhpbXVtIHN0YXJ0aW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChhdWRpby92aWRlbyBQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAgICAgX3RoaXMubWF4U3RhcnRQVFMgPSB2b2lkIDA7XG4gICAgICAvLyBUaGUgbWluaW11bSBlbmRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgICBfdGhpcy5taW5FbmRQVFMgPSB2b2lkIDA7XG4gICAgICAvLyBMb2FkL3BhcnNlIHRpbWluZyBpbmZvcm1hdGlvblxuICAgICAgX3RoaXMuc3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG4gICAgICAvLyBJbml0IFNlZ21lbnQgYnl0ZXMgKHVuc2V0IGZvciBtZWRpYSBzZWdtZW50cylcbiAgICAgIF90aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgICAvLyBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzZWdtZW50IHdhcyBkb3dubG9hZGVkIGluIG9yZGVyIHRvIHRlc3QgYml0cmF0ZSwgYW5kIHdhcyBub3QgYnVmZmVyZWRcbiAgICAgIF90aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgICAvLyAjRVhUSU5GICBzZWdtZW50IHRpdGxlXG4gICAgICBfdGhpcy50aXRsZSA9IG51bGw7XG4gICAgICAvLyBUaGUgTWVkaWEgSW5pdGlhbGl6YXRpb24gU2VjdGlvbiBmb3IgdGhpcyBzZWdtZW50XG4gICAgICBfdGhpcy5pbml0U2VnbWVudCA9IG51bGw7XG4gICAgICAvLyBGcmFnbWVudCBpcyB0aGUgbGFzdCBmcmFnbWVudCBpbiB0aGUgbWVkaWEgcGxheWxpc3RcbiAgICAgIF90aGlzLmVuZExpc3QgPSB2b2lkIDA7XG4gICAgICAvLyBGcmFnbWVudCBpcyBtYXJrZWQgYnkgYW4gRVhULVgtR0FQIHRhZyBpbmRpY2F0aW5nIHRoYXQgaXQgZG9lcyBub3QgY29udGFpbiBtZWRpYSBkYXRhIGFuZCBzaG91bGQgbm90IGJlIGxvYWRlZFxuICAgICAgX3RoaXMuZ2FwID0gdm9pZCAwO1xuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgX3RoaXMudXJsSWQgPSAwO1xuICAgICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8yID0gRnJhZ21lbnQucHJvdG90eXBlO1xuICAgIF9wcm90bzIuc2V0S2V5Rm9ybWF0ID0gZnVuY3Rpb24gc2V0S2V5Rm9ybWF0KGtleUZvcm1hdCkge1xuICAgICAgaWYgKHRoaXMubGV2ZWxrZXlzKSB7XG4gICAgICAgIHZhciBfa2V5ID0gdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0XTtcbiAgICAgICAgaWYgKF9rZXkgJiYgIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICAgICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBfa2V5LmdldERlY3J5cHREYXRhKHRoaXMuc24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8yLmFib3J0UmVxdWVzdHMgPSBmdW5jdGlvbiBhYm9ydFJlcXVlc3RzKCkge1xuICAgICAgdmFyIF90aGlzJGxvYWRlciwgX3RoaXMka2V5TG9hZGVyO1xuICAgICAgKF90aGlzJGxvYWRlciA9IHRoaXMubG9hZGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbG9hZGVyLmFib3J0KCk7XG4gICAgICAoX3RoaXMka2V5TG9hZGVyID0gdGhpcy5rZXlMb2FkZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRrZXlMb2FkZXIuYWJvcnQoKTtcbiAgICB9O1xuICAgIF9wcm90bzIuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8gPSBmdW5jdGlvbiBzZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyh0eXBlLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTLCBwYXJ0aWFsKSB7XG4gICAgICBpZiAocGFydGlhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHBhcnRpYWwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50YXJ5U3RyZWFtcyA9IHRoaXMuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICB2YXIgaW5mbyA9IGVsZW1lbnRhcnlTdHJlYW1zW3R5cGVdO1xuICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgIGVsZW1lbnRhcnlTdHJlYW1zW3R5cGVdID0ge1xuICAgICAgICAgIHN0YXJ0UFRTOiBzdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFM6IGVuZFBUUyxcbiAgICAgICAgICBzdGFydERUUzogc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTOiBlbmREVFMsXG4gICAgICAgICAgcGFydGlhbDogcGFydGlhbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpbmZvLnN0YXJ0UFRTID0gTWF0aC5taW4oaW5mby5zdGFydFBUUywgc3RhcnRQVFMpO1xuICAgICAgaW5mby5lbmRQVFMgPSBNYXRoLm1heChpbmZvLmVuZFBUUywgZW5kUFRTKTtcbiAgICAgIGluZm8uc3RhcnREVFMgPSBNYXRoLm1pbihpbmZvLnN0YXJ0RFRTLCBzdGFydERUUyk7XG4gICAgICBpbmZvLmVuZERUUyA9IE1hdGgubWF4KGluZm8uZW5kRFRTLCBlbmREVFMpO1xuICAgIH07XG4gICAgX3Byb3RvMi5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvID0gZnVuY3Rpb24gY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpIHtcbiAgICAgIHZhciBlbGVtZW50YXJ5U3RyZWFtcyA9IHRoaXMuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICBlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0gbnVsbDtcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10gPSBudWxsO1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dID0gbnVsbDtcbiAgICB9O1xuICAgIF9jcmVhdGVDbGFzcyhGcmFnbWVudCwgW3tcbiAgICAgIGtleTogXCJkZWNyeXB0ZGF0YVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBsZXZlbGtleXMgPSB0aGlzLmxldmVsa2V5cztcbiAgICAgICAgaWYgKCFsZXZlbGtleXMgJiYgIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9kZWNyeXB0ZGF0YSAmJiB0aGlzLmxldmVsa2V5cyAmJiAhdGhpcy5sZXZlbGtleXMuTk9ORSkge1xuICAgICAgICAgIHZhciBfa2V5MiA9IHRoaXMubGV2ZWxrZXlzLmlkZW50aXR5O1xuICAgICAgICAgIGlmIChfa2V5Mikge1xuICAgICAgICAgICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBfa2V5Mi5nZXREZWNyeXB0RGF0YSh0aGlzLnNuKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleUZvcm1hdHMgPSBPYmplY3Qua2V5cyh0aGlzLmxldmVsa2V5cyk7XG4gICAgICAgICAgICBpZiAoa2V5Rm9ybWF0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhID0gdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0c1swXV0uZ2V0RGVjcnlwdERhdGEodGhpcy5zbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNyeXB0ZGF0YTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZW5kXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbmRQcm9ncmFtRGF0ZVRpbWVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5wcm9ncmFtRGF0ZVRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKHRoaXMucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkdXJhdGlvbiA9ICFpc0Zpbml0ZU51bWJlcih0aGlzLmR1cmF0aW9uKSA/IDAgOiB0aGlzLmR1cmF0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9ncmFtRGF0ZVRpbWUgKyBkdXJhdGlvbiAqIDEwMDA7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVuY3J5cHRlZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyRfZGVjcnlwdGRhdGE7XG4gICAgICAgIC8vIEF0IHRoZSBtM3U4LXBhcnNlciBsZXZlbCB3ZSBuZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtYW5pZmVzdCBzaWduYWxsZWQga2V5Zm9ybWF0c1xuICAgICAgICAvLyB3aGVuIHdlIHdhbnQgdGhlIGZyYWdtZW50IHRvIHN0YXJ0IHJlcG9ydGluZyB0aGF0IGl0IGlzIGVuY3J5cHRlZC5cbiAgICAgICAgLy8gQ3VycmVudGx5LCBrZXlGb3JtYXQgd2lsbCBvbmx5IGJlIHNldCBmb3IgaWRlbnRpdHkga2V5c1xuICAgICAgICBpZiAoKF90aGlzJF9kZWNyeXB0ZGF0YSA9IHRoaXMuX2RlY3J5cHRkYXRhKSAhPSBudWxsICYmIF90aGlzJF9kZWNyeXB0ZGF0YS5lbmNyeXB0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxldmVsa2V5cykge1xuICAgICAgICAgIHZhciBrZXlGb3JtYXRzID0gT2JqZWN0LmtleXModGhpcy5sZXZlbGtleXMpO1xuICAgICAgICAgIHZhciBsZW4gPSBrZXlGb3JtYXRzLmxlbmd0aDtcbiAgICAgICAgICBpZiAobGVuID4gMSB8fCBsZW4gPT09IDEgJiYgdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0c1swXV0uZW5jcnlwdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gRnJhZ21lbnQ7XG4gIH0oQmFzZVNlZ21lbnQpO1xuXG4gIC8qKlxuICAgKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIFBhcnRpYWwgU2VnbWVudC4gRm91bmQgaW4ge0BsaW5rIGhscy5qcyNMZXZlbERldGFpbHMucGFydExpc3R9LlxuICAgKi9cbiAgdmFyIFBhcnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlU2VnbWVudDIpIHtcbiAgICBfaW5oZXJpdHNMb29zZShQYXJ0LCBfQmFzZVNlZ21lbnQyKTtcbiAgICBmdW5jdGlvbiBQYXJ0KHBhcnRBdHRycywgZnJhZywgYmFzZXVybCwgaW5kZXgsIHByZXZpb3VzKSB7XG4gICAgICB2YXIgX3RoaXMyO1xuICAgICAgX3RoaXMyID0gX0Jhc2VTZWdtZW50Mi5jYWxsKHRoaXMsIGJhc2V1cmwpIHx8IHRoaXM7XG4gICAgICBfdGhpczIuZnJhZ09mZnNldCA9IDA7XG4gICAgICBfdGhpczIuZHVyYXRpb24gPSAwO1xuICAgICAgX3RoaXMyLmdhcCA9IGZhbHNlO1xuICAgICAgX3RoaXMyLmluZGVwZW5kZW50ID0gZmFsc2U7XG4gICAgICBfdGhpczIucmVsdXJsID0gdm9pZCAwO1xuICAgICAgX3RoaXMyLmZyYWdtZW50ID0gdm9pZCAwO1xuICAgICAgX3RoaXMyLmluZGV4ID0gdm9pZCAwO1xuICAgICAgX3RoaXMyLnN0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICAgICAgX3RoaXMyLmR1cmF0aW9uID0gcGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdEVVJBVElPTicpO1xuICAgICAgX3RoaXMyLmdhcCA9IHBhcnRBdHRycy5ib29sKCdHQVAnKTtcbiAgICAgIF90aGlzMi5pbmRlcGVuZGVudCA9IHBhcnRBdHRycy5ib29sKCdJTkRFUEVOREVOVCcpO1xuICAgICAgX3RoaXMyLnJlbHVybCA9IHBhcnRBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdVUkknKTtcbiAgICAgIF90aGlzMi5mcmFnbWVudCA9IGZyYWc7XG4gICAgICBfdGhpczIuaW5kZXggPSBpbmRleDtcbiAgICAgIHZhciBieXRlUmFuZ2UgPSBwYXJ0QXR0cnMuZW51bWVyYXRlZFN0cmluZygnQllURVJBTkdFJyk7XG4gICAgICBpZiAoYnl0ZVJhbmdlKSB7XG4gICAgICAgIF90aGlzMi5zZXRCeXRlUmFuZ2UoYnl0ZVJhbmdlLCBwcmV2aW91cyk7XG4gICAgICB9XG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgX3RoaXMyLmZyYWdPZmZzZXQgPSBwcmV2aW91cy5mcmFnT2Zmc2V0ICsgcHJldmlvdXMuZHVyYXRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXMyO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoUGFydCwgW3tcbiAgICAgIGtleTogXCJzdGFydFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50LnN0YXJ0ICsgdGhpcy5mcmFnT2Zmc2V0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlbmRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxvYWRlZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBlbGVtZW50YXJ5U3RyZWFtcyA9IHRoaXMuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICAgIHJldHVybiAhIShlbGVtZW50YXJ5U3RyZWFtcy5hdWRpbyB8fCBlbGVtZW50YXJ5U3RyZWFtcy52aWRlbyB8fCBlbGVtZW50YXJ5U3RyZWFtcy5hdWRpb3ZpZGVvKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFBhcnQ7XG4gIH0oQmFzZVNlZ21lbnQpO1xuXG4gIHZhciBERUZBVUxUX1RBUkdFVF9EVVJBVElPTiA9IDEwO1xuXG4gIC8qKlxuICAgKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIE1lZGlhIFBsYXlsaXN0LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsLmRldGFpbHN9LlxuICAgKi9cbiAgdmFyIExldmVsRGV0YWlscyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGV2ZWxEZXRhaWxzKGJhc2VVcmwpIHtcbiAgICAgIHRoaXMuUFRTS25vd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuYWxpZ25lZFNsaWRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9uID0gdm9pZCAwO1xuICAgICAgdGhpcy5lbmRDQyA9IDA7XG4gICAgICB0aGlzLmVuZFNOID0gMDtcbiAgICAgIHRoaXMuZnJhZ21lbnRzID0gdm9pZCAwO1xuICAgICAgdGhpcy5mcmFnbWVudEhpbnQgPSB2b2lkIDA7XG4gICAgICB0aGlzLnBhcnRMaXN0ID0gbnVsbDtcbiAgICAgIHRoaXMuZGF0ZVJhbmdlcyA9IHZvaWQgMDtcbiAgICAgIHRoaXMubGl2ZSA9IHRydWU7XG4gICAgICB0aGlzLmFnZUhlYWRlciA9IDA7XG4gICAgICB0aGlzLmFkdmFuY2VkRGF0ZVRpbWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLnVwZGF0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5hZHZhbmNlZCA9IHRydWU7XG4gICAgICB0aGlzLmF2YWlsYWJpbGl0eURlbGF5ID0gdm9pZCAwO1xuICAgICAgLy8gTWFuaWZlc3QgcmVsb2FkIHN5bmNocm9uaXphdGlvblxuICAgICAgdGhpcy5taXNzZXMgPSAwO1xuICAgICAgdGhpcy5zdGFydENDID0gMDtcbiAgICAgIHRoaXMuc3RhcnRTTiA9IDA7XG4gICAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IG51bGw7XG4gICAgICB0aGlzLnRhcmdldGR1cmF0aW9uID0gMDtcbiAgICAgIHRoaXMudG90YWxkdXJhdGlvbiA9IDA7XG4gICAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgICAgdGhpcy51cmwgPSB2b2lkIDA7XG4gICAgICB0aGlzLm0zdTggPSAnJztcbiAgICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgICB0aGlzLmNhbkJsb2NrUmVsb2FkID0gZmFsc2U7XG4gICAgICB0aGlzLmNhblNraXBVbnRpbCA9IDA7XG4gICAgICB0aGlzLmNhblNraXBEYXRlUmFuZ2VzID0gZmFsc2U7XG4gICAgICB0aGlzLnNraXBwZWRTZWdtZW50cyA9IDA7XG4gICAgICB0aGlzLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSB2b2lkIDA7XG4gICAgICB0aGlzLnBhcnRIb2xkQmFjayA9IDA7XG4gICAgICB0aGlzLmhvbGRCYWNrID0gMDtcbiAgICAgIHRoaXMucGFydFRhcmdldCA9IDA7XG4gICAgICB0aGlzLnByZWxvYWRIaW50ID0gdm9pZCAwO1xuICAgICAgdGhpcy5yZW5kaXRpb25SZXBvcnRzID0gdm9pZCAwO1xuICAgICAgdGhpcy50dW5lSW5Hb2FsID0gMDtcbiAgICAgIHRoaXMuZGVsdGFVcGRhdGVGYWlsZWQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmRyaWZ0U3RhcnRUaW1lID0gMDtcbiAgICAgIHRoaXMuZHJpZnRFbmRUaW1lID0gMDtcbiAgICAgIHRoaXMuZHJpZnRTdGFydCA9IDA7XG4gICAgICB0aGlzLmRyaWZ0RW5kID0gMDtcbiAgICAgIHRoaXMuZW5jcnlwdGVkRnJhZ21lbnRzID0gdm9pZCAwO1xuICAgICAgdGhpcy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG51bGw7XG4gICAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IG51bGw7XG4gICAgICB0aGlzLmhhc1ZhcmlhYmxlUmVmcyA9IGZhbHNlO1xuICAgICAgdGhpcy5mcmFnbWVudHMgPSBbXTtcbiAgICAgIHRoaXMuZW5jcnlwdGVkRnJhZ21lbnRzID0gW107XG4gICAgICB0aGlzLmRhdGVSYW5nZXMgPSB7fTtcbiAgICAgIHRoaXMudXJsID0gYmFzZVVybDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IExldmVsRGV0YWlscy5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnJlbG9hZGVkID0gZnVuY3Rpb24gcmVsb2FkZWQocHJldmlvdXMpIHtcbiAgICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJ0U25EaWZmID0gdGhpcy5sYXN0UGFydFNuIC0gcHJldmlvdXMubGFzdFBhcnRTbjtcbiAgICAgIHZhciBwYXJ0SW5kZXhEaWZmID0gdGhpcy5sYXN0UGFydEluZGV4IC0gcHJldmlvdXMubGFzdFBhcnRJbmRleDtcbiAgICAgIHRoaXMudXBkYXRlZCA9IHRoaXMuZW5kU04gIT09IHByZXZpb3VzLmVuZFNOIHx8ICEhcGFydEluZGV4RGlmZiB8fCAhIXBhcnRTbkRpZmYgfHwgIXRoaXMubGl2ZTtcbiAgICAgIHRoaXMuYWR2YW5jZWQgPSB0aGlzLmVuZFNOID4gcHJldmlvdXMuZW5kU04gfHwgcGFydFNuRGlmZiA+IDAgfHwgcGFydFNuRGlmZiA9PT0gMCAmJiBwYXJ0SW5kZXhEaWZmID4gMDtcbiAgICAgIGlmICh0aGlzLnVwZGF0ZWQgfHwgdGhpcy5hZHZhbmNlZCkge1xuICAgICAgICB0aGlzLm1pc3NlcyA9IE1hdGguZmxvb3IocHJldmlvdXMubWlzc2VzICogMC42KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWlzc2VzID0gcHJldmlvdXMubWlzc2VzICsgMTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXZhaWxhYmlsaXR5RGVsYXkgPSBwcmV2aW91cy5hdmFpbGFiaWxpdHlEZWxheTtcbiAgICB9O1xuICAgIF9jcmVhdGVDbGFzcyhMZXZlbERldGFpbHMsIFt7XG4gICAgICBrZXk6IFwiaGFzUHJvZ3JhbURhdGVUaW1lXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBpc0Zpbml0ZU51bWJlcih0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5wcm9ncmFtRGF0ZVRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibGV2ZWxUYXJnZXREdXJhdGlvblwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiB8fCB0aGlzLnRhcmdldGR1cmF0aW9uIHx8IERFRkFVTFRfVEFSR0VUX0RVUkFUSU9OO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkcmlmdFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBydW5UaW1lID0gdGhpcy5kcmlmdEVuZFRpbWUgLSB0aGlzLmRyaWZ0U3RhcnRUaW1lO1xuICAgICAgICBpZiAocnVuVGltZSA+IDApIHtcbiAgICAgICAgICB2YXIgcnVuRHVyYXRpb24gPSB0aGlzLmRyaWZ0RW5kIC0gdGhpcy5kcmlmdFN0YXJ0O1xuICAgICAgICAgIHJldHVybiBydW5EdXJhdGlvbiAqIDEwMDAgLyBydW5UaW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlZGdlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydEVuZCB8fCB0aGlzLmZyYWdtZW50RW5kO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwYXJ0RW5kXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIF90aGlzJHBhcnRMaXN0O1xuICAgICAgICBpZiAoKF90aGlzJHBhcnRMaXN0ID0gdGhpcy5wYXJ0TGlzdCkgIT0gbnVsbCAmJiBfdGhpcyRwYXJ0TGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudEVuZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZnJhZ21lbnRFbmRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMkZnJhZ21lbnRzO1xuICAgICAgICBpZiAoKF90aGlzJGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzKSAhPSBudWxsICYmIF90aGlzJGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZ2VcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5hZHZhbmNlZERhdGVUaW1lKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KERhdGUubm93KCkgLSB0aGlzLmFkdmFuY2VkRGF0ZVRpbWUsIDApIC8gMTAwMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibGFzdFBhcnRJbmRleFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyRwYXJ0TGlzdDI7XG4gICAgICAgIGlmICgoX3RoaXMkcGFydExpc3QyID0gdGhpcy5wYXJ0TGlzdCkgIT0gbnVsbCAmJiBfdGhpcyRwYXJ0TGlzdDIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGggLSAxXS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImxhc3RQYXJ0U25cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMkcGFydExpc3QzO1xuICAgICAgICBpZiAoKF90aGlzJHBhcnRMaXN0MyA9IHRoaXMucGFydExpc3QpICE9IG51bGwgJiYgX3RoaXMkcGFydExpc3QzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uZnJhZ21lbnQuc247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kU047XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBMZXZlbERldGFpbHM7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBiYXNlNjREZWNvZGUoYmFzZTY0ZW5jb2RlZFN0cikge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYXRvYihiYXNlNjRlbmNvZGVkU3RyKSwgZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRLZXlJZEJ5dGVzKHN0cikge1xuICAgIHZhciBrZXlJZGJ5dGVzID0gc3RyVG9VdGY4YXJyYXkoc3RyKS5zdWJhcnJheSgwLCAxNik7XG4gICAgdmFyIHBhZGRlZGtleUlkYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgcGFkZGVka2V5SWRieXRlcy5zZXQoa2V5SWRieXRlcywgMTYgLSBrZXlJZGJ5dGVzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHBhZGRlZGtleUlkYnl0ZXM7XG4gIH1cbiAgZnVuY3Rpb24gY2hhbmdlRW5kaWFubmVzcyhrZXlJZCkge1xuICAgIHZhciBzd2FwID0gZnVuY3Rpb24gc3dhcChhcnJheSwgZnJvbSwgdG8pIHtcbiAgICAgIHZhciBjdXIgPSBhcnJheVtmcm9tXTtcbiAgICAgIGFycmF5W2Zyb21dID0gYXJyYXlbdG9dO1xuICAgICAgYXJyYXlbdG9dID0gY3VyO1xuICAgIH07XG4gICAgc3dhcChrZXlJZCwgMCwgMyk7XG4gICAgc3dhcChrZXlJZCwgMSwgMik7XG4gICAgc3dhcChrZXlJZCwgNCwgNSk7XG4gICAgc3dhcChrZXlJZCwgNiwgNyk7XG4gIH1cbiAgZnVuY3Rpb24gY29udmVydERhdGFVcmlUb0FycmF5Qnl0ZXModXJpKSB7XG4gICAgLy8gZGF0YTpbPG1lZGlhIHR5cGVdWzthdHRyaWJ1dGU9dmFsdWVdWztiYXNlNjRdLDxkYXRhPlxuICAgIHZhciBjb2xvbnNwbGl0ID0gdXJpLnNwbGl0KCc6Jyk7XG4gICAgdmFyIGtleWRhdGEgPSBudWxsO1xuICAgIGlmIChjb2xvbnNwbGl0WzBdID09PSAnZGF0YScgJiYgY29sb25zcGxpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBzZW1pY29sb25zcGxpdCA9IGNvbG9uc3BsaXRbMV0uc3BsaXQoJzsnKTtcbiAgICAgIHZhciBjb21tYXNwbGl0ID0gc2VtaWNvbG9uc3BsaXRbc2VtaWNvbG9uc3BsaXQubGVuZ3RoIC0gMV0uc3BsaXQoJywnKTtcbiAgICAgIGlmIChjb21tYXNwbGl0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB2YXIgaXNiYXNlNjQgPSBjb21tYXNwbGl0WzBdID09PSAnYmFzZTY0JztcbiAgICAgICAgdmFyIGRhdGEgPSBjb21tYXNwbGl0WzFdO1xuICAgICAgICBpZiAoaXNiYXNlNjQpIHtcbiAgICAgICAgICBzZW1pY29sb25zcGxpdC5zcGxpY2UoLTEsIDEpOyAvLyByZW1vdmUgZnJvbSBwcm9jZXNzaW5nXG4gICAgICAgICAga2V5ZGF0YSA9IGJhc2U2NERlY29kZShkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXlkYXRhID0gZ2V0S2V5SWRCeXRlcyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5ZGF0YTtcbiAgfVxuICBmdW5jdGlvbiBzdHJUb1V0ZjhhcnJheShzdHIpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSwgZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogcmV0dXJucyBgdW5kZWZpbmVkYCBpcyBgc2VsZmAgaXMgbWlzc2luZywgZS5nLiBpbiBub2RlICovXG4gIHZhciBvcHRpb25hbFNlbGYgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9OYXZpZ2F0b3IvcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzXG4gICAqL1xuICB2YXIgS2V5U3lzdGVtcyA9IHtcbiAgICBDTEVBUktFWTogXCJvcmcudzMuY2xlYXJrZXlcIixcbiAgICBGQUlSUExBWTogXCJjb20uYXBwbGUuZnBzXCIsXG4gICAgUExBWVJFQURZOiBcImNvbS5taWNyb3NvZnQucGxheXJlYWR5XCIsXG4gICAgV0lERVZJTkU6IFwiY29tLndpZGV2aW5lLmFscGhhXCJcbiAgfTtcblxuICAvLyBQbGF5bGlzdCAjRVhULVgtS0VZIEtFWUZPUk1BVCB2YWx1ZXNcbiAgdmFyIEtleVN5c3RlbUZvcm1hdHMgPSB7XG4gICAgQ0xFQVJLRVk6IFwib3JnLnczLmNsZWFya2V5XCIsXG4gICAgRkFJUlBMQVk6IFwiY29tLmFwcGxlLnN0cmVhbWluZ2tleWRlbGl2ZXJ5XCIsXG4gICAgUExBWVJFQURZOiBcImNvbS5taWNyb3NvZnQucGxheXJlYWR5XCIsXG4gICAgV0lERVZJTkU6IFwidXJuOnV1aWQ6ZWRlZjhiYTktNzlkNi00YWNlLWEzYzgtMjdkY2Q1MWQyMWVkXCJcbiAgfTtcbiAgZnVuY3Rpb24ga2V5U3lzdGVtRm9ybWF0VG9LZXlTeXN0ZW1Eb21haW4oZm9ybWF0KSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTpcbiAgICAgICAgcmV0dXJuIEtleVN5c3RlbXMuRkFJUlBMQVk7XG4gICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZOlxuICAgICAgICByZXR1cm4gS2V5U3lzdGVtcy5QTEFZUkVBRFk7XG4gICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuV0lERVZJTkU6XG4gICAgICAgIHJldHVybiBLZXlTeXN0ZW1zLldJREVWSU5FO1xuICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZOlxuICAgICAgICByZXR1cm4gS2V5U3lzdGVtcy5DTEVBUktFWTtcbiAgICB9XG4gIH1cblxuICAvLyBTeXN0ZW0gSURzIGZvciB3aGljaCB3ZSBjYW4gZXh0cmFjdCBhIGtleSBJRCBmcm9tIFwiZW5jcnlwdGVkXCIgZXZlbnQgUFNTSFxuICB2YXIgS2V5U3lzdGVtSWRzID0ge1xuICAgIENFTkM6IFwiMTA3N2VmZWNjMGIyNGQwMmFjZTMzYzFlNTJlMmZiNGJcIixcbiAgICBDTEVBUktFWTogXCJlMjcxOWQ1OGE5ODViM2M5NzgxYWIwMzBhZjc4ZDMwZVwiLFxuICAgIEZBSVJQTEFZOiBcIjk0Y2U4NmZiMDdmZjRmNDNhZGI4OTNkMmZhOTY4Y2EyXCIsXG4gICAgUExBWVJFQURZOiBcIjlhMDRmMDc5OTg0MDQyODZhYjkyZTY1YmUwODg1Zjk1XCIsXG4gICAgV0lERVZJTkU6IFwiZWRlZjhiYTk3OWQ2NGFjZWEzYzgyN2RjZDUxZDIxZWRcIlxuICB9O1xuICBmdW5jdGlvbiBrZXlTeXN0ZW1JZFRvS2V5U3lzdGVtRG9tYWluKHN5c3RlbUlkKSB7XG4gICAgaWYgKHN5c3RlbUlkID09PSBLZXlTeXN0ZW1JZHMuV0lERVZJTkUpIHtcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1zLldJREVWSU5FO1xuICAgIH0gZWxzZSBpZiAoc3lzdGVtSWQgPT09IEtleVN5c3RlbUlkcy5QTEFZUkVBRFkpIHtcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1zLlBMQVlSRUFEWTtcbiAgICB9IGVsc2UgaWYgKHN5c3RlbUlkID09PSBLZXlTeXN0ZW1JZHMuQ0VOQyB8fCBzeXN0ZW1JZCA9PT0gS2V5U3lzdGVtSWRzLkNMRUFSS0VZKSB7XG4gICAgICByZXR1cm4gS2V5U3lzdGVtcy5DTEVBUktFWTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24ga2V5U3lzdGVtRG9tYWluVG9LZXlTeXN0ZW1Gb3JtYXQoa2V5U3lzdGVtKSB7XG4gICAgc3dpdGNoIChrZXlTeXN0ZW0pIHtcbiAgICAgIGNhc2UgS2V5U3lzdGVtcy5GQUlSUExBWTpcbiAgICAgICAgcmV0dXJuIEtleVN5c3RlbUZvcm1hdHMuRkFJUlBMQVk7XG4gICAgICBjYXNlIEtleVN5c3RlbXMuUExBWVJFQURZOlxuICAgICAgICByZXR1cm4gS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk7XG4gICAgICBjYXNlIEtleVN5c3RlbXMuV0lERVZJTkU6XG4gICAgICAgIHJldHVybiBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FO1xuICAgICAgY2FzZSBLZXlTeXN0ZW1zLkNMRUFSS0VZOlxuICAgICAgICByZXR1cm4gS2V5U3lzdGVtRm9ybWF0cy5DTEVBUktFWTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0S2V5U3lzdGVtc0ZvckNvbmZpZyhjb25maWcpIHtcbiAgICB2YXIgZHJtU3lzdGVtcyA9IGNvbmZpZy5kcm1TeXN0ZW1zLFxuICAgICAgd2lkZXZpbmVMaWNlbnNlVXJsID0gY29uZmlnLndpZGV2aW5lTGljZW5zZVVybDtcbiAgICB2YXIga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGRybVN5c3RlbXMgPyBbS2V5U3lzdGVtcy5GQUlSUExBWSwgS2V5U3lzdGVtcy5XSURFVklORSwgS2V5U3lzdGVtcy5QTEFZUkVBRFksIEtleVN5c3RlbXMuQ0xFQVJLRVldLmZpbHRlcihmdW5jdGlvbiAoa2V5U3lzdGVtKSB7XG4gICAgICByZXR1cm4gISFkcm1TeXN0ZW1zW2tleVN5c3RlbV07XG4gICAgfSkgOiBbXTtcbiAgICBpZiAoIWtleVN5c3RlbXNUb0F0dGVtcHRbS2V5U3lzdGVtcy5XSURFVklORV0gJiYgd2lkZXZpbmVMaWNlbnNlVXJsKSB7XG4gICAgICBrZXlTeXN0ZW1zVG9BdHRlbXB0LnB1c2goS2V5U3lzdGVtcy5XSURFVklORSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlTeXN0ZW1zVG9BdHRlbXB0O1xuICB9XG4gIHZhciByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSBmdW5jdGlvbiAoX29wdGlvbmFsU2VsZiRuYXZpZ2F0KSB7XG4gICAgaWYgKG9wdGlvbmFsU2VsZiAhPSBudWxsICYmIChfb3B0aW9uYWxTZWxmJG5hdmlnYXQgPSBvcHRpb25hbFNlbGYubmF2aWdhdG9yKSAhPSBudWxsICYmIF9vcHRpb25hbFNlbGYkbmF2aWdhdC5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MpIHtcbiAgICAgIHJldHVybiBzZWxmLm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MuYmluZChzZWxmLm5hdmlnYXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIGdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpIHtcbiAgICB2YXIgaW5pdERhdGFUeXBlcztcbiAgICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgICAgY2FzZSBLZXlTeXN0ZW1zLkZBSVJQTEFZOlxuICAgICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJywgJ3NpbmYnXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtleVN5c3RlbXMuV0lERVZJTkU6XG4gICAgICBjYXNlIEtleVN5c3RlbXMuUExBWVJFQURZOlxuICAgICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJ107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZXlTeXN0ZW1zLkNMRUFSS0VZOlxuICAgICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJywgJ2tleWlkcyddO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24ga2V5LXN5c3RlbTogXCIgKyBrZXlTeXN0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhpbml0RGF0YVR5cGVzLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoaW5pdERhdGFUeXBlcywgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCBkcm1TeXN0ZW1PcHRpb25zKSB7XG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICBpbml0RGF0YVR5cGVzOiBpbml0RGF0YVR5cGVzLFxuICAgICAgcGVyc2lzdGVudFN0YXRlOiBkcm1TeXN0ZW1PcHRpb25zLnBlcnNpc3RlbnRTdGF0ZSB8fCAnb3B0aW9uYWwnLFxuICAgICAgZGlzdGluY3RpdmVJZGVudGlmaWVyOiBkcm1TeXN0ZW1PcHRpb25zLmRpc3RpbmN0aXZlSWRlbnRpZmllciB8fCAnb3B0aW9uYWwnLFxuICAgICAgc2Vzc2lvblR5cGVzOiBkcm1TeXN0ZW1PcHRpb25zLnNlc3Npb25UeXBlcyB8fCBbZHJtU3lzdGVtT3B0aW9ucy5zZXNzaW9uVHlwZSB8fCAndGVtcG9yYXJ5J10sXG4gICAgICBhdWRpb0NhcGFiaWxpdGllczogYXVkaW9Db2RlY3MubWFwKGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImF1ZGlvL21wNDsgY29kZWNzPVxcXCJcIiArIGNvZGVjICsgXCJcXFwiXCIsXG4gICAgICAgICAgcm9idXN0bmVzczogZHJtU3lzdGVtT3B0aW9ucy5hdWRpb1JvYnVzdG5lc3MgfHwgJycsXG4gICAgICAgICAgZW5jcnlwdGlvblNjaGVtZTogZHJtU3lzdGVtT3B0aW9ucy5hdWRpb0VuY3J5cHRpb25TY2hlbWUgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICB2aWRlb0NhcGFiaWxpdGllczogdmlkZW9Db2RlY3MubWFwKGZ1bmN0aW9uIChjb2RlYykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRlbnRUeXBlOiBcInZpZGVvL21wNDsgY29kZWNzPVxcXCJcIiArIGNvZGVjICsgXCJcXFwiXCIsXG4gICAgICAgICAgcm9idXN0bmVzczogZHJtU3lzdGVtT3B0aW9ucy52aWRlb1JvYnVzdG5lc3MgfHwgJycsXG4gICAgICAgICAgZW5jcnlwdGlvblNjaGVtZTogZHJtU3lzdGVtT3B0aW9ucy52aWRlb0VuY3J5cHRpb25TY2hlbWUgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9O1xuICAgIHJldHVybiBbYmFzZUNvbmZpZ107XG4gIH1cblxuICBmdW5jdGlvbiBzbGljZVVpbnQ4KGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUaGlzIHBvbHlmaWxscyBJRTExIHVzYWdlIG9mIFVpbnQ4QXJyYXkgc2xpY2UuXG4gICAgLy8gSXQgYWx3YXlzIGV4aXN0cyBpbiB0aGUgVHlwZVNjcmlwdCBkZWZpbml0aW9uIHNvIGZhaWxzLCBidXQgaXQgZmFpbHMgYXQgcnVudGltZSBvbiBJRTExLlxuICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZSA/IGFycmF5LnNsaWNlKHN0YXJ0LCBlbmQpIDogbmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKTtcbiAgfVxuXG4gIC8vIGJyZWFraW5nIHVwIHRob3NlIHR3byB0eXBlcyBpbiBvcmRlciB0byBjbGFyaWZ5IHdoYXQgaXMgaGFwcGVuaW5nIGluIHRoZSBkZWNvZGluZyBwYXRoLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYW4gSUQzIGhlYWRlciBjYW4gYmUgZm91bmQgYXQgb2Zmc2V0IGluIGRhdGFcbiAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2hcbiAgICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAqL1xuICB2YXIgaXNIZWFkZXIkMiA9IGZ1bmN0aW9uIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAgIC8qXG4gICAgICogaHR0cDovL2lkMy5vcmcvaWQzdjIuMy4wXG4gICAgICogWzBdICAgICA9ICdJJ1xuICAgICAqIFsxXSAgICAgPSAnRCdcbiAgICAgKiBbMl0gICAgID0gJzMnXG4gICAgICogWzMsNF0gICA9IHtWZXJzaW9ufVxuICAgICAqIFs1XSAgICAgPSB7RmxhZ3N9XG4gICAgICogWzYtOV0gICA9IHtJRDMgU2l6ZX1cbiAgICAgKlxuICAgICAqIEFuIElEM3YyIHRhZyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG4gICAgICogICQ0OSA0NCAzMyB5eSB5eSB4eCB6eiB6eiB6eiB6elxuICAgICAqIFdoZXJlIHl5IGlzIGxlc3MgdGhhbiAkRkYsIHh4IGlzIHRoZSAnZmxhZ3MnIGJ5dGUgYW5kIHp6IGlzIGxlc3MgdGhhbiAkODBcbiAgICAgKi9cbiAgICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIGxvb2sgZm9yICdJRDMnIGlkZW50aWZpZXJcbiAgICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4NDkgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCArIDJdID09PSAweDMzKSB7XG4gICAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhmZiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhmZikge1xuICAgICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOV0gPCAweDgwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYW4gSUQzIGZvb3RlciBjYW4gYmUgZm91bmQgYXQgb2Zmc2V0IGluIGRhdGFcbiAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2hcbiAgICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAqL1xuICB2YXIgaXNGb290ZXIgPSBmdW5jdGlvbiBpc0Zvb3RlcihkYXRhLCBvZmZzZXQpIHtcbiAgICAvKlxuICAgICAqIFRoZSBmb290ZXIgaXMgYSBjb3B5IG9mIHRoZSBoZWFkZXIsIGJ1dCB3aXRoIGEgZGlmZmVyZW50IGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIGxvb2sgZm9yICczREknIGlkZW50aWZpZXJcbiAgICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4MzMgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCArIDJdID09PSAweDQ5KSB7XG4gICAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhmZiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhmZikge1xuICAgICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOV0gPCAweDgwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFueSBhZGphY2VudCBJRDMgdGFncyBmb3VuZCBpbiBkYXRhIHN0YXJ0aW5nIGF0IG9mZnNldCwgYXMgb25lIGJsb2NrIG9mIGRhdGFcbiAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAgICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gICAqIEByZXR1cm5zIHRoZSBibG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgYW55IElEMyB0YWdzIGZvdW5kXG4gICAqIG9yICp1bmRlZmluZWQqIGlmIG5vIGhlYWRlciBpcyBmb3VuZCBhdCB0aGUgc3RhcnRpbmcgb2Zmc2V0XG4gICAqL1xuICB2YXIgZ2V0SUQzRGF0YSA9IGZ1bmN0aW9uIGdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KSB7XG4gICAgdmFyIGZyb250ID0gb2Zmc2V0O1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHdoaWxlIChpc0hlYWRlciQyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgIC8vIElEMyBoZWFkZXIgaXMgMTAgYnl0ZXNcbiAgICAgIGxlbmd0aCArPSAxMDtcbiAgICAgIHZhciBzaXplID0gcmVhZFNpemUoZGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgICBsZW5ndGggKz0gc2l6ZTtcbiAgICAgIGlmIChpc0Zvb3RlcihkYXRhLCBvZmZzZXQgKyAxMCkpIHtcbiAgICAgICAgLy8gSUQzIGZvb3RlciBpcyAxMCBieXRlc1xuICAgICAgICBsZW5ndGggKz0gMTA7XG4gICAgICB9XG4gICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGRhdGEuc3ViYXJyYXkoZnJvbnQsIGZyb250ICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcbiAgdmFyIHJlYWRTaXplID0gZnVuY3Rpb24gcmVhZFNpemUoZGF0YSwgb2Zmc2V0KSB7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIHNpemUgPSAoZGF0YVtvZmZzZXRdICYgMHg3ZikgPDwgMjE7XG4gICAgc2l6ZSB8PSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4N2YpIDw8IDE0O1xuICAgIHNpemUgfD0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDdmKSA8PCA3O1xuICAgIHNpemUgfD0gZGF0YVtvZmZzZXQgKyAzXSAmIDB4N2Y7XG4gICAgcmV0dXJuIHNpemU7XG4gIH07XG4gIHZhciBjYW5QYXJzZSQyID0gZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGlzSGVhZGVyJDIoZGF0YSwgb2Zmc2V0KSAmJiByZWFkU2l6ZShkYXRhLCBvZmZzZXQgKyA2KSArIDEwIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgdGhlIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmb3VuZCBpbiB0aGUgSUQzIGRhdGEgY2h1bmtcbiAgICogQHBhcmFtIGRhdGEgLSBCbG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgSUQzIHRhZ3NcbiAgICovXG4gIHZhciBnZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiBnZXRUaW1lU3RhbXAoZGF0YSkge1xuICAgIHZhciBmcmFtZXMgPSBnZXRJRDNGcmFtZXMoZGF0YSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmcmFtZSA9IGZyYW1lc1tpXTtcbiAgICAgIGlmIChpc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSkge1xuICAgICAgICByZXR1cm4gcmVhZFRpbWVTdGFtcChmcmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxuICAgKi9cbiAgdmFyIGlzVGltZVN0YW1wRnJhbWUgPSBmdW5jdGlvbiBpc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSB7XG4gICAgcmV0dXJuIGZyYW1lICYmIGZyYW1lLmtleSA9PT0gJ1BSSVYnICYmIGZyYW1lLmluZm8gPT09ICdjb20uYXBwbGUuc3RyZWFtaW5nLnRyYW5zcG9ydFN0cmVhbVRpbWVzdGFtcCc7XG4gIH07XG4gIHZhciBnZXRGcmFtZURhdGEgPSBmdW5jdGlvbiBnZXRGcmFtZURhdGEoZGF0YSkge1xuICAgIC8qXG4gICAgRnJhbWUgSUQgICAgICAgJHh4IHh4IHh4IHh4IChmb3VyIGNoYXJhY3RlcnMpXG4gICAgU2l6ZSAgICAgICAgICAgJHh4IHh4IHh4IHh4XG4gICAgRmxhZ3MgICAgICAgICAgJHh4IHh4XG4gICAgKi9cbiAgICB2YXIgdHlwZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSk7XG4gICAgdmFyIHNpemUgPSByZWFkU2l6ZShkYXRhLCA0KTtcblxuICAgIC8vIHNraXAgZnJhbWUgaWQsIHNpemUsIGFuZCBmbGFnc1xuICAgIHZhciBvZmZzZXQgPSAxMDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBkYXRhOiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSlcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIElEMyBmcmFtZXMgZm91bmQgaW4gYWxsIHRoZSBJRDMgdGFncyBpbiB0aGUgaWQzRGF0YVxuICAgKiBAcGFyYW0gaWQzRGF0YSAtIFRoZSBJRDMgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gICAqL1xuICB2YXIgZ2V0SUQzRnJhbWVzID0gZnVuY3Rpb24gZ2V0SUQzRnJhbWVzKGlkM0RhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgZnJhbWVzID0gW107XG4gICAgd2hpbGUgKGlzSGVhZGVyJDIoaWQzRGF0YSwgb2Zmc2V0KSkge1xuICAgICAgdmFyIHNpemUgPSByZWFkU2l6ZShpZDNEYXRhLCBvZmZzZXQgKyA2KTtcbiAgICAgIC8vIHNraXAgcGFzdCBJRDMgaGVhZGVyXG4gICAgICBvZmZzZXQgKz0gMTA7XG4gICAgICB2YXIgZW5kID0gb2Zmc2V0ICsgc2l6ZTtcbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBmcmFtZXMgaW4gdGhlIElEMyB0YWdcbiAgICAgIHdoaWxlIChvZmZzZXQgKyA4IDwgZW5kKSB7XG4gICAgICAgIHZhciBmcmFtZURhdGEgPSBnZXRGcmFtZURhdGEoaWQzRGF0YS5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgICAgdmFyIGZyYW1lID0gZGVjb2RlRnJhbWUoZnJhbWVEYXRhKTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2tpcCBmcmFtZSBoZWFkZXIgYW5kIGZyYW1lIGRhdGFcbiAgICAgICAgb2Zmc2V0ICs9IGZyYW1lRGF0YS5zaXplICsgMTA7XG4gICAgICB9XG4gICAgICBpZiAoaXNGb290ZXIoaWQzRGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBvZmZzZXQgKz0gMTA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFtZXM7XG4gIH07XG4gIHZhciBkZWNvZGVGcmFtZSA9IGZ1bmN0aW9uIGRlY29kZUZyYW1lKGZyYW1lKSB7XG4gICAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xuICAgICAgcmV0dXJuIGRlY29kZVByaXZGcmFtZShmcmFtZSk7XG4gICAgfSBlbHNlIGlmIChmcmFtZS50eXBlWzBdID09PSAnVycpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUkxGcmFtZShmcmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVUZXh0RnJhbWUoZnJhbWUpO1xuICB9O1xuICB2YXIgZGVjb2RlUHJpdkZyYW1lID0gZnVuY3Rpb24gZGVjb2RlUHJpdkZyYW1lKGZyYW1lKSB7XG4gICAgLypcbiAgICBGb3JtYXQ6IDx0ZXh0IHN0cmluZz5cXDA8YmluYXJ5IGRhdGE+XG4gICAgKi9cbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBvd25lciA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEsIHRydWUpO1xuICAgIHZhciBwcml2YXRlRGF0YSA9IG5ldyBVaW50OEFycmF5KGZyYW1lLmRhdGEuc3ViYXJyYXkob3duZXIubGVuZ3RoICsgMSkpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgICBpbmZvOiBvd25lcixcbiAgICAgIGRhdGE6IHByaXZhdGVEYXRhLmJ1ZmZlclxuICAgIH07XG4gIH07XG4gIHZhciBkZWNvZGVUZXh0RnJhbWUgPSBmdW5jdGlvbiBkZWNvZGVUZXh0RnJhbWUoZnJhbWUpIHtcbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChmcmFtZS50eXBlID09PSAnVFhYWCcpIHtcbiAgICAgIC8qXG4gICAgICBGb3JtYXQ6XG4gICAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgICAgWzEtP10gPSB7RGVzY3JpcHRpb259XFwwe1ZhbHVlfVxuICAgICAgKi9cbiAgICAgIHZhciBpbmRleCA9IDE7XG4gICAgICB2YXIgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgICAgdmFyIHZhbHVlID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgICBpbmZvOiBkZXNjcmlwdGlvbixcbiAgICAgICAgZGF0YTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIC8qXG4gICAgRm9ybWF0OlxuICAgIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gICAgWzEtP10gPSB7VmFsdWV9XG4gICAgKi9cbiAgICB2YXIgdGV4dCA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoMSkpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgICBkYXRhOiB0ZXh0XG4gICAgfTtcbiAgfTtcbiAgdmFyIGRlY29kZVVSTEZyYW1lID0gZnVuY3Rpb24gZGVjb2RlVVJMRnJhbWUoZnJhbWUpIHtcbiAgICBpZiAoZnJhbWUudHlwZSA9PT0gJ1dYWFgnKSB7XG4gICAgICAvKlxuICAgICAgRm9ybWF0OlxuICAgICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtVUkx9XG4gICAgICAqL1xuICAgICAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAxO1xuICAgICAgdmFyIGRlc2NyaXB0aW9uID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCksIHRydWUpO1xuICAgICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICAgIHZhciB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleTogZnJhbWUudHlwZSxcbiAgICAgICAgaW5mbzogZGVzY3JpcHRpb24sXG4gICAgICAgIGRhdGE6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMC0/XSA9IHtVUkx9XG4gICAgKi9cbiAgICB2YXIgdXJsID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogZnJhbWUudHlwZSxcbiAgICAgIGRhdGE6IHVybFxuICAgIH07XG4gIH07XG4gIHZhciByZWFkVGltZVN0YW1wID0gZnVuY3Rpb24gcmVhZFRpbWVTdGFtcCh0aW1lU3RhbXBGcmFtZSkge1xuICAgIGlmICh0aW1lU3RhbXBGcmFtZS5kYXRhLmJ5dGVMZW5ndGggPT09IDgpIHtcbiAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGltZVN0YW1wRnJhbWUuZGF0YSk7XG4gICAgICAvLyB0aW1lc3RhbXAgaXMgMzMgYml0IGV4cHJlc3NlZCBhcyBhIGJpZy1lbmRpYW4gZWlnaHQtb2N0ZXQgbnVtYmVyLFxuICAgICAgLy8gd2l0aCB0aGUgdXBwZXIgMzEgYml0cyBzZXQgdG8gemVyby5cbiAgICAgIHZhciBwdHMzM0JpdCA9IGRhdGFbM10gJiAweDE7XG4gICAgICB2YXIgdGltZXN0YW1wID0gKGRhdGFbNF0gPDwgMjMpICsgKGRhdGFbNV0gPDwgMTUpICsgKGRhdGFbNl0gPDwgNykgKyBkYXRhWzddO1xuICAgICAgdGltZXN0YW1wIC89IDQ1O1xuICAgICAgaWYgKHB0czMzQml0KSB7XG4gICAgICAgIHRpbWVzdGFtcCArPSA0NzcyMTg1OC44NDtcbiAgICAgIH0gLy8gMl4zMiAvIDkwXG5cbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84OTM2OTg0L3VpbnQ4YXJyYXktdG8tc3RyaW5nLWluLWphdmFzY3JpcHQvMjIzNzMxOTdcbiAgLy8gaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L3V0Zi50eHRcbiAgLyogdXRmLmpzIC0gVVRGLTggPD0+IFVURi0xNiBjb252ZXJ0aW9uXG4gICAqXG4gICAqIENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gICAqIFZlcnNpb246IDEuMFxuICAgKiBMYXN0TW9kaWZpZWQ6IERlYyAyNSAxOTk5XG4gICAqIFRoaXMgbGlicmFyeSBpcyBmcmVlLiAgWW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdC5cbiAgICovXG4gIHZhciB1dGY4QXJyYXlUb1N0ciA9IGZ1bmN0aW9uIHV0ZjhBcnJheVRvU3RyKGFycmF5LCBleGl0T25OdWxsKSB7XG4gICAgaWYgKGV4aXRPbk51bGwgPT09IHZvaWQgMCkge1xuICAgICAgZXhpdE9uTnVsbCA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZGVjb2RlciA9IGdldFRleHREZWNvZGVyKCk7XG4gICAgaWYgKGRlY29kZXIpIHtcbiAgICAgIHZhciBkZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUoYXJyYXkpO1xuICAgICAgaWYgKGV4aXRPbk51bGwpIHtcbiAgICAgICAgLy8gZ3JhYiB1cCB0byB0aGUgZmlyc3QgbnVsbFxuICAgICAgICB2YXIgaWR4ID0gZGVjb2RlZC5pbmRleE9mKCdcXDAnKTtcbiAgICAgICAgcmV0dXJuIGlkeCAhPT0gLTEgPyBkZWNvZGVkLnN1YnN0cmluZygwLCBpZHgpIDogZGVjb2RlZDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGFueSBudWxsIGNoYXJhY3RlcnNcbiAgICAgIHJldHVybiBkZWNvZGVkLnJlcGxhY2UoL1xcMC9nLCAnJyk7XG4gICAgfVxuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIGM7XG4gICAgdmFyIGNoYXIyO1xuICAgIHZhciBjaGFyMztcbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBjID0gYXJyYXlbaSsrXTtcbiAgICAgIGlmIChjID09PSAweDAwICYmIGV4aXRPbk51bGwpIHtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gMHgwMCB8fCBjID09PSAweDAzKSB7XG4gICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgMyAoRU5EX09GX1RFWFQpIG9yIDAgKE5VTEwpIHRoZW4gc2tpcCBpdFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYyA+PiA0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIC8vIDB4eHh4eHh4XG4gICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgLy8gMTEweCB4eHh4ICAgMTB4eCB4eHh4XG4gICAgICAgICAgY2hhcjIgPSBhcnJheVtpKytdO1xuICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMHgxZikgPDwgNiB8IGNoYXIyICYgMHgzZik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgLy8gMTExMCB4eHh4ICAxMHh4IHh4eHggIDEweHggeHh4eFxuICAgICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgICBjaGFyMyA9IGFycmF5W2krK107XG4gICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAweDBmKSA8PCAxMiB8IChjaGFyMiAmIDB4M2YpIDw8IDYgfCAoY2hhcjMgJiAweDNmKSA8PCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbiAgdmFyIGRlY29kZXI7XG4gIGZ1bmN0aW9uIGdldFRleHREZWNvZGVyKCkge1xuICAgIC8vIE9uIFBsYXkgU3RhdGlvbiA0LCBUZXh0RGVjb2RlciBpcyBkZWZpbmVkIGJ1dCBwYXJ0aWFsbHkgaW1wbGVtZW50ZWQuXG4gICAgLy8gTWFudWFsIGRlY29kaW5nIG9wdGlvbiBpcyBwcmVmZXJhYmxlXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ1BsYXlTdGF0aW9uIDQnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWRlY29kZXIgJiYgdHlwZW9mIHNlbGYuVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWNvZGVyID0gbmV3IHNlbGYuVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqICBoZXggZHVtcCBoZWxwZXIgY2xhc3NcbiAgICovXG5cbiAgdmFyIEhleCA9IHtcbiAgICBoZXhEdW1wOiBmdW5jdGlvbiBoZXhEdW1wKGFycmF5KSB7XG4gICAgICB2YXIgc3RyID0gJyc7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBoID0gYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcblxuICB2YXIgVUlOVDMyX01BWCQxID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbiAgdmFyIHB1c2ggPSBbXS5wdXNoO1xuXG4gIC8vIFdlIGFyZSB1c2luZyBmaXhlZCB0cmFjayBJRHMgZm9yIGRyaXZpbmcgdGhlIE1QNCByZW11eGVyXG4gIC8vIGluc3RlYWQgb2YgZm9sbG93aW5nIHRoZSBUUyBQSURzLlxuICAvLyBUaGVyZSBpcyBubyByZWFzb24gbm90IHRvIGRvIHRoaXMgYW5kIHNvbWUgYnJvd3NlcnMvU291cmNlQnVmZmVyLWRlbXV4ZXJzXG4gIC8vIG1heSBub3QgbGlrZSBpZiB0aGVyZSBhcmUgVHJhY2tJRCBcInN3aXRjaGVzXCJcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8xMzMxXG4gIC8vIEhlcmUgd2UgYXJlIG1hcHBpbmcgb3VyIGludGVybmFsIHRyYWNrIHR5cGVzIHRvIGNvbnN0YW50IE1QNCB0cmFjayBJRHNcbiAgLy8gV2l0aCBNU0UgY3VycmVudGx5IG9uZSBjYW4gb25seSBoYXZlIG9uZSB0cmFjayBvZiBlYWNoLCBhbmQgd2UgYXJlIG11eGluZ1xuICAvLyB3aGF0ZXZlciB2aWRlby9hdWRpbyByZW5kaXRpb24gaW4gdGhlbS5cbiAgdmFyIFJlbXV4ZXJUcmFja0lkQ29uZmlnID0ge1xuICAgIHZpZGVvOiAxLFxuICAgIGF1ZGlvOiAyLFxuICAgIGlkMzogMyxcbiAgICB0ZXh0OiA0XG4gIH07XG4gIGZ1bmN0aW9uIGJpbjJzdHIoZGF0YSkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGRhdGEpO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRVaW50MTYoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gYnVmZmVyW29mZnNldF0gPDwgOCB8IGJ1ZmZlcltvZmZzZXQgKyAxXTtcbiAgICByZXR1cm4gdmFsIDwgMCA/IDY1NTM2ICsgdmFsIDogdmFsO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRVaW50MzIoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsID0gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCk7XG4gICAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRVaW50NjQoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVhZFVpbnQzMihidWZmZXIsIG9mZnNldCk7XG4gICAgcmVzdWx0ICo9IE1hdGgucG93KDIsIDMyKTtcbiAgICByZXN1bHQgKz0gcmVhZFVpbnQzMihidWZmZXIsIG9mZnNldCArIDQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCkge1xuICAgIHJldHVybiBidWZmZXJbb2Zmc2V0XSA8PCAyNCB8IGJ1ZmZlcltvZmZzZXQgKyAxXSA8PCAxNiB8IGJ1ZmZlcltvZmZzZXQgKyAyXSA8PCA4IHwgYnVmZmVyW29mZnNldCArIDNdO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlVWludDMyKGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gdmFsdWUgPj4gMjQ7XG4gICAgYnVmZmVyW29mZnNldCArIDFdID0gdmFsdWUgPj4gMTYgJiAweGZmO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyAyXSA9IHZhbHVlID4+IDggJiAweGZmO1xuICAgIGJ1ZmZlcltvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgfVxuXG4gIC8vIEZpbmQgXCJtb29mXCIgYm94XG4gIGZ1bmN0aW9uIGhhc01vb2ZEYXRhKGRhdGEpIHtcbiAgICB2YXIgZW5kID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOykge1xuICAgICAgdmFyIHNpemUgPSByZWFkVWludDMyKGRhdGEsIGkpO1xuICAgICAgaWYgKHNpemUgPiA4ICYmIGRhdGFbaSArIDRdID09PSAweDZkICYmIGRhdGFbaSArIDVdID09PSAweDZmICYmIGRhdGFbaSArIDZdID09PSAweDZmICYmIGRhdGFbaSArIDddID09PSAweDY2KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaSA9IHNpemUgPiAxID8gaSArIHNpemUgOiBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGRhdGEgZm9yIGEgYm94IHNwZWNpZmllZCBieSBpdHMgcGF0aFxuICBmdW5jdGlvbiBmaW5kQm94KGRhdGEsIHBhdGgpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmICghcGF0aC5sZW5ndGgpIHtcbiAgICAgIC8vIHNob3J0LWNpcmN1aXQgdGhlIHNlYXJjaCBmb3IgZW1wdHkgcGF0aHNcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICB2YXIgZW5kID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOykge1xuICAgICAgdmFyIHNpemUgPSByZWFkVWludDMyKGRhdGEsIGkpO1xuICAgICAgdmFyIHR5cGUgPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkoaSArIDQsIGkgKyA4KSk7XG4gICAgICB2YXIgZW5kYm94ID0gc2l6ZSA+IDEgPyBpICsgc2l6ZSA6IGVuZDtcbiAgICAgIGlmICh0eXBlID09PSBwYXRoWzBdKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgcGF0aCBhbmQgd2UndmUgZm91bmQgdGhlIGJveCB3ZSB3ZXJlXG4gICAgICAgICAgLy8gbG9va2luZyBmb3JcbiAgICAgICAgICByZXN1bHRzLnB1c2goZGF0YS5zdWJhcnJheShpICsgOCwgZW5kYm94KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCBib3ggYWxvbmcgdGhlIHBhdGhcbiAgICAgICAgICB2YXIgc3VicmVzdWx0cyA9IGZpbmRCb3goZGF0YS5zdWJhcnJheShpICsgOCwgZW5kYm94KSwgcGF0aC5zbGljZSgxKSk7XG4gICAgICAgICAgaWYgKHN1YnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIHN1YnJlc3VsdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSA9IGVuZGJveDtcbiAgICB9XG5cbiAgICAvLyB3ZSd2ZSBmaW5pc2hlZCBzZWFyY2hpbmcgYWxsIG9mIGRhdGFcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVNlZ21lbnRJbmRleChzaWR4KSB7XG4gICAgdmFyIHJlZmVyZW5jZXMgPSBbXTtcbiAgICB2YXIgdmVyc2lvbiA9IHNpZHhbMF07XG5cbiAgICAvLyBzZXQgaW5pdGlhbCBvZmZzZXQsIHdlIHNraXAgdGhlIHJlZmVyZW5jZSBJRCAobm90IG5lZWRlZClcbiAgICB2YXIgaW5kZXggPSA4O1xuICAgIHZhciB0aW1lc2NhbGUgPSByZWFkVWludDMyKHNpZHgsIGluZGV4KTtcbiAgICBpbmRleCArPSA0O1xuICAgIHZhciBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgPSAwO1xuICAgIHZhciBmaXJzdE9mZnNldCA9IDA7XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSA9IHJlYWRVaW50MzIoc2lkeCwgaW5kZXgpO1xuICAgICAgZmlyc3RPZmZzZXQgPSByZWFkVWludDMyKHNpZHgsIGluZGV4ICsgNCk7XG4gICAgICBpbmRleCArPSA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgPSByZWFkVWludDY0KHNpZHgsIGluZGV4KTtcbiAgICAgIGZpcnN0T2Zmc2V0ID0gcmVhZFVpbnQ2NChzaWR4LCBpbmRleCArIDgpO1xuICAgICAgaW5kZXggKz0gMTY7XG4gICAgfVxuXG4gICAgLy8gc2tpcCByZXNlcnZlZFxuICAgIGluZGV4ICs9IDI7XG4gICAgdmFyIHN0YXJ0Qnl0ZSA9IHNpZHgubGVuZ3RoICsgZmlyc3RPZmZzZXQ7XG4gICAgdmFyIHJlZmVyZW5jZXNDb3VudCA9IHJlYWRVaW50MTYoc2lkeCwgaW5kZXgpO1xuICAgIGluZGV4ICs9IDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZlcmVuY2VzQ291bnQ7IGkrKykge1xuICAgICAgdmFyIHJlZmVyZW5jZUluZGV4ID0gaW5kZXg7XG4gICAgICB2YXIgcmVmZXJlbmNlSW5mbyA9IHJlYWRVaW50MzIoc2lkeCwgcmVmZXJlbmNlSW5kZXgpO1xuICAgICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcbiAgICAgIHZhciByZWZlcmVuY2VTaXplID0gcmVmZXJlbmNlSW5mbyAmIDB4N2ZmZmZmZmY7XG4gICAgICB2YXIgcmVmZXJlbmNlVHlwZSA9IChyZWZlcmVuY2VJbmZvICYgMHg4MDAwMDAwMCkgPj4+IDMxO1xuICAgICAgaWYgKHJlZmVyZW5jZVR5cGUgPT09IDEpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1NJRFggaGFzIGhpZXJhcmNoaWNhbCByZWZlcmVuY2VzIChub3Qgc3VwcG9ydGVkKScpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBzdWJzZWdtZW50RHVyYXRpb24gPSByZWFkVWludDMyKHNpZHgsIHJlZmVyZW5jZUluZGV4KTtcbiAgICAgIHJlZmVyZW5jZUluZGV4ICs9IDQ7XG4gICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICByZWZlcmVuY2VTaXplOiByZWZlcmVuY2VTaXplLFxuICAgICAgICBzdWJzZWdtZW50RHVyYXRpb246IHN1YnNlZ21lbnREdXJhdGlvbixcbiAgICAgICAgLy8gdW5zY2FsZWRcbiAgICAgICAgaW5mbzoge1xuICAgICAgICAgIGR1cmF0aW9uOiBzdWJzZWdtZW50RHVyYXRpb24gLyB0aW1lc2NhbGUsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0Qnl0ZSxcbiAgICAgICAgICBlbmQ6IHN0YXJ0Qnl0ZSArIHJlZmVyZW5jZVNpemUgLSAxXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc3RhcnRCeXRlICs9IHJlZmVyZW5jZVNpemU7XG5cbiAgICAgIC8vIFNraXBwaW5nIDEgYml0IGZvciB8c3RhcnRzV2l0aFNhcHwsIDMgYml0cyBmb3IgfHNhcFR5cGV8LCBhbmQgMjggYml0c1xuICAgICAgLy8gZm9yIHxzYXBEZWx0YXwuXG4gICAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgICAvLyBza2lwIHRvIG5leHQgcmVmXG4gICAgICBpbmRleCA9IHJlZmVyZW5jZUluZGV4O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZWFybGllc3RQcmVzZW50YXRpb25UaW1lOiBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUsXG4gICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZSxcbiAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICByZWZlcmVuY2VzQ291bnQ6IHJlZmVyZW5jZXNDb3VudCxcbiAgICAgIHJlZmVyZW5jZXM6IHJlZmVyZW5jZXNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBNUDQgaW5pdGlhbGl6YXRpb24gc2VnbWVudCBhbmQgZXh0cmFjdHMgc3RyZWFtIHR5cGUgYW5kXG4gICAqIHRpbWVzY2FsZSB2YWx1ZXMgZm9yIGFueSBkZWNsYXJlZCB0cmFja3MuIFRpbWVzY2FsZSB2YWx1ZXMgaW5kaWNhdGUgdGhlXG4gICAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcbiAgICogZWxzZXdoZXJlIGluIHRoZSBNUDQuXG4gICAqXG4gICAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcbiAgICogaW5mb3JtYXRpb246IHRoZSB0aW1lc2NhbGUgdW5pdCBhbmQgdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlXG4gICAqIHRpbWUuIE11bHRpcGxlIHRpbWVzY2FsZXMgY2FuIGJlIHNwZWNpZmllZCB3aXRoaW4gYW4gTVA0IGJ1dCB0aGVcbiAgICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxuICAgKiB0aGUgbWVkaWEgaGVhZGVyIGJveCBmb3IgdGhlIHRyYWNrOlxuICAgKiBgYGBcbiAgICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcbiAgICogbW9vdiA+IHRyYWsgPiBtZGlhID4gaGRsclxuICAgKiBgYGBcbiAgICogQHBhcmFtIGluaXRTZWdtZW50IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XG4gICAqIEByZXR1cm5zIGEgaGFzaCBvZiB0cmFjayB0eXBlIHRvIHRpbWVzY2FsZSB2YWx1ZXMgb3IgbnVsbCBpZlxuICAgKiB0aGUgaW5pdCBzZWdtZW50IGlzIG1hbGZvcm1lZC5cbiAgICovXG5cbiAgZnVuY3Rpb24gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgdHJha3MgPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAndHJhayddKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhayA9IHRyYWtzW2ldO1xuICAgICAgdmFyIHRraGQgPSBmaW5kQm94KHRyYWssIFsndGtoZCddKVswXTtcbiAgICAgIGlmICh0a2hkKSB7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gdGtoZFswXTtcbiAgICAgICAgdmFyIHRyYWNrSWQgPSByZWFkVWludDMyKHRraGQsIHZlcnNpb24gPT09IDAgPyAxMiA6IDIwKTtcbiAgICAgICAgdmFyIG1kaGQgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdtZGhkJ10pWzBdO1xuICAgICAgICBpZiAobWRoZCkge1xuICAgICAgICAgIHZlcnNpb24gPSBtZGhkWzBdO1xuICAgICAgICAgIHZhciB0aW1lc2NhbGUgPSByZWFkVWludDMyKG1kaGQsIHZlcnNpb24gPT09IDAgPyAxMiA6IDIwKTtcbiAgICAgICAgICB2YXIgaGRsciA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ2hkbHInXSlbMF07XG4gICAgICAgICAgaWYgKGhkbHIpIHtcbiAgICAgICAgICAgIHZhciBoZGxyVHlwZSA9IGJpbjJzdHIoaGRsci5zdWJhcnJheSg4LCAxMikpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB7XG4gICAgICAgICAgICAgIHNvdW46IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyxcbiAgICAgICAgICAgICAgdmlkZTogRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXG4gICAgICAgICAgICB9W2hkbHJUeXBlXTtcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlIGNvZGVjIGRldGFpbHNcbiAgICAgICAgICAgICAgdmFyIHN0c2QgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdtaW5mJywgJ3N0YmwnLCAnc3RzZCddKVswXTtcbiAgICAgICAgICAgICAgdmFyIHN0c2REYXRhID0gcGFyc2VTdHNkKHN0c2QpO1xuICAgICAgICAgICAgICByZXN1bHRbdHJhY2tJZF0gPSB7XG4gICAgICAgICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXN1bHRbdHlwZV0gPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUsXG4gICAgICAgICAgICAgICAgaWQ6IHRyYWNrSWRcbiAgICAgICAgICAgICAgfSwgc3RzZERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdHJleCA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICdtdmV4JywgJ3RyZXgnXSk7XG4gICAgdHJleC5mb3JFYWNoKGZ1bmN0aW9uICh0cmV4KSB7XG4gICAgICB2YXIgdHJhY2tJZCA9IHJlYWRVaW50MzIodHJleCwgNCk7XG4gICAgICB2YXIgdHJhY2sgPSByZXN1bHRbdHJhY2tJZF07XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgdHJhY2suZGVmYXVsdCA9IHtcbiAgICAgICAgICBkdXJhdGlvbjogcmVhZFVpbnQzMih0cmV4LCAxMiksXG4gICAgICAgICAgZmxhZ3M6IHJlYWRVaW50MzIodHJleCwgMjApXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVN0c2Qoc3RzZCkge1xuICAgIHZhciBzYW1wbGVFbnRyaWVzID0gc3RzZC5zdWJhcnJheSg4KTtcbiAgICB2YXIgc2FtcGxlRW50cmllc0VuZCA9IHNhbXBsZUVudHJpZXMuc3ViYXJyYXkoOCArIDc4KTtcbiAgICB2YXIgZm91ckNDID0gYmluMnN0cihzYW1wbGVFbnRyaWVzLnN1YmFycmF5KDQsIDgpKTtcbiAgICB2YXIgY29kZWMgPSBmb3VyQ0M7XG4gICAgdmFyIGVuY3J5cHRlZCA9IGZvdXJDQyA9PT0gJ2VuY2EnIHx8IGZvdXJDQyA9PT0gJ2VuY3YnO1xuICAgIGlmIChlbmNyeXB0ZWQpIHtcbiAgICAgIHZhciBlbmNCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXMsIFtmb3VyQ0NdKVswXTtcbiAgICAgIHZhciBlbmNCb3hDaGlsZHJlbiA9IGVuY0JveC5zdWJhcnJheShmb3VyQ0MgPT09ICdlbmNhJyA/IDI4IDogNzgpO1xuICAgICAgdmFyIHNpbmZzID0gZmluZEJveChlbmNCb3hDaGlsZHJlbiwgWydzaW5mJ10pO1xuICAgICAgc2luZnMuZm9yRWFjaChmdW5jdGlvbiAoc2luZikge1xuICAgICAgICB2YXIgc2NobSA9IGZpbmRCb3goc2luZiwgWydzY2htJ10pWzBdO1xuICAgICAgICBpZiAoc2NobSkge1xuICAgICAgICAgIHZhciBzY2hlbWUgPSBiaW4yc3RyKHNjaG0uc3ViYXJyYXkoNCwgOCkpO1xuICAgICAgICAgIGlmIChzY2hlbWUgPT09ICdjYmNzJyB8fCBzY2hlbWUgPT09ICdjZW5jJykge1xuICAgICAgICAgICAgdmFyIGZybWEgPSBmaW5kQm94KHNpbmYsIFsnZnJtYSddKVswXTtcbiAgICAgICAgICAgIGlmIChmcm1hKSB7XG4gICAgICAgICAgICAgIC8vIGZvciBlbmNyeXB0ZWQgY29udGVudCBjb2RlYyBmb3VyQ0Mgd2lsbCBiZSBpbiBmcm1hXG4gICAgICAgICAgICAgIGNvZGVjID0gYmluMnN0cihmcm1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICBjYXNlICdhdmMxJzpcbiAgICAgIGNhc2UgJ2F2YzInOlxuICAgICAgY2FzZSAnYXZjMyc6XG4gICAgICBjYXNlICdhdmM0JzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIGV4dHJhY3QgcHJvZmlsZSArIGNvbXBhdGliaWxpdHkgKyBsZXZlbCBvdXQgb2YgYXZjQyBib3hcbiAgICAgICAgICB2YXIgYXZjQ0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWydhdmNDJ10pWzBdO1xuICAgICAgICAgIGNvZGVjICs9ICcuJyArIHRvSGV4KGF2Y0NCb3hbMV0pICsgdG9IZXgoYXZjQ0JveFsyXSkgKyB0b0hleChhdmNDQm94WzNdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbXA0YSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29kZWNCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXMsIFtmb3VyQ0NdKVswXTtcbiAgICAgICAgICB2YXIgZXNkc0JveCA9IGZpbmRCb3goY29kZWNCb3guc3ViYXJyYXkoMjgpLCBbJ2VzZHMnXSlbMF07XG4gICAgICAgICAgaWYgKGVzZHNCb3ggJiYgZXNkc0JveC5sZW5ndGggPiAxMikge1xuICAgICAgICAgICAgdmFyIGkgPSA0O1xuICAgICAgICAgICAgLy8gRVMgRGVzY3JpcHRvciB0YWdcbiAgICAgICAgICAgIGlmIChlc2RzQm94W2krK10gIT09IDB4MDMpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gc2tpcEJFUkludGVnZXIoZXNkc0JveCwgaSk7XG4gICAgICAgICAgICBpICs9IDI7IC8vIHNraXAgZXNfaWQ7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBlc2RzQm94W2krK107XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiAweDgwKSB7XG4gICAgICAgICAgICAgIGkgKz0gMjsgLy8gc2tpcCBkZXBlbmRlbmN5IGVzX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiAweDQwKSB7XG4gICAgICAgICAgICAgIGkgKz0gZXNkc0JveFtpKytdOyAvLyBza2lwIFVSTFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVjb2RlciBjb25maWcgZGVzY3JpcHRvclxuICAgICAgICAgICAgaWYgKGVzZHNCb3hbaSsrXSAhPT0gMHgwNCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSBza2lwQkVSSW50ZWdlcihlc2RzQm94LCBpKTtcbiAgICAgICAgICAgIHZhciBvYmplY3RUeXBlID0gZXNkc0JveFtpKytdO1xuICAgICAgICAgICAgaWYgKG9iamVjdFR5cGUgPT09IDB4NDApIHtcbiAgICAgICAgICAgICAgY29kZWMgKz0gJy4nICsgdG9IZXgob2JqZWN0VHlwZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gMTI7XG4gICAgICAgICAgICAvLyBEZWNvZGVyIHNwZWNpZmljIGluZm9cbiAgICAgICAgICAgIGlmIChlc2RzQm94W2krK10gIT09IDB4MDUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gc2tpcEJFUkludGVnZXIoZXNkc0JveCwgaSk7XG4gICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gZXNkc0JveFtpKytdO1xuICAgICAgICAgICAgdmFyIGF1ZGlvT2JqZWN0VHlwZSA9IChmaXJzdEJ5dGUgJiAweGY4KSA+PiAzO1xuICAgICAgICAgICAgaWYgKGF1ZGlvT2JqZWN0VHlwZSA9PT0gMzEpIHtcbiAgICAgICAgICAgICAgYXVkaW9PYmplY3RUeXBlICs9IDEgKyAoKGZpcnN0Qnl0ZSAmIDB4NykgPDwgMykgKyAoKGVzZHNCb3hbaV0gJiAweGUwKSA+PiA1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVjICs9ICcuJyArIGF1ZGlvT2JqZWN0VHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2h2YzEnOlxuICAgICAgY2FzZSAnaGV2MSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaHZjQ0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWydodmNDJ10pWzBdO1xuICAgICAgICAgIHZhciBwcm9maWxlQnl0ZSA9IGh2Y0NCb3hbMV07XG4gICAgICAgICAgdmFyIHByb2ZpbGVTcGFjZSA9IFsnJywgJ0EnLCAnQicsICdDJ11bcHJvZmlsZUJ5dGUgPj4gNl07XG4gICAgICAgICAgdmFyIGdlbmVyYWxQcm9maWxlSWRjID0gcHJvZmlsZUJ5dGUgJiAweDFmO1xuICAgICAgICAgIHZhciBwcm9maWxlQ29tcGF0ID0gcmVhZFVpbnQzMihodmNDQm94LCAyKTtcbiAgICAgICAgICB2YXIgdGllckZsYWcgPSAocHJvZmlsZUJ5dGUgJiAweDIwKSA+PiA1ID8gJ0gnIDogJ0wnO1xuICAgICAgICAgIHZhciBsZXZlbElEQyA9IGh2Y0NCb3hbMTJdO1xuICAgICAgICAgIHZhciBjb25zdHJhaW50SW5kaWNhdG9yID0gaHZjQ0JveC5zdWJhcnJheSg2LCAxMik7XG4gICAgICAgICAgY29kZWMgKz0gJy4nICsgcHJvZmlsZVNwYWNlICsgZ2VuZXJhbFByb2ZpbGVJZGM7XG4gICAgICAgICAgY29kZWMgKz0gJy4nICsgcHJvZmlsZUNvbXBhdC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBjb2RlYyArPSAnLicgKyB0aWVyRmxhZyArIGxldmVsSURDO1xuICAgICAgICAgIHZhciBjb25zdHJhaW50U3RyaW5nID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSBjb25zdHJhaW50SW5kaWNhdG9yLmxlbmd0aDsgX2ktLTspIHtcbiAgICAgICAgICAgIHZhciBfYnl0ZSA9IGNvbnN0cmFpbnRJbmRpY2F0b3JbX2ldO1xuICAgICAgICAgICAgaWYgKF9ieXRlIHx8IGNvbnN0cmFpbnRTdHJpbmcpIHtcbiAgICAgICAgICAgICAgdmFyIGVuY29kZWRCeXRlID0gX2J5dGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGNvbnN0cmFpbnRTdHJpbmcgPSAnLicgKyBlbmNvZGVkQnl0ZSArIGNvbnN0cmFpbnRTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvZGVjICs9IGNvbnN0cmFpbnRTdHJpbmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2R2aDEnOlxuICAgICAgY2FzZSAnZHZoZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZHZjQ0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWydkdmNDJ10pWzBdO1xuICAgICAgICAgIHZhciBwcm9maWxlID0gZHZjQ0JveFsyXSA+PiAxICYgMHg3ZjtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBkdmNDQm94WzJdIDw8IDUgJiAweDIwIHwgZHZjQ0JveFszXSA+PiAzICYgMHgxZjtcbiAgICAgICAgICBjb2RlYyArPSAnLicgKyBhZGRMZWFkaW5nWmVybyhwcm9maWxlKSArICcuJyArIGFkZExlYWRpbmdaZXJvKGxldmVsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAndnAwOSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdnBjQ0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWyd2cGNDJ10pWzBdO1xuICAgICAgICAgIHZhciBfcHJvZmlsZSA9IHZwY0NCb3hbNF07XG4gICAgICAgICAgdmFyIF9sZXZlbCA9IHZwY0NCb3hbNV07XG4gICAgICAgICAgdmFyIGJpdERlcHRoID0gdnBjQ0JveFs2XSA+PiA0ICYgMHgwZjtcbiAgICAgICAgICBjb2RlYyArPSAnLicgKyBhZGRMZWFkaW5nWmVybyhfcHJvZmlsZSkgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhfbGV2ZWwpICsgJy4nICsgYWRkTGVhZGluZ1plcm8oYml0RGVwdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdhdjAxJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBhdjFDQm94ID0gZmluZEJveChzYW1wbGVFbnRyaWVzRW5kLCBbJ2F2MUMnXSlbMF07XG4gICAgICAgICAgdmFyIF9wcm9maWxlMiA9IGF2MUNCb3hbMV0gPj4+IDU7XG4gICAgICAgICAgdmFyIF9sZXZlbDIgPSBhdjFDQm94WzFdICYgMHgxZjtcbiAgICAgICAgICB2YXIgX3RpZXJGbGFnID0gYXYxQ0JveFsyXSA+Pj4gNyA/ICdIJyA6ICdNJztcbiAgICAgICAgICB2YXIgaGlnaEJpdERlcHRoID0gKGF2MUNCb3hbMl0gJiAweDQwKSA+PiA2O1xuICAgICAgICAgIHZhciB0d2VsdmVCaXQgPSAoYXYxQ0JveFsyXSAmIDB4MjApID4+IDU7XG4gICAgICAgICAgdmFyIF9iaXREZXB0aCA9IF9wcm9maWxlMiA9PT0gMiAmJiBoaWdoQml0RGVwdGggPyB0d2VsdmVCaXQgPyAxMiA6IDEwIDogaGlnaEJpdERlcHRoID8gMTAgOiA4O1xuICAgICAgICAgIHZhciBtb25vY2hyb21lID0gKGF2MUNCb3hbMl0gJiAweDEwKSA+PiA0O1xuICAgICAgICAgIHZhciBjaHJvbWFTdWJzYW1wbGluZ1ggPSAoYXYxQ0JveFsyXSAmIDB4MDgpID4+IDM7XG4gICAgICAgICAgdmFyIGNocm9tYVN1YnNhbXBsaW5nWSA9IChhdjFDQm94WzJdICYgMHgwNCkgPj4gMjtcbiAgICAgICAgICB2YXIgY2hyb21hU2FtcGxlUG9zaXRpb24gPSBhdjFDQm94WzJdICYgMHgwMztcbiAgICAgICAgICAvLyBUT0RPOiBwYXJzZSBjb2xvcl9kZXNjcmlwdGlvbl9wcmVzZW50X2ZsYWdcbiAgICAgICAgICAvLyBkZWZhdWx0IGl0IHRvIEJULjcwOS9saW1pdGVkIHJhbmdlIGZvciBub3dcbiAgICAgICAgICAvLyBtb3JlIGluZm8gaHR0cHM6Ly9hb21lZGlhY29kZWMuZ2l0aHViLmlvL2F2MS1pc29ibWZmLyNhdjFjb2RlY2NvbmZpZ3VyYXRpb25ib3gtc3ludGF4XG4gICAgICAgICAgdmFyIGNvbG9yUHJpbWFyaWVzID0gMTtcbiAgICAgICAgICB2YXIgdHJhbnNmZXJDaGFyYWN0ZXJpc3RpY3MgPSAxO1xuICAgICAgICAgIHZhciBtYXRyaXhDb2VmZmljaWVudHMgPSAxO1xuICAgICAgICAgIHZhciB2aWRlb0Z1bGxSYW5nZUZsYWcgPSAwO1xuICAgICAgICAgIGNvZGVjICs9ICcuJyArIF9wcm9maWxlMiArICcuJyArIGFkZExlYWRpbmdaZXJvKF9sZXZlbDIpICsgX3RpZXJGbGFnICsgJy4nICsgYWRkTGVhZGluZ1plcm8oX2JpdERlcHRoKSArICcuJyArIG1vbm9jaHJvbWUgKyAnLicgKyBjaHJvbWFTdWJzYW1wbGluZ1ggKyBjaHJvbWFTdWJzYW1wbGluZ1kgKyBjaHJvbWFTYW1wbGVQb3NpdGlvbiArICcuJyArIGFkZExlYWRpbmdaZXJvKGNvbG9yUHJpbWFyaWVzKSArICcuJyArIGFkZExlYWRpbmdaZXJvKHRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzKSArICcuJyArIGFkZExlYWRpbmdaZXJvKG1hdHJpeENvZWZmaWNpZW50cykgKyAnLicgKyB2aWRlb0Z1bGxSYW5nZUZsYWc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGVjOiBjb2RlYyxcbiAgICAgIGVuY3J5cHRlZDogZW5jcnlwdGVkXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBza2lwQkVSSW50ZWdlcihieXRlcywgaSkge1xuICAgIHZhciBsaW1pdCA9IGkgKyA1O1xuICAgIHdoaWxlIChieXRlc1tpKytdICYgMHg4MCAmJiBpIDwgbGltaXQpIHt9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgZnVuY3Rpb24gdG9IZXgoeCkge1xuICAgIHJldHVybiAoJzAnICsgeC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvKG51bSkge1xuICAgIHJldHVybiAobnVtIDwgMTAgPyAnMCcgOiAnJykgKyBudW07XG4gIH1cbiAgZnVuY3Rpb24gcGF0Y2hFbmN5cHRpb25EYXRhKGluaXRTZWdtZW50LCBkZWNyeXB0ZGF0YSkge1xuICAgIGlmICghaW5pdFNlZ21lbnQgfHwgIWRlY3J5cHRkYXRhKSB7XG4gICAgICByZXR1cm4gaW5pdFNlZ21lbnQ7XG4gICAgfVxuICAgIHZhciBrZXlJZCA9IGRlY3J5cHRkYXRhLmtleUlkO1xuICAgIGlmIChrZXlJZCAmJiBkZWNyeXB0ZGF0YS5pc0NvbW1vbkVuY3J5cHRpb24pIHtcbiAgICAgIHZhciB0cmFrcyA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuICAgICAgdHJha3MuZm9yRWFjaChmdW5jdGlvbiAodHJhaykge1xuICAgICAgICB2YXIgc3RzZCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21pbmYnLCAnc3RibCcsICdzdHNkJ10pWzBdO1xuXG4gICAgICAgIC8vIHNraXAgdGhlIHNhbXBsZSBlbnRyeSBjb3VudFxuICAgICAgICB2YXIgc2FtcGxlRW50cmllcyA9IHN0c2Quc3ViYXJyYXkoOCk7XG4gICAgICAgIHZhciBlbmNCb3hlcyA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgWydlbmNhJ10pO1xuICAgICAgICB2YXIgaXNBdWRpbyA9IGVuY0JveGVzLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmICghaXNBdWRpbykge1xuICAgICAgICAgIGVuY0JveGVzID0gZmluZEJveChzYW1wbGVFbnRyaWVzLCBbJ2VuY3YnXSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jQm94ZXMuZm9yRWFjaChmdW5jdGlvbiAoZW5jKSB7XG4gICAgICAgICAgdmFyIGVuY0JveENoaWxkcmVuID0gaXNBdWRpbyA/IGVuYy5zdWJhcnJheSgyOCkgOiBlbmMuc3ViYXJyYXkoNzgpO1xuICAgICAgICAgIHZhciBzaW5mQm94ZXMgPSBmaW5kQm94KGVuY0JveENoaWxkcmVuLCBbJ3NpbmYnXSk7XG4gICAgICAgICAgc2luZkJveGVzLmZvckVhY2goZnVuY3Rpb24gKHNpbmYpIHtcbiAgICAgICAgICAgIHZhciB0ZW5jID0gcGFyc2VTaW5mKHNpbmYpO1xuICAgICAgICAgICAgaWYgKHRlbmMpIHtcbiAgICAgICAgICAgICAgLy8gTG9vayBmb3IgZGVmYXVsdCBrZXkgaWQgKGtleUlEIG9mZnNldCBpcyBhbHdheXMgOCB3aXRoaW4gdGhlIHRlbmMgYm94KTpcbiAgICAgICAgICAgICAgdmFyIHRlbmNLZXlJZCA9IHRlbmMuc3ViYXJyYXkoOCwgMjQpO1xuICAgICAgICAgICAgICBpZiAoIXRlbmNLZXlJZC5zb21lKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgIT09IDA7XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIltlbWVdIFBhdGNoaW5nIGtleUlkIGluICdlbmNcIiArIChpc0F1ZGlvID8gJ2EnIDogJ3YnKSArIFwiPnNpbmY+PnRlbmMnIGJveDogXCIgKyBIZXguaGV4RHVtcCh0ZW5jS2V5SWQpICsgXCIgLT4gXCIgKyBIZXguaGV4RHVtcChrZXlJZCkpO1xuICAgICAgICAgICAgICAgIHRlbmMuc2V0KGtleUlkLCA4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdFNlZ21lbnQ7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTaW5mKHNpbmYpIHtcbiAgICB2YXIgc2NobSA9IGZpbmRCb3goc2luZiwgWydzY2htJ10pWzBdO1xuICAgIGlmIChzY2htKSB7XG4gICAgICB2YXIgc2NoZW1lID0gYmluMnN0cihzY2htLnN1YmFycmF5KDQsIDgpKTtcbiAgICAgIGlmIChzY2hlbWUgPT09ICdjYmNzJyB8fCBzY2hlbWUgPT09ICdjZW5jJykge1xuICAgICAgICByZXR1cm4gZmluZEJveChzaW5mLCBbJ3NjaGknLCAndGVuYyddKVswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lLCBpbiBzZWNvbmRzLCBmb3IgYW4gTVA0XG4gICAqIGZyYWdtZW50LiBJZiBtdWx0aXBsZSBmcmFnbWVudHMgYXJlIHNwZWNpZmllZCwgdGhlIGVhcmxpZXN0IHRpbWUgaXNcbiAgICogcmV0dXJuZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGNhbiBiZSBwYXJzZWQgZnJvbSB0cmFjayBmcmFnbWVudFxuICAgKiBtZXRhZGF0YTpcbiAgICogYGBgXG4gICAqIG1vb2YgPiB0cmFmID4gdGZkdC5iYXNlTWVkaWFEZWNvZGVUaW1lXG4gICAqIGBgYFxuICAgKiBJdCByZXF1aXJlcyB0aGUgdGltZXNjYWxlIHZhbHVlIGZyb20gdGhlIG1kaGQgdG8gaW50ZXJwcmV0LlxuICAgKlxuICAgKiBAcGFyYW0gaW5pdERhdGEgLSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzXG4gICAqIEBwYXJhbSBmbXA0IC0gdGhlIGJ5dGVzIG9mIHRoZSBtcDQgZnJhZ21lbnRcbiAgICogQHJldHVybnMgdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUgZm9yIHRoZVxuICAgKiBmcmFnbWVudCwgaW4gc2Vjb25kc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3RhcnREVFMoaW5pdERhdGEsIGZtcDQpIHtcbiAgICAvLyB3ZSBuZWVkIGluZm8gZnJvbSB0d28gY2hpbGRyZW4gb2YgZWFjaCB0cmFjayBmcmFnbWVudCBib3hcbiAgICByZXR1cm4gZmluZEJveChmbXA0LCBbJ21vb2YnLCAndHJhZiddKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgdHJhZikge1xuICAgICAgdmFyIHRmZHQgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKVswXTtcbiAgICAgIHZhciB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgIHZhciBzdGFydCA9IGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCB0ZmhkKSB7XG4gICAgICAgIC8vIGdldCB0aGUgdHJhY2sgaWQgZnJvbSB0aGUgdGZoZFxuICAgICAgICB2YXIgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgICB2YXIgdHJhY2sgPSBpbml0RGF0YVtpZF07XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgIHZhciBiYXNlVGltZSA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgICAgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICAgIC8vIElmIHZhbHVlIGlzIHRvbyBsYXJnZSwgYXNzdW1lIHNpZ25lZCA2NC1iaXQuIE5lZ2F0aXZlIHRyYWNrIGZyYWdtZW50IGRlY29kZSB0aW1lcyBhcmUgaW52YWxpZCwgYnV0IHRoZXkgZXhpc3QgaW4gdGhlIHdpbGQuXG4gICAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGxhcmdlIHZhbHVlcyBmcm9tIGJlaW5nIHVzZWQgZm9yIGluaXRQVFMsIHdoaWNoIGNhbiBjYXVzZSBwbGF5bGlzdCBzeW5jIGlzc3Vlcy5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy81MzAzXG4gICAgICAgICAgICBpZiAoYmFzZVRpbWUgPT09IFVJTlQzMl9NQVgkMSkge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybihcIlttcDQtZGVtdXhlcl06IElnbm9yaW5nIGFzc3VtZWQgaW52YWxpZCBzaWduZWQgNjQtYml0IHRyYWNrIGZyYWdtZW50IGRlY29kZSB0aW1lXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZVRpbWUgKj0gVUlOVDMyX01BWCQxICsgMTtcbiAgICAgICAgICAgIGJhc2VUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgICAgICAgdmFyIHNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7XG4gICAgICAgICAgLy8gY29udmVydCBiYXNlIHRpbWUgdG8gc2Vjb25kc1xuICAgICAgICAgIHZhciBzdGFydFRpbWUgPSBiYXNlVGltZSAvIHNjYWxlO1xuICAgICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihzdGFydFRpbWUpICYmIChyZXN1bHQgPT09IG51bGwgfHwgc3RhcnRUaW1lIDwgcmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0VGltZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIG51bGwpO1xuICAgICAgaWYgKHN0YXJ0ICE9PSBudWxsICYmIGlzRmluaXRlTnVtYmVyKHN0YXJ0KSAmJiAocmVzdWx0ID09PSBudWxsIHx8IHN0YXJ0IDwgcmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIG51bGwpO1xuICB9XG5cbiAgLypcbiAgICBGb3IgUmVmZXJlbmNlOlxuICAgIGFsaWduZWQoOCkgY2xhc3MgVHJhY2tGcmFnbWVudEhlYWRlckJveFxuICAgICAgICAgICAgIGV4dGVuZHMgRnVsbEJveCjigJh0Zmhk4oCZLCAwLCB0Zl9mbGFncyl7XG4gICAgICAgdW5zaWduZWQgaW50KDMyKSAgdHJhY2tfSUQ7XG4gICAgICAgLy8gYWxsIHRoZSBmb2xsb3dpbmcgYXJlIG9wdGlvbmFsIGZpZWxkc1xuICAgICAgIHVuc2lnbmVkIGludCg2NCkgIGJhc2VfZGF0YV9vZmZzZXQ7XG4gICAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4O1xuICAgICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uO1xuICAgICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX3NpemU7XG4gICAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICB9XG4gICAqL1xuICBmdW5jdGlvbiBnZXREdXJhdGlvbihkYXRhLCBpbml0RGF0YSkge1xuICAgIHZhciByYXdEdXJhdGlvbiA9IDA7XG4gICAgdmFyIHZpZGVvRHVyYXRpb24gPSAwO1xuICAgIHZhciBhdWRpb0R1cmF0aW9uID0gMDtcbiAgICB2YXIgdHJhZnMgPSBmaW5kQm94KGRhdGEsIFsnbW9vZicsICd0cmFmJ10pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFmID0gdHJhZnNbaV07XG4gICAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSB0ZmhkICYgdHJ1biBwZXIgdHJhZlxuICAgICAgLy8gVGhpcyBpcyB0cnVlIGZvciBDTUFGIHN0eWxlIGNvbnRlbnQsIGFuZCB3ZSBzaG91bGQgcGVyaGFwcyBjaGVjayB0aGUgZnR5cFxuICAgICAgLy8gYW5kIG9ubHkgbG9vayBmb3IgYSBzaW5nbGUgdHJ1biB0aGVuLCBidXQgZm9yIElTT0JNRkYgd2Ugc2hvdWxkIGNoZWNrXG4gICAgICAvLyBmb3IgbXVsdGlwbGUgdHJhY2sgcnVucy5cbiAgICAgIHZhciB0ZmhkID0gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSlbMF07XG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgIHZhciBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICB2YXIgdHJhY2sgPSBpbml0RGF0YVtpZF07XG4gICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHRyYWNrRGVmYXVsdCA9IHRyYWNrLmRlZmF1bHQ7XG4gICAgICB2YXIgdGZoZEZsYWdzID0gcmVhZFVpbnQzMih0ZmhkLCAwKSB8ICh0cmFja0RlZmF1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrRGVmYXVsdC5mbGFncyk7XG4gICAgICB2YXIgc2FtcGxlRHVyYXRpb24gPSB0cmFja0RlZmF1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrRGVmYXVsdC5kdXJhdGlvbjtcbiAgICAgIGlmICh0ZmhkRmxhZ3MgJiAweDAwMDAwOCkge1xuICAgICAgICAvLyAweDAwMDAwOCBpbmRpY2F0ZXMgdGhlIHByZXNlbmNlIG9mIHRoZSBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiBmaWVsZFxuICAgICAgICBpZiAodGZoZEZsYWdzICYgMHgwMDAwMDIpIHtcbiAgICAgICAgICAvLyAweDAwMDAwMiBpbmRpY2F0ZXMgdGhlIHByZXNlbmNlIG9mIHRoZSBzYW1wbGVfZGVzY3JpcHRpb25faW5kZXggZmllbGQsIHdoaWNoIHByZWNlZGVzIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgICAgLy8gSWYgcHJlc2VudCwgdGhlIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uIGV4aXN0cyBhdCBieXRlIG9mZnNldCAxMlxuICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0ZmhkLCAxMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgZHVyYXRpb24gaXMgYXQgYnl0ZSBvZmZzZXQgOFxuICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0ZmhkLCA4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYXNzdW1lIGEgOTBrSHogY2xvY2sgaWYgbm8gdGltZXNjYWxlIHdhcyBzcGVjaWZpZWRcbiAgICAgIHZhciB0aW1lc2NhbGUgPSB0cmFjay50aW1lc2NhbGUgfHwgOTBlMztcbiAgICAgIHZhciB0cnVucyA9IGZpbmRCb3godHJhZiwgWyd0cnVuJ10pO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0cnVucy5sZW5ndGg7IGorKykge1xuICAgICAgICByYXdEdXJhdGlvbiA9IGNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzKHRydW5zW2pdKTtcbiAgICAgICAgaWYgKCFyYXdEdXJhdGlvbiAmJiBzYW1wbGVEdXJhdGlvbikge1xuICAgICAgICAgIHZhciBzYW1wbGVDb3VudCA9IHJlYWRVaW50MzIodHJ1bnNbal0sIDQpO1xuICAgICAgICAgIHJhd0R1cmF0aW9uID0gc2FtcGxlRHVyYXRpb24gKiBzYW1wbGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2sudHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKSB7XG4gICAgICAgICAgdmlkZW9EdXJhdGlvbiArPSByYXdEdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFjay50eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8pIHtcbiAgICAgICAgICBhdWRpb0R1cmF0aW9uICs9IHJhd0R1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2aWRlb0R1cmF0aW9uID09PSAwICYmIGF1ZGlvRHVyYXRpb24gPT09IDApIHtcbiAgICAgIC8vIElmIGR1cmF0aW9uIHNhbXBsZXMgYXJlIG5vdCBhdmFpbGFibGUgaW4gdGhlIHRyYWYgdXNlIHNpZHggc3Vic2VnbWVudF9kdXJhdGlvblxuICAgICAgdmFyIHNpZHhNaW5TdGFydCA9IEluZmluaXR5O1xuICAgICAgdmFyIHNpZHhNYXhFbmQgPSAwO1xuICAgICAgdmFyIHNpZHhEdXJhdGlvbiA9IDA7XG4gICAgICB2YXIgc2lkeHMgPSBmaW5kQm94KGRhdGEsIFsnc2lkeCddKTtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHNpZHhzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIHNpZHggPSBwYXJzZVNlZ21lbnRJbmRleChzaWR4c1tfaTJdKTtcbiAgICAgICAgaWYgKHNpZHggIT0gbnVsbCAmJiBzaWR4LnJlZmVyZW5jZXMpIHtcbiAgICAgICAgICBzaWR4TWluU3RhcnQgPSBNYXRoLm1pbihzaWR4TWluU3RhcnQsIHNpZHguZWFybGllc3RQcmVzZW50YXRpb25UaW1lIC8gc2lkeC50aW1lc2NhbGUpO1xuICAgICAgICAgIHZhciBzdWJTZWdtZW50RHVyYXRpb24gPSBzaWR4LnJlZmVyZW5jZXMucmVkdWNlKGZ1bmN0aW9uIChkdXIsIHJlZikge1xuICAgICAgICAgICAgcmV0dXJuIGR1ciArIHJlZi5pbmZvLmR1cmF0aW9uIHx8IDA7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgc2lkeE1heEVuZCA9IE1hdGgubWF4KHNpZHhNYXhFbmQsIHN1YlNlZ21lbnREdXJhdGlvbiArIHNpZHguZWFybGllc3RQcmVzZW50YXRpb25UaW1lIC8gc2lkeC50aW1lc2NhbGUpO1xuICAgICAgICAgIHNpZHhEdXJhdGlvbiA9IHNpZHhNYXhFbmQgLSBzaWR4TWluU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaWR4RHVyYXRpb24gJiYgaXNGaW5pdGVOdW1iZXIoc2lkeER1cmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gc2lkeER1cmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmlkZW9EdXJhdGlvbikge1xuICAgICAgcmV0dXJuIHZpZGVvRHVyYXRpb247XG4gICAgfVxuICAgIHJldHVybiBhdWRpb0R1cmF0aW9uO1xuICB9XG5cbiAgLypcbiAgICBGb3IgUmVmZXJlbmNlOlxuICAgIGFsaWduZWQoOCkgY2xhc3MgVHJhY2tSdW5Cb3hcbiAgICAgICAgICAgICBleHRlbmRzIEZ1bGxCb3go4oCYdHJ1buKAmSwgdmVyc2lvbiwgdHJfZmxhZ3MpIHtcbiAgICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfY291bnQ7XG4gICAgICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgb3B0aW9uYWwgZmllbGRzXG4gICAgICAgc2lnbmVkIGludCgzMikgZGF0YV9vZmZzZXQ7XG4gICAgICAgdW5zaWduZWQgaW50KDMyKSAgZmlyc3Rfc2FtcGxlX2ZsYWdzO1xuICAgICAgIC8vIGFsbCBmaWVsZHMgaW4gdGhlIGZvbGxvd2luZyBhcnJheSBhcmUgb3B0aW9uYWxcbiAgICAgICB7XG4gICAgICAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2R1cmF0aW9uO1xuICAgICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9zaXplO1xuICAgICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9mbGFnc1xuICAgICAgICAgIGlmICh2ZXJzaW9uID09IDApXG4gICAgICAgICAgICAgeyB1bnNpZ25lZCBpbnQoMzIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgIHsgc2lnbmVkIGludCgzMilcbiAgICAgICB9WyBzYW1wbGVfY291bnQgXVxuICAgIH1cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzKHRydW4pIHtcbiAgICB2YXIgZmxhZ3MgPSByZWFkVWludDMyKHRydW4sIDApO1xuICAgIC8vIEZsYWdzIGFyZSBhdCBvZmZzZXQgMCwgbm9uLW9wdGlvbmFsIHNhbXBsZV9jb3VudCBpcyBhdCBvZmZzZXQgNC4gVGhlcmVmb3JlIHdlIHN0YXJ0IDggYnl0ZXMgaW4uXG4gICAgLy8gRWFjaCBmaWVsZCBpcyBhbiBpbnQzMiwgd2hpY2ggaXMgNCBieXRlc1xuICAgIHZhciBvZmZzZXQgPSA4O1xuICAgIC8vIGRhdGEtb2Zmc2V0LXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwMDAxKSB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG4gICAgLy8gZmlyc3Qtc2FtcGxlLWZsYWdzLXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwMDA0KSB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG4gICAgdmFyIGR1cmF0aW9uID0gMDtcbiAgICB2YXIgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW4sIDQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlQ291bnQ7IGkrKykge1xuICAgICAgLy8gc2FtcGxlLWR1cmF0aW9uLXByZXNlbnQgZmxhZ1xuICAgICAgaWYgKGZsYWdzICYgMHgwMDAxMDApIHtcbiAgICAgICAgdmFyIHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0cnVuLCBvZmZzZXQpO1xuICAgICAgICBkdXJhdGlvbiArPSBzYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICB9XG4gICAgICAvLyBzYW1wbGUtc2l6ZS1wcmVzZW50IGZsYWdcbiAgICAgIGlmIChmbGFncyAmIDB4MDAwMjAwKSB7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgfVxuICAgICAgLy8gc2FtcGxlLWZsYWdzLXByZXNlbnQgZmxhZ1xuICAgICAgaWYgKGZsYWdzICYgMHgwMDA0MDApIHtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICB9XG4gICAgICAvLyBzYW1wbGUtY29tcG9zaXRpb24tdGltZS1vZmZzZXRzLXByZXNlbnQgZmxhZ1xuICAgICAgaWYgKGZsYWdzICYgMHgwMDA4MDApIHtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBvZmZzZXRTdGFydERUUyhpbml0RGF0YSwgZm1wNCwgdGltZU9mZnNldCkge1xuICAgIGZpbmRCb3goZm1wNCwgWydtb29mJywgJ3RyYWYnXSkuZm9yRWFjaChmdW5jdGlvbiAodHJhZikge1xuICAgICAgZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkuZm9yRWFjaChmdW5jdGlvbiAodGZoZCkge1xuICAgICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgICAgdmFyIGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgICAgdmFyIHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgICAgIHZhciB0aW1lc2NhbGUgPSB0cmFjay50aW1lc2NhbGUgfHwgOTBlMztcbiAgICAgICAgLy8gZ2V0IHRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGZyb20gdGhlIHRmZHRcbiAgICAgICAgZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkuZm9yRWFjaChmdW5jdGlvbiAodGZkdCkge1xuICAgICAgICAgIHZhciB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGltZU9mZnNldCAqIHRpbWVzY2FsZTtcbiAgICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgYmFzZU1lZGlhRGVjb2RlVGltZSA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lIC09IG9mZnNldDtcbiAgICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGgubWF4KGJhc2VNZWRpYURlY29kZVRpbWUsIDApO1xuICAgICAgICAgICAgICB3cml0ZVVpbnQzMih0ZmR0LCA0LCBiYXNlTWVkaWFEZWNvZGVUaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgLT0gb2Zmc2V0O1xuICAgICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5tYXgoYmFzZU1lZGlhRGVjb2RlVGltZSwgMCk7XG4gICAgICAgICAgICAgIHZhciB1cHBlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYJDEgKyAxKSk7XG4gICAgICAgICAgICAgIHZhciBsb3dlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYJDEgKyAxKSk7XG4gICAgICAgICAgICAgIHdyaXRlVWludDMyKHRmZHQsIDQsIHVwcGVyKTtcbiAgICAgICAgICAgICAgd3JpdGVVaW50MzIodGZkdCwgOCwgbG93ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRPRE86IENoZWNrIGlmIHRoZSBsYXN0IG1vb2YrbWRhdCBwYWlyIGlzIHBhcnQgb2YgdGhlIHZhbGlkIHJhbmdlXG4gIGZ1bmN0aW9uIHNlZ21lbnRWYWxpZFJhbmdlKGRhdGEpIHtcbiAgICB2YXIgc2VnbWVudGVkUmFuZ2UgPSB7XG4gICAgICB2YWxpZDogbnVsbCxcbiAgICAgIHJlbWFpbmRlcjogbnVsbFxuICAgIH07XG4gICAgdmFyIG1vb2ZzID0gZmluZEJveChkYXRhLCBbJ21vb2YnXSk7XG4gICAgaWYgKG1vb2ZzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHNlZ21lbnRlZFJhbmdlLnJlbWFpbmRlciA9IGRhdGE7XG4gICAgICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG4gICAgfVxuICAgIHZhciBsYXN0ID0gbW9vZnNbbW9vZnMubGVuZ3RoIC0gMV07XG4gICAgLy8gT2Zmc2V0IGJ5IDggYnl0ZXM7IGZpbmRCb3ggb2Zmc2V0cyB0aGUgc3RhcnQgYnkgYXMgbXVjaFxuICAgIHNlZ21lbnRlZFJhbmdlLnZhbGlkID0gc2xpY2VVaW50OChkYXRhLCAwLCBsYXN0LmJ5dGVPZmZzZXQgLSA4KTtcbiAgICBzZWdtZW50ZWRSYW5nZS5yZW1haW5kZXIgPSBzbGljZVVpbnQ4KGRhdGEsIGxhc3QuYnl0ZU9mZnNldCAtIDgpO1xuICAgIHJldHVybiBzZWdtZW50ZWRSYW5nZTtcbiAgfVxuICBmdW5jdGlvbiBhcHBlbmRVaW50OEFycmF5KGRhdGExLCBkYXRhMikge1xuICAgIHZhciB0ZW1wID0gbmV3IFVpbnQ4QXJyYXkoZGF0YTEubGVuZ3RoICsgZGF0YTIubGVuZ3RoKTtcbiAgICB0ZW1wLnNldChkYXRhMSk7XG4gICAgdGVtcC5zZXQoZGF0YTIsIGRhdGExLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRlbXA7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHRyYWNrKSB7XG4gICAgdmFyIHNlaVNhbXBsZXMgPSBbXTtcbiAgICB2YXIgdmlkZW9EYXRhID0gdHJhY2suc2FtcGxlcztcbiAgICB2YXIgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlO1xuICAgIHZhciB0cmFja0lkID0gdHJhY2suaWQ7XG4gICAgdmFyIGlzSEVWQ0ZsYXZvciA9IGZhbHNlO1xuICAgIHZhciBtb29mcyA9IGZpbmRCb3godmlkZW9EYXRhLCBbJ21vb2YnXSk7XG4gICAgbW9vZnMubWFwKGZ1bmN0aW9uIChtb29mKSB7XG4gICAgICB2YXIgbW9vZk9mZnNldCA9IG1vb2YuYnl0ZU9mZnNldCAtIDg7XG4gICAgICB2YXIgdHJhZnMgPSBmaW5kQm94KG1vb2YsIFsndHJhZiddKTtcbiAgICAgIHRyYWZzLm1hcChmdW5jdGlvbiAodHJhZikge1xuICAgICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgICB2YXIgYmFzZVRpbWUgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKS5tYXAoZnVuY3Rpb24gKHRmZHQpIHtcbiAgICAgICAgICB2YXIgdmVyc2lvbiA9IHRmZHRbMF07XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgICAgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdCAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgICByZXN1bHQgKz0gcmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCAvIHRpbWVzY2FsZTtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIGlmIChiYXNlVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGltZU9mZnNldCA9IGJhc2VUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAoZnVuY3Rpb24gKHRmaGQpIHtcbiAgICAgICAgICB2YXIgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgICAgIHZhciB0ZmhkRmxhZ3MgPSByZWFkVWludDMyKHRmaGQsIDApICYgMHhmZmZmZmY7XG4gICAgICAgICAgdmFyIGJhc2VEYXRhT2Zmc2V0UHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAwMSkgIT09IDA7XG4gICAgICAgICAgdmFyIHNhbXBsZURlc2NyaXB0aW9uSW5kZXhQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDAyKSAhPT0gMDtcbiAgICAgICAgICB2YXIgZGVmYXVsdFNhbXBsZUR1cmF0aW9uUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAwOCkgIT09IDA7XG4gICAgICAgICAgdmFyIGRlZmF1bHRTYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgdmFyIGRlZmF1bHRTYW1wbGVTaXplUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAxMCkgIT09IDA7XG4gICAgICAgICAgdmFyIGRlZmF1bHRTYW1wbGVTaXplID0gMDtcbiAgICAgICAgICB2YXIgZGVmYXVsdFNhbXBsZUZsYWdzUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAyMCkgIT09IDA7XG4gICAgICAgICAgdmFyIHRmaGRPZmZzZXQgPSA4O1xuICAgICAgICAgIGlmIChpZCA9PT0gdHJhY2tJZCkge1xuICAgICAgICAgICAgaWYgKGJhc2VEYXRhT2Zmc2V0UHJlc2VudCkge1xuICAgICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2FtcGxlRGVzY3JpcHRpb25JbmRleFByZXNlbnQpIHtcbiAgICAgICAgICAgICAgdGZoZE9mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZmF1bHRTYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgICAgZGVmYXVsdFNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0ZmhkLCB0ZmhkT2Zmc2V0KTtcbiAgICAgICAgICAgICAgdGZoZE9mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZmF1bHRTYW1wbGVTaXplUHJlc2VudCkge1xuICAgICAgICAgICAgICBkZWZhdWx0U2FtcGxlU2l6ZSA9IHJlYWRVaW50MzIodGZoZCwgdGZoZE9mZnNldCk7XG4gICAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRmxhZ3NQcmVzZW50KSB7XG4gICAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFjay50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgIGlzSEVWQ0ZsYXZvciA9IGlzSEVWQyh0cmFjay5jb2RlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5kQm94KHRyYWYsIFsndHJ1biddKS5tYXAoZnVuY3Rpb24gKHRydW4pIHtcbiAgICAgICAgICAgICAgdmFyIHZlcnNpb24gPSB0cnVuWzBdO1xuICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSByZWFkVWludDMyKHRydW4sIDApICYgMHhmZmZmZmY7XG4gICAgICAgICAgICAgIHZhciBkYXRhT2Zmc2V0UHJlc2VudCA9IChmbGFncyAmIDB4MDAwMDAxKSAhPT0gMDtcbiAgICAgICAgICAgICAgdmFyIGRhdGFPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgZmlyc3RTYW1wbGVGbGFnc1ByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDAwNCkgIT09IDA7XG4gICAgICAgICAgICAgIHZhciBzYW1wbGVEdXJhdGlvblByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDEwMCkgIT09IDA7XG4gICAgICAgICAgICAgIHZhciBzYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICAgIHZhciBzYW1wbGVTaXplUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMjAwKSAhPT0gMDtcbiAgICAgICAgICAgICAgdmFyIHNhbXBsZVNpemUgPSAwO1xuICAgICAgICAgICAgICB2YXIgc2FtcGxlRmxhZ3NQcmVzZW50ID0gKGZsYWdzICYgMHgwMDA0MDApICE9PSAwO1xuICAgICAgICAgICAgICB2YXIgc2FtcGxlQ29tcG9zaXRpb25PZmZzZXRzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwODAwKSAhPT0gMDtcbiAgICAgICAgICAgICAgdmFyIGNvbXBvc2l0aW9uT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIHNhbXBsZUNvdW50ID0gcmVhZFVpbnQzMih0cnVuLCA0KTtcbiAgICAgICAgICAgICAgdmFyIHRydW5PZmZzZXQgPSA4OyAvLyBwYXN0IHZlcnNpb24sIGZsYWdzLCBhbmQgc2FtcGxlIGNvdW50XG5cbiAgICAgICAgICAgICAgaWYgKGRhdGFPZmZzZXRQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgZGF0YU9mZnNldCA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmaXJzdFNhbXBsZUZsYWdzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgc2FtcGxlT2Zmc2V0ID0gZGF0YU9mZnNldCArIG1vb2ZPZmZzZXQ7XG4gICAgICAgICAgICAgIGZvciAodmFyIGl4ID0gMDsgaXggPCBzYW1wbGVDb3VudDsgaXgrKykge1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSBkZWZhdWx0U2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzYW1wbGVTaXplUHJlc2VudCkge1xuICAgICAgICAgICAgICAgICAgc2FtcGxlU2l6ZSA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNhbXBsZVNpemUgPSBkZWZhdWx0U2FtcGxlU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNhbXBsZUZsYWdzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlQ29tcG9zaXRpb25PZmZzZXRzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRpb25PZmZzZXQgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRpb25PZmZzZXQgPSByZWFkU2ludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJhY2sudHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmFsdVRvdGFsU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAobmFsdVRvdGFsU2l6ZSA8IHNhbXBsZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbHVTaXplID0gcmVhZFVpbnQzMih2aWRlb0RhdGEsIHNhbXBsZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZU9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTRUlNZXNzYWdlKGlzSEVWQ0ZsYXZvciwgdmlkZW9EYXRhW3NhbXBsZU9mZnNldF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB2aWRlb0RhdGEuc3ViYXJyYXkoc2FtcGxlT2Zmc2V0LCBzYW1wbGVPZmZzZXQgKyBuYWx1U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTRUlNZXNzYWdlRnJvbU5BTHUoZGF0YSwgaXNIRVZDRmxhdm9yID8gMiA6IDEsIHRpbWVPZmZzZXQgKyBjb21wb3NpdGlvbk9mZnNldCAvIHRpbWVzY2FsZSwgc2VpU2FtcGxlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0ICs9IG5hbHVTaXplO1xuICAgICAgICAgICAgICAgICAgICBuYWx1VG90YWxTaXplICs9IG5hbHVTaXplICsgNDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZU9mZnNldCArPSBzYW1wbGVEdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzZWlTYW1wbGVzO1xuICB9XG4gIGZ1bmN0aW9uIGlzSEVWQyhjb2RlYykge1xuICAgIGlmICghY29kZWMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGRlbGltaXQgPSBjb2RlYy5pbmRleE9mKCcuJyk7XG4gICAgdmFyIGJhc2VDb2RlYyA9IGRlbGltaXQgPCAwID8gY29kZWMgOiBjb2RlYy5zdWJzdHJpbmcoMCwgZGVsaW1pdCk7XG4gICAgcmV0dXJuIGJhc2VDb2RlYyA9PT0gJ2h2YzEnIHx8IGJhc2VDb2RlYyA9PT0gJ2hldjEnIHx8XG4gICAgLy8gRG9sYnkgVmlzaW9uXG4gICAgYmFzZUNvZGVjID09PSAnZHZoMScgfHwgYmFzZUNvZGVjID09PSAnZHZoZSc7XG4gIH1cbiAgZnVuY3Rpb24gaXNTRUlNZXNzYWdlKGlzSEVWQ0ZsYXZvciwgbmFsdUhlYWRlcikge1xuICAgIGlmIChpc0hFVkNGbGF2b3IpIHtcbiAgICAgIHZhciBuYWx1VHlwZSA9IG5hbHVIZWFkZXIgPj4gMSAmIDB4M2Y7XG4gICAgICByZXR1cm4gbmFsdVR5cGUgPT09IDM5IHx8IG5hbHVUeXBlID09PSA0MDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9uYWx1VHlwZSA9IG5hbHVIZWFkZXIgJiAweDFmO1xuICAgICAgcmV0dXJuIF9uYWx1VHlwZSA9PT0gNjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTRUlNZXNzYWdlRnJvbU5BTHUodW5lc2NhcGVkRGF0YSwgaGVhZGVyU2l6ZSwgcHRzLCBzYW1wbGVzKSB7XG4gICAgdmFyIGRhdGEgPSBkaXNjYXJkRVBCKHVuZXNjYXBlZERhdGEpO1xuICAgIHZhciBzZWlQdHIgPSAwO1xuICAgIC8vIHNraXAgbmFsIGhlYWRlclxuICAgIHNlaVB0ciArPSBoZWFkZXJTaXplO1xuICAgIHZhciBwYXlsb2FkVHlwZSA9IDA7XG4gICAgdmFyIHBheWxvYWRTaXplID0gMDtcbiAgICB2YXIgYiA9IDA7XG4gICAgd2hpbGUgKHNlaVB0ciA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICBwYXlsb2FkVHlwZSA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzZWlQdHIgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBiID0gZGF0YVtzZWlQdHIrK107XG4gICAgICAgIHBheWxvYWRUeXBlICs9IGI7XG4gICAgICB9IHdoaWxlIChiID09PSAweGZmKTtcblxuICAgICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplLlxuICAgICAgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoc2VpUHRyID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYiA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgICBwYXlsb2FkU2l6ZSArPSBiO1xuICAgICAgfSB3aGlsZSAoYiA9PT0gMHhmZik7XG4gICAgICB2YXIgbGVmdE92ZXIgPSBkYXRhLmxlbmd0aCAtIHNlaVB0cjtcbiAgICAgIC8vIENyZWF0ZSBhIHZhcmlhYmxlIHRvIHByb2Nlc3MgdGhlIHBheWxvYWRcbiAgICAgIHZhciBwYXlQdHIgPSBzZWlQdHI7XG5cbiAgICAgIC8vIEluY3JlbWVudCB0aGUgc2VpUHRyIHRvIHRoZSBlbmQgb2YgdGhlIHBheWxvYWRcbiAgICAgIGlmIChwYXlsb2FkU2l6ZSA8IGxlZnRPdmVyKSB7XG4gICAgICAgIHNlaVB0ciArPSBwYXlsb2FkU2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPiBsZWZ0T3Zlcikge1xuICAgICAgICAvLyBTb21lIHR5cGUgb2YgY29ycnVwdGlvbiBoYXMgaGFwcGVuZWQ/XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIk1hbGZvcm1lZCBTRUkgcGF5bG9hZC4gXCIgKyBwYXlsb2FkU2l6ZSArIFwiIGlzIHRvbyBzbWFsbCwgb25seSBcIiArIGxlZnRPdmVyICsgXCIgYnl0ZXMgbGVmdCB0byBwYXJzZS5cIik7XG4gICAgICAgIC8vIFdlIG1pZ2h0IGJlIGFibGUgdG8gcGFyc2Ugc29tZSBkYXRhLCBidXQgbGV0J3MgYmUgc2FmZSBhbmQgaWdub3JlIGl0LlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChwYXlsb2FkVHlwZSA9PT0gNCkge1xuICAgICAgICB2YXIgY291bnRyeUNvZGUgPSBkYXRhW3BheVB0cisrXTtcbiAgICAgICAgaWYgKGNvdW50cnlDb2RlID09PSAxODEpIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZXJDb2RlID0gcmVhZFVpbnQxNihkYXRhLCBwYXlQdHIpO1xuICAgICAgICAgIHBheVB0ciArPSAyO1xuICAgICAgICAgIGlmIChwcm92aWRlckNvZGUgPT09IDQ5KSB7XG4gICAgICAgICAgICB2YXIgdXNlclN0cnVjdHVyZSA9IHJlYWRVaW50MzIoZGF0YSwgcGF5UHRyKTtcbiAgICAgICAgICAgIHBheVB0ciArPSA0O1xuICAgICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcbiAgICAgICAgICAgICAgdmFyIHVzZXJEYXRhVHlwZSA9IGRhdGFbcGF5UHRyKytdO1xuXG4gICAgICAgICAgICAgIC8vIFJhdyBDRUEtNjA4IGJ5dGVzIHdyYXBwZWQgaW4gQ0VBLTcwOCBwYWNrZXRcbiAgICAgICAgICAgICAgaWYgKHVzZXJEYXRhVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdEJ5dGUgPSBkYXRhW3BheVB0cisrXTtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxDQ3MgPSAweDFmICYgZmlyc3RCeXRlO1xuICAgICAgICAgICAgICAgIHZhciBlbmFibGVkID0gMHg0MCAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxCeXRlcyA9IGVuYWJsZWQgPyAyICsgdG90YWxDQ3MgKiAzIDogMDtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxCeXRlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheVswXSA9IGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdG90YWxCeXRlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtpXSA9IGRhdGFbcGF5UHRyKytdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogdXNlckRhdGFUeXBlLFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZFR5cGU6IHBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgcHRzOiBwdHMsXG4gICAgICAgICAgICAgICAgICBieXRlczogYnl0ZUFycmF5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGF5bG9hZFR5cGUgPT09IDUpIHtcbiAgICAgICAgaWYgKHBheWxvYWRTaXplID4gMTYpIHtcbiAgICAgICAgICB2YXIgdXVpZFN0ckFycmF5ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgMTY7IF9pMysrKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBkYXRhW3BheVB0cisrXS50b1N0cmluZygxNik7XG4gICAgICAgICAgICB1dWlkU3RyQXJyYXkucHVzaChfYi5sZW5ndGggPT0gMSA/ICcwJyArIF9iIDogX2IpO1xuICAgICAgICAgICAgaWYgKF9pMyA9PT0gMyB8fCBfaTMgPT09IDUgfHwgX2kzID09PSA3IHx8IF9pMyA9PT0gOSkge1xuICAgICAgICAgICAgICB1dWlkU3RyQXJyYXkucHVzaCgnLScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGVuZ3RoID0gcGF5bG9hZFNpemUgLSAxNjtcbiAgICAgICAgICB2YXIgdXNlckRhdGFCeXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgICAgdXNlckRhdGFCeXRlc1tfaTRdID0gZGF0YVtwYXlQdHIrK107XG4gICAgICAgICAgfVxuICAgICAgICAgIHNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICBwYXlsb2FkVHlwZTogcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICBwdHM6IHB0cyxcbiAgICAgICAgICAgIHV1aWQ6IHV1aWRTdHJBcnJheS5qb2luKCcnKSxcbiAgICAgICAgICAgIHVzZXJEYXRhOiB1dGY4QXJyYXlUb1N0cih1c2VyRGF0YUJ5dGVzKSxcbiAgICAgICAgICAgIHVzZXJEYXRhQnl0ZXM6IHVzZXJEYXRhQnl0ZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmUgRW11bGF0aW9uIFByZXZlbnRpb24gYnl0ZXMgZnJvbSBhIFJCU1BcbiAgICovXG4gIGZ1bmN0aW9uIGRpc2NhcmRFUEIoZGF0YSkge1xuICAgIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgdmFyIEVQQlBvc2l0aW9ucyA9IFtdO1xuICAgIHZhciBpID0gMTtcblxuICAgIC8vIEZpbmQgYWxsIGBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlc2BcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCAtIDIpIHtcbiAgICAgIGlmIChkYXRhW2ldID09PSAwICYmIGRhdGFbaSArIDFdID09PSAwICYmIGRhdGFbaSArIDJdID09PSAweDAzKSB7XG4gICAgICAgIEVQQlBvc2l0aW9ucy5wdXNoKGkgKyAyKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIEVtdWxhdGlvbiBQcmV2ZW50aW9uIEJ5dGVzIHdlcmUgZm91bmQganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgLy8gYXJyYXlcbiAgICBpZiAoRVBCUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcbiAgICB2YXIgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gRVBCUG9zaXRpb25zLmxlbmd0aDtcbiAgICB2YXIgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmV3TGVuZ3RoOyBzb3VyY2VJbmRleCsrLCBpKyspIHtcbiAgICAgIGlmIChzb3VyY2VJbmRleCA9PT0gRVBCUG9zaXRpb25zWzBdKSB7XG4gICAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICAgIHNvdXJjZUluZGV4Kys7XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIHBvc2l0aW9uIGluZGV4XG4gICAgICAgIEVQQlBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgbmV3RGF0YVtpXSA9IGRhdGFbc291cmNlSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUVtc2coZGF0YSkge1xuICAgIHZhciB2ZXJzaW9uID0gZGF0YVswXTtcbiAgICB2YXIgc2NoZW1lSWRVcmkgPSAnJztcbiAgICB2YXIgdmFsdWUgPSAnJztcbiAgICB2YXIgdGltZVNjYWxlID0gMDtcbiAgICB2YXIgcHJlc2VudGF0aW9uVGltZURlbHRhID0gMDtcbiAgICB2YXIgcHJlc2VudGF0aW9uVGltZSA9IDA7XG4gICAgdmFyIGV2ZW50RHVyYXRpb24gPSAwO1xuICAgIHZhciBpZCA9IDA7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICB9XG4gICAgICBzY2hlbWVJZFVyaSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICB9XG4gICAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIHRpbWVTY2FsZSA9IHJlYWRVaW50MzIoZGF0YSwgMTIpO1xuICAgICAgcHJlc2VudGF0aW9uVGltZURlbHRhID0gcmVhZFVpbnQzMihkYXRhLCAxNik7XG4gICAgICBldmVudER1cmF0aW9uID0gcmVhZFVpbnQzMihkYXRhLCAyMCk7XG4gICAgICBpZCA9IHJlYWRVaW50MzIoZGF0YSwgMjQpO1xuICAgICAgb2Zmc2V0ID0gMjg7XG4gICAgfSBlbHNlIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIHRpbWVTY2FsZSA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgICAgdmFyIGxlZnRQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICB2YXIgcmlnaHRQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICBwcmVzZW50YXRpb25UaW1lID0gTWF0aC5wb3coMiwgMzIpICogbGVmdFByZXNlbnRhdGlvblRpbWUgKyByaWdodFByZXNlbnRhdGlvblRpbWU7XG4gICAgICBpZiAoIWlzU2FmZUludGVnZXIocHJlc2VudGF0aW9uVGltZSkpIHtcbiAgICAgICAgcHJlc2VudGF0aW9uVGltZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICBsb2dnZXIud2FybignUHJlc2VudGF0aW9uIHRpbWUgZXhjZWVkcyBzYWZlIGludGVnZXIgbGltaXQgYW5kIHdyYXBwZWQgdG8gbWF4IHNhZmUgaW50ZWdlciBpbiBwYXJzaW5nIGVtc2cgYm94Jyk7XG4gICAgICB9XG4gICAgICBldmVudER1cmF0aW9uID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICBpZCA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIH1cbiAgICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIH1cbiAgICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cbiAgICB2YXIgcGF5bG9hZCA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWVJZFVyaTogc2NoZW1lSWRVcmksXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICB0aW1lU2NhbGU6IHRpbWVTY2FsZSxcbiAgICAgIHByZXNlbnRhdGlvblRpbWU6IHByZXNlbnRhdGlvblRpbWUsXG4gICAgICBwcmVzZW50YXRpb25UaW1lRGVsdGE6IHByZXNlbnRhdGlvblRpbWVEZWx0YSxcbiAgICAgIGV2ZW50RHVyYXRpb246IGV2ZW50RHVyYXRpb24sXG4gICAgICBpZDogaWQsXG4gICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBtcDRCb3godHlwZSkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXlsb2FkID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBheWxvYWRbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICB2YXIgbGVuID0gcGF5bG9hZC5sZW5ndGg7XG4gICAgdmFyIHNpemUgPSA4O1xuICAgIHZhciBpID0gbGVuO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgcmVzdWx0WzBdID0gc2l6ZSA+PiAyNCAmIDB4ZmY7XG4gICAgcmVzdWx0WzFdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG4gICAgcmVzdWx0WzJdID0gc2l6ZSA+PiA4ICYgMHhmZjtcbiAgICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcbiAgICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICAgIGZvciAoaSA9IDAsIHNpemUgPSA4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBtcDRwc3NoKHN5c3RlbUlkLCBrZXlpZHMsIGRhdGEpIHtcbiAgICBpZiAoc3lzdGVtSWQuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN5c3RlbSBpZCcpO1xuICAgIH1cbiAgICB2YXIgdmVyc2lvbjtcbiAgICB2YXIga2lkcztcbiAgICBpZiAoa2V5aWRzKSB7XG4gICAgICB2ZXJzaW9uID0gMTtcbiAgICAgIGtpZHMgPSBuZXcgVWludDhBcnJheShrZXlpZHMubGVuZ3RoICogMTYpO1xuICAgICAgZm9yICh2YXIgaXggPSAwOyBpeCA8IGtleWlkcy5sZW5ndGg7IGl4KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlpZHNbaXhdOyAvLyB1aW50OGFycmF5XG4gICAgICAgIGlmIChrLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAga2lkcy5zZXQoaywgaXggKiAxNik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcnNpb24gPSAwO1xuICAgICAga2lkcyA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxuICAgIHZhciBraWRDb3VudDtcbiAgICBpZiAodmVyc2lvbiA+IDApIHtcbiAgICAgIGtpZENvdW50ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICBpZiAoa2V5aWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbmV3IERhdGFWaWV3KGtpZENvdW50LmJ1ZmZlcikuc2V0VWludDMyKDAsIGtleWlkcy5sZW5ndGgsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2lkQ291bnQgPSBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB2YXIgZGF0YVNpemUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICBuZXcgRGF0YVZpZXcoZGF0YVNpemUuYnVmZmVyKS5zZXRVaW50MzIoMCwgZGF0YS5ieXRlTGVuZ3RoLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBtcDRCb3goWzExMiwgMTE1LCAxMTUsIDEwNF0sIG5ldyBVaW50OEFycmF5KFt2ZXJzaW9uLCAweDAwLCAweDAwLCAweDAwIC8vIEZsYWdzXG4gICAgXSksIHN5c3RlbUlkLFxuICAgIC8vIDE2IGJ5dGVzXG4gICAga2lkQ291bnQsIGtpZHMsIGRhdGFTaXplLCBkYXRhIHx8IG5ldyBVaW50OEFycmF5KCkpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlTXVsdGlQc3NoKGluaXREYXRhKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAoaW5pdERhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGxlbmd0aCA9IGluaXREYXRhLmJ5dGVMZW5ndGg7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHdoaWxlIChvZmZzZXQgKyAzMiA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbml0RGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgdmFyIHBzc2ggPSBwYXJzZVBzc2godmlldyk7XG4gICAgICAgIHJlc3VsdHMucHVzaChwc3NoKTtcbiAgICAgICAgb2Zmc2V0ICs9IHBzc2guc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VQc3NoKHZpZXcpIHtcbiAgICB2YXIgc2l6ZSA9IHZpZXcuZ2V0VWludDMyKDApO1xuICAgIHZhciBvZmZzZXQgPSB2aWV3LmJ5dGVPZmZzZXQ7XG4gICAgdmFyIGxlbmd0aCA9IHZpZXcuYnl0ZUxlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHNpemU6IGxlbmd0aFxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB2aWV3LmdldFVpbnQzMig0KTtcbiAgICBpZiAodHlwZSAhPT0gMHg3MDczNzM2OCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHNpemU6IHNpemVcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciB2ZXJzaW9uID0gdmlldy5nZXRVaW50MzIoOCkgPj4+IDI0O1xuICAgIGlmICh2ZXJzaW9uICE9PSAwICYmIHZlcnNpb24gIT09IDEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBzaXplOiBzaXplXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgYnVmZmVyID0gdmlldy5idWZmZXI7XG4gICAgdmFyIHN5c3RlbUlkID0gSGV4LmhleER1bXAobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQgKyAxMiwgMTYpKTtcbiAgICB2YXIgZGF0YVNpemVPcktpZENvdW50ID0gdmlldy5nZXRVaW50MzIoMjgpO1xuICAgIHZhciBraWRzID0gbnVsbDtcbiAgICB2YXIgZGF0YSA9IG51bGw7XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgIGlmIChzaXplIC0gMzIgPCBkYXRhU2l6ZU9yS2lkQ291bnQgfHwgZGF0YVNpemVPcktpZENvdW50IDwgMjIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQgKyAzMiwgZGF0YVNpemVPcktpZENvdW50KTtcbiAgICB9IGVsc2UgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgIGlmICghZGF0YVNpemVPcktpZENvdW50IHx8IGxlbmd0aCA8IG9mZnNldCArIDMyICsgZGF0YVNpemVPcktpZENvdW50ICogMTYgKyAxNikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGtpZHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVNpemVPcktpZENvdW50OyBpKyspIHtcbiAgICAgICAga2lkcy5wdXNoKG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgb2Zmc2V0ICsgMzIgKyBpICogMTYsIDE2KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgc3lzdGVtSWQ6IHN5c3RlbUlkLFxuICAgICAga2lkczoga2lkcyxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIHNpemU6IHNpemVcbiAgICB9O1xuICB9XG5cbiAgdmFyIGtleVVyaVRvS2V5SWRNYXAgPSB7fTtcbiAgdmFyIExldmVsS2V5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBMZXZlbEtleS5jbGVhcktleVVyaVRvS2V5SWRNYXAgPSBmdW5jdGlvbiBjbGVhcktleVVyaVRvS2V5SWRNYXAoKSB7XG4gICAgICBrZXlVcmlUb0tleUlkTWFwID0ge307XG4gICAgfTtcbiAgICBmdW5jdGlvbiBMZXZlbEtleShtZXRob2QsIHVyaSwgZm9ybWF0LCBmb3JtYXR2ZXJzaW9ucywgaXYpIHtcbiAgICAgIGlmIChmb3JtYXR2ZXJzaW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGZvcm1hdHZlcnNpb25zID0gWzFdO1xuICAgICAgfVxuICAgICAgaWYgKGl2ID09PSB2b2lkIDApIHtcbiAgICAgICAgaXYgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy51cmkgPSB2b2lkIDA7XG4gICAgICB0aGlzLm1ldGhvZCA9IHZvaWQgMDtcbiAgICAgIHRoaXMua2V5Rm9ybWF0ID0gdm9pZCAwO1xuICAgICAgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZW5jcnlwdGVkID0gdm9pZCAwO1xuICAgICAgdGhpcy5pc0NvbW1vbkVuY3J5cHRpb24gPSB2b2lkIDA7XG4gICAgICB0aGlzLml2ID0gbnVsbDtcbiAgICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICAgIHRoaXMua2V5SWQgPSBudWxsO1xuICAgICAgdGhpcy5wc3NoID0gbnVsbDtcbiAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgdGhpcy51cmkgPSB1cmk7XG4gICAgICB0aGlzLmtleUZvcm1hdCA9IGZvcm1hdDtcbiAgICAgIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMgPSBmb3JtYXR2ZXJzaW9ucztcbiAgICAgIHRoaXMuaXYgPSBpdjtcbiAgICAgIHRoaXMuZW5jcnlwdGVkID0gbWV0aG9kID8gbWV0aG9kICE9PSAnTk9ORScgOiBmYWxzZTtcbiAgICAgIHRoaXMuaXNDb21tb25FbmNyeXB0aW9uID0gdGhpcy5lbmNyeXB0ZWQgJiYgbWV0aG9kICE9PSAnQUVTLTEyOCc7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBMZXZlbEtleS5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAvLyBJZiBpdCdzIFNlZ21lbnQgZW5jcnlwdGlvbiBvciBObyBlbmNyeXB0aW9uLCBqdXN0IHNlbGVjdCB0aGF0IGtleSBzeXN0ZW1cbiAgICAgIGlmICh0aGlzLm1ldGhvZCkge1xuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09ICdBRVMtMTI4JyB8fCB0aGlzLm1ldGhvZCA9PT0gJ05PTkUnKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMua2V5Rm9ybWF0ID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgLy8gTWFpbnRhaW4gc3VwcG9ydCBmb3IgY2xlYXIgU0FNUExFLUFFUyB3aXRoIE1QRUctMyBUU1xuICAgICAgICAgIHJldHVybiB0aGlzLm1ldGhvZCA9PT0gJ1NBTVBMRS1BRVMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAodGhpcy5rZXlGb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTpcbiAgICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5XSURFVklORTpcbiAgICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6XG4gICAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuQ0xFQVJLRVk6XG4gICAgICAgICAgICAgIHJldHVybiBbJ0lTTy0yMzAwMS03JywgJ1NBTVBMRS1BRVMnLCAnU0FNUExFLUFFUy1DRU5DJywgJ1NBTVBMRS1BRVMtQ1RSJ10uaW5kZXhPZih0aGlzLm1ldGhvZCkgIT09IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLmdldERlY3J5cHREYXRhID0gZnVuY3Rpb24gZ2V0RGVjcnlwdERhdGEoc24pIHtcbiAgICAgIGlmICghdGhpcy5lbmNyeXB0ZWQgfHwgIXRoaXMudXJpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAnQUVTLTEyOCcgJiYgdGhpcy51cmkgJiYgIXRoaXMuaXYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAvLyBXZSBhcmUgZmV0Y2hpbmcgZGVjcnlwdGlvbiBkYXRhIGZvciBhIGluaXRpYWxpemF0aW9uIHNlZ21lbnRcbiAgICAgICAgICAvLyBJZiB0aGUgc2VnbWVudCB3YXMgZW5jcnlwdGVkIHdpdGggQUVTLTEyOFxuICAgICAgICAgIC8vIEl0IG11c3QgaGF2ZSBhbiBJViBkZWZpbmVkLiBXZSBjYW5ub3Qgc3Vic3RpdHV0ZSB0aGUgU2VnbWVudCBOdW1iZXIgaW4uXG4gICAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAnQUVTLTEyOCcgJiYgIXRoaXMuaXYpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwibWlzc2luZyBJViBmb3IgaW5pdGlhbGl6YXRpb24gc2VnbWVudCB3aXRoIG1ldGhvZD1cXFwiXCIgKyB0aGlzLm1ldGhvZCArIFwiXFxcIiAtIGNvbXBsaWFuY2UgaXNzdWVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHNuIHRvIHJlc3VsdGluZyB2YWx1ZSBmcm9tIGltcGxpY2l0IGNvbnZlcnNpb25zICdpbml0U2VnbWVudCcgdmFsdWVzIGZvciBJViBnZW5lcmF0aW9uLlxuICAgICAgICAgIHNuID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXYgPSBjcmVhdGVJbml0aWFsaXphdGlvblZlY3Rvcihzbik7XG4gICAgICAgIHZhciBkZWNyeXB0ZGF0YSA9IG5ldyBMZXZlbEtleSh0aGlzLm1ldGhvZCwgdGhpcy51cmksICdpZGVudGl0eScsIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMsIGl2KTtcbiAgICAgICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0aWFsaXplIGtleUlkIGlmIHBvc3NpYmxlXG4gICAgICB2YXIga2V5Qnl0ZXMgPSBjb252ZXJ0RGF0YVVyaVRvQXJyYXlCeXRlcyh0aGlzLnVyaSk7XG4gICAgICBpZiAoa2V5Qnl0ZXMpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmtleUZvcm1hdCkge1xuICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5XSURFVklORTpcbiAgICAgICAgICAgIHRoaXMucHNzaCA9IGtleUJ5dGVzO1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiB3aWRldmluZSBrZXlJRCBpcyBlbWJlZGRlZCBpbiBQU1NIIGJveC4gUmVhZCBLZXkgSUQuXG4gICAgICAgICAgICBpZiAoa2V5Qnl0ZXMubGVuZ3RoID49IDIyKSB7XG4gICAgICAgICAgICAgIHRoaXMua2V5SWQgPSBrZXlCeXRlcy5zdWJhcnJheShrZXlCeXRlcy5sZW5ndGggLSAyMiwga2V5Qnl0ZXMubGVuZ3RoIC0gNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgUGxheVJlYWR5S2V5U3lzdGVtVVVJRCA9IG5ldyBVaW50OEFycmF5KFsweDlhLCAweDA0LCAweGYwLCAweDc5LCAweDk4LCAweDQwLCAweDQyLCAweDg2LCAweGFiLCAweDkyLCAweGU2LCAweDViLCAweGUwLCAweDg4LCAweDVmLCAweDk1XSk7XG4gICAgICAgICAgICAgIHRoaXMucHNzaCA9IG1wNHBzc2goUGxheVJlYWR5S2V5U3lzdGVtVVVJRCwgbnVsbCwga2V5Qnl0ZXMpO1xuICAgICAgICAgICAgICB2YXIga2V5Qnl0ZXNVdGYxNiA9IG5ldyBVaW50MTZBcnJheShrZXlCeXRlcy5idWZmZXIsIGtleUJ5dGVzLmJ5dGVPZmZzZXQsIGtleUJ5dGVzLmJ5dGVMZW5ndGggLyAyKTtcbiAgICAgICAgICAgICAgdmFyIGtleUJ5dGVTdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIEFycmF5LmZyb20oa2V5Qnl0ZXNVdGYxNikpO1xuXG4gICAgICAgICAgICAgIC8vIFBhcnNlIFBsYXlyZWFkeSBXUk1IZWFkZXIgWE1MXG4gICAgICAgICAgICAgIHZhciB4bWxLZXlCeXRlcyA9IGtleUJ5dGVTdHIuc3Vic3RyaW5nKGtleUJ5dGVTdHIuaW5kZXhPZignPCcpLCBrZXlCeXRlU3RyLmxlbmd0aCk7XG4gICAgICAgICAgICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgICAgICAgIHZhciB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbEtleUJ5dGVzLCAndGV4dC94bWwnKTtcbiAgICAgICAgICAgICAgdmFyIGtleURhdGEgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0tJRCcpWzBdO1xuICAgICAgICAgICAgICBpZiAoa2V5RGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlJZCA9IGtleURhdGEuY2hpbGROb2Rlc1swXSA/IGtleURhdGEuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUgOiBrZXlEYXRhLmdldEF0dHJpYnV0ZSgnVkFMVUUnKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5SWQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXlJZEFycmF5ID0gYmFzZTY0RGVjb2RlKGtleUlkKS5zdWJhcnJheSgwLCAxNik7XG4gICAgICAgICAgICAgICAgICAvLyBLSUQgdmFsdWUgaW4gUFJPIGlzIGEgYmFzZTY0LWVuY29kZWQgbGl0dGxlIGVuZGlhbiBHVUlEIGludGVycHJldGF0aW9uIG9mIFVVSURcbiAgICAgICAgICAgICAgICAgIC8vIEtJRCB2YWx1ZSBpbiDigJh0ZW5j4oCZIGlzIGEgYmlnIGVuZGlhbiBVVUlEIEdVSUQgaW50ZXJwcmV0YXRpb24gb2YgVVVJRFxuICAgICAgICAgICAgICAgICAgY2hhbmdlRW5kaWFubmVzcyhrZXlJZEFycmF5KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMua2V5SWQgPSBrZXlJZEFycmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIga2V5ZGF0YSA9IGtleUJ5dGVzLnN1YmFycmF5KDAsIDE2KTtcbiAgICAgICAgICAgICAgaWYgKGtleWRhdGEubGVuZ3RoICE9PSAxNikge1xuICAgICAgICAgICAgICAgIHZhciBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgICAgICAgICAgcGFkZGVkLnNldChrZXlkYXRhLCAxNiAtIGtleWRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBrZXlkYXRhID0gcGFkZGVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMua2V5SWQgPSBrZXlkYXRhO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yOiBhc3NpZ24gYSBuZXcga2V5SWQgZm9yIGVhY2ggdXJpXG4gICAgICBpZiAoIXRoaXMua2V5SWQgfHwgdGhpcy5rZXlJZC5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgICAgICB2YXIgX2tleUlkID0ga2V5VXJpVG9LZXlJZE1hcFt0aGlzLnVyaV07XG4gICAgICAgIGlmICghX2tleUlkKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IE9iamVjdC5rZXlzKGtleVVyaVRvS2V5SWRNYXApLmxlbmd0aCAlIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgIF9rZXlJZCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgICB2YXIgZHYgPSBuZXcgRGF0YVZpZXcoX2tleUlkLmJ1ZmZlciwgMTIsIDQpOyAvLyBKdXN0IHNldCB0aGUgbGFzdCA0IGJ5dGVzXG4gICAgICAgICAgZHYuc2V0VWludDMyKDAsIHZhbCk7XG4gICAgICAgICAga2V5VXJpVG9LZXlJZE1hcFt0aGlzLnVyaV0gPSBfa2V5SWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXlJZCA9IF9rZXlJZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIExldmVsS2V5O1xuICB9KCk7XG4gIGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxpemF0aW9uVmVjdG9yKHNlZ21lbnROdW1iZXIpIHtcbiAgICB2YXIgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGZvciAodmFyIGkgPSAxMjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHVpbnQ4Vmlld1tpXSA9IHNlZ21lbnROdW1iZXIgPj4gOCAqICgxNSAtIGkpICYgMHhmZjtcbiAgICB9XG4gICAgcmV0dXJuIHVpbnQ4VmlldztcbiAgfVxuXG4gIHZhciBWQVJJQUJMRV9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHtcXCQoW2EtekEtWjAtOS1fXSspXFx9L2c7XG4gIGZ1bmN0aW9uIGhhc1ZhcmlhYmxlUmVmZXJlbmNlcyhzdHIpIHtcbiAgICByZXR1cm4gVkFSSUFCTEVfUkVQTEFDRU1FTlRfUkVHRVgudGVzdChzdHIpO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBhdHRyLCBhdHRyaWJ1dGVOYW1lcykge1xuICAgIGlmIChwYXJzZWQudmFyaWFibGVMaXN0ICE9PSBudWxsIHx8IHBhcnNlZC5oYXNWYXJpYWJsZVJlZnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXR0cltuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgYXR0cltuYW1lXSA9IHN1YnN0aXR1dGVWYXJpYWJsZXMocGFyc2VkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3Vic3RpdHV0ZVZhcmlhYmxlcyhwYXJzZWQsIHZhbHVlKSB7XG4gICAgaWYgKHBhcnNlZC52YXJpYWJsZUxpc3QgIT09IG51bGwgfHwgcGFyc2VkLmhhc1ZhcmlhYmxlUmVmcykge1xuICAgICAgdmFyIHZhcmlhYmxlTGlzdCA9IHBhcnNlZC52YXJpYWJsZUxpc3Q7XG4gICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShWQVJJQUJMRV9SRVBMQUNFTUVOVF9SRUdFWCwgZnVuY3Rpb24gKHZhcmlhYmxlUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhciB2YXJpYWJsZU5hbWUgPSB2YXJpYWJsZVJlZmVyZW5jZS5zdWJzdHJpbmcoMiwgdmFyaWFibGVSZWZlcmVuY2UubGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciB2YXJpYWJsZVZhbHVlID0gdmFyaWFibGVMaXN0ID09IG51bGwgPyB2b2lkIDAgOiB2YXJpYWJsZUxpc3RbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgaWYgKHZhcmlhYmxlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKFwiTWlzc2luZyBwcmVjZWRpbmcgRVhULVgtREVGSU5FIHRhZyBmb3IgVmFyaWFibGUgUmVmZXJlbmNlOiBcXFwiXCIgKyB2YXJpYWJsZU5hbWUgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIHJldHVybiB2YXJpYWJsZVJlZmVyZW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyaWFibGVWYWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gYWRkVmFyaWFibGVEZWZpbml0aW9uKHBhcnNlZCwgYXR0ciwgcGFyZW50VXJsKSB7XG4gICAgdmFyIHZhcmlhYmxlTGlzdCA9IHBhcnNlZC52YXJpYWJsZUxpc3Q7XG4gICAgaWYgKCF2YXJpYWJsZUxpc3QpIHtcbiAgICAgIHBhcnNlZC52YXJpYWJsZUxpc3QgPSB2YXJpYWJsZUxpc3QgPSB7fTtcbiAgICB9XG4gICAgdmFyIE5BTUU7XG4gICAgdmFyIFZBTFVFO1xuICAgIGlmICgnUVVFUllQQVJBTScgaW4gYXR0cikge1xuICAgICAgTkFNRSA9IGF0dHIuUVVFUllQQVJBTTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzZWFyY2hQYXJhbXMgPSBuZXcgc2VsZi5VUkwocGFyZW50VXJsKS5zZWFyY2hQYXJhbXM7XG4gICAgICAgIGlmIChzZWFyY2hQYXJhbXMuaGFzKE5BTUUpKSB7XG4gICAgICAgICAgVkFMVUUgPSBzZWFyY2hQYXJhbXMuZ2V0KE5BTUUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJcIiArIE5BTUUgKyBcIlxcXCIgZG9lcyBub3QgbWF0Y2ggYW55IHF1ZXJ5IHBhcmFtZXRlciBpbiBVUkk6IFxcXCJcIiArIHBhcmVudFVybCArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yIHx8IChwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoXCJFWFQtWC1ERUZJTkUgUVVFUllQQVJBTTogXCIgKyBlcnJvci5tZXNzYWdlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIE5BTUUgPSBhdHRyLk5BTUU7XG4gICAgICBWQUxVRSA9IGF0dHIuVkFMVUU7XG4gICAgfVxuICAgIGlmIChOQU1FIGluIHZhcmlhYmxlTGlzdCkge1xuICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yIHx8IChwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoXCJFWFQtWC1ERUZJTkUgZHVwbGljYXRlIFZhcmlhYmxlIE5hbWUgZGVjbGFyYXRpb25zOiBcXFwiXCIgKyBOQU1FICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyaWFibGVMaXN0W05BTUVdID0gVkFMVUUgfHwgJyc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGltcG9ydFZhcmlhYmxlRGVmaW5pdGlvbihwYXJzZWQsIGF0dHIsIHNvdXJjZVZhcmlhYmxlTGlzdCkge1xuICAgIHZhciBJTVBPUlQgPSBhdHRyLklNUE9SVDtcbiAgICBpZiAoc291cmNlVmFyaWFibGVMaXN0ICYmIElNUE9SVCBpbiBzb3VyY2VWYXJpYWJsZUxpc3QpIHtcbiAgICAgIHZhciB2YXJpYWJsZUxpc3QgPSBwYXJzZWQudmFyaWFibGVMaXN0O1xuICAgICAgaWYgKCF2YXJpYWJsZUxpc3QpIHtcbiAgICAgICAgcGFyc2VkLnZhcmlhYmxlTGlzdCA9IHZhcmlhYmxlTGlzdCA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyaWFibGVMaXN0W0lNUE9SVF0gPSBzb3VyY2VWYXJpYWJsZUxpc3RbSU1QT1JUXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yIHx8IChwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoXCJFWFQtWC1ERUZJTkUgSU1QT1JUIGF0dHJpYnV0ZSBub3QgZm91bmQgaW4gTXVsdGl2YXJpYW50IFBsYXlsaXN0OiBcXFwiXCIgKyBJTVBPUlQgKyBcIlxcXCJcIikpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZWRpYVNvdXJjZSBoZWxwZXJcbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0TWVkaWFTb3VyY2UocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSB7XG4gICAgaWYgKHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHZhciBtbXMgPSAocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlIHx8ICFzZWxmLk1lZGlhU291cmNlKSAmJiBzZWxmLk1hbmFnZWRNZWRpYVNvdXJjZTtcbiAgICByZXR1cm4gbW1zIHx8IHNlbGYuTWVkaWFTb3VyY2UgfHwgc2VsZi5XZWJLaXRNZWRpYVNvdXJjZTtcbiAgfVxuICBmdW5jdGlvbiBpc01hbmFnZWRNZWRpYVNvdXJjZShzb3VyY2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNvdXJjZSA9PT0gc2VsZi5NYW5hZ2VkTWVkaWFTb3VyY2U7XG4gIH1cblxuICAvLyBmcm9tIGh0dHA6Ly9tcDRyYS5vcmcvY29kZWNzLmh0bWxcbiAgLy8gdmFsdWVzIGluZGljYXRlIGNvZGVjIHNlbGVjdGlvbiBwcmVmZXJlbmNlIChsb3dlciBpcyBoaWdoZXIgcHJpb3JpdHkpXG4gIHZhciBzYW1wbGVFbnRyeUNvZGVzSVNPID0ge1xuICAgIGF1ZGlvOiB7XG4gICAgICBhM2RzOiAxLFxuICAgICAgJ2FjLTMnOiAwLjk1LFxuICAgICAgJ2FjLTQnOiAxLFxuICAgICAgYWxhYzogMC45LFxuICAgICAgYWxhdzogMSxcbiAgICAgIGRyYTE6IDEsXG4gICAgICAnZHRzKyc6IDEsXG4gICAgICAnZHRzLSc6IDEsXG4gICAgICBkdHNjOiAxLFxuICAgICAgZHRzZTogMSxcbiAgICAgIGR0c2g6IDEsXG4gICAgICAnZWMtMyc6IDAuOSxcbiAgICAgIGVuY2E6IDEsXG4gICAgICBmTGFDOiAwLjksXG4gICAgICAvLyBNUDQtUkEgbGlzdGVkIGNvZGVjIGVudHJ5IGZvciBGTEFDXG4gICAgICBmbGFjOiAwLjksXG4gICAgICAvLyBsZWdhY3kgYnJvd3NlciBjb2RlYyBuYW1lIGZvciBGTEFDXG4gICAgICBGTEFDOiAwLjksXG4gICAgICAvLyBzb21lIG1hbmlmZXN0cyBtYXkgbGlzdCBcIkZMQUNcIiB3aXRoIEFwcGxlJ3MgdG9vbHNcbiAgICAgIGc3MTk6IDEsXG4gICAgICBnNzI2OiAxLFxuICAgICAgbTRhZTogMSxcbiAgICAgIG1oYTE6IDEsXG4gICAgICBtaGEyOiAxLFxuICAgICAgbWhtMTogMSxcbiAgICAgIG1obTI6IDEsXG4gICAgICBtbHBhOiAxLFxuICAgICAgbXA0YTogMSxcbiAgICAgICdyYXcgJzogMSxcbiAgICAgIE9wdXM6IDEsXG4gICAgICBvcHVzOiAxLFxuICAgICAgLy8gYnJvd3NlcnMgZXhwZWN0IHRoaXMgdG8gYmUgbG93ZXJjYXNlIGRlc3BpdGUgTVA0UkEgc2F5cyAnT3B1cydcbiAgICAgIHNhbXI6IDEsXG4gICAgICBzYXdiOiAxLFxuICAgICAgc2F3cDogMSxcbiAgICAgIHNldmM6IDEsXG4gICAgICBzcWNwOiAxLFxuICAgICAgc3NtdjogMSxcbiAgICAgIHR3b3M6IDEsXG4gICAgICB1bGF3OiAxXG4gICAgfSxcbiAgICB2aWRlbzoge1xuICAgICAgYXZjMTogMSxcbiAgICAgIGF2YzI6IDEsXG4gICAgICBhdmMzOiAxLFxuICAgICAgYXZjNDogMSxcbiAgICAgIGF2Y3A6IDEsXG4gICAgICBhdjAxOiAwLjgsXG4gICAgICBkcmFjOiAxLFxuICAgICAgZHZhMTogMSxcbiAgICAgIGR2YXY6IDEsXG4gICAgICBkdmgxOiAwLjcsXG4gICAgICBkdmhlOiAwLjcsXG4gICAgICBlbmN2OiAxLFxuICAgICAgaGV2MTogMC43NSxcbiAgICAgIGh2YzE6IDAuNzUsXG4gICAgICBtanAyOiAxLFxuICAgICAgbXA0djogMSxcbiAgICAgIG12YzE6IDEsXG4gICAgICBtdmMyOiAxLFxuICAgICAgbXZjMzogMSxcbiAgICAgIG12YzQ6IDEsXG4gICAgICByZXN2OiAxLFxuICAgICAgcnY2MDogMSxcbiAgICAgIHMyNjM6IDEsXG4gICAgICBzdmMxOiAxLFxuICAgICAgc3ZjMjogMSxcbiAgICAgICd2Yy0xJzogMSxcbiAgICAgIHZwMDg6IDEsXG4gICAgICB2cDA5OiAwLjlcbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIHN0cHA6IDEsXG4gICAgICB3dnR0OiAxXG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSkge1xuICAgIHZhciB0eXBlQ29kZXMgPSBzYW1wbGVFbnRyeUNvZGVzSVNPW3R5cGVdO1xuICAgIHJldHVybiAhIXR5cGVDb2RlcyAmJiAhIXR5cGVDb2Rlc1tjb2RlYy5zbGljZSgwLCA0KV07XG4gIH1cbiAgZnVuY3Rpb24gYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQoY29kZWNzLCB0eXBlLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpIHtcbiAgICBpZiAocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID09PSB2b2lkIDApIHtcbiAgICAgIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhY29kZWNzLnNwbGl0KCcsJykuc29tZShmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgIHJldHVybiAhaXNDb2RlY01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjLCB0eXBlLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ29kZWNNZWRpYVNvdXJjZVN1cHBvcnRlZChjb2RlYywgdHlwZSwgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSB7XG4gICAgdmFyIF9NZWRpYVNvdXJjZSRpc1R5cGVTdTtcbiAgICBpZiAocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID09PSB2b2lkIDApIHtcbiAgICAgIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gICAgcmV0dXJuIChfTWVkaWFTb3VyY2UkaXNUeXBlU3UgPSBNZWRpYVNvdXJjZSA9PSBudWxsID8gdm9pZCAwIDogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKG1pbWVUeXBlRm9yQ29kZWMoY29kZWMsIHR5cGUpKSkgIT0gbnVsbCA/IF9NZWRpYVNvdXJjZSRpc1R5cGVTdSA6IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIG1pbWVUeXBlRm9yQ29kZWMoY29kZWMsIHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSArIFwiL21wNDtjb2RlY3M9XFxcIlwiICsgY29kZWMgKyBcIlxcXCJcIjtcbiAgfVxuICBmdW5jdGlvbiB2aWRlb0NvZGVjUHJlZmVyZW5jZVZhbHVlKHZpZGVvQ29kZWMpIHtcbiAgICBpZiAodmlkZW9Db2RlYykge1xuICAgICAgdmFyIGZvdXJDQyA9IHZpZGVvQ29kZWMuc3Vic3RyaW5nKDAsIDQpO1xuICAgICAgcmV0dXJuIHNhbXBsZUVudHJ5Q29kZXNJU08udmlkZW9bZm91ckNDXTtcbiAgICB9XG4gICAgcmV0dXJuIDI7XG4gIH1cbiAgZnVuY3Rpb24gY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKGNvZGVjU2V0KSB7XG4gICAgcmV0dXJuIGNvZGVjU2V0LnNwbGl0KCcsJykucmVkdWNlKGZ1bmN0aW9uIChudW0sIGZvdXJDQykge1xuICAgICAgdmFyIHByZWZlcmVuY2VWYWx1ZSA9IHNhbXBsZUVudHJ5Q29kZXNJU08udmlkZW9bZm91ckNDXTtcbiAgICAgIGlmIChwcmVmZXJlbmNlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChwcmVmZXJlbmNlVmFsdWUgKiAyICsgbnVtKSAvIChudW0gPyAzIDogMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHNhbXBsZUVudHJ5Q29kZXNJU08uYXVkaW9bZm91ckNDXSArIG51bSkgLyAobnVtID8gMiA6IDEpO1xuICAgIH0sIDApO1xuICB9XG4gIHZhciBDT0RFQ19DT01QQVRJQkxFX05BTUVTID0ge307XG4gIGZ1bmN0aW9uIGdldENvZGVjQ29tcGF0aWJsZU5hbWVMb3dlcihsb3dlckNhc2VDb2RlYywgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSB7XG4gICAgaWYgKHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ09ERUNfQ09NUEFUSUJMRV9OQU1FU1tsb3dlckNhc2VDb2RlY10pIHtcbiAgICAgIHJldHVybiBDT0RFQ19DT01QQVRJQkxFX05BTUVTW2xvd2VyQ2FzZUNvZGVjXTtcbiAgICB9XG5cbiAgICAvLyBJZGVhbHkgZkxhQyBhbmQgT3B1cyB3b3VsZCBiZSBmaXJzdCAoc3BlYy1jb21wbGlhbnQpIGJ1dFxuICAgIC8vIHNvbWUgYnJvd3NlcnMgd2lsbCByZXBvcnQgdGhhdCBmTGFDIGlzIHN1cHBvcnRlZCB0aGVuIGZhaWwuXG4gICAgLy8gc2VlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNDIyNzI4XG4gICAgdmFyIGNvZGVjc1RvQ2hlY2sgPSB7XG4gICAgICBmbGFjOiBbJ2ZsYWMnLCAnZkxhQycsICdGTEFDJ10sXG4gICAgICBvcHVzOiBbJ29wdXMnLCAnT3B1cyddXG4gICAgfVtsb3dlckNhc2VDb2RlY107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlY3NUb0NoZWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXNDb2RlY01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjc1RvQ2hlY2tbaV0sICdhdWRpbycsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkpIHtcbiAgICAgICAgQ09ERUNfQ09NUEFUSUJMRV9OQU1FU1tsb3dlckNhc2VDb2RlY10gPSBjb2RlY3NUb0NoZWNrW2ldO1xuICAgICAgICByZXR1cm4gY29kZWNzVG9DaGVja1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvd2VyQ2FzZUNvZGVjO1xuICB9XG4gIHZhciBBVURJT19DT0RFQ19SRUdFWFAgPSAvZmxhY3xvcHVzL2k7XG4gIGZ1bmN0aW9uIGdldENvZGVjQ29tcGF0aWJsZU5hbWUoY29kZWMsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkge1xuICAgIGlmIChwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPT09IHZvaWQgMCkge1xuICAgICAgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVjLnJlcGxhY2UoQVVESU9fQ09ERUNfUkVHRVhQLCBmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIGdldENvZGVjQ29tcGF0aWJsZU5hbWVMb3dlcihtLnRvTG93ZXJDYXNlKCksIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcGlja01vc3RDb21wbGV0ZUNvZGVjTmFtZShwYXJzZWRDb2RlYywgbGV2ZWxDb2RlYykge1xuICAgIC8vIFBhcnNpbmcgb2YgbXA0YSBjb2RlY3Mgc3RyaW5ncyBpbiBtcDQtdG9vbHMgZnJvbSBtZWRpYSBpcyBpbmNvbXBsZXRlIGFzIG9mIGQ4YzZjN2FcbiAgICAvLyBzbyB1c2UgbGV2ZWwgY29kZWMgaXMgcGFyc2VkIGNvZGVjIGlzIHVuYXZhaWxhYmxlIG9yIGluY29tcGxldGVcbiAgICBpZiAocGFyc2VkQ29kZWMgJiYgcGFyc2VkQ29kZWMgIT09ICdtcDRhJykge1xuICAgICAgcmV0dXJuIHBhcnNlZENvZGVjO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxDb2RlYyA/IGxldmVsQ29kZWMuc3BsaXQoJywnKVswXSA6IGxldmVsQ29kZWM7XG4gIH1cbiAgZnVuY3Rpb24gY29udmVydEFWQzFUb0FWQ09USShjb2RlYykge1xuICAgIC8vIENvbnZlcnQgYXZjMSBjb2RlYyBzdHJpbmcgZnJvbSBSRkMtNDI4MSB0byBSRkMtNjM4MSBmb3IgTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkXG4gICAgLy8gRXhhbXBsZXM6IGF2YzEuNjYuMzAgdG8gYXZjMS40MjAwMWUgYW5kIGF2YzEuNzcuMzAsYXZjMS42Ni4zMCB0byBhdmMxLjRkMDAxZSxhdmMxLjQyMDAxZS5cbiAgICB2YXIgY29kZWNzID0gY29kZWMuc3BsaXQoJywnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF2Y2RhdGEgPSBjb2RlY3NbaV0uc3BsaXQoJy4nKTtcbiAgICAgIGlmIChhdmNkYXRhLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGF2Y2RhdGEuc2hpZnQoKSArICcuJztcbiAgICAgICAgcmVzdWx0ICs9IHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpO1xuICAgICAgICByZXN1bHQgKz0gKCcwMDAnICsgcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgY29kZWNzW2ldID0gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29kZWNzLmpvaW4oJywnKTtcbiAgfVxuXG4gIHZhciBNQVNURVJfUExBWUxJU1RfUkVHRVggPSAvI0VYVC1YLVNUUkVBTS1JTkY6KFteXFxyXFxuXSopKD86W1xcclxcbl0oPzojW15cXHJcXG5dKik/KSooW15cXHJcXG5dKyl8I0VYVC1YLShTRVNTSU9OLURBVEF8U0VTU0lPTi1LRVl8REVGSU5FfENPTlRFTlQtU1RFRVJJTkd8U1RBUlQpOihbXlxcclxcbl0qKVtcXHJcXG5dKy9nO1xuICB2YXIgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYID0gLyNFWFQtWC1NRURJQTooLiopL2c7XG4gIHZhciBJU19NRURJQV9QTEFZTElTVCA9IC9eI0VYVCg/OklORnwtWC1UQVJHRVREVVJBVElPTik6L207IC8vIEhhbmRsZSBlbXB0eSBNZWRpYSBQbGF5bGlzdCAoZmlyc3QgRVhUSU5GIG5vdCBzaWduYWxlZCwgYnV0IFRBUkdFVERVUkFUSU9OIHByZXNlbnQpXG5cbiAgdmFyIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFsvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSxcbiAgLy8gZHVyYXRpb24gKCNFWFRJTkY6PGR1cmF0aW9uPiw8dGl0bGU+KSwgZ3JvdXAgMSA9PiBkdXJhdGlvbiwgZ3JvdXAgMiA9PiB0aXRsZVxuICAvKD8hIykgKihcXFNbXlxcclxcbl0qKS8uc291cmNlLFxuICAvLyBzZWdtZW50IFVSSSwgZ3JvdXAgMyA9PiB0aGUgVVJJIChub3RlIG5ld2xpbmUgaXMgbm90IGVhdGVuKVxuICAvI0VYVC1YLUJZVEVSQU5HRToqKC4rKS8uc291cmNlLFxuICAvLyBuZXh0IHNlZ21lbnQncyBieXRlcmFuZ2UsIGdyb3VwIDQgPT4gcmFuZ2Ugc3BlYyAoeEB5KVxuICAvI0VYVC1YLVBST0dSQU0tREFURS1USU1FOiguKykvLnNvdXJjZSxcbiAgLy8gbmV4dCBzZWdtZW50J3MgcHJvZ3JhbSBkYXRlL3RpbWUgZ3JvdXAgNSA9PiB0aGUgZGF0ZXRpbWUgc3BlY1xuICAvIy4qLy5zb3VyY2UgLy8gQWxsIG90aGVyIG5vbi1zZWdtZW50IG9yaWVudGVkIHRhZ3Mgd2lsbCBtYXRjaCB3aXRoIGFsbCBncm91cHMgZW1wdHlcbiAgXS5qb2luKCd8JyksICdnJyk7XG4gIHZhciBMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XID0gbmV3IFJlZ0V4cChbLyMoRVhUTTNVKS8uc291cmNlLCAvI0VYVC1YLShEQVRFUkFOR0V8REVGSU5FfEtFWXxNQVB8UEFSVHxQQVJULUlORnxQTEFZTElTVC1UWVBFfFBSRUxPQUQtSElOVHxSRU5ESVRJT04tUkVQT1JUfFNFUlZFUi1DT05UUk9MfFNLSVB8U1RBUlQpOiguKykvLnNvdXJjZSwgLyNFWFQtWC0oQklUUkFURXxESVNDT05USU5VSVRZLVNFUVVFTkNFfE1FRElBLVNFUVVFTkNFfFRBUkdFVERVUkFUSU9OfFZFUlNJT04pOiAqKFxcZCspLy5zb3VyY2UsIC8jRVhULVgtKERJU0NPTlRJTlVJVFl8RU5ETElTVHxHQVB8SU5ERVBFTkRFTlQtU0VHTUVOVFMpLy5zb3VyY2UsIC8oIykoW146XSopOiguKikvLnNvdXJjZSwgLygjKSguKikoPzouKilcXHI/XFxuPy8uc291cmNlXS5qb2luKCd8JykpO1xuICB2YXIgTTNVOFBhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTTNVOFBhcnNlcigpIHt9XG4gICAgTTNVOFBhcnNlci5maW5kR3JvdXAgPSBmdW5jdGlvbiBmaW5kR3JvdXAoZ3JvdXBzLCBtZWRpYUdyb3VwSWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgaWYgKGdyb3VwLmlkID09PSBtZWRpYUdyb3VwSWQpIHtcbiAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIE0zVThQYXJzZXIucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUodXJsLCBiYXNlVXJsKSB7XG4gICAgICByZXR1cm4gdXJsVG9vbGtpdEV4cG9ydHMuYnVpbGRBYnNvbHV0ZVVSTChiYXNlVXJsLCB1cmwsIHtcbiAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIE0zVThQYXJzZXIuaXNNZWRpYVBsYXlsaXN0ID0gZnVuY3Rpb24gaXNNZWRpYVBsYXlsaXN0KHN0cikge1xuICAgICAgcmV0dXJuIElTX01FRElBX1BMQVlMSVNULnRlc3Qoc3RyKTtcbiAgICB9O1xuICAgIE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdCA9IGZ1bmN0aW9uIHBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCBiYXNldXJsKSB7XG4gICAgICB2YXIgaGFzVmFyaWFibGVSZWZzID0gaGFzVmFyaWFibGVSZWZlcmVuY2VzKHN0cmluZykgO1xuICAgICAgdmFyIHBhcnNlZCA9IHtcbiAgICAgICAgY29udGVudFN0ZWVyaW5nOiBudWxsLFxuICAgICAgICBsZXZlbHM6IFtdLFxuICAgICAgICBwbGF5bGlzdFBhcnNpbmdFcnJvcjogbnVsbCxcbiAgICAgICAgc2Vzc2lvbkRhdGE6IG51bGwsXG4gICAgICAgIHNlc3Npb25LZXlzOiBudWxsLFxuICAgICAgICBzdGFydFRpbWVPZmZzZXQ6IG51bGwsXG4gICAgICAgIHZhcmlhYmxlTGlzdDogbnVsbCxcbiAgICAgICAgaGFzVmFyaWFibGVSZWZzOiBoYXNWYXJpYWJsZVJlZnNcbiAgICAgIH07XG4gICAgICB2YXIgbGV2ZWxzV2l0aEtub3duQ29kZWNzID0gW107XG4gICAgICBNQVNURVJfUExBWUxJU1RfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICB3aGlsZSAoKHJlc3VsdCA9IE1BU1RFUl9QTEFZTElTVF9SRUdFWC5leGVjKHN0cmluZykpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHJlc3VsdFsxXSkge1xuICAgICAgICAgIHZhciBfbGV2ZWwkdW5rbm93bkNvZGVjcztcbiAgICAgICAgICAvLyAnI0VYVC1YLVNUUkVBTS1JTkYnIGlzIGZvdW5kLCBwYXJzZSBsZXZlbCB0YWcgIGluIGdyb3VwIDFcbiAgICAgICAgICB2YXIgYXR0cnMgPSBuZXcgQXR0ckxpc3QocmVzdWx0WzFdKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgYXR0cnMsIFsnQ09ERUNTJywgJ1NVUFBMRU1FTlRBTC1DT0RFQ1MnLCAnQUxMT1dFRC1DUEMnLCAnUEFUSFdBWS1JRCcsICdTVEFCTEUtVkFSSUFOVC1JRCcsICdBVURJTycsICdWSURFTycsICdTVUJUSVRMRVMnLCAnQ0xPU0VELUNBUFRJT05TJywgJ05BTUUnXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB1cmkgPSBzdWJzdGl0dXRlVmFyaWFibGVzKHBhcnNlZCwgcmVzdWx0WzJdKSA7XG4gICAgICAgICAgdmFyIGxldmVsID0ge1xuICAgICAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgICAgICAgICAgYml0cmF0ZTogYXR0cnMuZGVjaW1hbEludGVnZXIoJ0JBTkRXSURUSCcpIHx8IGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdBVkVSQUdFLUJBTkRXSURUSCcpLFxuICAgICAgICAgICAgbmFtZTogYXR0cnMuTkFNRSxcbiAgICAgICAgICAgIHVybDogTTNVOFBhcnNlci5yZXNvbHZlKHVyaSwgYmFzZXVybClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gYXR0cnMuZGVjaW1hbFJlc29sdXRpb24oJ1JFU09MVVRJT04nKTtcbiAgICAgICAgICBpZiAocmVzb2x1dGlvbikge1xuICAgICAgICAgICAgbGV2ZWwud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xuICAgICAgICAgICAgbGV2ZWwuaGVpZ2h0ID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldENvZGVjcyhhdHRycy5DT0RFQ1MsIGxldmVsKTtcbiAgICAgICAgICBpZiAoISgoX2xldmVsJHVua25vd25Db2RlY3MgPSBsZXZlbC51bmtub3duQ29kZWNzKSAhPSBudWxsICYmIF9sZXZlbCR1bmtub3duQ29kZWNzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGxldmVsc1dpdGhLbm93bkNvZGVjcy5wdXNoKGxldmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyc2VkLmxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHRbM10pIHtcbiAgICAgICAgICB2YXIgdGFnID0gcmVzdWx0WzNdO1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gcmVzdWx0WzRdO1xuICAgICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgICBjYXNlICdTRVNTSU9OLURBVEEnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gI0VYVC1YLVNFU1NJT04tREFUQVxuICAgICAgICAgICAgICAgIHZhciBzZXNzaW9uQXR0cnMgPSBuZXcgQXR0ckxpc3QoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIHNlc3Npb25BdHRycywgWydEQVRBLUlEJywgJ0xBTkdVQUdFJywgJ1ZBTFVFJywgJ1VSSSddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFJZCA9IHNlc3Npb25BdHRyc1snREFUQS1JRCddO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhSWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuc2Vzc2lvbkRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25EYXRhID0ge307XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbkRhdGFbZGF0YUlkXSA9IHNlc3Npb25BdHRycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1NFU1NJT04tS0VZJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICNFWFQtWC1TRVNTSU9OLUtFWVxuICAgICAgICAgICAgICAgIHZhciBzZXNzaW9uS2V5ID0gcGFyc2VLZXkoYXR0cmlidXRlcywgYmFzZXVybCwgcGFyc2VkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbktleS5lbmNyeXB0ZWQgJiYgc2Vzc2lvbktleS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnNlc3Npb25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uS2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcGFyc2VkLnNlc3Npb25LZXlzLnB1c2goc2Vzc2lvbktleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiW0tleXNdIElnbm9yaW5nIGludmFsaWQgRVhULVgtU0VTU0lPTi1LRVkgdGFnOiBcXFwiXCIgKyBhdHRyaWJ1dGVzICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnREVGSU5FJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICNFWFQtWC1ERUZJTkVcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVBdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIHZhcmlhYmxlQXR0cmlidXRlcywgWydOQU1FJywgJ1ZBTFVFJywgJ1FVRVJZUEFSQU0nXSk7XG4gICAgICAgICAgICAgICAgICBhZGRWYXJpYWJsZURlZmluaXRpb24ocGFyc2VkLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQ09OVEVOVC1TVEVFUklORyc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAjRVhULVgtQ09OVEVOVC1TVEVFUklOR1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzLCBbJ1NFUlZFUi1VUkknLCAnUEFUSFdBWS1JRCddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VkLmNvbnRlbnRTdGVlcmluZyA9IHtcbiAgICAgICAgICAgICAgICAgIHVyaTogTTNVOFBhcnNlci5yZXNvbHZlKGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXNbJ1NFUlZFUi1VUkknXSwgYmFzZXVybCksXG4gICAgICAgICAgICAgICAgICBwYXRod2F5SWQ6IGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXNbJ1BBVEhXQVktSUQnXSB8fCAnLidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAjRVhULVgtU1RBUlRcbiAgICAgICAgICAgICAgICBwYXJzZWQuc3RhcnRUaW1lT2Zmc2V0ID0gcGFyc2VTdGFydFRpbWVPZmZzZXQoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZpbHRlciBvdXQgbGV2ZWxzIHdpdGggdW5rbm93biBjb2RlY3MgaWYgaXQgZG9lcyBub3QgcmVtb3ZlIGFsbCBsZXZlbHNcbiAgICAgIHZhciBzdHJpcFVua25vd25Db2RlY0xldmVscyA9IGxldmVsc1dpdGhLbm93bkNvZGVjcy5sZW5ndGggPiAwICYmIGxldmVsc1dpdGhLbm93bkNvZGVjcy5sZW5ndGggPCBwYXJzZWQubGV2ZWxzLmxlbmd0aDtcbiAgICAgIHBhcnNlZC5sZXZlbHMgPSBzdHJpcFVua25vd25Db2RlY0xldmVscyA/IGxldmVsc1dpdGhLbm93bkNvZGVjcyA6IHBhcnNlZC5sZXZlbHM7XG4gICAgICBpZiAocGFyc2VkLmxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdubyBsZXZlbHMgZm91bmQgaW4gbWFuaWZlc3QnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfTtcbiAgICBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYSA9IGZ1bmN0aW9uIHBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIGJhc2V1cmwsIHBhcnNlZCkge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICB2YXIgbGV2ZWxzID0gcGFyc2VkLmxldmVscztcbiAgICAgIHZhciBncm91cHNCeVR5cGUgPSB7XG4gICAgICAgIEFVRElPOiBsZXZlbHMubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogbGV2ZWwuYXR0cnMuQVVESU8sXG4gICAgICAgICAgICBhdWRpb0NvZGVjOiBsZXZlbC5hdWRpb0NvZGVjXG4gICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIFNVQlRJVExFUzogbGV2ZWxzLm1hcChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGxldmVsLmF0dHJzLlNVQlRJVExFUyxcbiAgICAgICAgICAgIHRleHRDb2RlYzogbGV2ZWwudGV4dENvZGVjXG4gICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgICdDTE9TRUQtQ0FQVElPTlMnOiBbXVxuICAgICAgfTtcbiAgICAgIHZhciBpZCA9IDA7XG4gICAgICBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSk7XG4gICAgICAgIHZhciB0eXBlID0gYXR0cnMuVFlQRTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICB2YXIgZ3JvdXBzID0gZ3JvdXBzQnlUeXBlW3R5cGVdO1xuICAgICAgICAgIHZhciBtZWRpYXMgPSByZXN1bHRzW3R5cGVdIHx8IFtdO1xuICAgICAgICAgIHJlc3VsdHNbdHlwZV0gPSBtZWRpYXM7XG4gICAgICAgICAge1xuICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIGF0dHJzLCBbJ1VSSScsICdHUk9VUC1JRCcsICdMQU5HVUFHRScsICdBU1NPQy1MQU5HVUFHRScsICdTVEFCTEUtUkVORElUSU9OLUlEJywgJ05BTUUnLCAnSU5TVFJFQU0tSUQnLCAnQ0hBUkFDVEVSSVNUSUNTJywgJ0NIQU5ORUxTJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGFuZyA9IGF0dHJzLkxBTkdVQUdFO1xuICAgICAgICAgIHZhciBhc3NvY0xhbmcgPSBhdHRyc1snQVNTT0MtTEFOR1VBR0UnXTtcbiAgICAgICAgICB2YXIgY2hhbm5lbHMgPSBhdHRycy5DSEFOTkVMUztcbiAgICAgICAgICB2YXIgY2hhcmFjdGVyaXN0aWNzID0gYXR0cnMuQ0hBUkFDVEVSSVNUSUNTO1xuICAgICAgICAgIHZhciBpbnN0cmVhbUlkID0gYXR0cnNbJ0lOU1RSRUFNLUlEJ107XG4gICAgICAgICAgdmFyIG1lZGlhID0ge1xuICAgICAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICAgIGlkOiBpZCsrLFxuICAgICAgICAgICAgZ3JvdXBJZDogYXR0cnNbJ0dST1VQLUlEJ10gfHwgJycsXG4gICAgICAgICAgICBuYW1lOiBhdHRycy5OQU1FIHx8IGxhbmcgfHwgJycsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgZGVmYXVsdDogYXR0cnMuYm9vbCgnREVGQVVMVCcpLFxuICAgICAgICAgICAgYXV0b3NlbGVjdDogYXR0cnMuYm9vbCgnQVVUT1NFTEVDVCcpLFxuICAgICAgICAgICAgZm9yY2VkOiBhdHRycy5ib29sKCdGT1JDRUQnKSxcbiAgICAgICAgICAgIGxhbmc6IGxhbmcsXG4gICAgICAgICAgICB1cmw6IGF0dHJzLlVSSSA/IE0zVThQYXJzZXIucmVzb2x2ZShhdHRycy5VUkksIGJhc2V1cmwpIDogJydcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChhc3NvY0xhbmcpIHtcbiAgICAgICAgICAgIG1lZGlhLmFzc29jTGFuZyA9IGFzc29jTGFuZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYW5uZWxzKSB7XG4gICAgICAgICAgICBtZWRpYS5jaGFubmVscyA9IGNoYW5uZWxzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhcmFjdGVyaXN0aWNzKSB7XG4gICAgICAgICAgICBtZWRpYS5jaGFyYWN0ZXJpc3RpY3MgPSBjaGFyYWN0ZXJpc3RpY3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnN0cmVhbUlkKSB7XG4gICAgICAgICAgICBtZWRpYS5pbnN0cmVhbUlkID0gaW5zdHJlYW1JZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdyb3VwcyAhPSBudWxsICYmIGdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhdWRpbyBvciB0ZXh0IGdyb3VwcyBzaWduYWxsZWQgaW4gdGhlIG1hbmlmZXN0LCBsZXQncyBsb29rIGZvciBhIG1hdGNoaW5nIGNvZGVjIHN0cmluZyBmb3IgdGhpcyB0cmFja1xuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZmluZCB0aGUgdHJhY2sgc2lnbmFsbGVkLCBsZXRzIHVzZSB0aGUgZmlyc3QgYXVkaW8gZ3JvdXBzIGNvZGVjIHdlIGhhdmVcbiAgICAgICAgICAgIC8vIEFjdGluZyBhcyBhIGJlc3QgZ3Vlc3NcbiAgICAgICAgICAgIHZhciBncm91cENvZGVjID0gTTNVOFBhcnNlci5maW5kR3JvdXAoZ3JvdXBzLCBtZWRpYS5ncm91cElkKSB8fCBncm91cHNbMF07XG4gICAgICAgICAgICBhc3NpZ25Db2RlYyhtZWRpYSwgZ3JvdXBDb2RlYywgJ2F1ZGlvQ29kZWMnKTtcbiAgICAgICAgICAgIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cENvZGVjLCAndGV4dENvZGVjJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lZGlhcy5wdXNoKG1lZGlhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBNM1U4UGFyc2VyLnBhcnNlTGV2ZWxQbGF5bGlzdCA9IGZ1bmN0aW9uIHBhcnNlTGV2ZWxQbGF5bGlzdChzdHJpbmcsIGJhc2V1cmwsIGlkLCB0eXBlLCBsZXZlbFVybElkLCBtdWx0aXZhcmlhbnRWYXJpYWJsZUxpc3QpIHtcbiAgICAgIHZhciBsZXZlbCA9IG5ldyBMZXZlbERldGFpbHMoYmFzZXVybCk7XG4gICAgICB2YXIgZnJhZ21lbnRzID0gbGV2ZWwuZnJhZ21lbnRzO1xuICAgICAgLy8gVGhlIG1vc3QgcmVjZW50IGluaXQgc2VnbWVudCBzZWVuIChhcHBsaWVzIHRvIGFsbCBzdWJzZXF1ZW50IHNlZ21lbnRzKVxuICAgICAgdmFyIGN1cnJlbnRJbml0U2VnbWVudCA9IG51bGw7XG4gICAgICB2YXIgY3VycmVudFNOID0gMDtcbiAgICAgIHZhciBjdXJyZW50UGFydCA9IDA7XG4gICAgICB2YXIgdG90YWxkdXJhdGlvbiA9IDA7XG4gICAgICB2YXIgZGlzY29udGludWl0eUNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHByZXZGcmFnID0gbnVsbDtcbiAgICAgIHZhciBmcmFnID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2V1cmwpO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxldmVsa2V5cztcbiAgICAgIHZhciBmaXJzdFBkdEluZGV4ID0gLTE7XG4gICAgICB2YXIgY3JlYXRlTmV4dEZyYWcgPSBmYWxzZTtcbiAgICAgIHZhciBuZXh0Qnl0ZVJhbmdlID0gbnVsbDtcbiAgICAgIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QubGFzdEluZGV4ID0gMDtcbiAgICAgIGxldmVsLm0zdTggPSBzdHJpbmc7XG4gICAgICBsZXZlbC5oYXNWYXJpYWJsZVJlZnMgPSBoYXNWYXJpYWJsZVJlZmVyZW5jZXMoc3RyaW5nKSA7XG4gICAgICB3aGlsZSAoKHJlc3VsdCA9IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QuZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoY3JlYXRlTmV4dEZyYWcpIHtcbiAgICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IGZhbHNlO1xuICAgICAgICAgIGZyYWcgPSBuZXcgRnJhZ21lbnQodHlwZSwgYmFzZXVybCk7XG4gICAgICAgICAgLy8gc2V0dXAgdGhlIG5leHQgZnJhZ21lbnQgZm9yIHBhcnQgbG9hZGluZ1xuICAgICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgICAgIGZyYWcuc24gPSBjdXJyZW50U047XG4gICAgICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICBpZiAoY3VycmVudEluaXRTZWdtZW50KSB7XG4gICAgICAgICAgICBmcmFnLmluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgICAgY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAobmV4dEJ5dGVSYW5nZSkge1xuICAgICAgICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShuZXh0Qnl0ZVJhbmdlKTtcbiAgICAgICAgICAgICAgbmV4dEJ5dGVSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHJlc3VsdFsxXTtcbiAgICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gSU5GXG4gICAgICAgICAgZnJhZy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQoZHVyYXRpb24pO1xuICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgICB2YXIgdGl0bGUgPSAoJyAnICsgcmVzdWx0WzJdKS5zbGljZSgxKTtcbiAgICAgICAgICBmcmFnLnRpdGxlID0gdGl0bGUgfHwgbnVsbDtcbiAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh0aXRsZSA/IFsnSU5GJywgZHVyYXRpb24sIHRpdGxlXSA6IFsnSU5GJywgZHVyYXRpb25dKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHRbM10pIHtcbiAgICAgICAgICAvLyB1cmxcbiAgICAgICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKGxldmVsa2V5cykge1xuICAgICAgICAgICAgICBzZXRGcmFnTGV2ZWxLZXlzKGZyYWcsIGxldmVsa2V5cywgbGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhZy5zbiA9IGN1cnJlbnRTTjtcbiAgICAgICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKGZyYWcpO1xuICAgICAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICAgICAgdmFyIHVyaSA9ICgnICcgKyByZXN1bHRbM10pLnNsaWNlKDEpO1xuICAgICAgICAgICAgZnJhZy5yZWx1cmwgPSBzdWJzdGl0dXRlVmFyaWFibGVzKGxldmVsLCB1cmkpIDtcbiAgICAgICAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZyk7XG4gICAgICAgICAgICBwcmV2RnJhZyA9IGZyYWc7XG4gICAgICAgICAgICB0b3RhbGR1cmF0aW9uICs9IGZyYWcuZHVyYXRpb247XG4gICAgICAgICAgICBjdXJyZW50U04rKztcbiAgICAgICAgICAgIGN1cnJlbnRQYXJ0ID0gMDtcbiAgICAgICAgICAgIGNyZWF0ZU5leHRGcmFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzRdKSB7XG4gICAgICAgICAgLy8gWC1CWVRFUkFOR0VcbiAgICAgICAgICB2YXIgZGF0YSA9ICgnICcgKyByZXN1bHRbNF0pLnNsaWNlKDEpO1xuICAgICAgICAgIGlmIChwcmV2RnJhZykge1xuICAgICAgICAgICAgZnJhZy5zZXRCeXRlUmFuZ2UoZGF0YSwgcHJldkZyYWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzVdKSB7XG4gICAgICAgICAgLy8gUFJPR1JBTS1EQVRFLVRJTUVcbiAgICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSAoJyAnICsgcmVzdWx0WzVdKS5zbGljZSgxKTtcbiAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ1BST0dSQU0tREFURS1USU1FJywgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWVdKTtcbiAgICAgICAgICBpZiAoZmlyc3RQZHRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGZpcnN0UGR0SW5kZXggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHRbMF0ubWF0Y2goTEVWRUxfUExBWUxJU1RfUkVHRVhfU0xPVyk7XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdObyBtYXRjaGVzIG9uIHNsb3cgcmVnZXggbWF0Y2ggZm9yIGxldmVsIHBsYXlsaXN0IScpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgICAgdmFyIHRhZyA9ICgnICcgKyByZXN1bHRbaV0pLnNsaWNlKDEpO1xuICAgICAgICAgIHZhciB2YWx1ZTEgPSAoJyAnICsgcmVzdWx0W2kgKyAxXSkuc2xpY2UoMSk7XG4gICAgICAgICAgdmFyIHZhbHVlMiA9IHJlc3VsdFtpICsgMl0gPyAoJyAnICsgcmVzdWx0W2kgKyAyXSkuc2xpY2UoMSkgOiAnJztcbiAgICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgICAgY2FzZSAnUExBWUxJU1QtVFlQRSc6XG4gICAgICAgICAgICAgIGxldmVsLnR5cGUgPSB2YWx1ZTEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdNRURJQS1TRVFVRU5DRSc6XG4gICAgICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1NLSVAnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHNraXBBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHNraXBBdHRycywgWydSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVMnXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBza2lwcGVkU2VnbWVudHMgPSBza2lwQXR0cnMuZGVjaW1hbEludGVnZXIoJ1NLSVBQRUQtU0VHTUVOVFMnKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoc2tpcHBlZFNlZ21lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgbGV2ZWwuc2tpcHBlZFNlZ21lbnRzID0gc2tpcHBlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHJlc3VsdCBpbiBmcmFnbWVudHNbXSBjb250YWluaW5nIHVuZGVmaW5lZCB2YWx1ZXMsIHdoaWNoIHdlIHdpbGwgZmlsbCBpbiB3aXRoIGBtZXJnZURldGFpbHNgXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IHNraXBwZWRTZWdtZW50czsgX2ktLTspIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRzLnVuc2hpZnQobnVsbCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjdXJyZW50U04gKz0gc2tpcHBlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHNraXBBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdSRUNFTlRMWS1SRU1PVkVELURBVEVSQU5HRVMnKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgbGV2ZWwucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMuc3BsaXQoJ1xcdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnVEFSR0VURFVSQVRJT04nOlxuICAgICAgICAgICAgICBsZXZlbC50YXJnZXRkdXJhdGlvbiA9IE1hdGgubWF4KHBhcnNlSW50KHZhbHVlMSksIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1ZFUlNJT04nOlxuICAgICAgICAgICAgICBsZXZlbC52ZXJzaW9uID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdJTkRFUEVOREVOVC1TRUdNRU5UUyc6XG4gICAgICAgICAgICBjYXNlICdFWFRNM1UnOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0VORExJU1QnOlxuICAgICAgICAgICAgICBsZXZlbC5saXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZTEgfHwgdmFsdWUyKSB7XG4gICAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godmFsdWUyID8gW3ZhbHVlMSwgdmFsdWUyXSA6IFt2YWx1ZTFdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0RJU0NPTlRJTlVJVFknOlxuICAgICAgICAgICAgICBkaXNjb250aW51aXR5Q291bnRlcisrO1xuICAgICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdHQVAnOlxuICAgICAgICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFt0YWddKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdCSVRSQVRFJzpcbiAgICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goW3RhZywgdmFsdWUxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnREFURVJBTkdFJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlUmFuZ2VBdHRyID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgZGF0ZVJhbmdlQXR0ciwgWydJRCcsICdDTEFTUycsICdTVEFSVC1EQVRFJywgJ0VORC1EQVRFJywgJ1NDVEUzNS1DTUQnLCAnU0NURTM1LU9VVCcsICdTQ1RFMzUtSU4nXSk7XG4gICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBkYXRlUmFuZ2VBdHRyLCBkYXRlUmFuZ2VBdHRyLmNsaWVudEF0dHJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRhdGVSYW5nZSA9IG5ldyBEYXRlUmFuZ2UoZGF0ZVJhbmdlQXR0ciwgbGV2ZWwuZGF0ZVJhbmdlc1tkYXRlUmFuZ2VBdHRyLklEXSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVSYW5nZS5pc1ZhbGlkIHx8IGxldmVsLnNraXBwZWRTZWdtZW50cykge1xuICAgICAgICAgICAgICAgICAgbGV2ZWwuZGF0ZVJhbmdlc1tkYXRlUmFuZ2UuaWRdID0gZGF0ZVJhbmdlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIklnbm9yaW5nIGludmFsaWQgREFURVJBTkdFIHRhZzogXFxcIlwiICsgdmFsdWUxICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gZnJhZ21lbnQgdGFnIGxpc3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5ICg8IHYxLjIuMClcbiAgICAgICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0VYVC1YLURBVEVSQU5HRScsIHZhbHVlMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdERUZJTkUnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlQXR0cmlidXRlcyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgdmFyaWFibGVBdHRyaWJ1dGVzLCBbJ05BTUUnLCAnVkFMVUUnLCAnSU1QT1JUJywgJ1FVRVJZUEFSQU0nXSk7XG4gICAgICAgICAgICAgICAgICBpZiAoJ0lNUE9SVCcgaW4gdmFyaWFibGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydFZhcmlhYmxlRGVmaW5pdGlvbihsZXZlbCwgdmFyaWFibGVBdHRyaWJ1dGVzLCBtdWx0aXZhcmlhbnRWYXJpYWJsZUxpc3QpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmFyaWFibGVEZWZpbml0aW9uKGxldmVsLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnRElTQ09OVElOVUlUWS1TRVFVRU5DRSc6XG4gICAgICAgICAgICAgIGRpc2NvbnRpbnVpdHlDb3VudGVyID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdLRVknOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGxldmVsS2V5ID0gcGFyc2VLZXkodmFsdWUxLCBiYXNldXJsLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsS2V5LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsZXZlbEtleS5tZXRob2QgPT09ICdOT05FJykge1xuICAgICAgICAgICAgICAgICAgICBsZXZlbGtleXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFsZXZlbGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0ge307XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAobGV2ZWxrZXlzW2xldmVsS2V5LmtleUZvcm1hdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0gX2V4dGVuZHMoe30sIGxldmVsa2V5cyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXZlbGtleXNbbGV2ZWxLZXkua2V5Rm9ybWF0XSA9IGxldmVsS2V5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIltLZXlzXSBJZ25vcmluZyBpbnZhbGlkIEVYVC1YLUtFWSB0YWc6IFxcXCJcIiArIHZhbHVlMSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1NUQVJUJzpcbiAgICAgICAgICAgICAgbGV2ZWwuc3RhcnRUaW1lT2Zmc2V0ID0gcGFyc2VTdGFydFRpbWVPZmZzZXQodmFsdWUxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdNQVAnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgbWFwQXR0cnMsIFsnQllURVJBTkdFJywgJ1VSSSddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZyYWcuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgc2VnbWVudCB0YWcgaXMgYWZ0ZXIgc2VnbWVudCBkdXJhdGlvbiB0YWcuXG4gICAgICAgICAgICAgICAgICAvLyAgICNFWFRJTkY6IDYuMFxuICAgICAgICAgICAgICAgICAgLy8gICAjRVhULVgtTUFQOlVSST1cImluaXQubXA0XG4gICAgICAgICAgICAgICAgICB2YXIgaW5pdCA9IG5ldyBGcmFnbWVudCh0eXBlLCBiYXNldXJsKTtcbiAgICAgICAgICAgICAgICAgIHNldEluaXRTZWdtZW50KGluaXQsIG1hcEF0dHJzLCBpZCwgbGV2ZWxrZXlzKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICBmcmFnLmluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWUgJiYgIWZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzZWdtZW50IHRhZyBpcyBiZWZvcmUgc2VnbWVudCBkdXJhdGlvbiB0YWdcbiAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIEVYVC1YLU1BUCBpcyBkZWNsYXJlZCBhZnRlciBFWFQtWC1CWVRFUkFOR0VcbiAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBmcmFnLmJ5dGVSYW5nZUVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZnJhZy5ieXRlUmFuZ2VTdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEJ5dGVSYW5nZSA9IGVuZCAtIHN0YXJ0ICsgXCJAXCIgKyBzdGFydDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRCeXRlUmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc2V0SW5pdFNlZ21lbnQoZnJhZywgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gZnJhZztcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZU5leHRGcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1NFUlZFUi1DT05UUk9MJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJDb250cm9sQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAgICBsZXZlbC5jYW5CbG9ja1JlbG9hZCA9IHNlcnZlckNvbnRyb2xBdHRycy5ib29sKCdDQU4tQkxPQ0stUkVMT0FEJyk7XG4gICAgICAgICAgICAgICAgbGV2ZWwuY2FuU2tpcFVudGlsID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoJ0NBTi1TS0lQLVVOVElMJywgMCk7XG4gICAgICAgICAgICAgICAgbGV2ZWwuY2FuU2tpcERhdGVSYW5nZXMgPSBsZXZlbC5jYW5Ta2lwVW50aWwgPiAwICYmIHNlcnZlckNvbnRyb2xBdHRycy5ib29sKCdDQU4tU0tJUC1EQVRFUkFOR0VTJyk7XG4gICAgICAgICAgICAgICAgbGV2ZWwucGFydEhvbGRCYWNrID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoJ1BBUlQtSE9MRC1CQUNLJywgMCk7XG4gICAgICAgICAgICAgICAgbGV2ZWwuaG9sZEJhY2sgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdCgnSE9MRC1CQUNLJywgMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1BBUlQtSU5GJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0SW5mQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAgICBsZXZlbC5wYXJ0VGFyZ2V0ID0gcGFydEluZkF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdQQVJULVRBUkdFVCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdQQVJUJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0TGlzdCA9IGxldmVsLnBhcnRMaXN0O1xuICAgICAgICAgICAgICAgIGlmICghcGFydExpc3QpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRMaXN0ID0gbGV2ZWwucGFydExpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzRnJhZ21lbnRQYXJ0ID0gY3VycmVudFBhcnQgPiAwID8gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gY3VycmVudFBhcnQrKztcbiAgICAgICAgICAgICAgICB2YXIgcGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgcGFydEF0dHJzLCBbJ0JZVEVSQU5HRScsICdVUkknXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gbmV3IFBhcnQocGFydEF0dHJzLCBmcmFnLCBiYXNldXJsLCBpbmRleCwgcHJldmlvdXNGcmFnbWVudFBhcnQpO1xuICAgICAgICAgICAgICAgIHBhcnRMaXN0LnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgZnJhZy5kdXJhdGlvbiArPSBwYXJ0LmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdQUkVMT0FELUhJTlQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHByZWxvYWRIaW50QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBwcmVsb2FkSGludEF0dHJzLCBbJ1VSSSddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV2ZWwucHJlbG9hZEhpbnQgPSBwcmVsb2FkSGludEF0dHJzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdSRU5ESVRJT04tUkVQT1JUJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciByZW5kaXRpb25SZXBvcnRBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHJlbmRpdGlvblJlcG9ydEF0dHJzLCBbJ1VSSSddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV2ZWwucmVuZGl0aW9uUmVwb3J0cyA9IGxldmVsLnJlbmRpdGlvblJlcG9ydHMgfHwgW107XG4gICAgICAgICAgICAgICAgbGV2ZWwucmVuZGl0aW9uUmVwb3J0cy5wdXNoKHJlbmRpdGlvblJlcG9ydEF0dHJzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6IFwiICsgcmVzdWx0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJldkZyYWcgJiYgIXByZXZGcmFnLnJlbHVybCkge1xuICAgICAgICBmcmFnbWVudHMucG9wKCk7XG4gICAgICAgIHRvdGFsZHVyYXRpb24gLT0gcHJldkZyYWcuZHVyYXRpb247XG4gICAgICAgIGlmIChsZXZlbC5wYXJ0TGlzdCkge1xuICAgICAgICAgIGxldmVsLmZyYWdtZW50SGludCA9IHByZXZGcmFnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxldmVsLnBhcnRMaXN0KSB7XG4gICAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZyk7XG4gICAgICAgIGZyYWcuY2MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRIaW50ID0gZnJhZztcbiAgICAgICAgaWYgKGxldmVsa2V5cykge1xuICAgICAgICAgIHNldEZyYWdMZXZlbEtleXMoZnJhZywgbGV2ZWxrZXlzLCBsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBmcmFnbWVudExlbmd0aCA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgZmlyc3RGcmFnbWVudCA9IGZyYWdtZW50c1swXTtcbiAgICAgIHZhciBsYXN0RnJhZ21lbnQgPSBmcmFnbWVudHNbZnJhZ21lbnRMZW5ndGggLSAxXTtcbiAgICAgIHRvdGFsZHVyYXRpb24gKz0gbGV2ZWwuc2tpcHBlZFNlZ21lbnRzICogbGV2ZWwudGFyZ2V0ZHVyYXRpb247XG4gICAgICBpZiAodG90YWxkdXJhdGlvbiA+IDAgJiYgZnJhZ21lbnRMZW5ndGggJiYgbGFzdEZyYWdtZW50KSB7XG4gICAgICAgIGxldmVsLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb24gLyBmcmFnbWVudExlbmd0aDtcbiAgICAgICAgdmFyIGxhc3RTbiA9IGxhc3RGcmFnbWVudC5zbjtcbiAgICAgICAgbGV2ZWwuZW5kU04gPSBsYXN0U24gIT09ICdpbml0U2VnbWVudCcgPyBsYXN0U24gOiAwO1xuICAgICAgICBpZiAoIWxldmVsLmxpdmUpIHtcbiAgICAgICAgICBsYXN0RnJhZ21lbnQuZW5kTGlzdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0RnJhZ21lbnQpIHtcbiAgICAgICAgICBsZXZlbC5zdGFydENDID0gZmlyc3RGcmFnbWVudC5jYztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWwuZW5kU04gPSAwO1xuICAgICAgICBsZXZlbC5zdGFydENDID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbC5mcmFnbWVudEhpbnQpIHtcbiAgICAgICAgdG90YWxkdXJhdGlvbiArPSBsZXZlbC5mcmFnbWVudEhpbnQuZHVyYXRpb247XG4gICAgICB9XG4gICAgICBsZXZlbC50b3RhbGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbjtcbiAgICAgIGxldmVsLmVuZENDID0gZGlzY29udGludWl0eUNvdW50ZXI7XG5cbiAgICAgIC8qKlxuICAgICAgICogQmFja2ZpbGwgYW55IG1pc3NpbmcgUERUIHZhbHVlc1xuICAgICAgICogXCJJZiB0aGUgZmlyc3QgRVhULVgtUFJPR1JBTS1EQVRFLVRJTUUgdGFnIGluIGEgUGxheWxpc3QgYXBwZWFycyBhZnRlclxuICAgICAgICogb25lIG9yIG1vcmUgTWVkaWEgU2VnbWVudCBVUklzLCB0aGUgY2xpZW50IFNIT1VMRCBleHRyYXBvbGF0ZVxuICAgICAgICogYmFja3dhcmQgZnJvbSB0aGF0IHRhZyAodXNpbmcgRVhUSU5GIGR1cmF0aW9ucyBhbmQvb3IgbWVkaWFcbiAgICAgICAqIHRpbWVzdGFtcHMpIHRvIGFzc29jaWF0ZSBkYXRlcyB3aXRoIHRob3NlIHNlZ21lbnRzLlwiXG4gICAgICAgKiBXZSBoYXZlIGFscmVhZHkgZXh0cmFwb2xhdGVkIGZvcndhcmQsIGJ1dCBhbGwgZnJhZ21lbnRzIHVwIHRvIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBQRFQgZG8gbm90IGhhdmUgdGhlaXIgUERUc1xuICAgICAgICogY29tcHV0ZWQuXG4gICAgICAgKi9cbiAgICAgIGlmIChmaXJzdFBkdEluZGV4ID4gMCkge1xuICAgICAgICBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMoZnJhZ21lbnRzLCBmaXJzdFBkdEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZXZlbDtcbiAgICB9O1xuICAgIHJldHVybiBNM1U4UGFyc2VyO1xuICB9KCk7XG4gIGZ1bmN0aW9uIHBhcnNlS2V5KGtleVRhZ0F0dHJpYnV0ZXMsIGJhc2V1cmwsIHBhcnNlZCkge1xuICAgIHZhciBfa2V5QXR0cnMkTUVUSE9ELCBfa2V5QXR0cnMkS0VZRk9STUFUO1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4MjE2I3NlY3Rpb24tNC4zLjIuNFxuICAgIHZhciBrZXlBdHRycyA9IG5ldyBBdHRyTGlzdChrZXlUYWdBdHRyaWJ1dGVzKTtcbiAgICB7XG4gICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwga2V5QXR0cnMsIFsnS0VZRk9STUFUJywgJ0tFWUZPUk1BVFZFUlNJT05TJywgJ1VSSScsICdJVicsICdVUkknXSk7XG4gICAgfVxuICAgIHZhciBkZWNyeXB0bWV0aG9kID0gKF9rZXlBdHRycyRNRVRIT0QgPSBrZXlBdHRycy5NRVRIT0QpICE9IG51bGwgPyBfa2V5QXR0cnMkTUVUSE9EIDogJyc7XG4gICAgdmFyIGRlY3J5cHR1cmkgPSBrZXlBdHRycy5VUkk7XG4gICAgdmFyIGRlY3J5cHRpdiA9IGtleUF0dHJzLmhleGFkZWNpbWFsSW50ZWdlcignSVYnKTtcbiAgICB2YXIgZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zID0ga2V5QXR0cnMuS0VZRk9STUFUVkVSU0lPTlM7XG4gICAgLy8gRnJvbSBSRkM6IFRoaXMgYXR0cmlidXRlIGlzIE9QVElPTkFMOyBpdHMgYWJzZW5jZSBpbmRpY2F0ZXMgYW4gaW1wbGljaXQgdmFsdWUgb2YgXCJpZGVudGl0eVwiLlxuICAgIHZhciBkZWNyeXB0a2V5Zm9ybWF0ID0gKF9rZXlBdHRycyRLRVlGT1JNQVQgPSBrZXlBdHRycy5LRVlGT1JNQVQpICE9IG51bGwgPyBfa2V5QXR0cnMkS0VZRk9STUFUIDogJ2lkZW50aXR5JztcbiAgICBpZiAoZGVjcnlwdHVyaSAmJiBrZXlBdHRycy5JViAmJiAhZGVjcnlwdGl2KSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIElWOiBcIiArIGtleUF0dHJzLklWKTtcbiAgICB9XG4gICAgLy8gSWYgZGVjcnlwdHVyaSBpcyBhIFVSSSB3aXRoIGEgc2NoZW1lLCB0aGVuIGJhc2V1cmwgd2lsbCBiZSBpZ25vcmVkXG4gICAgLy8gTm8gdXJpIGlzIGFsbG93ZWQgd2hlbiBNRVRIT0QgaXMgTk9ORVxuICAgIHZhciByZXNvbHZlZFVyaSA9IGRlY3J5cHR1cmkgPyBNM1U4UGFyc2VyLnJlc29sdmUoZGVjcnlwdHVyaSwgYmFzZXVybCkgOiAnJztcbiAgICB2YXIga2V5Rm9ybWF0VmVyc2lvbnMgPSAoZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zID8gZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zIDogJzEnKS5zcGxpdCgnLycpLm1hcChOdW1iZXIpLmZpbHRlcihOdW1iZXIuaXNGaW5pdGUpO1xuICAgIHJldHVybiBuZXcgTGV2ZWxLZXkoZGVjcnlwdG1ldGhvZCwgcmVzb2x2ZWRVcmksIGRlY3J5cHRrZXlmb3JtYXQsIGtleUZvcm1hdFZlcnNpb25zLCBkZWNyeXB0aXYpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUaW1lT2Zmc2V0KHN0YXJ0QXR0cmlidXRlcykge1xuICAgIHZhciBzdGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHN0YXJ0QXR0cmlidXRlcyk7XG4gICAgdmFyIHN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1RJTUUtT0ZGU0VUJyk7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgIHJldHVybiBzdGFydFRpbWVPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHNldENvZGVjcyhjb2RlY3NBdHRyaWJ1dGVWYWx1ZSwgbGV2ZWwpIHtcbiAgICB2YXIgY29kZWNzID0gKGNvZGVjc0F0dHJpYnV0ZVZhbHVlIHx8ICcnKS5zcGxpdCgvWyAsXSsvKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH0pO1xuICAgIFsndmlkZW8nLCAnYXVkaW8nLCAndGV4dCddLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBmaWx0ZXJlZCA9IGNvZGVjcy5maWx0ZXIoZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICAgIHJldHVybiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChmaWx0ZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgLy8gQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgYWxsIGNvZGVjcyBmb3IgdHlwZVxuICAgICAgICBsZXZlbFt0eXBlICsgXCJDb2RlY1wiXSA9IGZpbHRlcmVkLmpvaW4oJywnKTtcbiAgICAgICAgLy8gUmVtb3ZlIGtub3duIGNvZGVjcyBzbyB0aGF0IG9ubHkgdW5rbm93bkNvZGVjcyBhcmUgbGVmdCBhZnRlciBpdGVyYXRpbmcgdGhyb3VnaCBlYWNoIHR5cGVcbiAgICAgICAgY29kZWNzID0gY29kZWNzLmZpbHRlcihmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyZWQuaW5kZXhPZihjb2RlYykgPT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXZlbC51bmtub3duQ29kZWNzID0gY29kZWNzO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cEl0ZW0sIGNvZGVjUHJvcGVydHkpIHtcbiAgICB2YXIgY29kZWNWYWx1ZSA9IGdyb3VwSXRlbVtjb2RlY1Byb3BlcnR5XTtcbiAgICBpZiAoY29kZWNWYWx1ZSkge1xuICAgICAgbWVkaWFbY29kZWNQcm9wZXJ0eV0gPSBjb2RlY1ZhbHVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMoZnJhZ21lbnRzLCBmaXJzdFBkdEluZGV4KSB7XG4gICAgdmFyIGZyYWdQcmV2ID0gZnJhZ21lbnRzW2ZpcnN0UGR0SW5kZXhdO1xuICAgIGZvciAodmFyIGkgPSBmaXJzdFBkdEluZGV4OyBpLS07KSB7XG4gICAgICB2YXIgZnJhZyA9IGZyYWdtZW50c1tpXTtcbiAgICAgIC8vIEV4aXQgb24gZGVsdGEtcGxheWxpc3Qgc2tpcHBlZCBzZWdtZW50c1xuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gZnJhZ1ByZXYucHJvZ3JhbURhdGVUaW1lIC0gZnJhZy5kdXJhdGlvbiAqIDEwMDA7XG4gICAgICBmcmFnUHJldiA9IGZyYWc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZykge1xuICAgIGlmIChmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBEYXRlLnBhcnNlKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKTtcbiAgICB9IGVsc2UgaWYgKHByZXZGcmFnICE9IG51bGwgJiYgcHJldkZyYWcucHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IHByZXZGcmFnLmVuZFByb2dyYW1EYXRlVGltZTtcbiAgICB9XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihmcmFnLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0SW5pdFNlZ21lbnQoZnJhZywgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpIHtcbiAgICBmcmFnLnJlbHVybCA9IG1hcEF0dHJzLlVSSTtcbiAgICBpZiAobWFwQXR0cnMuQllURVJBTkdFKSB7XG4gICAgICBmcmFnLnNldEJ5dGVSYW5nZShtYXBBdHRycy5CWVRFUkFOR0UpO1xuICAgIH1cbiAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgZnJhZy5zbiA9ICdpbml0U2VnbWVudCc7XG4gICAgaWYgKGxldmVsa2V5cykge1xuICAgICAgZnJhZy5sZXZlbGtleXMgPSBsZXZlbGtleXM7XG4gICAgfVxuICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHNldEZyYWdMZXZlbEtleXMoZnJhZywgbGV2ZWxrZXlzLCBsZXZlbCkge1xuICAgIGZyYWcubGV2ZWxrZXlzID0gbGV2ZWxrZXlzO1xuICAgIHZhciBlbmNyeXB0ZWRGcmFnbWVudHMgPSBsZXZlbC5lbmNyeXB0ZWRGcmFnbWVudHM7XG4gICAgaWYgKCghZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCB8fCBlbmNyeXB0ZWRGcmFnbWVudHNbZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCAtIDFdLmxldmVsa2V5cyAhPT0gbGV2ZWxrZXlzKSAmJiBPYmplY3Qua2V5cyhsZXZlbGtleXMpLnNvbWUoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGxldmVsa2V5c1tmb3JtYXRdLmlzQ29tbW9uRW5jcnlwdGlvbjtcbiAgICB9KSkge1xuICAgICAgZW5jcnlwdGVkRnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFBsYXlsaXN0Q29udGV4dFR5cGUgPSB7XG4gICAgTUFOSUZFU1Q6IFwibWFuaWZlc3RcIixcbiAgICBMRVZFTDogXCJsZXZlbFwiLFxuICAgIEFVRElPX1RSQUNLOiBcImF1ZGlvVHJhY2tcIixcbiAgICBTVUJUSVRMRV9UUkFDSzogXCJzdWJ0aXRsZVRyYWNrXCJcbiAgfTtcbiAgdmFyIFBsYXlsaXN0TGV2ZWxUeXBlID0ge1xuICAgIE1BSU46IFwibWFpblwiLFxuICAgIEFVRElPOiBcImF1ZGlvXCIsXG4gICAgU1VCVElUTEU6IFwic3VidGl0bGVcIlxuICB9O1xuXG4gIGZ1bmN0aW9uIG1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KSB7XG4gICAgdmFyIHR5cGUgPSBjb250ZXh0LnR5cGU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgIHJldHVybiBQbGF5bGlzdExldmVsVHlwZS5BVURJTztcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgcmV0dXJuIFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU47XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KSB7XG4gICAgdmFyIHVybCA9IHJlc3BvbnNlLnVybDtcbiAgICAvLyByZXNwb25zZVVSTCBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMgKGl0IGlzIHVzZWQgdG8gZGV0ZWN0IFVSTCByZWRpcmVjdGlvbilcbiAgICAvLyBkYXRhLXVyaSBtb2RlIGFsc28gbm90IHN1cHBvcnRlZCAoYnV0IG5vIG5lZWQgdG8gZGV0ZWN0IHJlZGlyZWN0aW9uKVxuICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCB8fCB1cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgLy8gZmFsbGJhY2sgdG8gaW5pdGlhbCBVUkxcbiAgICAgIHVybCA9IGNvbnRleHQudXJsO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIHZhciBQbGF5bGlzdExvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGxheWxpc3RMb2FkZXIoaGxzKSB7XG4gICAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICAgIHRoaXMubG9hZGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IG51bGw7XG4gICAgICB0aGlzLmhscyA9IGhscztcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHt9O1xuICAgIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgICAgdGhpcy5kZXN0cm95SW50ZXJuYWxMb2FkZXJzKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB0aGlzLm9uQXVkaW9UcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURJTkcsIHRoaXMub25BdWRpb1RyYWNrTG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGVmYXVsdHMgb3IgY29uZmlndXJlZCBsb2FkZXItdHlwZSBvdmVybG9hZHMgKHBMb2FkZXIgYW5kIGxvYWRlciBjb25maWcgcGFyYW1zKVxuICAgICAqLztcbiAgICBfcHJvdG8uY3JlYXRlSW50ZXJuYWxMb2FkZXIgPSBmdW5jdGlvbiBjcmVhdGVJbnRlcm5hbExvYWRlcihjb250ZXh0KSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgICAgdmFyIFBMb2FkZXIgPSBjb25maWcucExvYWRlcjtcbiAgICAgIHZhciBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgICAgdmFyIEludGVybmFsTG9hZGVyID0gUExvYWRlciB8fCBMb2FkZXI7XG4gICAgICB2YXIgbG9hZGVyID0gbmV3IEludGVybmFsTG9hZGVyKGNvbmZpZyk7XG4gICAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IGxvYWRlcjtcbiAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0SW50ZXJuYWxMb2FkZXIgPSBmdW5jdGlvbiBnZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkZXJzW2NvbnRleHQudHlwZV07XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRJbnRlcm5hbExvYWRlciA9IGZ1bmN0aW9uIHJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpIHtcbiAgICAgIGlmICh0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgYGRlc3Ryb3lgIG9uIGFsbCBpbnRlcm5hbCBsb2FkZXIgaW5zdGFuY2VzIG1hcHBlZCAob25lIHBlciBjb250ZXh0IHR5cGUpXG4gICAgICovO1xuICAgIF9wcm90by5kZXN0cm95SW50ZXJuYWxMb2FkZXJzID0gZnVuY3Rpb24gZGVzdHJveUludGVybmFsTG9hZGVycygpIHtcbiAgICAgIGZvciAodmFyIGNvbnRleHRUeXBlIGluIHRoaXMubG9hZGVycykge1xuICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXTtcbiAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHRUeXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMudmFyaWFibGVMaXN0ID0gbnVsbDtcbiAgICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgdGhpcy5kZXN0cm95SW50ZXJuYWxMb2FkZXJzKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIHVybCA9IGRhdGEudXJsO1xuICAgICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgICAgdGhpcy5sb2FkKHtcbiAgICAgICAgaWQ6IG51bGwsXG4gICAgICAgIGxldmVsOiAwLFxuICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogbnVsbFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbExvYWRpbmcgPSBmdW5jdGlvbiBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGlkID0gZGF0YS5pZCxcbiAgICAgICAgbGV2ZWwgPSBkYXRhLmxldmVsLFxuICAgICAgICBwYXRod2F5SWQgPSBkYXRhLnBhdGh3YXlJZCxcbiAgICAgICAgdXJsID0gZGF0YS51cmwsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzO1xuICAgICAgdGhpcy5sb2FkKHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgIHBhdGh3YXlJZDogcGF0aHdheUlkLFxuICAgICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5vbkF1ZGlvVHJhY2tMb2FkaW5nID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGlkID0gZGF0YS5pZCxcbiAgICAgICAgZ3JvdXBJZCA9IGRhdGEuZ3JvdXBJZCxcbiAgICAgICAgdXJsID0gZGF0YS51cmwsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzO1xuICAgICAgdGhpcy5sb2FkKHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgICBsZXZlbDogbnVsbCxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0ssXG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrTG9hZGluZyA9IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja0xvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBpZCA9IGRhdGEuaWQsXG4gICAgICAgIGdyb3VwSWQgPSBkYXRhLmdyb3VwSWQsXG4gICAgICAgIHVybCA9IGRhdGEudXJsLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcztcbiAgICAgIHRoaXMubG9hZCh7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCxcbiAgICAgICAgbGV2ZWw6IG51bGwsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNvbnRleHQpIHtcbiAgICAgIHZhciBfY29udGV4dCRkZWxpdmVyeURpcmUsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG5cbiAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW3BsYXlsaXN0LWxvYWRlcl06IExvYWRpbmcgcGxheWxpc3Qgb2YgdHlwZSAke2NvbnRleHQudHlwZX0sIGxldmVsOiAke2NvbnRleHQubGV2ZWx9LCBpZDogJHtjb250ZXh0LmlkfWApO1xuXG4gICAgICAvLyBDaGVjayBpZiBhIGxvYWRlciBmb3IgdGhpcyBjb250ZXh0IGFscmVhZHkgZXhpc3RzXG4gICAgICB2YXIgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgdmFyIGxvYWRlckNvbnRleHQgPSBsb2FkZXIuY29udGV4dDtcbiAgICAgICAgaWYgKGxvYWRlckNvbnRleHQgJiYgbG9hZGVyQ29udGV4dC51cmwgPT09IGNvbnRleHQudXJsICYmIGxvYWRlckNvbnRleHQubGV2ZWwgPT09IGNvbnRleHQubGV2ZWwpIHtcbiAgICAgICAgICAvLyBzYW1lIFVSTCBjYW4ndCBvdmVybGFwXG4gICAgICAgICAgbG9nZ2VyLnRyYWNlKCdbcGxheWxpc3QtbG9hZGVyXTogcGxheWxpc3QgcmVxdWVzdCBvbmdvaW5nJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5sb2coXCJbcGxheWxpc3QtbG9hZGVyXTogYWJvcnRpbmcgcHJldmlvdXMgbG9hZGVyIGZvciB0eXBlOiBcIiArIGNvbnRleHQudHlwZSk7XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBkaWZmZXJlbnQgY29uZmlncyBmb3IgcmV0cmllcyBkZXBlbmRpbmcgb25cbiAgICAgIC8vIGNvbnRleHQgKG1hbmlmZXN0LCBsZXZlbCwgYXVkaW8vc3VicyBwbGF5bGlzdClcbiAgICAgIHZhciBsb2FkUG9saWN5O1xuICAgICAgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCkge1xuICAgICAgICBsb2FkUG9saWN5ID0gY29uZmlnLm1hbmlmZXN0TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZFBvbGljeSA9IF9leHRlbmRzKHt9LCBjb25maWcucGxheWxpc3RMb2FkUG9saWN5LmRlZmF1bHQsIHtcbiAgICAgICAgICB0aW1lb3V0UmV0cnk6IG51bGwsXG4gICAgICAgICAgZXJyb3JSZXRyeTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxvYWRlciA9IHRoaXMuY3JlYXRlSW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG5cbiAgICAgIC8vIE92ZXJyaWRlIGxldmVsL3RyYWNrIHRpbWVvdXQgZm9yIExMLUhMUyByZXF1ZXN0c1xuICAgICAgLy8gKHRoZSBkZWZhdWx0IG9mIDEwMDAwbXMgaXMgY291bnRlciBwcm9kdWN0aXZlIHRvIGJsb2NraW5nIHBsYXlsaXN0IHJlbG9hZCByZXF1ZXN0cylcbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcigoX2NvbnRleHQkZGVsaXZlcnlEaXJlID0gY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfY29udGV4dCRkZWxpdmVyeURpcmUucGFydCkpIHtcbiAgICAgICAgdmFyIGxldmVsRGV0YWlscztcbiAgICAgICAgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCAmJiBjb250ZXh0LmxldmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMubGV2ZWxzW2NvbnRleHQubGV2ZWxdLmRldGFpbHM7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIGNvbnRleHQuaWQgIT09IG51bGwpIHtcbiAgICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5hdWRpb1RyYWNrc1tjb250ZXh0LmlkXS5kZXRhaWxzO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBjb250ZXh0LmlkICE9PSBudWxsKSB7XG4gICAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMuc3VidGl0bGVUcmFja3NbY29udGV4dC5pZF0uZGV0YWlscztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV2ZWxEZXRhaWxzKSB7XG4gICAgICAgICAgdmFyIHBhcnRUYXJnZXQgPSBsZXZlbERldGFpbHMucGFydFRhcmdldDtcbiAgICAgICAgICB2YXIgdGFyZ2V0RHVyYXRpb24gPSBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICAgICAgaWYgKHBhcnRUYXJnZXQgJiYgdGFyZ2V0RHVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBtYXhMb3dMYXRlbmN5UGxheWxpc3RSZWZyZXNoID0gTWF0aC5tYXgocGFydFRhcmdldCAqIDMsIHRhcmdldER1cmF0aW9uICogMC44KSAqIDEwMDA7XG4gICAgICAgICAgICBsb2FkUG9saWN5ID0gX2V4dGVuZHMoe30sIGxvYWRQb2xpY3ksIHtcbiAgICAgICAgICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IE1hdGgubWluKG1heExvd0xhdGVuY3lQbGF5bGlzdFJlZnJlc2gsIGxvYWRQb2xpY3kubWF4VGltZVRvRmlyc3RCeXRlTXMpLFxuICAgICAgICAgICAgICBtYXhMb2FkVGltZU1zOiBNYXRoLm1pbihtYXhMb3dMYXRlbmN5UGxheWxpc3RSZWZyZXNoLCBsb2FkUG9saWN5Lm1heFRpbWVUb0ZpcnN0Qnl0ZU1zKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5ID0gbG9hZFBvbGljeS5lcnJvclJldHJ5IHx8IGxvYWRQb2xpY3kudGltZW91dFJldHJ5IHx8IHt9O1xuICAgICAgdmFyIGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgbG9hZFBvbGljeTogbG9hZFBvbGljeSxcbiAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heE51bVJldHJ5IHx8IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5yZXRyeURlbGF5TXMgfHwgMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heFJldHJ5RGVsYXlNcyB8fCAwXG4gICAgICB9O1xuICAgICAgdmFyIGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgIHZhciBsb2FkZXIgPSBfdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgICBfdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHQudHlwZSk7XG4gICAgICAgICAgdmFyIHN0cmluZyA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICAgICAgICAvLyBWYWxpZGF0ZSBpZiBpdCBpcyBhbiBNM1U4IGF0IGFsbFxuICAgICAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVE0zVScpICE9PSAwKSB7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV3IEVycm9yKCdubyBFWFRNM1UgZGVsaW1pdGVyJyksIG5ldHdvcmtEZXRhaWxzIHx8IG51bGwsIHN0YXRzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGlmIChNM1U4UGFyc2VyLmlzTWVkaWFQbGF5bGlzdChzdHJpbmcpKSB7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzIHx8IG51bGwsIGxvYWRlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZU1hc3RlclBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSB7XG4gICAgICAgICAgX3RoaXMuaGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBmYWxzZSwgcmVzcG9uc2UsIHN0YXRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiBmdW5jdGlvbiBvblRpbWVvdXQoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgX3RoaXMuaGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCB0cnVlLCB1bmRlZmluZWQsIHN0YXRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbcGxheWxpc3QtbG9hZGVyXTogQ2FsbGluZyBpbnRlcm5hbCBsb2FkZXIgZGVsZWdhdGUgZm9yIFVSTDogJHtjb250ZXh0LnVybH1gKTtcblxuICAgICAgbG9hZGVyLmxvYWQoY29udGV4dCwgbG9hZGVyQ29uZmlnLCBsb2FkZXJDYWxsYmFja3MpO1xuICAgIH07XG4gICAgX3Byb3RvLmhhbmRsZU1hc3RlclBsYXlsaXN0ID0gZnVuY3Rpb24gaGFuZGxlTWFzdGVyUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgdmFyIHN0cmluZyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICB2YXIgdXJsID0gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgICAgdmFyIHBhcnNlZFJlc3VsdCA9IE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdChzdHJpbmcsIHVybCk7XG4gICAgICBpZiAocGFyc2VkUmVzdWx0LnBsYXlsaXN0UGFyc2luZ0Vycm9yKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIHBhcnNlZFJlc3VsdC5wbGF5bGlzdFBhcnNpbmdFcnJvciwgbmV0d29ya0RldGFpbHMsIHN0YXRzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRlbnRTdGVlcmluZyA9IHBhcnNlZFJlc3VsdC5jb250ZW50U3RlZXJpbmcsXG4gICAgICAgIGxldmVscyA9IHBhcnNlZFJlc3VsdC5sZXZlbHMsXG4gICAgICAgIHNlc3Npb25EYXRhID0gcGFyc2VkUmVzdWx0LnNlc3Npb25EYXRhLFxuICAgICAgICBzZXNzaW9uS2V5cyA9IHBhcnNlZFJlc3VsdC5zZXNzaW9uS2V5cyxcbiAgICAgICAgc3RhcnRUaW1lT2Zmc2V0ID0gcGFyc2VkUmVzdWx0LnN0YXJ0VGltZU9mZnNldCxcbiAgICAgICAgdmFyaWFibGVMaXN0ID0gcGFyc2VkUmVzdWx0LnZhcmlhYmxlTGlzdDtcbiAgICAgIHRoaXMudmFyaWFibGVMaXN0ID0gdmFyaWFibGVMaXN0O1xuICAgICAgdmFyIF9NM1U4UGFyc2VyJHBhcnNlTWFzdCA9IE0zVThQYXJzZXIucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHN0cmluZywgdXJsLCBwYXJzZWRSZXN1bHQpLFxuICAgICAgICBfTTNVOFBhcnNlciRwYXJzZU1hc3QyID0gX00zVThQYXJzZXIkcGFyc2VNYXN0LkFVRElPLFxuICAgICAgICBhdWRpb1RyYWNrcyA9IF9NM1U4UGFyc2VyJHBhcnNlTWFzdDIgPT09IHZvaWQgMCA/IFtdIDogX00zVThQYXJzZXIkcGFyc2VNYXN0MixcbiAgICAgICAgc3VidGl0bGVzID0gX00zVThQYXJzZXIkcGFyc2VNYXN0LlNVQlRJVExFUyxcbiAgICAgICAgY2FwdGlvbnMgPSBfTTNVOFBhcnNlciRwYXJzZU1hc3RbJ0NMT1NFRC1DQVBUSU9OUyddO1xuICAgICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGZvdW5kIGFuIGF1ZGlvIHRyYWNrIGVtYmVkZGVkIGluIG1haW4gcGxheWxpc3QgKGF1ZGlvIHRyYWNrIHdpdGhvdXQgVVJJIGF0dHJpYnV0ZSlcbiAgICAgICAgdmFyIGVtYmVkZGVkQXVkaW9Gb3VuZCA9IGF1ZGlvVHJhY2tzLnNvbWUoZnVuY3Rpb24gKGF1ZGlvVHJhY2spIHtcbiAgICAgICAgICByZXR1cm4gIWF1ZGlvVHJhY2sudXJsO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBkZWZpbmVkLCBidXQgYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCxcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzaWduYWwgdGhpcyBtYWluIGF1ZGlvIHRyYWNrIHRoaXMgY291bGQgaGFwcGVuIHdpdGggcGxheWxpc3RzIHdpdGhcbiAgICAgICAgLy8gYWx0IGF1ZGlvIHJlbmRpdGlvbiBpbiB3aGljaCBxdWFsaXR5IGxldmVscyAobWFpbilcbiAgICAgICAgLy8gY29udGFpbnMgYm90aCBhdWRpbyt2aWRlby4gYnV0IHdpdGggbWl4ZWQgYXVkaW8gdHJhY2sgbm90IHNpZ25hbGVkXG4gICAgICAgIGlmICghZW1iZWRkZWRBdWRpb0ZvdW5kICYmIGxldmVsc1swXS5hdWRpb0NvZGVjICYmICFsZXZlbHNbMF0uYXR0cnMuQVVESU8pIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdbcGxheWxpc3QtbG9hZGVyXTogYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgYnV0IG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIHNpZ25hbGVkLCBjcmVhdGUgb25lJyk7XG4gICAgICAgICAgYXVkaW9UcmFja3MudW5zaGlmdCh7XG4gICAgICAgICAgICB0eXBlOiAnbWFpbicsXG4gICAgICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgICAgICBncm91cElkOiAnbWFpbicsXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIGF1dG9zZWxlY3Q6IGZhbHNlLFxuICAgICAgICAgICAgZm9yY2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGlkOiAtMSxcbiAgICAgICAgICAgIGF0dHJzOiBuZXcgQXR0ckxpc3Qoe30pLFxuICAgICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICAgIHVybDogJydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgICBsZXZlbHM6IGxldmVscyxcbiAgICAgICAgYXVkaW9UcmFja3M6IGF1ZGlvVHJhY2tzLFxuICAgICAgICBzdWJ0aXRsZXM6IHN1YnRpdGxlcyxcbiAgICAgICAgY2FwdGlvbnM6IGNhcHRpb25zLFxuICAgICAgICBjb250ZW50U3RlZXJpbmc6IGNvbnRlbnRTdGVlcmluZyxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzZXNzaW9uRGF0YTogc2Vzc2lvbkRhdGEsXG4gICAgICAgIHNlc3Npb25LZXlzOiBzZXNzaW9uS2V5cyxcbiAgICAgICAgc3RhcnRUaW1lT2Zmc2V0OiBzdGFydFRpbWVPZmZzZXQsXG4gICAgICAgIHZhcmlhYmxlTGlzdDogdmFyaWFibGVMaXN0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdCA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGxvYWRlcikge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgdmFyIGlkID0gY29udGV4dC5pZCxcbiAgICAgICAgbGV2ZWwgPSBjb250ZXh0LmxldmVsLFxuICAgICAgICB0eXBlID0gY29udGV4dC50eXBlO1xuICAgICAgdmFyIHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZXZlbFVybElkID0gMDtcbiAgICAgIHZhciBsZXZlbElkID0gaXNGaW5pdGVOdW1iZXIobGV2ZWwpID8gbGV2ZWwgOiBpc0Zpbml0ZU51bWJlcihpZCkgPyBpZCA6IDA7XG4gICAgICB2YXIgbGV2ZWxUeXBlID0gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpO1xuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IE0zVThQYXJzZXIucGFyc2VMZXZlbFBsYXlsaXN0KHJlc3BvbnNlLmRhdGEsIHVybCwgbGV2ZWxJZCwgbGV2ZWxUeXBlLCBsZXZlbFVybElkLCB0aGlzLnZhcmlhYmxlTGlzdCk7XG5cbiAgICAgIC8vIFdlIGhhdmUgZG9uZSBvdXIgZmlyc3QgcmVxdWVzdCAoTWFuaWZlc3QtdHlwZSkgYW5kIHJlY2VpdmVcbiAgICAgIC8vIG5vdCBhIG1hc3RlciBwbGF5bGlzdCBidXQgYSBjaHVuay1saXN0ICh0cmFjay9sZXZlbClcbiAgICAgIC8vIFdlIGZpcmUgdGhlIG1hbmlmZXN0LWxvYWRlZCBldmVudCBhbnl3YXkgd2l0aCB0aGUgcGFyc2VkIGxldmVsLWRldGFpbHNcbiAgICAgIC8vIGJ5IGNyZWF0aW5nIGEgc2luZ2xlLWxldmVsIHN0cnVjdHVyZSBmb3IgaXQuXG4gICAgICBpZiAodHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCkge1xuICAgICAgICB2YXIgc2luZ2xlTGV2ZWwgPSB7XG4gICAgICAgICAgYXR0cnM6IG5ldyBBdHRyTGlzdCh7fSksXG4gICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgfTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgICAgIGxldmVsczogW3NpbmdsZUxldmVsXSxcbiAgICAgICAgICBhdWRpb1RyYWNrczogW10sXG4gICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBzZXNzaW9uRGF0YTogbnVsbCxcbiAgICAgICAgICBzZXNzaW9uS2V5czogbnVsbCxcbiAgICAgICAgICBjb250ZW50U3RlZXJpbmc6IG51bGwsXG4gICAgICAgICAgc3RhcnRUaW1lT2Zmc2V0OiBudWxsLFxuICAgICAgICAgIHZhcmlhYmxlTGlzdDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gc2F2ZSBwYXJzaW5nIHRpbWVcbiAgICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIC8vIGV4dGVuZCB0aGUgY29udGV4dCB3aXRoIHRoZSBuZXcgbGV2ZWxEZXRhaWxzIHByb3BlcnR5XG4gICAgICBjb250ZXh0LmxldmVsRGV0YWlscyA9IGxldmVsRGV0YWlscztcbiAgICAgIHRoaXMuaGFuZGxlUGxheWxpc3RMb2FkZWQobGV2ZWxEZXRhaWxzLCByZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBsb2FkZXIpO1xuICAgIH07XG4gICAgX3Byb3RvLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yID0gZnVuY3Rpb24gaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIGVycm9yLCBuZXR3b3JrRGV0YWlscywgc3RhdHMpIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsXG4gICAgICAgIGZhdGFsOiBjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QsXG4gICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICBlcnI6IGVycm9yLFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgIHN0YXRzOiBzdGF0c1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlTmV0d29ya0Vycm9yID0gZnVuY3Rpb24gaGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCB0aW1lb3V0LCByZXNwb25zZSwgc3RhdHMpIHtcbiAgICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGltZW91dCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG1lc3NhZ2UgPSBcIkEgbmV0d29yayBcIiArICh0aW1lb3V0ID8gJ3RpbWVvdXQnIDogJ2Vycm9yJyArIChyZXNwb25zZSA/ICcgKHN0YXR1cyAnICsgcmVzcG9uc2UuY29kZSArICcpJyA6ICcnKSkgKyBcIiBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nIFwiICsgY29udGV4dC50eXBlO1xuICAgICAgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCkge1xuICAgICAgICBtZXNzYWdlICs9IFwiOiBcIiArIGNvbnRleHQubGV2ZWwgKyBcIiBpZDogXCIgKyBjb250ZXh0LmlkO1xuICAgICAgfSBlbHNlIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgfHwgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIgaWQ6IFwiICsgY29udGV4dC5pZCArIFwiIGdyb3VwLWlkOiBcXFwiXCIgKyBjb250ZXh0Lmdyb3VwSWQgKyBcIlxcXCJcIjtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIGxvZ2dlci53YXJuKFwiW3BsYXlsaXN0LWxvYWRlcl06IFwiICsgbWVzc2FnZSk7XG4gICAgICB2YXIgZGV0YWlscyA9IEVycm9yRGV0YWlscy5VTktOT1dOO1xuICAgICAgdmFyIGZhdGFsID0gZmFsc2U7XG4gICAgICB2YXIgbG9hZGVyID0gdGhpcy5nZXRJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcbiAgICAgIHN3aXRjaCAoY29udGV4dC50eXBlKSB7XG4gICAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9FUlJPUjtcbiAgICAgICAgICBmYXRhbCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTDpcbiAgICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjtcbiAgICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I7XG4gICAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5TVUJUSVRMRV9MT0FEX0VSUk9SO1xuICAgICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yRGF0YSA9IHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICBmYXRhbDogZmF0YWwsXG4gICAgICAgIHVybDogY29udGV4dC51cmwsXG4gICAgICAgIGxvYWRlcjogbG9hZGVyLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgc3RhdHM6IHN0YXRzXG4gICAgICB9O1xuICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciB1cmwgPSAobmV0d29ya0RldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IG5ldHdvcmtEZXRhaWxzLnVybCkgfHwgY29udGV4dC51cmw7XG4gICAgICAgIGVycm9yRGF0YS5yZXNwb25zZSA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBkYXRhOiB1bmRlZmluZWRcbiAgICAgICAgfSwgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGVycm9yRGF0YSk7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlUGxheWxpc3RMb2FkZWQgPSBmdW5jdGlvbiBoYW5kbGVQbGF5bGlzdExvYWRlZChsZXZlbERldGFpbHMsIHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIGxvYWRlcikge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgdmFyIHR5cGUgPSBjb250ZXh0LnR5cGUsXG4gICAgICAgIGxldmVsID0gY29udGV4dC5sZXZlbCxcbiAgICAgICAgaWQgPSBjb250ZXh0LmlkLFxuICAgICAgICBncm91cElkID0gY29udGV4dC5ncm91cElkLFxuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSBjb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcztcbiAgICAgIHZhciB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgICB2YXIgcGFyZW50ID0gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpO1xuICAgICAgdmFyIGxldmVsSW5kZXggPSB0eXBlb2YgY29udGV4dC5sZXZlbCA9PT0gJ251bWJlcicgJiYgcGFyZW50ID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gbGV2ZWwgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoIWxldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBfZXJyb3IgPSBuZXcgRXJyb3IoJ05vIFNlZ21lbnRzIGZvdW5kIGluIFBsYXlsaXN0Jyk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfRU1QVFlfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgIGVycm9yOiBfZXJyb3IsXG4gICAgICAgICAgcmVhc29uOiBfZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICBsZXZlbDogbGV2ZWxJbmRleCxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgc3RhdHM6IHN0YXRzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikge1xuICAgICAgICBsZXZlbERldGFpbHMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoJ01pc3NpbmcgVGFyZ2V0IER1cmF0aW9uJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3IgPSBsZXZlbERldGFpbHMucGxheWxpc3RQYXJzaW5nRXJyb3I7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgIGxldmVsOiBsZXZlbEluZGV4LFxuICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBzdGF0czogc3RhdHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSAmJiBsb2FkZXIpIHtcbiAgICAgICAgaWYgKGxvYWRlci5nZXRDYWNoZUFnZSkge1xuICAgICAgICAgIGxldmVsRGV0YWlscy5hZ2VIZWFkZXIgPSBsb2FkZXIuZ2V0Q2FjaGVBZ2UoKSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbG9hZGVyLmdldENhY2hlQWdlIHx8IGlzTmFOKGxldmVsRGV0YWlscy5hZ2VIZWFkZXIpKSB7XG4gICAgICAgICAgbGV2ZWxEZXRhaWxzLmFnZUhlYWRlciA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1Q6XG4gICAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTDpcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuTEVWRUxfTE9BREVELCB7XG4gICAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgICBsZXZlbDogbGV2ZWxJbmRleCB8fCAwLFxuICAgICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgICBzdGF0czogc3RhdHMsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgICBncm91cElkOiBncm91cElkIHx8ICcnLFxuICAgICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUGxheWxpc3RMb2FkZXI7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBzZW5kQWRkVHJhY2tFdmVudCh0cmFjaywgdmlkZW9FbCkge1xuICAgIHZhciBldmVudDtcbiAgICB0cnkge1xuICAgICAgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHRyYWNrJyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBmb3IgSUUxMVxuICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2ZW50LmluaXRFdmVudCgnYWRkdHJhY2snLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgICBldmVudC50cmFjayA9IHRyYWNrO1xuICAgIHZpZGVvRWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkQ3VlVG9UcmFjayh0cmFjaywgY3VlKSB7XG4gICAgLy8gU29tZXRpbWVzIHRoZXJlIGFyZSBjdWUgb3ZlcmxhcHMgb24gc2VnbWVudGVkIHZ0dHMgc28gdGhlIHNhbWVcbiAgICAvLyBjdWUgY2FuIGFwcGVhciBtb3JlIHRoYW4gb25jZSBpbiBkaWZmZXJlbnQgdnR0IGZpbGVzLlxuICAgIC8vIFRoaXMgYXZvaWQgc2hvd2luZyBkdXBsaWNhdGVkIGN1ZXMgd2l0aCBzYW1lIHRpbWVjb2RlIGFuZCB0ZXh0LlxuICAgIHZhciBtb2RlID0gdHJhY2subW9kZTtcbiAgICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgIH1cbiAgICBpZiAodHJhY2suY3VlcyAmJiAhdHJhY2suY3Vlcy5nZXRDdWVCeUlkKGN1ZS5pZCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICBpZiAoIXRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkQ3VlIGlzIGZhaWxlZCBmb3I6IFwiICsgY3VlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlt0ZXh0dHJhY2stdXRpbHNdOiBcIiArIGVycik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHRleHRUcmFja0N1ZSA9IG5ldyBzZWxmLlRleHRUcmFja0N1ZShjdWUuc3RhcnRUaW1lLCBjdWUuZW5kVGltZSwgY3VlLnRleHQpO1xuICAgICAgICAgIHRleHRUcmFja0N1ZS5pZCA9IGN1ZS5pZDtcbiAgICAgICAgICB0cmFjay5hZGRDdWUodGV4dFRyYWNrQ3VlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlt0ZXh0dHJhY2stdXRpbHNdOiBMZWdhY3kgVGV4dFRyYWNrQ3VlIGZhbGxiYWNrIGZhaWxlZDogXCIgKyBlcnIyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgdHJhY2subW9kZSA9IG1vZGU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNsZWFyQ3VycmVudEN1ZXModHJhY2spIHtcbiAgICAvLyBXaGVuIHRyYWNrLm1vZGUgaXMgZGlzYWJsZWQsIHRyYWNrLmN1ZXMgd2lsbCBiZSBudWxsLlxuICAgIC8vIFRvIGd1YXJhbnRlZSB0aGUgcmVtb3ZhbCBvZiBjdWVzLCB3ZSBuZWVkIHRvIHRlbXBvcmFyaWx5XG4gICAgLy8gY2hhbmdlIHRoZSBtb2RlIHRvIGhpZGRlblxuICAgIHZhciBtb2RlID0gdHJhY2subW9kZTtcbiAgICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgIH1cbiAgICBpZiAodHJhY2suY3Vlcykge1xuICAgICAgZm9yICh2YXIgaSA9IHRyYWNrLmN1ZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIHRyYWNrLnJlbW92ZUN1ZSh0cmFjay5jdWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICAgIHRyYWNrLm1vZGUgPSBtb2RlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVDdWVzSW5SYW5nZSh0cmFjaywgc3RhcnQsIGVuZCwgcHJlZGljYXRlKSB7XG4gICAgdmFyIG1vZGUgPSB0cmFjay5tb2RlO1xuICAgIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICB0cmFjay5tb2RlID0gJ2hpZGRlbic7XG4gICAgfVxuICAgIGlmICh0cmFjay5jdWVzICYmIHRyYWNrLmN1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGN1ZXMgPSBnZXRDdWVzSW5SYW5nZSh0cmFjay5jdWVzLCBzdGFydCwgZW5kKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoY3Vlc1tpXSkpIHtcbiAgICAgICAgICB0cmFjay5yZW1vdmVDdWUoY3Vlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICAgIHRyYWNrLm1vZGUgPSBtb2RlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgZmlyc3QgY3VlIHN0YXJ0aW5nIGFmdGVyIGdpdmVuIHRpbWUuXG4gIC8vIE1vZGlmaWVkIHZlcnNpb24gb2YgYmluYXJ5IHNlYXJjaCBPKGxvZyhuKSkuXG4gIGZ1bmN0aW9uIGdldEZpcnN0Q3VlSW5kZXhBZnRlclRpbWUoY3VlcywgdGltZSkge1xuICAgIC8vIElmIGZpcnN0IGN1ZSBzdGFydHMgYWZ0ZXIgdGltZSwgc3RhcnQgdGhlcmVcbiAgICBpZiAodGltZSA8IGN1ZXNbMF0uc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGxhc3QgY3VlIGVuZHMgYmVmb3JlIHRpbWUgdGhlcmUgaXMgbm8gb3ZlcmxhcFxuICAgIHZhciBsZW4gPSBjdWVzLmxlbmd0aCAtIDE7XG4gICAgaWYgKHRpbWUgPiBjdWVzW2xlbl0uZW5kVGltZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB2YXIgbGVmdCA9IDA7XG4gICAgdmFyIHJpZ2h0ID0gbGVuO1xuICAgIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigocmlnaHQgKyBsZWZ0KSAvIDIpO1xuICAgICAgaWYgKHRpbWUgPCBjdWVzW21pZF0uc3RhcnRUaW1lKSB7XG4gICAgICAgIHJpZ2h0ID0gbWlkIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAodGltZSA+IGN1ZXNbbWlkXS5zdGFydFRpbWUgJiYgbGVmdCA8IGxlbikge1xuICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IGxvd2VyIG9yIGhpZ2hlciwgaXQgbXVzdCBiZSBlcXVhbC5cbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCwgbGVmdCBhbmQgcmlnaHQgaGF2ZSBzd2FwcGVkLlxuICAgIC8vIE5vIGRpcmVjdCBtYXRjaCB3YXMgZm91bmQsIGxlZnQgb3IgcmlnaHQgZWxlbWVudCBtdXN0IGJlIHRoZSBjbG9zZXN0LiBDaGVjayB3aGljaCBvbmUgaGFzIHRoZSBzbWFsbGVzdCBkaWZmLlxuICAgIHJldHVybiBjdWVzW2xlZnRdLnN0YXJ0VGltZSAtIHRpbWUgPCB0aW1lIC0gY3Vlc1tyaWdodF0uc3RhcnRUaW1lID8gbGVmdCA6IHJpZ2h0O1xuICB9XG4gIGZ1bmN0aW9uIGdldEN1ZXNJblJhbmdlKGN1ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgY3Vlc0ZvdW5kID0gW107XG4gICAgdmFyIGZpcnN0Q3VlSW5SYW5nZSA9IGdldEZpcnN0Q3VlSW5kZXhBZnRlclRpbWUoY3Vlcywgc3RhcnQpO1xuICAgIGlmIChmaXJzdEN1ZUluUmFuZ2UgPiAtMSkge1xuICAgICAgZm9yICh2YXIgaSA9IGZpcnN0Q3VlSW5SYW5nZSwgbGVuID0gY3Vlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgX2N1ZSA9IGN1ZXNbaV07XG4gICAgICAgIGlmIChfY3VlLnN0YXJ0VGltZSA+PSBzdGFydCAmJiBfY3VlLmVuZFRpbWUgPD0gZW5kKSB7XG4gICAgICAgICAgY3Vlc0ZvdW5kLnB1c2goX2N1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2N1ZS5zdGFydFRpbWUgPiBlbmQpIHtcbiAgICAgICAgICByZXR1cm4gY3Vlc0ZvdW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdWVzRm91bmQ7XG4gIH1cbiAgZnVuY3Rpb24gZmlsdGVyU3VidGl0bGVUcmFja3ModGV4dFRyYWNrTGlzdCkge1xuICAgIHZhciB0cmFja3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRleHRUcmFja0xpc3RbaV07XG4gICAgICAvLyBFZGdlIGFkZHMgYSB0cmFjayB3aXRob3V0IGEgbGFiZWw7IHdlIGRvbid0IHdhbnQgdG8gdXNlIGl0XG4gICAgICBpZiAoKHRyYWNrLmtpbmQgPT09ICdzdWJ0aXRsZXMnIHx8IHRyYWNrLmtpbmQgPT09ICdjYXB0aW9ucycpICYmIHRyYWNrLmxhYmVsKSB7XG4gICAgICAgIHRyYWNrcy5wdXNoKHRleHRUcmFja0xpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJhY2tzO1xuICB9XG5cbiAgdmFyIE1ldGFkYXRhU2NoZW1hID0ge1xuICAgIGF1ZGlvSWQzOiBcIm9yZy5pZDNcIixcbiAgICBkYXRlUmFuZ2U6IFwiY29tLmFwcGxlLnF1aWNrdGltZS5ITFNcIixcbiAgICBlbXNnOiBcImh0dHBzOi8vYW9tZWRpYS5vcmcvZW1zZy9JRDNcIlxuICB9O1xuXG4gIHZhciBNSU5fQ1VFX0RVUkFUSU9OID0gMC4yNTtcbiAgZnVuY3Rpb24gZ2V0Q3VlQ2xhc3MoKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc2VsZi5WVFRDdWUgfHwgc2VsZi5UZXh0VHJhY2tDdWU7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQ3VlV2l0aERhdGFGaWVsZHMoQ3VlLCBzdGFydFRpbWUsIGVuZFRpbWUsIGRhdGEsIHR5cGUpIHtcbiAgICB2YXIgY3VlID0gbmV3IEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsICcnKTtcbiAgICB0cnkge1xuICAgICAgY3VlLnZhbHVlID0gZGF0YTtcbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGN1ZS50eXBlID0gdHlwZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgSlNPTi5zdHJpbmdpZnkodHlwZSA/IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfSwgZGF0YSkgOiBkYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiBjdWU7XG4gIH1cblxuICAvLyBWVFRDdWUgbGF0ZXN0IGRyYWZ0IGFsbG93cyBhbiBpbmZpbml0ZSBkdXJhdGlvbiwgZmFsbGJhY2tcbiAgLy8gdG8gTUFYX1ZBTFVFIGlmIG5lY2Vzc2FyeVxuICB2YXIgTUFYX0NVRV9FTkRUSU1FID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICAgIHRyeSB7XG4gICAgICBDdWUgJiYgbmV3IEN1ZSgwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksICcnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfSgpO1xuICBmdW5jdGlvbiBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMoZGF0ZSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIC8gMTAwMCAtIG9mZnNldDtcbiAgfVxuICBmdW5jdGlvbiBoZXhUb0FycmF5QnVmZmVyKHN0cikge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oc3RyLnJlcGxhY2UoL14weC8sICcnKS5yZXBsYWNlKC8oW1xcZGEtZkEtRl17Mn0pID8vZywgJzB4JDEgJykucmVwbGFjZSgvICskLywgJycpLnNwbGl0KCcgJykpLmJ1ZmZlcjtcbiAgfVxuICB2YXIgSUQzVHJhY2tDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJRDNUcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgICB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gSUQzVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLl91bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHRoaXMub25GcmFnUGFyc2luZ01ldGFkYXRhLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIH1cblxuICAgIC8vIEFkZCBJRDMgbWV0YXRhZGF0YSB0ZXh0IHRyYWNrLlxuICAgIDtcbiAgICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjbGVhckN1cnJlbnRDdWVzKHRoaXMuaWQzVHJhY2spO1xuICAgICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gICAgfTtcbiAgICBfcHJvdG8uY3JlYXRlVHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVUcmFjayhtZWRpYSkge1xuICAgICAgdmFyIHRyYWNrID0gdGhpcy5nZXRJRDNUcmFjayhtZWRpYS50ZXh0VHJhY2tzKTtcbiAgICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9O1xuICAgIF9wcm90by5nZXRJRDNUcmFjayA9IGZ1bmN0aW9uIGdldElEM1RyYWNrKHRleHRUcmFja3MpIHtcbiAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRleHRUcmFjayA9IHRleHRUcmFja3NbaV07XG4gICAgICAgIGlmICh0ZXh0VHJhY2sua2luZCA9PT0gJ21ldGFkYXRhJyAmJiB0ZXh0VHJhY2subGFiZWwgPT09ICdpZDMnKSB7XG4gICAgICAgICAgLy8gc2VuZCAnYWRkdHJhY2snIHdoZW4gcmV1c2luZyB0aGUgdGV4dFRyYWNrIGZvciBtZXRhZGF0YSxcbiAgICAgICAgICAvLyBzYW1lIGFzIHdoYXQgd2UgZG8gZm9yIGNhcHRpb25zXG4gICAgICAgICAgc2VuZEFkZFRyYWNrRXZlbnQodGV4dFRyYWNrLCB0aGlzLm1lZGlhKTtcbiAgICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tZWRpYS5hZGRUZXh0VHJhY2soJ21ldGFkYXRhJywgJ2lkMycpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uRnJhZ1BhcnNpbmdNZXRhZGF0YSA9IGZ1bmN0aW9uIG9uRnJhZ1BhcnNpbmdNZXRhZGF0YShldmVudCwgZGF0YSkge1xuICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyRobHMkY29uZmlnID0gdGhpcy5obHMuY29uZmlnLFxuICAgICAgICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzID0gX3RoaXMkaGxzJGNvbmZpZy5lbmFibGVFbXNnTWV0YWRhdGFDdWVzLFxuICAgICAgICBlbmFibGVJRDNNZXRhZGF0YUN1ZXMgPSBfdGhpcyRobHMkY29uZmlnLmVuYWJsZUlEM01ldGFkYXRhQ3VlcztcbiAgICAgIGlmICghZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyAmJiAhZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzYW1wbGVzID0gZGF0YS5zYW1wbGVzO1xuXG4gICAgICAvLyBjcmVhdGUgdHJhY2sgZHluYW1pY2FsbHlcbiAgICAgIGlmICghdGhpcy5pZDNUcmFjaykge1xuICAgICAgICB0aGlzLmlkM1RyYWNrID0gdGhpcy5jcmVhdGVUcmFjayh0aGlzLm1lZGlhKTtcbiAgICAgIH1cbiAgICAgIHZhciBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICAgICAgaWYgKCFDdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gc2FtcGxlc1tpXS50eXBlO1xuICAgICAgICBpZiAodHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiAhZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyB8fCAhZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyYW1lcyA9IGdldElEM0ZyYW1lcyhzYW1wbGVzW2ldLmRhdGEpO1xuICAgICAgICBpZiAoZnJhbWVzKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHNhbXBsZXNbaV0ucHRzO1xuICAgICAgICAgIHZhciBlbmRUaW1lID0gc3RhcnRUaW1lICsgc2FtcGxlc1tpXS5kdXJhdGlvbjtcbiAgICAgICAgICBpZiAoZW5kVGltZSA+IE1BWF9DVUVfRU5EVElNRSkge1xuICAgICAgICAgICAgZW5kVGltZSA9IE1BWF9DVUVfRU5EVElNRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRpbWVEaWZmID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgICBpZiAodGltZURpZmYgPD0gMCkge1xuICAgICAgICAgICAgZW5kVGltZSA9IHN0YXJ0VGltZSArIE1JTl9DVUVfRFVSQVRJT047XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZnJhbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZnJhbWUgPSBmcmFtZXNbal07XG4gICAgICAgICAgICAvLyBTYWZhcmkgZG9lc24ndCBwdXQgdGhlIHRpbWVzdGFtcCBmcmFtZSBpbiB0aGUgVGV4dFRyYWNrXG4gICAgICAgICAgICBpZiAoIWlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICAgICAgICAgIC8vIGFkZCBhIGJvdW5kcyB0byBhbnkgdW5ib3VuZGVkIGN1ZXNcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVJZDNDdWVFbmRzKHN0YXJ0VGltZSwgdHlwZSk7XG4gICAgICAgICAgICAgIHZhciBjdWUgPSBjcmVhdGVDdWVXaXRoRGF0YUZpZWxkcyhDdWUsIHN0YXJ0VGltZSwgZW5kVGltZSwgZnJhbWUsIHR5cGUpO1xuICAgICAgICAgICAgICBpZiAoY3VlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZDNUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnVwZGF0ZUlkM0N1ZUVuZHMgPSBmdW5jdGlvbiB1cGRhdGVJZDNDdWVFbmRzKHN0YXJ0VGltZSwgdHlwZSkge1xuICAgICAgdmFyIF90aGlzJGlkM1RyYWNrO1xuICAgICAgdmFyIGN1ZXMgPSAoX3RoaXMkaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaWQzVHJhY2suY3VlcztcbiAgICAgIGlmIChjdWVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBjdWVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIHZhciBjdWUgPSBjdWVzW2ldO1xuICAgICAgICAgIGlmIChjdWUudHlwZSA9PT0gdHlwZSAmJiBjdWUuc3RhcnRUaW1lIDwgc3RhcnRUaW1lICYmIGN1ZS5lbmRUaW1lID09PSBNQVhfQ1VFX0VORFRJTUUpIHtcbiAgICAgICAgICAgIGN1ZS5lbmRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uQnVmZmVyRmx1c2hpbmcgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCBfcmVmKSB7XG4gICAgICB2YXIgc3RhcnRPZmZzZXQgPSBfcmVmLnN0YXJ0T2Zmc2V0LFxuICAgICAgICBlbmRPZmZzZXQgPSBfcmVmLmVuZE9mZnNldCxcbiAgICAgICAgdHlwZSA9IF9yZWYudHlwZTtcbiAgICAgIHZhciBpZDNUcmFjayA9IHRoaXMuaWQzVHJhY2ssXG4gICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKCFobHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIF9obHMkY29uZmlnID0gaGxzLmNvbmZpZyxcbiAgICAgICAgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyA9IF9obHMkY29uZmlnLmVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMsXG4gICAgICAgIGVuYWJsZUlEM01ldGFkYXRhQ3VlcyA9IF9obHMkY29uZmlnLmVuYWJsZUlEM01ldGFkYXRhQ3VlcztcbiAgICAgIGlmIChpZDNUcmFjayAmJiAoZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyB8fCBlbmFibGVJRDNNZXRhZGF0YUN1ZXMpKSB7XG4gICAgICAgIHZhciBwcmVkaWNhdGU7XG4gICAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24gcHJlZGljYXRlKGN1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1ZS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyAmJiBlbmFibGVJRDNNZXRhZGF0YUN1ZXM7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24gcHJlZGljYXRlKGN1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1ZS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5lbXNnICYmIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXM7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbiBwcmVkaWNhdGUoY3VlKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VlLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzICYmIGVuYWJsZUlEM01ldGFkYXRhQ3VlcyB8fCBjdWUudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiBlbmFibGVFbXNnTWV0YWRhdGFDdWVzO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlQ3Vlc0luUmFuZ2UoaWQzVHJhY2ssIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHByZWRpY2F0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbFVwZGF0ZWQgPSBmdW5jdGlvbiBvbkxldmVsVXBkYXRlZChldmVudCwgX3JlZjIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgZGV0YWlscyA9IF9yZWYyLmRldGFpbHM7XG4gICAgICBpZiAoIXRoaXMubWVkaWEgfHwgIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICF0aGlzLmhscy5jb25maWcuZW5hYmxlRGF0ZVJhbmdlTWV0YWRhdGFDdWVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCxcbiAgICAgICAgaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrO1xuICAgICAgdmFyIGRhdGVSYW5nZXMgPSBkZXRhaWxzLmRhdGVSYW5nZXM7XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlcyk7XG4gICAgICAvLyBSZW1vdmUgY3VlcyBmcm9tIHRyYWNrIG5vdCBmb3VuZCBpbiBkZXRhaWxzLmRhdGVSYW5nZXNcbiAgICAgIGlmIChpZDNUcmFjaykge1xuICAgICAgICB2YXIgaWRzVG9SZW1vdmUgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2VDdWVzQXBwZW5kZWQpLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICByZXR1cm4gIWlkcy5pbmNsdWRlcyhpZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICB2YXIgaWQgPSBpZHNUb1JlbW92ZVtpXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdLmN1ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWQzVHJhY2sucmVtb3ZlQ3VlKGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF0uY3Vlc1trZXldKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGlkc1RvUmVtb3ZlLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEV4aXQgaWYgdGhlIHBsYXlsaXN0IGRvZXMgbm90IGhhdmUgRGF0ZSBSYW5nZXMgb3IgZG9lcyBub3QgaGF2ZSBQcm9ncmFtIERhdGUgVGltZVxuICAgICAgdmFyIGxhc3RGcmFnbWVudCA9IGRldGFpbHMuZnJhZ21lbnRzW2RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGlkcy5sZW5ndGggPT09IDAgfHwgIWlzRmluaXRlTnVtYmVyKGxhc3RGcmFnbWVudCA9PSBudWxsID8gdm9pZCAwIDogbGFzdEZyYWdtZW50LnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICAgIHRoaXMuaWQzVHJhY2sgPSB0aGlzLmNyZWF0ZVRyYWNrKHRoaXMubWVkaWEpO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGVUaW1lT2Zmc2V0ID0gbGFzdEZyYWdtZW50LnByb2dyYW1EYXRlVGltZSAvIDEwMDAgLSBsYXN0RnJhZ21lbnQuc3RhcnQ7XG4gICAgICB2YXIgQ3VlID0gZ2V0Q3VlQ2xhc3MoKTtcbiAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tfaV07XG4gICAgICAgIHZhciBkYXRlUmFuZ2UgPSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhkYXRlUmFuZ2Uuc3RhcnREYXRlLCBkYXRlVGltZU9mZnNldCk7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBEYXRlUmFuZ2VzIHRvIGRldGVybWluZSBlbmQtdGltZSAoa25vd24gRFVSQVRJT04sIEVORC1EQVRFLCBvciBFTkQtT04tTkVYVClcbiAgICAgICAgdmFyIGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9IGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF07XG4gICAgICAgIHZhciBjdWVzID0gKGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9PSBudWxsID8gdm9pZCAwIDogYXBwZW5kZWREYXRlUmFuZ2VDdWVzLmN1ZXMpIHx8IHt9O1xuICAgICAgICB2YXIgZHVyYXRpb25Lbm93biA9IChhcHBlbmRlZERhdGVSYW5nZUN1ZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVuZGVkRGF0ZVJhbmdlQ3Vlcy5kdXJhdGlvbktub3duKSB8fCBmYWxzZTtcbiAgICAgICAgdmFyIGVuZFRpbWUgPSBNQVhfQ1VFX0VORFRJTUU7XG4gICAgICAgIHZhciBlbmREYXRlID0gZGF0ZVJhbmdlLmVuZERhdGU7XG4gICAgICAgIGlmIChlbmREYXRlKSB7XG4gICAgICAgICAgZW5kVGltZSA9IGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhlbmREYXRlLCBkYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgZHVyYXRpb25Lbm93biA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0ZVJhbmdlLmVuZE9uTmV4dCAmJiAhZHVyYXRpb25Lbm93bikge1xuICAgICAgICAgIHZhciBuZXh0RGF0ZVJhbmdlV2l0aFNhbWVDbGFzcyA9IGlkcy5yZWR1Y2UoZnVuY3Rpb24gKGNhbmRpZGF0ZURhdGVSYW5nZSwgaWQpIHtcbiAgICAgICAgICAgIGlmIChpZCAhPT0gZGF0ZVJhbmdlLmlkKSB7XG4gICAgICAgICAgICAgIHZhciBvdGhlckRhdGVSYW5nZSA9IGRhdGVSYW5nZXNbaWRdO1xuICAgICAgICAgICAgICBpZiAob3RoZXJEYXRlUmFuZ2UuY2xhc3MgPT09IGRhdGVSYW5nZS5jbGFzcyAmJiBvdGhlckRhdGVSYW5nZS5zdGFydERhdGUgPiBkYXRlUmFuZ2Uuc3RhcnREYXRlICYmICghY2FuZGlkYXRlRGF0ZVJhbmdlIHx8IGRhdGVSYW5nZS5zdGFydERhdGUgPCBjYW5kaWRhdGVEYXRlUmFuZ2Uuc3RhcnREYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlckRhdGVSYW5nZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZURhdGVSYW5nZTtcbiAgICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgICBpZiAobmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3MpIHtcbiAgICAgICAgICAgIGVuZFRpbWUgPSBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMobmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3Muc3RhcnREYXRlLCBkYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgICBkdXJhdGlvbktub3duID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgVGV4dFRyYWNrIEN1ZXMgZm9yIGVhY2ggTWV0YWRhdGFHcm91cCBJdGVtIChzZWxlY3QgRGF0ZVJhbmdlIGF0dHJpYnV0ZSlcbiAgICAgICAgLy8gVGhpcyBpcyB0byBlbXVsYXRlIFNhZmFyaSBITFMgcGxheWJhY2sgaGFuZGxpbmcgb2YgRGF0ZVJhbmdlIHRhZ3NcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2UuYXR0cik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBrZXkgPSBhdHRyaWJ1dGVzW2pdO1xuICAgICAgICAgIGlmICghaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjdWUgPSBjdWVzW2tleV07XG4gICAgICAgICAgaWYgKGN1ZSkge1xuICAgICAgICAgICAgaWYgKGR1cmF0aW9uS25vd24gJiYgIWFwcGVuZGVkRGF0ZVJhbmdlQ3Vlcy5kdXJhdGlvbktub3duKSB7XG4gICAgICAgICAgICAgIGN1ZS5lbmRUaW1lID0gZW5kVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKEN1ZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRlUmFuZ2UuYXR0cltrZXldO1xuICAgICAgICAgICAgaWYgKGlzU0NURTM1QXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IGhleFRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2N1ZSA9IGNyZWF0ZUN1ZVdpdGhEYXRhRmllbGRzKEN1ZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCB7XG4gICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICB9LCBNZXRhZGF0YVNjaGVtYS5kYXRlUmFuZ2UpO1xuICAgICAgICAgICAgaWYgKF9jdWUpIHtcbiAgICAgICAgICAgICAgX2N1ZS5pZCA9IGlkO1xuICAgICAgICAgICAgICBfdGhpcy5pZDNUcmFjay5hZGRDdWUoX2N1ZSk7XG4gICAgICAgICAgICAgIGN1ZXNba2V5XSA9IF9jdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBwcm9jZXNzZWQgRGF0ZVJhbmdlcyBieSBJRCBmb3IgdXBkYXRpbmcgY3VlcyB3aXRoIG5ldyBEYXRlUmFuZ2UgdGFnIGF0dHJpYnV0ZXNcbiAgICAgICAgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXSA9IHtcbiAgICAgICAgICBjdWVzOiBjdWVzLFxuICAgICAgICAgIGRhdGVSYW5nZTogZGF0ZVJhbmdlLFxuICAgICAgICAgIGR1cmF0aW9uS25vd246IGR1cmF0aW9uS25vd25cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaWRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBfbG9vcDIoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJRDNUcmFja0NvbnRyb2xsZXI7XG4gIH0oKTtcblxuICB2YXIgTGF0ZW5jeUNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExhdGVuY3lDb250cm9sbGVyKGhscykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gbnVsbDtcbiAgICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgICAgdGhpcy5zdGFsbENvdW50ID0gMDtcbiAgICAgIHRoaXMuX2xhdGVuY3kgPSBudWxsO1xuICAgICAgdGhpcy50aW1ldXBkYXRlSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnRpbWV1cGRhdGUoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmhscyA9IGhscztcbiAgICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IExhdGVuY3lDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMub25NZWRpYURldGFjaGluZygpO1xuICAgICAgdGhpcy5sZXZlbERldGFpbHMgPSBudWxsO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5obHMgPSB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgdGhpcy5obHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgdGhpcy5obHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgICAgdGhpcy5obHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgdGhpcy5obHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICAgIHRoaXMuaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy50aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgICB0aGlzLmxldmVsRGV0YWlscyA9IG51bGw7XG4gICAgICB0aGlzLl9sYXRlbmN5ID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhbGxDb3VudCA9IDA7XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbFVwZGF0ZWQgPSBmdW5jdGlvbiBvbkxldmVsVXBkYXRlZChldmVudCwgX3JlZikge1xuICAgICAgdmFyIGRldGFpbHMgPSBfcmVmLmRldGFpbHM7XG4gICAgICB0aGlzLmxldmVsRGV0YWlscyA9IGRldGFpbHM7XG4gICAgICBpZiAoZGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgICB0aGlzLnRpbWV1cGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGV0YWlscy5saXZlICYmIHRoaXMubWVkaWEpIHtcbiAgICAgICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy50aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfdGhpcyRsZXZlbERldGFpbHM7XG4gICAgICBpZiAoZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGFsbENvdW50Kys7XG4gICAgICBpZiAoKF90aGlzJGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzKSAhPSBudWxsICYmIF90aGlzJGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdbcGxheWJhY2stcmF0ZS1jb250cm9sbGVyXTogU3RhbGwgZGV0ZWN0ZWQsIGFkanVzdGluZyB0YXJnZXQgbGF0ZW5jeScpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnRpbWV1cGRhdGUgPSBmdW5jdGlvbiB0aW1ldXBkYXRlKCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgICBpZiAoIW1lZGlhIHx8ICFsZXZlbERldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgdmFyIGxhdGVuY3kgPSB0aGlzLmNvbXB1dGVMYXRlbmN5KCk7XG4gICAgICBpZiAobGF0ZW5jeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXRlbmN5ID0gbGF0ZW5jeTtcblxuICAgICAgLy8gQWRhcHQgcGxheWJhY2tSYXRlIHRvIG1lZXQgdGFyZ2V0IGxhdGVuY3kgaW4gbG93LWxhdGVuY3kgbW9kZVxuICAgICAgdmFyIF90aGlzJGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBsb3dMYXRlbmN5TW9kZSA9IF90aGlzJGNvbmZpZy5sb3dMYXRlbmN5TW9kZSxcbiAgICAgICAgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGUgPSBfdGhpcyRjb25maWcubWF4TGl2ZVN5bmNQbGF5YmFja1JhdGU7XG4gICAgICBpZiAoIWxvd0xhdGVuY3lNb2RlIHx8IG1heExpdmVTeW5jUGxheWJhY2tSYXRlID09PSAxIHx8ICFsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdGFyZ2V0TGF0ZW5jeSA9IHRoaXMudGFyZ2V0TGF0ZW5jeTtcbiAgICAgIGlmICh0YXJnZXRMYXRlbmN5ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkaXN0YW5jZUZyb21UYXJnZXQgPSBsYXRlbmN5IC0gdGFyZ2V0TGF0ZW5jeTtcbiAgICAgIC8vIE9ubHkgYWRqdXN0IHBsYXliYWNrUmF0ZSB3aGVuIHdpdGhpbiBvbmUgdGFyZ2V0IGR1cmF0aW9uIG9mIHRhcmdldExhdGVuY3lcbiAgICAgIC8vIGFuZCBtb3JlIHRoYW4gb25lIHNlY29uZCBmcm9tIHVuZGVyLWJ1ZmZlcmluZy5cbiAgICAgIC8vIFBsYXliYWNrIGZ1cnRoZXIgdGhhbiBvbmUgdGFyZ2V0IGR1cmF0aW9uIGZyb20gdGFyZ2V0IGNhbiBiZSBjb25zaWRlcmVkIERWUiBwbGF5YmFjay5cbiAgICAgIHZhciBsaXZlTWluTGF0ZW5jeUR1cmF0aW9uID0gTWF0aC5taW4odGhpcy5tYXhMYXRlbmN5LCB0YXJnZXRMYXRlbmN5ICsgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgIHZhciBpbkxpdmVSYW5nZSA9IGRpc3RhbmNlRnJvbVRhcmdldCA8IGxpdmVNaW5MYXRlbmN5RHVyYXRpb247XG4gICAgICBpZiAoaW5MaXZlUmFuZ2UgJiYgZGlzdGFuY2VGcm9tVGFyZ2V0ID4gMC4wNSAmJiB0aGlzLmZvcndhcmRCdWZmZXJMZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1pbigyLCBNYXRoLm1heCgxLjAsIG1heExpdmVTeW5jUGxheWJhY2tSYXRlKSk7XG4gICAgICAgIHZhciByYXRlID0gTWF0aC5yb3VuZCgyIC8gKDEgKyBNYXRoLmV4cCgtMC43NSAqIGRpc3RhbmNlRnJvbVRhcmdldCAtIHRoaXMuZWRnZVN0YWxsZWQpKSAqIDIwKSAvIDIwO1xuICAgICAgICBtZWRpYS5wbGF5YmFja1JhdGUgPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KDEsIHJhdGUpKTtcbiAgICAgIH0gZWxzZSBpZiAobWVkaWEucGxheWJhY2tSYXRlICE9PSAxICYmIG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMCkge1xuICAgICAgICBtZWRpYS5wbGF5YmFja1JhdGUgPSAxO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmVzdGltYXRlTGl2ZUVkZ2UgPSBmdW5jdGlvbiBlc3RpbWF0ZUxpdmVFZGdlKCkge1xuICAgICAgdmFyIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZXZlbERldGFpbHMuZWRnZSArIGxldmVsRGV0YWlscy5hZ2U7XG4gICAgfTtcbiAgICBfcHJvdG8uY29tcHV0ZUxhdGVuY3kgPSBmdW5jdGlvbiBjb21wdXRlTGF0ZW5jeSgpIHtcbiAgICAgIHZhciBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuICAgICAgaWYgKGxpdmVFZGdlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpdmVFZGdlIC0gdGhpcy5jdXJyZW50VGltZTtcbiAgICB9O1xuICAgIF9jcmVhdGVDbGFzcyhMYXRlbmN5Q29udHJvbGxlciwgW3tcbiAgICAgIGtleTogXCJsYXRlbmN5XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVuY3kgfHwgMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWF4TGF0ZW5jeVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICAgICAgaWYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxldmVsRGV0YWlscyA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24gOiAwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0YXJnZXRMYXRlbmN5XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgICAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvbGRCYWNrID0gbGV2ZWxEZXRhaWxzLmhvbGRCYWNrLFxuICAgICAgICAgIHBhcnRIb2xkQmFjayA9IGxldmVsRGV0YWlscy5wYXJ0SG9sZEJhY2ssXG4gICAgICAgICAgdGFyZ2V0ZHVyYXRpb24gPSBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICAgIHZhciBfdGhpcyRjb25maWcyID0gdGhpcy5jb25maWcsXG4gICAgICAgICAgbGl2ZVN5bmNEdXJhdGlvbiA9IF90aGlzJGNvbmZpZzIubGl2ZVN5bmNEdXJhdGlvbixcbiAgICAgICAgICBsaXZlU3luY0R1cmF0aW9uQ291bnQgPSBfdGhpcyRjb25maWcyLmxpdmVTeW5jRHVyYXRpb25Db3VudCxcbiAgICAgICAgICBsb3dMYXRlbmN5TW9kZSA9IF90aGlzJGNvbmZpZzIubG93TGF0ZW5jeU1vZGU7XG4gICAgICAgIHZhciB1c2VyQ29uZmlnID0gdGhpcy5obHMudXNlckNvbmZpZztcbiAgICAgICAgdmFyIHRhcmdldExhdGVuY3kgPSBsb3dMYXRlbmN5TW9kZSA/IHBhcnRIb2xkQmFjayB8fCBob2xkQmFjayA6IGhvbGRCYWNrO1xuICAgICAgICBpZiAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50IHx8IHRhcmdldExhdGVuY3kgPT09IDApIHtcbiAgICAgICAgICB0YXJnZXRMYXRlbmN5ID0gbGl2ZVN5bmNEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gbGl2ZVN5bmNEdXJhdGlvbiA6IGxpdmVTeW5jRHVyYXRpb25Db3VudCAqIHRhcmdldGR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhMaXZlU3luY09uU3RhbGxJbmNyZWFzZSA9IHRhcmdldGR1cmF0aW9uO1xuICAgICAgICB2YXIgbGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UgPSAxLjA7XG4gICAgICAgIHJldHVybiB0YXJnZXRMYXRlbmN5ICsgTWF0aC5taW4odGhpcy5zdGFsbENvdW50ICogbGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UsIG1heExpdmVTeW5jT25TdGFsbEluY3JlYXNlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibGl2ZVN5bmNQb3NpdGlvblwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuICAgICAgICB2YXIgdGFyZ2V0TGF0ZW5jeSA9IHRoaXMudGFyZ2V0TGF0ZW5jeTtcbiAgICAgICAgdmFyIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgICAgICBpZiAobGl2ZUVkZ2UgPT09IG51bGwgfHwgdGFyZ2V0TGF0ZW5jeSA9PT0gbnVsbCB8fCBsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWRnZSA9IGxldmVsRGV0YWlscy5lZGdlO1xuICAgICAgICB2YXIgc3luY1Bvc2l0aW9uID0gbGl2ZUVkZ2UgLSB0YXJnZXRMYXRlbmN5IC0gdGhpcy5lZGdlU3RhbGxlZDtcbiAgICAgICAgdmFyIG1pbiA9IGVkZ2UgLSBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICAgICAgdmFyIG1heCA9IGVkZ2UgLSAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQgfHwgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgc3luY1Bvc2l0aW9uKSwgbWF4KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJpZnRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGV2ZWxEZXRhaWxzLmRyaWZ0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlZGdlU3RhbGxlZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICAgICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhMZXZlbFVwZGF0ZUFnZSA9ICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBsZXZlbERldGFpbHMucGFydFRhcmdldCB8fCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pICogMztcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGxldmVsRGV0YWlscy5hZ2UgLSBtYXhMZXZlbFVwZGF0ZUFnZSwgMCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZvcndhcmRCdWZmZXJMZW5ndGhcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgICAgICBpZiAoIW1lZGlhIHx8ICFsZXZlbERldGFpbHMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVyZWRSYW5nZXMgPSBtZWRpYS5idWZmZXJlZC5sZW5ndGg7XG4gICAgICAgIHJldHVybiAoYnVmZmVyZWRSYW5nZXMgPyBtZWRpYS5idWZmZXJlZC5lbmQoYnVmZmVyZWRSYW5nZXMgLSAxKSA6IGxldmVsRGV0YWlscy5lZGdlKSAtIHRoaXMuY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBMYXRlbmN5Q29udHJvbGxlcjtcbiAgfSgpO1xuXG4gIHZhciBIZGNwTGV2ZWxzID0gWydOT05FJywgJ1RZUEUtMCcsICdUWVBFLTEnLCBudWxsXTtcbiAgZnVuY3Rpb24gaXNIZGNwTGV2ZWwodmFsdWUpIHtcbiAgICByZXR1cm4gSGRjcExldmVscy5pbmRleE9mKHZhbHVlKSA+IC0xO1xuICB9XG4gIHZhciBWaWRlb1JhbmdlVmFsdWVzID0gWydTRFInLCAnUFEnLCAnSExHJ107XG4gIGZ1bmN0aW9uIGlzVmlkZW9SYW5nZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmIFZpZGVvUmFuZ2VWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgfVxuICB2YXIgSGxzU2tpcCA9IHtcbiAgICBObzogXCJcIixcbiAgICBZZXM6IFwiWUVTXCIsXG4gICAgdjI6IFwidjJcIlxuICB9O1xuICBmdW5jdGlvbiBnZXRTa2lwVmFsdWUoZGV0YWlscykge1xuICAgIHZhciBjYW5Ta2lwVW50aWwgPSBkZXRhaWxzLmNhblNraXBVbnRpbCxcbiAgICAgIGNhblNraXBEYXRlUmFuZ2VzID0gZGV0YWlscy5jYW5Ta2lwRGF0ZVJhbmdlcyxcbiAgICAgIGFnZSA9IGRldGFpbHMuYWdlO1xuICAgIC8vIEEgQ2xpZW50IFNIT1VMRCBOT1QgcmVxdWVzdCBhIFBsYXlsaXN0IERlbHRhIFVwZGF0ZSB1bmxlc3MgaXQgYWxyZWFkeVxuICAgIC8vIGhhcyBhIHZlcnNpb24gb2YgdGhlIFBsYXlsaXN0IHRoYXQgaXMgbm8gb2xkZXIgdGhhbiBvbmUtaGFsZiBvZiB0aGUgU2tpcCBCb3VuZGFyeS5cbiAgICAvLyBAc2VlOiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LXBhbnRvcy1obHMtcmZjODIxNmJpcyNzZWN0aW9uLTYuMy43XG4gICAgdmFyIHBsYXlsaXN0UmVjZW50RW5vdWdoID0gYWdlIDwgY2FuU2tpcFVudGlsIC8gMjtcbiAgICBpZiAoY2FuU2tpcFVudGlsICYmIHBsYXlsaXN0UmVjZW50RW5vdWdoKSB7XG4gICAgICBpZiAoY2FuU2tpcERhdGVSYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIEhsc1NraXAudjI7XG4gICAgICB9XG4gICAgICByZXR1cm4gSGxzU2tpcC5ZZXM7XG4gICAgfVxuICAgIHJldHVybiBIbHNTa2lwLk5vO1xuICB9XG4gIHZhciBIbHNVcmxQYXJhbWV0ZXJzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIbHNVcmxQYXJhbWV0ZXJzKG1zbiwgcGFydCwgc2tpcCkge1xuICAgICAgdGhpcy5tc24gPSB2b2lkIDA7XG4gICAgICB0aGlzLnBhcnQgPSB2b2lkIDA7XG4gICAgICB0aGlzLnNraXAgPSB2b2lkIDA7XG4gICAgICB0aGlzLm1zbiA9IG1zbjtcbiAgICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gSGxzVXJsUGFyYW1ldGVycy5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZERpcmVjdGl2ZXMgPSBmdW5jdGlvbiBhZGREaXJlY3RpdmVzKHVyaSkge1xuICAgICAgdmFyIHVybCA9IG5ldyBzZWxmLlVSTCh1cmkpO1xuICAgICAgaWYgKHRoaXMubXNuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfbXNuJywgdGhpcy5tc24udG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfcGFydCcsIHRoaXMucGFydC50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNraXApIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfc2tpcCcsIHRoaXMuc2tpcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJsLmhyZWY7XG4gICAgfTtcbiAgICByZXR1cm4gSGxzVXJsUGFyYW1ldGVycztcbiAgfSgpO1xuICB2YXIgTGV2ZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExldmVsKGRhdGEpIHtcbiAgICAgIHRoaXMuX2F0dHJzID0gdm9pZCAwO1xuICAgICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgICAgdGhpcy5iaXRyYXRlID0gdm9pZCAwO1xuICAgICAgdGhpcy5jb2RlY1NldCA9IHZvaWQgMDtcbiAgICAgIHRoaXMudXJsID0gdm9pZCAwO1xuICAgICAgdGhpcy5mcmFtZVJhdGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgICAgdGhpcy5kZXRhaWxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5mcmFnbWVudEVycm9yID0gMDtcbiAgICAgIHRoaXMubG9hZEVycm9yID0gMDtcbiAgICAgIHRoaXMubG9hZGVkID0gdm9pZCAwO1xuICAgICAgdGhpcy5yZWFsQml0cmF0ZSA9IDA7XG4gICAgICB0aGlzLnN1cHBvcnRlZFByb21pc2UgPSB2b2lkIDA7XG4gICAgICB0aGlzLnN1cHBvcnRlZFJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2F2Z0JpdHJhdGUgPSAwO1xuICAgICAgdGhpcy5fYXVkaW9Hcm91cHMgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9zdWJ0aXRsZUdyb3VwcyA9IHZvaWQgMDtcbiAgICAgIC8vIERlcHJlY2F0ZWQgKHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgICAgIHRoaXMuX3VybElkID0gMDtcbiAgICAgIHRoaXMudXJsID0gW2RhdGEudXJsXTtcbiAgICAgIHRoaXMuX2F0dHJzID0gW2RhdGEuYXR0cnNdO1xuICAgICAgdGhpcy5iaXRyYXRlID0gZGF0YS5iaXRyYXRlO1xuICAgICAgaWYgKGRhdGEuZGV0YWlscykge1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICB9XG4gICAgICB0aGlzLmlkID0gZGF0YS5pZCB8fCAwO1xuICAgICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgdGhpcy53aWR0aCA9IGRhdGEud2lkdGggfHwgMDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgfHwgMDtcbiAgICAgIHRoaXMuZnJhbWVSYXRlID0gZGF0YS5hdHRycy5vcHRpb25hbEZsb2F0KCdGUkFNRS1SQVRFJywgMCk7XG4gICAgICB0aGlzLl9hdmdCaXRyYXRlID0gZGF0YS5hdHRycy5kZWNpbWFsSW50ZWdlcignQVZFUkFHRS1CQU5EV0lEVEgnKTtcbiAgICAgIHRoaXMuYXVkaW9Db2RlYyA9IGRhdGEuYXVkaW9Db2RlYztcbiAgICAgIHRoaXMudmlkZW9Db2RlYyA9IGRhdGEudmlkZW9Db2RlYztcbiAgICAgIHRoaXMuY29kZWNTZXQgPSBbZGF0YS52aWRlb0NvZGVjLCBkYXRhLmF1ZGlvQ29kZWNdLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gISFjO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzLnN1YnN0cmluZygwLCA0KTtcbiAgICAgIH0pLmpvaW4oJywnKTtcbiAgICAgIHRoaXMuYWRkR3JvdXBJZCgnYXVkaW8nLCBkYXRhLmF0dHJzLkFVRElPKTtcbiAgICAgIHRoaXMuYWRkR3JvdXBJZCgndGV4dCcsIGRhdGEuYXR0cnMuU1VCVElUTEVTKTtcbiAgICB9XG4gICAgdmFyIF9wcm90bzIgPSBMZXZlbC5wcm90b3R5cGU7XG4gICAgX3Byb3RvMi5oYXNBdWRpb0dyb3VwID0gZnVuY3Rpb24gaGFzQXVkaW9Hcm91cChncm91cElkKSB7XG4gICAgICByZXR1cm4gaGFzR3JvdXAodGhpcy5fYXVkaW9Hcm91cHMsIGdyb3VwSWQpO1xuICAgIH07XG4gICAgX3Byb3RvMi5oYXNTdWJ0aXRsZUdyb3VwID0gZnVuY3Rpb24gaGFzU3VidGl0bGVHcm91cChncm91cElkKSB7XG4gICAgICByZXR1cm4gaGFzR3JvdXAodGhpcy5fc3VidGl0bGVHcm91cHMsIGdyb3VwSWQpO1xuICAgIH07XG4gICAgX3Byb3RvMi5hZGRHcm91cElkID0gZnVuY3Rpb24gYWRkR3JvdXBJZCh0eXBlLCBncm91cElkKSB7XG4gICAgICBpZiAoIWdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgdmFyIGF1ZGlvR3JvdXBzID0gdGhpcy5fYXVkaW9Hcm91cHM7XG4gICAgICAgIGlmICghYXVkaW9Hcm91cHMpIHtcbiAgICAgICAgICBhdWRpb0dyb3VwcyA9IHRoaXMuX2F1ZGlvR3JvdXBzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1ZGlvR3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkgPT09IC0xKSB7XG4gICAgICAgICAgYXVkaW9Hcm91cHMucHVzaChncm91cElkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgdmFyIHN1YnRpdGxlR3JvdXBzID0gdGhpcy5fc3VidGl0bGVHcm91cHM7XG4gICAgICAgIGlmICghc3VidGl0bGVHcm91cHMpIHtcbiAgICAgICAgICBzdWJ0aXRsZUdyb3VwcyA9IHRoaXMuX3N1YnRpdGxlR3JvdXBzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnRpdGxlR3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkgPT09IC0xKSB7XG4gICAgICAgICAgc3VidGl0bGVHcm91cHMucHVzaChncm91cElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlcHJlY2F0ZWQgbWV0aG9kcyAocmV0YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxuICAgIDtcbiAgICBfcHJvdG8yLmFkZEZhbGxiYWNrID0gZnVuY3Rpb24gYWRkRmFsbGJhY2soKSB7fTtcbiAgICBfY3JlYXRlQ2xhc3MoTGV2ZWwsIFt7XG4gICAgICBrZXk6IFwibWF4Qml0cmF0ZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnJlYWxCaXRyYXRlLCB0aGlzLmJpdHJhdGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhdmVyYWdlQml0cmF0ZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdmdCaXRyYXRlIHx8IHRoaXMucmVhbEJpdHJhdGUgfHwgdGhpcy5iaXRyYXRlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhdHRyc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdHRyc1swXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY29kZWNzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuQ09ERUNTIHx8ICcnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwYXRod2F5SWRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyc1snUEFUSFdBWS1JRCddIHx8ICcuJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidmlkZW9SYW5nZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJzWydWSURFTy1SQU5HRSddIHx8ICdTRFInO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzY29yZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJzLm9wdGlvbmFsRmxvYXQoJ1NDT1JFJywgMCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInVyaVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybFswXSB8fCAnJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXVkaW9Hcm91cHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXVkaW9Hcm91cHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInN1YnRpdGxlR3JvdXBzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnRpdGxlR3JvdXBzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1cmxJZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7fVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhdWRpb0dyb3VwSWRzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9Hcm91cHMgPyBbdGhpcy5hdWRpb0dyb3VwSWRdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0ZXh0R3JvdXBJZHNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJ0aXRsZUdyb3VwcyA/IFt0aGlzLnRleHRHcm91cElkXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXVkaW9Hcm91cElkXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIF90aGlzJGF1ZGlvR3JvdXBzO1xuICAgICAgICByZXR1cm4gKF90aGlzJGF1ZGlvR3JvdXBzID0gdGhpcy5hdWRpb0dyb3VwcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGF1ZGlvR3JvdXBzWzBdO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0ZXh0R3JvdXBJZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBfdGhpcyRzdWJ0aXRsZUdyb3VwcztcbiAgICAgICAgcmV0dXJuIChfdGhpcyRzdWJ0aXRsZUdyb3VwcyA9IHRoaXMuc3VidGl0bGVHcm91cHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRzdWJ0aXRsZUdyb3Vwc1swXTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIExldmVsO1xuICB9KCk7XG4gIGZ1bmN0aW9uIGhhc0dyb3VwKGdyb3VwcywgZ3JvdXBJZCkge1xuICAgIGlmICghZ3JvdXBJZCB8fCAhZ3JvdXBzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBncm91cHMuaW5kZXhPZihncm91cElkKSAhPT0gLTE7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcm9tVG9QVFMoZnJhZ0Zyb20sIGZyYWdUbykge1xuICAgIHZhciBmcmFnVG9QVFMgPSBmcmFnVG8uc3RhcnRQVFM7XG4gICAgLy8gaWYgd2Uga25vdyBzdGFydFBUU1t0b0lkeF1cbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoZnJhZ1RvUFRTKSkge1xuICAgICAgLy8gdXBkYXRlIGZyYWdtZW50IGR1cmF0aW9uLlxuICAgICAgLy8gaXQgaGVscHMgdG8gZml4IGRyaWZ0cyBiZXR3ZWVuIHBsYXlsaXN0IHJlcG9ydGVkIGR1cmF0aW9uIGFuZCBmcmFnbWVudCByZWFsIGR1cmF0aW9uXG4gICAgICB2YXIgZHVyYXRpb24gPSAwO1xuICAgICAgdmFyIGZyYWc7XG4gICAgICBpZiAoZnJhZ1RvLnNuID4gZnJhZ0Zyb20uc24pIHtcbiAgICAgICAgZHVyYXRpb24gPSBmcmFnVG9QVFMgLSBmcmFnRnJvbS5zdGFydDtcbiAgICAgICAgZnJhZyA9IGZyYWdGcm9tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHVyYXRpb24gPSBmcmFnRnJvbS5zdGFydCAtIGZyYWdUb1BUUztcbiAgICAgICAgZnJhZyA9IGZyYWdUbztcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnLmR1cmF0aW9uICE9PSBkdXJhdGlvbikge1xuICAgICAgICBmcmFnLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICB9XG4gICAgICAvLyB3ZSBkb250IGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gICAgfSBlbHNlIGlmIChmcmFnVG8uc24gPiBmcmFnRnJvbS5zbikge1xuICAgICAgdmFyIGNvbnRpZ3VvdXMgPSBmcmFnRnJvbS5jYyA9PT0gZnJhZ1RvLmNjO1xuICAgICAgLy8gVE9ETzogV2l0aCBwYXJ0LWxvYWRpbmcgZW5kL2R1cmF0aW9ucyB3ZSBuZWVkIHRvIGNvbmZpcm0gdGhlIHdob2xlIGZyYWdtZW50IGlzIGxvYWRlZCBiZWZvcmUgdXNpbmcgKG9yIHNldHRpbmcpIG1pbkVuZFBUU1xuICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgZnJhZ0Zyb20ubWluRW5kUFRTKSB7XG4gICAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0ICsgKGZyYWdGcm9tLm1pbkVuZFBUUyAtIGZyYWdGcm9tLnN0YXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0ICsgZnJhZ0Zyb20uZHVyYXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdUby5zdGFydCA9IE1hdGgubWF4KGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvLmR1cmF0aW9uLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ1BUU0RUUyhkZXRhaWxzLCBmcmFnLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTKSB7XG4gICAgdmFyIHBhcnNlZE1lZGlhRHVyYXRpb24gPSBlbmRQVFMgLSBzdGFydFBUUztcbiAgICBpZiAocGFyc2VkTWVkaWFEdXJhdGlvbiA8PSAwKSB7XG4gICAgICBsb2dnZXIud2FybignRnJhZ21lbnQgc2hvdWxkIGhhdmUgYSBwb3NpdGl2ZSBkdXJhdGlvbicsIGZyYWcpO1xuICAgICAgZW5kUFRTID0gc3RhcnRQVFMgKyBmcmFnLmR1cmF0aW9uO1xuICAgICAgZW5kRFRTID0gc3RhcnREVFMgKyBmcmFnLmR1cmF0aW9uO1xuICAgIH1cbiAgICB2YXIgbWF4U3RhcnRQVFMgPSBzdGFydFBUUztcbiAgICB2YXIgbWluRW5kUFRTID0gZW5kUFRTO1xuICAgIHZhciBmcmFnU3RhcnRQdHMgPSBmcmFnLnN0YXJ0UFRTO1xuICAgIHZhciBmcmFnRW5kUHRzID0gZnJhZy5lbmRQVFM7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKGZyYWdTdGFydFB0cykpIHtcbiAgICAgIC8vIGRlbHRhIFBUUyBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlb1xuICAgICAgdmFyIGRlbHRhUFRTID0gTWF0aC5hYnMoZnJhZ1N0YXJ0UHRzIC0gc3RhcnRQVFMpO1xuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihmcmFnLmRlbHRhUFRTKSkge1xuICAgICAgICBmcmFnLmRlbHRhUFRTID0gZGVsdGFQVFM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnLmRlbHRhUFRTID0gTWF0aC5tYXgoZGVsdGFQVFMsIGZyYWcuZGVsdGFQVFMpO1xuICAgICAgfVxuICAgICAgbWF4U3RhcnRQVFMgPSBNYXRoLm1heChzdGFydFBUUywgZnJhZ1N0YXJ0UHRzKTtcbiAgICAgIHN0YXJ0UFRTID0gTWF0aC5taW4oc3RhcnRQVFMsIGZyYWdTdGFydFB0cyk7XG4gICAgICBzdGFydERUUyA9IE1hdGgubWluKHN0YXJ0RFRTLCBmcmFnLnN0YXJ0RFRTKTtcbiAgICAgIG1pbkVuZFBUUyA9IE1hdGgubWluKGVuZFBUUywgZnJhZ0VuZFB0cyk7XG4gICAgICBlbmRQVFMgPSBNYXRoLm1heChlbmRQVFMsIGZyYWdFbmRQdHMpO1xuICAgICAgZW5kRFRTID0gTWF0aC5tYXgoZW5kRFRTLCBmcmFnLmVuZERUUyk7XG4gICAgfVxuICAgIHZhciBkcmlmdCA9IHN0YXJ0UFRTIC0gZnJhZy5zdGFydDtcbiAgICBpZiAoZnJhZy5zdGFydCAhPT0gMCkge1xuICAgICAgZnJhZy5zdGFydCA9IHN0YXJ0UFRTO1xuICAgIH1cbiAgICBmcmFnLmR1cmF0aW9uID0gZW5kUFRTIC0gZnJhZy5zdGFydDtcbiAgICBmcmFnLnN0YXJ0UFRTID0gc3RhcnRQVFM7XG4gICAgZnJhZy5tYXhTdGFydFBUUyA9IG1heFN0YXJ0UFRTO1xuICAgIGZyYWcuc3RhcnREVFMgPSBzdGFydERUUztcbiAgICBmcmFnLmVuZFBUUyA9IGVuZFBUUztcbiAgICBmcmFnLm1pbkVuZFBUUyA9IG1pbkVuZFBUUztcbiAgICBmcmFnLmVuZERUUyA9IGVuZERUUztcbiAgICB2YXIgc24gPSBmcmFnLnNuOyAvLyAnaW5pdFNlZ21lbnQnXG4gICAgLy8gZXhpdCBpZiBzbiBvdXQgb2YgcmFuZ2VcbiAgICBpZiAoIWRldGFpbHMgfHwgc24gPCBkZXRhaWxzLnN0YXJ0U04gfHwgc24gPiBkZXRhaWxzLmVuZFNOKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIGk7XG4gICAgdmFyIGZyYWdJZHggPSBzbiAtIGRldGFpbHMuc3RhcnRTTjtcbiAgICB2YXIgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgLy8gdXBkYXRlIGZyYWcgcmVmZXJlbmNlIGluIGZyYWdtZW50cyBhcnJheVxuICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGZyYWdtZW50cyBhcnJheSBtaWdodCBub3QgY29udGFpbiB0aGlzIGZyYWcgb2JqZWN0LlxuICAgIC8vIHRoaXMgd2lsbCBoYXBwZW4gaWYgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIGJldHdlZW4gZnJhZyBsb2FkaW5nIGFuZCBjYWxsIHRvIHVwZGF0ZUZyYWdQVFNEVFMoKVxuICAgIC8vIGlmIHdlIGRvbid0IHVwZGF0ZSBmcmFnLCB3ZSB3b24ndCBiZSBhYmxlIHRvIHByb3BhZ2F0ZSBQVFMgaW5mbyBvbiB0aGUgcGxheWxpc3RcbiAgICAvLyByZXN1bHRpbmcgaW4gaW52YWxpZCBzbGlkaW5nIGNvbXB1dGF0aW9uXG4gICAgZnJhZ21lbnRzW2ZyYWdJZHhdID0gZnJhZztcbiAgICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXG4gICAgZm9yIChpID0gZnJhZ0lkeDsgaSA+IDA7IGktLSkge1xuICAgICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tpXSwgZnJhZ21lbnRzW2kgLSAxXSk7XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGZyYWdtZW50IFBUUy9kdXJhdGlvbiBmcm9tIHNlcW51bSB0byBsYXN0IGZyYWdcbiAgICBmb3IgKGkgPSBmcmFnSWR4OyBpIDwgZnJhZ21lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tpXSwgZnJhZ21lbnRzW2kgKyAxXSk7XG4gICAgfVxuICAgIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0sIGRldGFpbHMuZnJhZ21lbnRIaW50KTtcbiAgICB9XG4gICAgZGV0YWlscy5QVFNLbm93biA9IGRldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBkcmlmdDtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZURldGFpbHMob2xkRGV0YWlscywgbmV3RGV0YWlscykge1xuICAgIC8vIFRyYWNrIHRoZSBsYXN0IGluaXRTZWdtZW50IHByb2Nlc3NlZC4gSW5pdGlhbGl6ZSBpdCB0byB0aGUgbGFzdCBvbmUgb24gdGhlIHRpbWVsaW5lLlxuICAgIHZhciBjdXJyZW50SW5pdFNlZ21lbnQgPSBudWxsO1xuICAgIHZhciBvbGRGcmFnbWVudHMgPSBvbGREZXRhaWxzLmZyYWdtZW50cztcbiAgICBmb3IgKHZhciBpID0gb2xkRnJhZ21lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgb2xkSW5pdCA9IG9sZEZyYWdtZW50c1tpXS5pbml0U2VnbWVudDtcbiAgICAgIGlmIChvbGRJbml0KSB7XG4gICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IG9sZEluaXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkRGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAgIC8vIHByZXZlbnQgUFRTIGFuZCBkdXJhdGlvbiBmcm9tIGJlaW5nIGFkanVzdGVkIG9uIHRoZSBuZXh0IGhpbnRcbiAgICAgIGRlbGV0ZSBvbGREZXRhaWxzLmZyYWdtZW50SGludC5lbmRQVFM7XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIG9sZC9uZXcgcGxheWxpc3RzIGhhdmUgZnJhZ21lbnRzIGluIGNvbW1vblxuICAgIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTICwgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcbiAgICB2YXIgY2NPZmZzZXQgPSAwO1xuICAgIHZhciBQVFNGcmFnO1xuICAgIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKG9sZERldGFpbHMsIG5ld0RldGFpbHMsIGZ1bmN0aW9uIChvbGRGcmFnLCBuZXdGcmFnKSB7XG4gICAgICBpZiAob2xkRnJhZy5yZWx1cmwpIHtcbiAgICAgICAgLy8gRG8gbm90IGNvbXBhcmUgQ0MgaWYgdGhlIG9sZCBmcmFnbWVudCBoYXMgbm8gdXJsLiBUaGlzIGlzIGEgbGV2ZWwuZnJhZ21lbnRIaW50IHVzZWQgYnkgTEwtSExTIHBhcnRzLlxuICAgICAgICAvLyBJdCBtYXliZSBiZSBvZmYgYnkgMSBpZiBpdCB3YXMgY3JlYXRlZCBiZWZvcmUgYW55IHBhcnRzIG9yIGRpc2NvbnRpbnVpdHkgdGFncyB3ZXJlIGFwcGVuZGVkIHRvIHRoZSBlbmRcbiAgICAgICAgLy8gb2YgdGhlIHBsYXlsaXN0LlxuICAgICAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuICAgICAgfVxuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKG9sZEZyYWcuc3RhcnRQVFMpICYmIGlzRmluaXRlTnVtYmVyKG9sZEZyYWcuZW5kUFRTKSkge1xuICAgICAgICBuZXdGcmFnLnN0YXJ0ID0gbmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFM7XG4gICAgICAgIG5ld0ZyYWcuc3RhcnREVFMgPSBvbGRGcmFnLnN0YXJ0RFRTO1xuICAgICAgICBuZXdGcmFnLm1heFN0YXJ0UFRTID0gb2xkRnJhZy5tYXhTdGFydFBUUztcbiAgICAgICAgbmV3RnJhZy5lbmRQVFMgPSBvbGRGcmFnLmVuZFBUUztcbiAgICAgICAgbmV3RnJhZy5lbmREVFMgPSBvbGRGcmFnLmVuZERUUztcbiAgICAgICAgbmV3RnJhZy5taW5FbmRQVFMgPSBvbGRGcmFnLm1pbkVuZFBUUztcbiAgICAgICAgbmV3RnJhZy5kdXJhdGlvbiA9IG9sZEZyYWcuZW5kUFRTIC0gb2xkRnJhZy5zdGFydFBUUztcbiAgICAgICAgaWYgKG5ld0ZyYWcuZHVyYXRpb24pIHtcbiAgICAgICAgICBQVFNGcmFnID0gbmV3RnJhZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBUUyBpcyBrbm93biB3aGVuIGFueSBzZWdtZW50IGhhcyBzdGFydFBUUyBhbmQgZW5kUFRTXG4gICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBuZXdEZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5ld0ZyYWcuZWxlbWVudGFyeVN0cmVhbXMgPSBvbGRGcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgbmV3RnJhZy5sb2FkZXIgPSBvbGRGcmFnLmxvYWRlcjtcbiAgICAgIG5ld0ZyYWcuc3RhdHMgPSBvbGRGcmFnLnN0YXRzO1xuICAgICAgaWYgKG9sZEZyYWcuaW5pdFNlZ21lbnQpIHtcbiAgICAgICAgbmV3RnJhZy5pbml0U2VnbWVudCA9IG9sZEZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IG9sZEZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGN1cnJlbnRJbml0U2VnbWVudCkge1xuICAgICAgdmFyIGZyYWdtZW50c1RvQ2hlY2sgPSBuZXdEZXRhaWxzLmZyYWdtZW50SGludCA/IG5ld0RldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChuZXdEZXRhaWxzLmZyYWdtZW50SGludCkgOiBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgICAgIGZyYWdtZW50c1RvQ2hlY2suZm9yRWFjaChmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICB2YXIgX2N1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgICAgaWYgKGZyYWcgJiYgKCFmcmFnLmluaXRTZWdtZW50IHx8IGZyYWcuaW5pdFNlZ21lbnQucmVsdXJsID09PSAoKF9jdXJyZW50SW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfY3VycmVudEluaXRTZWdtZW50LnJlbHVybCkpKSB7XG4gICAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgICAgbmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IG5ld0RldGFpbHMuZnJhZ21lbnRzLnNvbWUoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICAgICAgcmV0dXJuICFmcmFnO1xuICAgICAgfSk7XG4gICAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCkge1xuICAgICAgICBsb2dnZXIud2FybignW2xldmVsLWhlbHBlcl0gUHJldmlvdXMgcGxheWxpc3QgbWlzc2luZyBzZWdtZW50cyBza2lwcGVkIGluIGRlbHRhIHBsYXlsaXN0Jyk7XG4gICAgICAgIGZvciAodmFyIF9pID0gbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHM7IF9pLS07KSB7XG4gICAgICAgICAgbmV3RGV0YWlscy5mcmFnbWVudHMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdEZXRhaWxzLnN0YXJ0U04gPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zbjtcbiAgICAgICAgbmV3RGV0YWlscy5zdGFydENDID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uY2M7XG4gICAgICB9IGVsc2UgaWYgKG5ld0RldGFpbHMuY2FuU2tpcERhdGVSYW5nZXMpIHtcbiAgICAgICAgbmV3RGV0YWlscy5kYXRlUmFuZ2VzID0gbWVyZ2VEYXRlUmFuZ2VzKG9sZERldGFpbHMuZGF0ZVJhbmdlcywgbmV3RGV0YWlscy5kYXRlUmFuZ2VzLCBuZXdEZXRhaWxzLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3RnJhZ21lbnRzID0gbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gICAgaWYgKGNjT2Zmc2V0KSB7XG4gICAgICBsb2dnZXIud2FybignZGlzY29udGludWl0eSBzbGlkaW5nIGZyb20gcGxheWxpc3QsIHRha2UgZHJpZnQgaW50byBhY2NvdW50Jyk7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBuZXdGcmFnbWVudHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBuZXdGcmFnbWVudHNbX2kyXS5jYyArPSBjY09mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgICBuZXdEZXRhaWxzLnN0YXJ0Q0MgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5jYztcbiAgICB9XG5cbiAgICAvLyBNZXJnZSBwYXJ0c1xuICAgIG1hcFBhcnRJbnRlcnNlY3Rpb24ob2xkRGV0YWlscy5wYXJ0TGlzdCwgbmV3RGV0YWlscy5wYXJ0TGlzdCwgZnVuY3Rpb24gKG9sZFBhcnQsIG5ld1BhcnQpIHtcbiAgICAgIG5ld1BhcnQuZWxlbWVudGFyeVN0cmVhbXMgPSBvbGRQYXJ0LmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgbmV3UGFydC5zdGF0cyA9IG9sZFBhcnQuc3RhdHM7XG4gICAgfSk7XG5cbiAgICAvLyBpZiBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgY29udGFpbnMgUFRTIGluZm8sIHJlY29tcHV0ZSBQVFMgaW5mb3JtYXRpb24gZm9yIGFsbCBmcmFnbWVudHNcbiAgICBpZiAoUFRTRnJhZykge1xuICAgICAgdXBkYXRlRnJhZ1BUU0RUUyhuZXdEZXRhaWxzLCBQVFNGcmFnLCBQVFNGcmFnLnN0YXJ0UFRTLCBQVFNGcmFnLmVuZFBUUywgUFRTRnJhZy5zdGFydERUUywgUFRTRnJhZy5lbmREVFMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnN1cmUgdGhhdCBkZWx0YSBpcyB3aXRoaW4gb2xkRnJhZ21lbnRzIHJhbmdlXG4gICAgICAvLyBhbHNvIGFkanVzdCBzbGlkaW5nIGluIGNhc2UgZGVsdGEgaXMgMCAod2UgY291bGQgaGF2ZSBvbGQ9WzUwLTYwXSBhbmQgbmV3PW9sZD1bNTAtNjFdKVxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGFsc28gbmVlZCB0byBhZGp1c3Qgc3RhcnQgb2Zmc2V0IG9mIGFsbCBmcmFnbWVudHNcbiAgICAgIGFkanVzdFNsaWRpbmcob2xkRGV0YWlscywgbmV3RGV0YWlscyk7XG4gICAgfVxuICAgIGlmIChuZXdGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24gPSBuZXdEZXRhaWxzLmVkZ2UgLSBuZXdGcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgfVxuICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBvbGREZXRhaWxzLmRyaWZ0U3RhcnRUaW1lO1xuICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydCA9IG9sZERldGFpbHMuZHJpZnRTdGFydDtcbiAgICB2YXIgYWR2YW5jZWREYXRlVGltZSA9IG5ld0RldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcbiAgICBpZiAobmV3RGV0YWlscy5hZHZhbmNlZCAmJiBhZHZhbmNlZERhdGVUaW1lKSB7XG4gICAgICB2YXIgZWRnZSA9IG5ld0RldGFpbHMuZWRnZTtcbiAgICAgIGlmICghbmV3RGV0YWlscy5kcmlmdFN0YXJ0KSB7XG4gICAgICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgICAgICBuZXdEZXRhaWxzLmRyaWZ0U3RhcnQgPSBlZGdlO1xuICAgICAgfVxuICAgICAgbmV3RGV0YWlscy5kcmlmdEVuZFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgICAgbmV3RGV0YWlscy5kcmlmdEVuZCA9IGVkZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0RldGFpbHMuZHJpZnRFbmRUaW1lID0gb2xkRGV0YWlscy5kcmlmdEVuZFRpbWU7XG4gICAgICBuZXdEZXRhaWxzLmRyaWZ0RW5kID0gb2xkRGV0YWlscy5kcmlmdEVuZDtcbiAgICAgIG5ld0RldGFpbHMuYWR2YW5jZWREYXRlVGltZSA9IG9sZERldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VEYXRlUmFuZ2VzKG9sZERhdGVSYW5nZXMsIGRlbHRhRGF0ZVJhbmdlcywgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgIHZhciBkYXRlUmFuZ2VzID0gX2V4dGVuZHMoe30sIG9sZERhdGVSYW5nZXMpO1xuICAgIGlmIChyZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gICAgICByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhkZWx0YURhdGVSYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICB2YXIgZGF0ZVJhbmdlID0gbmV3IERhdGVSYW5nZShkZWx0YURhdGVSYW5nZXNbaWRdLmF0dHIsIGRhdGVSYW5nZXNbaWRdKTtcbiAgICAgIGlmIChkYXRlUmFuZ2UuaXNWYWxpZCkge1xuICAgICAgICBkYXRlUmFuZ2VzW2lkXSA9IGRhdGVSYW5nZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiSWdub3JpbmcgaW52YWxpZCBQbGF5bGlzdCBEZWx0YSBVcGRhdGUgREFURVJBTkdFIHRhZzogXFxcIlwiICsgSlNPTi5zdHJpbmdpZnkoZGVsdGFEYXRlUmFuZ2VzW2lkXS5hdHRyKSArIFwiXFxcIlwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGF0ZVJhbmdlcztcbiAgfVxuICBmdW5jdGlvbiBtYXBQYXJ0SW50ZXJzZWN0aW9uKG9sZFBhcnRzLCBuZXdQYXJ0cywgaW50ZXJzZWN0aW9uRm4pIHtcbiAgICBpZiAob2xkUGFydHMgJiYgbmV3UGFydHMpIHtcbiAgICAgIHZhciBkZWx0YSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2xkUGFydHMubGVuZ3RoOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBfb2xkUGFydCA9IG9sZFBhcnRzW2ldO1xuICAgICAgICB2YXIgX25ld1BhcnQgPSBuZXdQYXJ0c1tpICsgZGVsdGFdO1xuICAgICAgICBpZiAoX29sZFBhcnQgJiYgX25ld1BhcnQgJiYgX29sZFBhcnQuaW5kZXggPT09IF9uZXdQYXJ0LmluZGV4ICYmIF9vbGRQYXJ0LmZyYWdtZW50LnNuID09PSBfbmV3UGFydC5mcmFnbWVudC5zbikge1xuICAgICAgICAgIGludGVyc2VjdGlvbkZuKF9vbGRQYXJ0LCBfbmV3UGFydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGEtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCBpbnRlcnNlY3Rpb25Gbikge1xuICAgIHZhciBza2lwcGVkU2VnbWVudHMgPSBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cztcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChvbGREZXRhaWxzLnN0YXJ0U04sIG5ld0RldGFpbHMuc3RhcnRTTikgLSBuZXdEZXRhaWxzLnN0YXJ0U047XG4gICAgdmFyIGVuZCA9IChvbGREZXRhaWxzLmZyYWdtZW50SGludCA/IDEgOiAwKSArIChza2lwcGVkU2VnbWVudHMgPyBuZXdEZXRhaWxzLmVuZFNOIDogTWF0aC5taW4ob2xkRGV0YWlscy5lbmRTTiwgbmV3RGV0YWlscy5lbmRTTikpIC0gbmV3RGV0YWlscy5zdGFydFNOO1xuICAgIHZhciBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiAtIG9sZERldGFpbHMuc3RhcnRTTjtcbiAgICB2YXIgbmV3RnJhZ3MgPSBuZXdEZXRhaWxzLmZyYWdtZW50SGludCA/IG5ld0RldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChuZXdEZXRhaWxzLmZyYWdtZW50SGludCkgOiBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgICB2YXIgb2xkRnJhZ3MgPSBvbGREZXRhaWxzLmZyYWdtZW50SGludCA/IG9sZERldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChvbGREZXRhaWxzLmZyYWdtZW50SGludCkgOiBvbGREZXRhaWxzLmZyYWdtZW50cztcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgIHZhciBfb2xkRnJhZyA9IG9sZEZyYWdzW2RlbHRhICsgaV07XG4gICAgICB2YXIgX25ld0ZyYWcgPSBuZXdGcmFnc1tpXTtcbiAgICAgIGlmIChza2lwcGVkU2VnbWVudHMgJiYgIV9uZXdGcmFnICYmIGkgPCBza2lwcGVkU2VnbWVudHMpIHtcbiAgICAgICAgLy8gRmlsbCBpbiBza2lwcGVkIHNlZ21lbnRzIGluIGRlbHRhIHBsYXlsaXN0XG4gICAgICAgIF9uZXdGcmFnID0gbmV3RGV0YWlscy5mcmFnbWVudHNbaV0gPSBfb2xkRnJhZztcbiAgICAgIH1cbiAgICAgIGlmIChfb2xkRnJhZyAmJiBfbmV3RnJhZykge1xuICAgICAgICBpbnRlcnNlY3Rpb25Gbihfb2xkRnJhZywgX25ld0ZyYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhZGp1c3RTbGlkaW5nKG9sZERldGFpbHMsIG5ld0RldGFpbHMpIHtcbiAgICB2YXIgZGVsdGEgPSBuZXdEZXRhaWxzLnN0YXJ0U04gKyBuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cyAtIG9sZERldGFpbHMuc3RhcnRTTjtcbiAgICB2YXIgb2xkRnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHM7XG4gICAgaWYgKGRlbHRhIDwgMCB8fCBkZWx0YSA+PSBvbGRGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFkZFNsaWRpbmcobmV3RGV0YWlscywgb2xkRnJhZ21lbnRzW2RlbHRhXS5zdGFydCk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkU2xpZGluZyhkZXRhaWxzLCBzdGFydCkge1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgZm9yICh2YXIgaSA9IGRldGFpbHMuc2tpcHBlZFNlZ21lbnRzOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZyYWdtZW50c1tpXS5zdGFydCArPSBzdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgICBkZXRhaWxzLmZyYWdtZW50SGludC5zdGFydCArPSBzdGFydDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY29tcHV0ZVJlbG9hZEludGVydmFsKG5ld0RldGFpbHMsIGRpc3RhbmNlVG9MaXZlRWRnZU1zKSB7XG4gICAgaWYgKGRpc3RhbmNlVG9MaXZlRWRnZU1zID09PSB2b2lkIDApIHtcbiAgICAgIGRpc3RhbmNlVG9MaXZlRWRnZU1zID0gSW5maW5pdHk7XG4gICAgfVxuICAgIHZhciByZWxvYWRJbnRlcnZhbCA9IDEwMDAgKiBuZXdEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgIGlmIChuZXdEZXRhaWxzLnVwZGF0ZWQpIHtcbiAgICAgIC8vIFVzZSBsYXN0IHNlZ21lbnQgZHVyYXRpb24gd2hlbiBzaG9ydGVyIHRoYW4gdGFyZ2V0IGR1cmF0aW9uIGFuZCBuZWFyIGxpdmUgZWRnZVxuICAgICAgdmFyIGZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgdmFyIGxpdmVFZGdlTWF4VGFyZ2V0RHVyYXRpb25zID0gNDtcbiAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoICYmIHJlbG9hZEludGVydmFsICogbGl2ZUVkZ2VNYXhUYXJnZXREdXJhdGlvbnMgPiBkaXN0YW5jZVRvTGl2ZUVkZ2VNcykge1xuICAgICAgICB2YXIgbGFzdFNlZ21lbnREdXJhdGlvbiA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZHVyYXRpb24gKiAxMDAwO1xuICAgICAgICBpZiAobGFzdFNlZ21lbnREdXJhdGlvbiA8IHJlbG9hZEludGVydmFsKSB7XG4gICAgICAgICAgcmVsb2FkSW50ZXJ2YWwgPSBsYXN0U2VnbWVudER1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzdGltYXRlID0gJ21pc3MgaGFsZiBhdmVyYWdlJztcbiAgICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XG4gICAgICAvLyBjaGFuZ2VkIHRoZW4gaXQgTVVTVCB3YWl0IGZvciBhIHBlcmlvZCBvZiBvbmUtaGFsZiB0aGUgdGFyZ2V0XG4gICAgICAvLyBkdXJhdGlvbiBiZWZvcmUgcmV0cnlpbmcuXG4gICAgICByZWxvYWRJbnRlcnZhbCAvPSAyO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5yb3VuZChyZWxvYWRJbnRlcnZhbCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RnJhZ21lbnRXaXRoU04obGV2ZWwsIHNuLCBmcmFnQ3VycmVudCkge1xuICAgIGlmICghKGxldmVsICE9IG51bGwgJiYgbGV2ZWwuZGV0YWlscykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICB2YXIgZnJhZ21lbnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW3NuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH1cbiAgICBmcmFnbWVudCA9IGxldmVsRGV0YWlscy5mcmFnbWVudEhpbnQ7XG4gICAgaWYgKGZyYWdtZW50ICYmIGZyYWdtZW50LnNuID09PSBzbikge1xuICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH1cbiAgICBpZiAoc24gPCBsZXZlbERldGFpbHMuc3RhcnRTTiAmJiBmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudC5zbiA9PT0gc24pIHtcbiAgICAgIHJldHVybiBmcmFnQ3VycmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UGFydFdpdGgobGV2ZWwsIHNuLCBwYXJ0SW5kZXgpIHtcbiAgICB2YXIgX2xldmVsJGRldGFpbHM7XG4gICAgaWYgKCEobGV2ZWwgIT0gbnVsbCAmJiBsZXZlbC5kZXRhaWxzKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaW5kUGFydCgoX2xldmVsJGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2xldmVsJGRldGFpbHMucGFydExpc3QsIHNuLCBwYXJ0SW5kZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRQYXJ0KHBhcnRMaXN0LCBzbiwgcGFydEluZGV4KSB7XG4gICAgaWYgKHBhcnRMaXN0KSB7XG4gICAgICBmb3IgKHZhciBpID0gcGFydExpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydExpc3RbaV07XG4gICAgICAgIGlmIChwYXJ0LmluZGV4ID09PSBwYXJ0SW5kZXggJiYgcGFydC5mcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiByZWFzc2lnbkZyYWdtZW50TGV2ZWxJbmRleGVzKGxldmVscykge1xuICAgIGxldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCwgaW5kZXgpIHtcbiAgICAgIHZhciBkZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAgIGlmIChkZXRhaWxzICE9IG51bGwgJiYgZGV0YWlscy5mcmFnbWVudHMpIHtcbiAgICAgICAgZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICBmcmFnbWVudC5sZXZlbCA9IGluZGV4O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVGltZW91dEVycm9yKGVycm9yKSB7XG4gICAgc3dpdGNoIChlcnJvci5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5NQU5JRkVTVF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmV0cnlDb25maWcobG9hZFBvbGljeSwgZXJyb3IpIHtcbiAgICB2YXIgaXNUaW1lb3V0ID0gaXNUaW1lb3V0RXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBsb2FkUG9saWN5LmRlZmF1bHRbKGlzVGltZW91dCA/ICd0aW1lb3V0JyA6ICdlcnJvcicpICsgXCJSZXRyeVwiXTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSZXRyeURlbGF5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50KSB7XG4gICAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gbWF4IHJldHJ5IGRlbGF5XG4gICAgdmFyIGJhY2tvZmZGYWN0b3IgPSByZXRyeUNvbmZpZy5iYWNrb2ZmID09PSAnbGluZWFyJyA/IDEgOiBNYXRoLnBvdygyLCByZXRyeUNvdW50KTtcbiAgICByZXR1cm4gTWF0aC5taW4oYmFja29mZkZhY3RvciAqIHJldHJ5Q29uZmlnLnJldHJ5RGVsYXlNcywgcmV0cnlDb25maWcubWF4UmV0cnlEZWxheU1zKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRMb2FkZXJDb25maWdXaXRob3V0UmV0aWVzKGxvZGVyQ29uZmlnKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBsb2RlckNvbmZpZyksIHtcbiAgICAgIGVycm9yUmV0cnk6IG51bGwsXG4gICAgICB0aW1lb3V0UmV0cnk6IG51bGxcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgaXNUaW1lb3V0LCBsb2FkZXJSZXNwb25zZSkge1xuICAgIGlmICghcmV0cnlDb25maWcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGh0dHBTdGF0dXMgPSBsb2FkZXJSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogbG9hZGVyUmVzcG9uc2UuY29kZTtcbiAgICB2YXIgcmV0cnkgPSByZXRyeUNvdW50IDwgcmV0cnlDb25maWcubWF4TnVtUmV0cnkgJiYgKHJldHJ5Rm9ySHR0cFN0YXR1cyhodHRwU3RhdHVzKSB8fCAhIWlzVGltZW91dCk7XG4gICAgcmV0dXJuIHJldHJ5Q29uZmlnLnNob3VsZFJldHJ5ID8gcmV0cnlDb25maWcuc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIHJldHJ5Q291bnQsIGlzVGltZW91dCwgbG9hZGVyUmVzcG9uc2UsIHJldHJ5KSA6IHJldHJ5O1xuICB9XG4gIGZ1bmN0aW9uIHJldHJ5Rm9ySHR0cFN0YXR1cyhodHRwU3RhdHVzKSB7XG4gICAgLy8gRG8gbm90IHJldHJ5IG9uIHN0YXR1cyA0eHgsIHN0YXR1cyAwIChDT1JTIGVycm9yKSwgb3IgdW5kZWZpbmVkIChkZWNyeXB0L2dhcC9wYXJzZSBlcnJvcilcbiAgICByZXR1cm4gaHR0cFN0YXR1cyA9PT0gMCAmJiBuYXZpZ2F0b3Iub25MaW5lID09PSBmYWxzZSB8fCAhIWh0dHBTdGF0dXMgJiYgKGh0dHBTdGF0dXMgPCA0MDAgfHwgaHR0cFN0YXR1cyA+IDQ5OSk7XG4gIH1cblxuICB2YXIgQmluYXJ5U2VhcmNoID0ge1xuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciBhbiBpdGVtIGluIGFuIGFycmF5IHdoaWNoIG1hdGNoZXMgYSBjZXJ0YWluIGNvbmRpdGlvbi5cbiAgICAgKiBUaGlzIHJlcXVpcmVzIHRoZSBjb25kaXRpb24gdG8gb25seSBtYXRjaCBvbmUgaXRlbSBpbiB0aGUgYXJyYXksXG4gICAgICogYW5kIGZvciB0aGUgYXJyYXkgdG8gYmUgb3JkZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIGNvbXBhcmlzb25GblxuICAgICAqICAgICAgQ2FsbGVkIGFuZCBwcm92aWRlZCBhIGNhbmRpZGF0ZSBpdGVtIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgKiAgICAgIFNob3VsZCByZXR1cm46XG4gICAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAxIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBsb2NhdGVkIGF0IGEgaGlnaGVyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBvYmplY3QgaWYgZm91bmQsIG90aGVyd2lzZSByZXR1cm5zIG51bGxcbiAgICAgKi9cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIHNlYXJjaChsaXN0LCBjb21wYXJpc29uRm4pIHtcbiAgICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgICB2YXIgbWF4SW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICB2YXIgY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgIHZhciBjdXJyZW50RWxlbWVudCA9IG51bGw7XG4gICAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgY3VycmVudEluZGV4ID0gKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMiB8IDA7XG4gICAgICAgIGN1cnJlbnRFbGVtZW50ID0gbGlzdFtjdXJyZW50SW5kZXhdO1xuICAgICAgICB2YXIgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmlzb25GbihjdXJyZW50RWxlbWVudCk7XG4gICAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaXJzdCBmcmFnbWVudCB3aG9zZSBlbmRQZHQgdmFsdWUgZXhjZWVkcyB0aGUgZ2l2ZW4gUERULCBvciBudWxsLlxuICAgKiBAcGFyYW0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAgICogQHBhcmFtIFBEVFZhbHVlIC0gVGhlIFBEVCB2YWx1ZSB3aGljaCBtdXN0IGJlIGV4Y2VlZGVkXG4gICAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICAgKi9cbiAgZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQRFQoZnJhZ21lbnRzLCBQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkge1xuICAgIGlmIChQRFRWYWx1ZSA9PT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheShmcmFnbWVudHMpIHx8ICFmcmFnbWVudHMubGVuZ3RoIHx8ICFpc0Zpbml0ZU51bWJlcihQRFRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIGxlc3MgdGhhbiBzdGFydFxuICAgIHZhciBzdGFydFBEVCA9IGZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XG4gICAgaWYgKFBEVFZhbHVlIDwgKHN0YXJ0UERUIHx8IDApKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGVuZFBEVCA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kUHJvZ3JhbURhdGVUaW1lO1xuICAgIGlmIChQRFRWYWx1ZSA+PSAoZW5kUERUIHx8IDApKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IG1heEZyYWdMb29rVXBUb2xlcmFuY2UgfHwgMDtcbiAgICBmb3IgKHZhciBzZWcgPSAwOyBzZWcgPCBmcmFnbWVudHMubGVuZ3RoOyArK3NlZykge1xuICAgICAgdmFyIGZyYWcgPSBmcmFnbWVudHNbc2VnXTtcbiAgICAgIGlmIChwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KFBEVFZhbHVlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnKSkge1xuICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgYSBmcmFnbWVudCBiYXNlZCBvbiB0aGUgU04gb2YgdGhlIHByZXZpb3VzIGZyYWdtZW50OyBvciBiYXNlZCBvbiB0aGUgbmVlZHMgb2YgdGhlIGN1cnJlbnQgYnVmZmVyLlxuICAgKiBUaGlzIG1ldGhvZCBjb21wZW5zYXRlcyBmb3Igc21hbGwgYnVmZmVyIGdhcHMgYnkgYXBwbHlpbmcgYSB0b2xlcmFuY2UgdG8gdGhlIHN0YXJ0IG9mIGFueSBjYW5kaWRhdGUgZnJhZ21lbnQsIHRodXNcbiAgICogYnJlYWtpbmcgYW55IHRyYXBzIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSBzYW1lIGZyYWdtZW50IHRvIGJlIGNvbnRpbnVvdXNseSBzZWxlY3RlZCB3aXRoaW4gYSBzbWFsbCByYW5nZS5cbiAgICogQHBhcmFtIGZyYWdQcmV2aW91cyAtIFRoZSBsYXN0IGZyYWcgc3VjY2Vzc2Z1bGx5IGFwcGVuZGVkXG4gICAqIEBwYXJhbSBmcmFnbWVudHMgLSBUaGUgYXJyYXkgb2YgY2FuZGlkYXRlIGZyYWdtZW50c1xuICAgKiBAcGFyYW0gYnVmZmVyRW5kIC0gVGhlIGVuZCBvZiB0aGUgY29udGlndW91cyBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICAgKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydC9lbmQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAgICogQHJldHVybnMgYSBtYXRjaGluZyBmcmFnbWVudCBvciBudWxsXG4gICAqL1xuICBmdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBUUyhmcmFnUHJldmlvdXMsIGZyYWdtZW50cywgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBuZXh0RnJhZ0xvb2t1cFRvbGVyYW5jZSkge1xuICAgIGlmIChidWZmZXJFbmQgPT09IHZvaWQgMCkge1xuICAgICAgYnVmZmVyRW5kID0gMDtcbiAgICB9XG4gICAgaWYgKG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPT09IHZvaWQgMCkge1xuICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XG4gICAgfVxuICAgIGlmIChuZXh0RnJhZ0xvb2t1cFRvbGVyYW5jZSA9PT0gdm9pZCAwKSB7XG4gICAgICBuZXh0RnJhZ0xvb2t1cFRvbGVyYW5jZSA9IDAuMDA1O1xuICAgIH1cbiAgICB2YXIgZnJhZ05leHQgPSBudWxsO1xuICAgIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICAgIGZyYWdOZXh0ID0gZnJhZ21lbnRzW2ZyYWdQcmV2aW91cy5zbiAtIGZyYWdtZW50c1swXS5zbiArIDFdIHx8IG51bGw7XG4gICAgICAvLyBjaGVjayBmb3IgYnVmZmVyLWVuZCByb3VuZGluZyBlcnJvclxuICAgICAgdmFyIGJ1ZmZlckVkZ2VFcnJvciA9IGZyYWdQcmV2aW91cy5lbmREVFMgLSBidWZmZXJFbmQ7XG4gICAgICBpZiAoYnVmZmVyRWRnZUVycm9yID4gMCAmJiBidWZmZXJFZGdlRXJyb3IgPCAwLjAwMDAwMTUpIHtcbiAgICAgICAgYnVmZmVyRW5kICs9IDAuMDAwMDAxNTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJ1ZmZlckVuZCA9PT0gMCAmJiBmcmFnbWVudHNbMF0uc3RhcnQgPT09IDApIHtcbiAgICAgIGZyYWdOZXh0ID0gZnJhZ21lbnRzWzBdO1xuICAgIH1cbiAgICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG4gICAgaWYgKGZyYWdOZXh0ICYmICgoIWZyYWdQcmV2aW91cyB8fCBmcmFnUHJldmlvdXMubGV2ZWwgPT09IGZyYWdOZXh0LmxldmVsKSAmJiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnTmV4dCkgPT09IDAgfHwgZnJhZ21lbnRXaXRoaW5GYXN0U3RhcnRTd2l0Y2goZnJhZ05leHQsIGZyYWdQcmV2aW91cywgTWF0aC5taW4obmV4dEZyYWdMb29rdXBUb2xlcmFuY2UsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UpKSkpIHtcbiAgICAgIHJldHVybiBmcmFnTmV4dDtcbiAgICB9XG4gICAgLy8gV2UgbWlnaHQgYmUgc2Vla2luZyBwYXN0IHRoZSB0b2xlcmFuY2Ugc28gZmluZCB0aGUgYmVzdCBtYXRjaFxuICAgIHZhciBmb3VuZEZyYWdtZW50ID0gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdC5iaW5kKG51bGwsIGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkpO1xuICAgIGlmIChmb3VuZEZyYWdtZW50ICYmIChmb3VuZEZyYWdtZW50ICE9PSBmcmFnUHJldmlvdXMgfHwgIWZyYWdOZXh0KSkge1xuICAgICAgcmV0dXJuIGZvdW5kRnJhZ21lbnQ7XG4gICAgfVxuICAgIC8vIElmIG5vIG1hdGNoIHdhcyBmb3VuZCByZXR1cm4gdGhlIG5leHQgZnJhZ21lbnQgYWZ0ZXIgZnJhZ1ByZXZpb3VzLCBvciBudWxsXG4gICAgcmV0dXJuIGZyYWdOZXh0O1xuICB9XG4gIGZ1bmN0aW9uIGZyYWdtZW50V2l0aGluRmFzdFN0YXJ0U3dpdGNoKGZyYWdOZXh0LCBmcmFnUHJldmlvdXMsIG5leHRGcmFnTG9va3VwVG9sZXJhbmNlKSB7XG4gICAgaWYgKGZyYWdQcmV2aW91cyAmJiBmcmFnUHJldmlvdXMuc3RhcnQgPT09IDAgJiYgZnJhZ1ByZXZpb3VzLmxldmVsIDwgZnJhZ05leHQubGV2ZWwgJiYgKGZyYWdQcmV2aW91cy5lbmRQVFMgfHwgMCkgPiAwKSB7XG4gICAgICB2YXIgZmlyc3REdXJhdGlvbiA9IGZyYWdQcmV2aW91cy50YWdMaXN0LnJlZHVjZShmdW5jdGlvbiAoZHVyYXRpb24sIHRhZykge1xuICAgICAgICBpZiAodGFnWzBdID09PSAnSU5GJykge1xuICAgICAgICAgIGR1cmF0aW9uICs9IHBhcnNlRmxvYXQodGFnWzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHVyYXRpb247XG4gICAgICB9LCBuZXh0RnJhZ0xvb2t1cFRvbGVyYW5jZSk7XG4gICAgICByZXR1cm4gZnJhZ05leHQuc3RhcnQgPD0gZmlyc3REdXJhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5U24ncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gICAqIEBwYXJhbSBjYW5kaWRhdGUgLSBUaGUgZnJhZ21lbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0gYnVmZmVyRW5kIC0gVGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICAgKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICAgKiBAcmV0dXJucyAwIGlmIGl0IG1hdGNoZXMsIDEgaWYgdG9vIGxvdywgLTEgaWYgdG9vIGhpZ2hcbiAgICovXG4gIGZ1bmN0aW9uIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdChidWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZSkge1xuICAgIGlmIChidWZmZXJFbmQgPT09IHZvaWQgMCkge1xuICAgICAgYnVmZmVyRW5kID0gMDtcbiAgICB9XG4gICAgaWYgKG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPT09IHZvaWQgMCkge1xuICAgICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSA9IDA7XG4gICAgfVxuICAgIC8vIGVhZ2VybHkgYWNjZXB0IGFuIGFjY3VyYXRlIG1hdGNoIChubyB0b2xlcmFuY2UpXG4gICAgaWYgKGNhbmRpZGF0ZS5zdGFydCA8PSBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uID4gYnVmZmVyRW5kKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAgIC8vIHRoaXMgaXMgdG8gY29wZSB3aXRoIHNpdHVhdGlvbnMgbGlrZVxuICAgIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gICAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgICAvLyBmcmFnWzFdIDogWzEwLDIwXVxuICAgIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cbiAgICAvLyAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXG4gICAgLy8gcHJldmlvdXMgZnJhZyAgICAgICAgIG1hdGNoaW5nIGZyYWdtZW50ICAgICAgICAgbmV4dCBmcmFnXG4gICAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAvLyBsb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAgIC8vIFNldCB0aGUgbG9va3VwIHRvbGVyYW5jZSB0byBiZSBzbWFsbCBlbm91Z2ggdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHNlZ21lbnQgLSBlbnN1cmVzIHdlIGRvbid0IHNraXAgb3ZlciB2ZXJ5IHNtYWxsIHNlZ21lbnRzXG4gICAgdmFyIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9IE1hdGgubWluKG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZS5kdXJhdGlvbiArIChjYW5kaWRhdGUuZGVsdGFQVFMgPyBjYW5kaWRhdGUuZGVsdGFQVFMgOiAwKSk7XG4gICAgaWYgKGNhbmRpZGF0ZS5zdGFydCArIGNhbmRpZGF0ZS5kdXJhdGlvbiAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA8PSBidWZmZXJFbmQpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmIGNhbmRpZGF0ZS5zdGFydCkge1xuICAgICAgLy8gaWYgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB3aWxsIGhhdmUgbmVnYXRpdmUgdmFsdWUgdGhlbiBkb24ndCByZXR1cm4gLTEgZm9yIGZpcnN0IGVsZW1lbnRcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlQZHQncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gICAqIFRoaXMgZnVuY3Rpb24gdGVzdHMgdGhlIGNhbmRpZGF0ZSdzIHByb2dyYW0gZGF0ZSB0aW1lIHZhbHVlcywgYXMgcmVwcmVzZW50ZWQgaW4gVW5peCB0aW1lXG4gICAqIEBwYXJhbSBjYW5kaWRhdGUgLSBUaGUgZnJhZ21lbnQgdG8gdGVzdFxuICAgKiBAcGFyYW0gcGR0QnVmZmVyRW5kIC0gVGhlIFVuaXggdGltZSByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZVxuICAgKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICAgKiBAcmV0dXJucyB0cnVlIGlmIGNvbnRpZ3VvdXMsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgZnVuY3Rpb24gcGR0V2l0aGluVG9sZXJhbmNlVGVzdChwZHRCdWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZSkge1xuICAgIHZhciBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpICogMTAwMDtcblxuICAgIC8vIGVuZFByb2dyYW1EYXRlVGltZSBjYW4gYmUgbnVsbCwgZGVmYXVsdCB0byB6ZXJvXG4gICAgdmFyIGVuZFByb2dyYW1EYXRlVGltZSA9IGNhbmRpZGF0ZS5lbmRQcm9ncmFtRGF0ZVRpbWUgfHwgMDtcbiAgICByZXR1cm4gZW5kUHJvZ3JhbURhdGVUaW1lIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gcGR0QnVmZmVyRW5kO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRGcmFnV2l0aENDKGZyYWdtZW50cywgY2MpIHtcbiAgICByZXR1cm4gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICAgIGlmIChjYW5kaWRhdGUuY2MgPCBjYykge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlLmNjID4gY2MpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgTmV0d29ya0Vycm9yQWN0aW9uID0ge1xuICAgIERvTm90aGluZzogMCxcbiAgICBTZW5kRW5kQ2FsbGJhY2s6IDEsXG4gICAgU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDogMixcbiAgICBSZW1vdmVBbHRlcm5hdGVQZXJtYW5lbnRseTogMyxcbiAgICBJbnNlcnREaXNjb250aW51aXR5OiA0LFxuICAgIFJldHJ5UmVxdWVzdDogNVxuICB9O1xuICB2YXIgRXJyb3JBY3Rpb25GbGFncyA9IHtcbiAgICBOb25lOiAwLFxuICAgIE1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0OiAxLFxuICAgIE1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIRENQOiAyLFxuICAgIFN3aXRjaFRvU0RSOiA0XG4gIH07IC8vIFJlc2VydmVkIGZvciBmdXR1cmUgdXNlXG4gIHZhciBFcnJvckNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVycm9yQ29udHJvbGxlcihobHMpIHtcbiAgICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgICAgIHRoaXMucGVuYWxpemVkUmVuZGl0aW9ucyA9IHt9O1xuICAgICAgdGhpcy5sb2cgPSB2b2lkIDA7XG4gICAgICB0aGlzLndhcm4gPSB2b2lkIDA7XG4gICAgICB0aGlzLmVycm9yID0gdm9pZCAwO1xuICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIFwiW2luZm9dOlwiKTtcbiAgICAgIHRoaXMud2FybiA9IGxvZ2dlci53YXJuLmJpbmQobG9nZ2VyLCBcIlt3YXJuaW5nXTpcIik7XG4gICAgICB0aGlzLmVycm9yID0gbG9nZ2VyLmVycm9yLmJpbmQobG9nZ2VyLCBcIltlcnJvcl06XCIpO1xuICAgICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gRXJyb3JDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmICghaGxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvck91dCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmhscyA9IG51bGw7XG4gICAgICB0aGlzLnBlbmFsaXplZFJlbmRpdGlvbnMgPSB7fTtcbiAgICB9O1xuICAgIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge307XG4gICAgX3Byb3RvLnN0b3BMb2FkID0gZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFZhcmlhbnRMZXZlbEluZGV4ID0gZnVuY3Rpb24gZ2V0VmFyaWFudExldmVsSW5kZXgoZnJhZykge1xuICAgICAgcmV0dXJuIChmcmFnID09IG51bGwgPyB2b2lkIDAgOiBmcmFnLnR5cGUpID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gZnJhZy5sZXZlbCA6IHRoaXMuaGxzLmxvYWRMZXZlbDtcbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgICAgIHRoaXMucGVuYWxpemVkUmVuZGl0aW9ucyA9IHt9O1xuICAgIH07XG4gICAgX3Byb3RvLm9uTGV2ZWxVcGRhdGVkID0gZnVuY3Rpb24gb25MZXZlbFVwZGF0ZWQoKSB7XG4gICAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgIH07XG4gICAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgX2RhdGEkZnJhZywgX2RhdGEkbGV2ZWw7XG4gICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dDtcbiAgICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SOlxuICAgICAgICAgIC8vIGlnbm9yZSBlbXB0eSBzZWdtZW50IGVycm9ycyBtYXJrZWQgYXMgZ2FwXG4gICAgICAgICAgaWYgKChfZGF0YSRmcmFnID0gZGF0YS5mcmFnKSAhPSBudWxsICYmIF9kYXRhJGZyYWcuZ2FwKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5Eb05vdGhpbmcsXG4gICAgICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfR0FQOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1I6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gU3dpdGNoIGxldmVsIGlmIHBvc3NpYmxlLCBvdGhlcndpc2UgYWxsb3cgcmV0cnkgY291bnQgdG8gcmVhY2ggbWF4IGVycm9yIHJldHJpZXNcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEpO1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbi5hY3Rpb24gPSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfZGF0YSRjb250ZXh0LCBfZGF0YSRjb250ZXh0JGxldmVsRGU7XG4gICAgICAgICAgICAvLyBPbmx5IHJldHJ5IHdoZW4gZW1wdHkgYW5kIGxpdmVcbiAgICAgICAgICAgIHZhciBsZXZlbEluZGV4ID0gZGF0YS5wYXJlbnQgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gPyBkYXRhLmxldmVsIDogaGxzLmxvYWRMZXZlbDtcbiAgICAgICAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5MRVZFTF9FTVBUWV9FUlJPUiAmJiAhISgoX2RhdGEkY29udGV4dCA9IGRhdGEuY29udGV4dCkgIT0gbnVsbCAmJiAoX2RhdGEkY29udGV4dCRsZXZlbERlID0gX2RhdGEkY29udGV4dC5sZXZlbERldGFpbHMpICE9IG51bGwgJiYgX2RhdGEkY29udGV4dCRsZXZlbERlLmxpdmUpKSB7XG4gICAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEVzY2FsYXRlIHRvIGZhdGFsIGlmIG5vdCByZXRyeWluZyBvciBzd2l0Y2hpbmdcbiAgICAgICAgICAgICAgZGF0YS5sZXZlbFJldHJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgICAgICBpZiAodHlwZW9mIChjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0LmxldmVsKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihkYXRhLCBjb250ZXh0LmxldmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLlNVQlRJVExFX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGxldmVsID0gaGxzLmxldmVsc1tobHMubG9hZExldmVsXTtcbiAgICAgICAgICAgIGlmIChsZXZlbCAmJiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIGxldmVsLmhhc0F1ZGlvR3JvdXAoY29udGV4dC5ncm91cElkKSB8fCBjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiYgbGV2ZWwuaGFzU3VidGl0bGVHcm91cChjb250ZXh0Lmdyb3VwSWQpKSkge1xuICAgICAgICAgICAgICAvLyBQZXJmb3JtIFBhdGh3YXkgc3dpdGNoIG9yIFJlZHVuZGFudCBmYWlsb3ZlciBpZiBwb3NzaWJsZSBmb3IgZmFzdGVzdCByZWNvdmVyeVxuICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgYWxsb3cgcGxheWxpc3QgcmV0cnkgY291bnQgdG8gcmVhY2ggbWF4IGVycm9yIHJldHJpZXNcbiAgICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEsIGhscy5sb2FkTGV2ZWwpO1xuICAgICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uLmFjdGlvbiA9IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94O1xuICAgICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uLmZsYWdzID0gRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdDtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU1RBVFVTX09VVFBVVF9SRVNUUklDVEVEOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbGV2ZWwgPSBobHMubGV2ZWxzW2hscy5sb2FkTGV2ZWxdO1xuICAgICAgICAgICAgdmFyIHJlc3RyaWN0ZWRIZGNwTGV2ZWwgPSBfbGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbC5hdHRyc1snSERDUC1MRVZFTCddO1xuICAgICAgICAgICAgaWYgKHJlc3RyaWN0ZWRIZGNwTGV2ZWwpIHtcbiAgICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIRENQLFxuICAgICAgICAgICAgICAgIGhkY3BMZXZlbDogcmVzdHJpY3RlZEhkY3BMZXZlbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5rZXlTeXN0ZW1FcnJvcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCAoX2RhdGEkbGV2ZWwgPSBkYXRhLmxldmVsKSAhPSBudWxsID8gX2RhdGEkbGV2ZWwgOiBobHMubG9hZExldmVsKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRTpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX05VREdFX09OX1NUQUxMOlxuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB7XG4gICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5Eb05vdGhpbmcsXG4gICAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS50eXBlID09PSBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IpIHtcbiAgICAgICAgdGhpcy5rZXlTeXN0ZW1FcnJvcihkYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5rZXlTeXN0ZW1FcnJvciA9IGZ1bmN0aW9uIGtleVN5c3RlbUVycm9yKGRhdGEpIHtcbiAgICAgIHZhciBsZXZlbEluZGV4ID0gdGhpcy5nZXRWYXJpYW50TGV2ZWxJbmRleChkYXRhLmZyYWcpO1xuICAgICAgLy8gRG8gbm90IHJldHJ5IGxldmVsLiBFc2NhbGF0ZSB0byBmYXRhbCBpZiBzd2l0Y2hpbmcgbGV2ZWxzIGZhaWxzLlxuICAgICAgZGF0YS5sZXZlbFJldHJ5ID0gZmFsc2U7XG4gICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgdmFyIHJldHJ5Q29uZmlnID0gZ2V0UmV0cnlDb25maWcoaGxzLmNvbmZpZy5wbGF5bGlzdExvYWRQb2xpY3ksIGRhdGEpO1xuICAgICAgdmFyIHJldHJ5Q291bnQgPSB0aGlzLnBsYXlsaXN0RXJyb3IrKztcbiAgICAgIHZhciByZXRyeSA9IHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCBpc1RpbWVvdXRFcnJvcihkYXRhKSwgZGF0YS5yZXNwb25zZSk7XG4gICAgICBpZiAocmV0cnkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QsXG4gICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZSxcbiAgICAgICAgICByZXRyeUNvbmZpZzogcmV0cnlDb25maWcsXG4gICAgICAgICAgcmV0cnlDb3VudDogcmV0cnlDb3VudFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICAgIGlmIChyZXRyeUNvbmZpZykge1xuICAgICAgICBlcnJvckFjdGlvbi5yZXRyeUNvbmZpZyA9IHJldHJ5Q29uZmlnO1xuICAgICAgICBlcnJvckFjdGlvbi5yZXRyeUNvdW50ID0gcmV0cnlDb3VudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvckFjdGlvbjtcbiAgICB9O1xuICAgIF9wcm90by5nZXRGcmFnUmV0cnlPclN3aXRjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIC8vIFNoYXJlIGZyYWdtZW50IGVycm9yIGNvdW50IGFjY3Jvc3MgbWVkaWEgb3B0aW9ucyAobWFpbiwgYXVkaW8sIHN1YnMpXG4gICAgICAvLyBUaGlzIGFsbG93cyBmb3IgbGV2ZWwgYmFzZWQgcmVuZGl0aW9uIHN3aXRjaGluZyB3aGVuIG1lZGlhIG9wdGlvbiBhc3NldHMgZmFpbFxuICAgICAgdmFyIHZhcmlhbnRMZXZlbEluZGV4ID0gdGhpcy5nZXRWYXJpYW50TGV2ZWxJbmRleChkYXRhLmZyYWcpO1xuICAgICAgdmFyIGxldmVsID0gaGxzLmxldmVsc1t2YXJpYW50TGV2ZWxJbmRleF07XG4gICAgICB2YXIgX2hscyRjb25maWcgPSBobHMuY29uZmlnLFxuICAgICAgICBmcmFnTG9hZFBvbGljeSA9IF9obHMkY29uZmlnLmZyYWdMb2FkUG9saWN5LFxuICAgICAgICBrZXlMb2FkUG9saWN5ID0gX2hscyRjb25maWcua2V5TG9hZFBvbGljeTtcbiAgICAgIHZhciByZXRyeUNvbmZpZyA9IGdldFJldHJ5Q29uZmlnKGRhdGEuZGV0YWlscy5zdGFydHNXaXRoKCdrZXknKSA/IGtleUxvYWRQb2xpY3kgOiBmcmFnTG9hZFBvbGljeSwgZGF0YSk7XG4gICAgICB2YXIgZnJhZ21lbnRFcnJvcnMgPSBobHMubGV2ZWxzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBsZXZlbCkge1xuICAgICAgICByZXR1cm4gYWNjICsgbGV2ZWwuZnJhZ21lbnRFcnJvcjtcbiAgICAgIH0sIDApO1xuICAgICAgLy8gU3dpdGNoIGxldmVscyB3aGVuIG91dCBvZiByZXRyaWVkIG9yIGxldmVsIGluZGV4IG91dCBvZiBib3VuZHNcbiAgICAgIGlmIChsZXZlbCkge1xuICAgICAgICBpZiAoZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuRlJBR19HQVApIHtcbiAgICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yKys7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldHJ5ID0gc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIGZyYWdtZW50RXJyb3JzLCBpc1RpbWVvdXRFcnJvcihkYXRhKSwgZGF0YS5yZXNwb25zZSk7XG4gICAgICAgIGlmIChyZXRyeSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QsXG4gICAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICAgICAgcmV0cnlDb25maWc6IHJldHJ5Q29uZmlnLFxuICAgICAgICAgICAgcmV0cnlDb3VudDogZnJhZ21lbnRFcnJvcnNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWFjaCBtYXggcmV0cnkgY291bnQsIG9yIE1pc3NpbmcgbGV2ZWwgcmVmZXJlbmNlXG4gICAgICAvLyBTd2l0Y2ggdG8gdmFsaWQgaW5kZXhcbiAgICAgIHZhciBlcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgdmFyaWFudExldmVsSW5kZXgpO1xuICAgICAgLy8gQWRkIHJldHJ5IGRldGFpbHMgdG8gYWxsb3cgc2tpcHBpbmcgb2YgRlJBR19QQVJTSU5HX0VSUk9SXG4gICAgICBpZiAocmV0cnlDb25maWcpIHtcbiAgICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb25maWcgPSByZXRyeUNvbmZpZztcbiAgICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb3VudCA9IGZyYWdtZW50RXJyb3JzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVycm9yQWN0aW9uO1xuICAgIH07XG4gICAgX3Byb3RvLmdldExldmVsU3dpdGNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKGxldmVsSW5kZXggPT09IG51bGwgfHwgbGV2ZWxJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldmVsSW5kZXggPSBobHMubG9hZExldmVsO1xuICAgICAgfVxuICAgICAgdmFyIGxldmVsID0gdGhpcy5obHMubGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgICAgaWYgKGxldmVsKSB7XG4gICAgICAgIHZhciBfZGF0YSRmcmFnMiwgX2RhdGEkY29udGV4dDI7XG4gICAgICAgIHZhciBlcnJvckRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICAgIGxldmVsLmxvYWRFcnJvcisrO1xuICAgICAgICBpZiAoZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUikge1xuICAgICAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWFyY2ggZm9yIG5leHQgbGV2ZWwgdG8gcmV0cnlcbiAgICAgICAgdmFyIG5leHRMZXZlbCA9IC0xO1xuICAgICAgICB2YXIgbGV2ZWxzID0gaGxzLmxldmVscyxcbiAgICAgICAgICBsb2FkTGV2ZWwgPSBobHMubG9hZExldmVsLFxuICAgICAgICAgIG1pbkF1dG9MZXZlbCA9IGhscy5taW5BdXRvTGV2ZWwsXG4gICAgICAgICAgbWF4QXV0b0xldmVsID0gaGxzLm1heEF1dG9MZXZlbDtcbiAgICAgICAgaWYgKCFobHMuYXV0b0xldmVsRW5hYmxlZCkge1xuICAgICAgICAgIGhscy5sb2FkTGV2ZWwgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJhZ0Vycm9yVHlwZSA9IChfZGF0YSRmcmFnMiA9IGRhdGEuZnJhZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGZyYWcyLnR5cGU7XG4gICAgICAgIC8vIEZpbmQgYWx0ZXJuYXRlIGF1ZGlvIGNvZGVjIGlmIGF2YWlsYWJsZSBvbiBhdWRpbyBjb2RlYyBlcnJvclxuICAgICAgICB2YXIgaXNBdWRpb0NvZGVjRXJyb3IgPSBmcmFnRXJyb3JUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5BVURJTyAmJiBlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IgfHwgZGF0YS5zb3VyY2VCdWZmZXJOYW1lID09PSAnYXVkaW8nICYmIChlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SIHx8IGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IpO1xuICAgICAgICB2YXIgZmluZEF1ZGlvQ29kZWNBbHRlcm5hdGUgPSBpc0F1ZGlvQ29kZWNFcnJvciAmJiBsZXZlbHMuc29tZShmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBhdWRpb0NvZGVjID0gX3JlZi5hdWRpb0NvZGVjO1xuICAgICAgICAgIHJldHVybiBsZXZlbC5hdWRpb0NvZGVjICE9PSBhdWRpb0NvZGVjO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRmluZCBhbHRlcm5hdGUgdmlkZW8gY29kZWMgaWYgYXZhaWxhYmxlIG9uIHZpZGVvIGNvZGVjIGVycm9yXG4gICAgICAgIHZhciBpc1ZpZGVvQ29kZWNFcnJvciA9IGRhdGEuc291cmNlQnVmZmVyTmFtZSA9PT0gJ3ZpZGVvJyAmJiAoZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUiB8fCBlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SKTtcbiAgICAgICAgdmFyIGZpbmRWaWRlb0NvZGVjQWx0ZXJuYXRlID0gaXNWaWRlb0NvZGVjRXJyb3IgJiYgbGV2ZWxzLnNvbWUoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgdmFyIGNvZGVjU2V0ID0gX3JlZjIuY29kZWNTZXQsXG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gX3JlZjIuYXVkaW9Db2RlYztcbiAgICAgICAgICByZXR1cm4gbGV2ZWwuY29kZWNTZXQgIT09IGNvZGVjU2V0ICYmIGxldmVsLmF1ZGlvQ29kZWMgPT09IGF1ZGlvQ29kZWM7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX3JlZjMgPSAoX2RhdGEkY29udGV4dDIgPSBkYXRhLmNvbnRleHQpICE9IG51bGwgPyBfZGF0YSRjb250ZXh0MiA6IHt9LFxuICAgICAgICAgIHBsYXlsaXN0RXJyb3JUeXBlID0gX3JlZjMudHlwZSxcbiAgICAgICAgICBwbGF5bGlzdEVycm9yR3JvdXBJZCA9IF9yZWYzLmdyb3VwSWQ7XG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IChpICsgbG9hZExldmVsKSAlIGxldmVscy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlICE9PSBsb2FkTGV2ZWwgJiYgY2FuZGlkYXRlID49IG1pbkF1dG9MZXZlbCAmJiBjYW5kaWRhdGUgPD0gbWF4QXV0b0xldmVsICYmIGxldmVsc1tjYW5kaWRhdGVdLmxvYWRFcnJvciA9PT0gMCkge1xuICAgICAgICAgICAgICB2YXIgX2xldmVsJGF1ZGlvR3JvdXBzLCBfbGV2ZWwkc3VidGl0bGVHcm91cHM7XG4gICAgICAgICAgICAgIHZhciBsZXZlbENhbmRpZGF0ZSA9IGxldmVsc1tjYW5kaWRhdGVdO1xuICAgICAgICAgICAgICAvLyBTa2lwIGxldmVsIHN3aXRjaCBpZiBHQVAgdGFnIGlzIGZvdW5kIGluIG5leHQgbGV2ZWwgYXQgc2FtZSBwb3NpdGlvblxuICAgICAgICAgICAgICBpZiAoZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuRlJBR19HQVAgJiYgZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiAmJiBkYXRhLmZyYWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWxzW2NhbmRpZGF0ZV0uZGV0YWlscztcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWxEZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZnJhZ0NhbmRpZGF0ZSA9IGZpbmRGcmFnbWVudEJ5UFRTKGRhdGEuZnJhZywgbGV2ZWxEZXRhaWxzLmZyYWdtZW50cywgZGF0YS5mcmFnLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgIGlmIChmcmFnQ2FuZGlkYXRlICE9IG51bGwgJiYgZnJhZ0NhbmRpZGF0ZS5nYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsYXlsaXN0RXJyb3JUeXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIGxldmVsQ2FuZGlkYXRlLmhhc0F1ZGlvR3JvdXAocGxheWxpc3RFcnJvckdyb3VwSWQpIHx8IHBsYXlsaXN0RXJyb3JUeXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGxldmVsQ2FuZGlkYXRlLmhhc1N1YnRpdGxlR3JvdXAocGxheWxpc3RFcnJvckdyb3VwSWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGF1ZGlvL3N1YnMgcGxheWxpc3QgZXJyb3JzIGZpbmQgYW5vdGhlciBncm91cCBJRCBvciBmYWxsdGhyb3VnaCB0byByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8gJiYgKF9sZXZlbCRhdWRpb0dyb3VwcyA9IGxldmVsLmF1ZGlvR3JvdXBzKSAhPSBudWxsICYmIF9sZXZlbCRhdWRpb0dyb3Vwcy5zb21lKGZ1bmN0aW9uIChncm91cElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxldmVsQ2FuZGlkYXRlLmhhc0F1ZGlvR3JvdXAoZ3JvdXBJZCk7XG4gICAgICAgICAgICAgIH0pIHx8IGZyYWdFcnJvclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFICYmIChfbGV2ZWwkc3VidGl0bGVHcm91cHMgPSBsZXZlbC5zdWJ0aXRsZUdyb3VwcykgIT0gbnVsbCAmJiBfbGV2ZWwkc3VidGl0bGVHcm91cHMuc29tZShmdW5jdGlvbiAoZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZXZlbENhbmRpZGF0ZS5oYXNTdWJ0aXRsZUdyb3VwKGdyb3VwSWQpO1xuICAgICAgICAgICAgICB9KSB8fCBmaW5kQXVkaW9Db2RlY0FsdGVybmF0ZSAmJiBsZXZlbC5hdWRpb0NvZGVjID09PSBsZXZlbENhbmRpZGF0ZS5hdWRpb0NvZGVjIHx8ICFmaW5kQXVkaW9Db2RlY0FsdGVybmF0ZSAmJiBsZXZlbC5hdWRpb0NvZGVjICE9PSBsZXZlbENhbmRpZGF0ZS5hdWRpb0NvZGVjIHx8IGZpbmRWaWRlb0NvZGVjQWx0ZXJuYXRlICYmIGxldmVsLmNvZGVjU2V0ID09PSBsZXZlbENhbmRpZGF0ZS5jb2RlY1NldCkge1xuICAgICAgICAgICAgICAgIC8vIEZvciB2aWRlby9hdWRpby9zdWJzIGZyYWcgZXJyb3JzIGZpbmQgYW5vdGhlciBncm91cCBJRCBvciBmYWxsdGhyb3VnaCB0byByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmV4dExldmVsID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgICByZXR1cm4gMTsgLy8gYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIF9yZXQ7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZXZlbHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgX3JldCA9IF9sb29wKCk7XG4gICAgICAgICAgaWYgKF9yZXQgPT09IDApIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChfcmV0ID09PSAxKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dExldmVsID4gLTEgJiYgaGxzLmxvYWRMZXZlbCAhPT0gbmV4dExldmVsKSB7XG4gICAgICAgICAgZGF0YS5sZXZlbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZSxcbiAgICAgICAgICAgIG5leHRBdXRvTGV2ZWw6IG5leHRMZXZlbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE5vIGxldmVscyB0byBzd2l0Y2ggLyBNYW51YWwgbGV2ZWwgc2VsZWN0aW9uIC8gTGV2ZWwgbm90IGZvdW5kXG4gICAgICAvLyBSZXNvbHZlIHdpdGggUGF0aHdheSBzd2l0Y2gsIFJlZHVuZGFudCBmYWlsLW92ZXIsIG9yIHN0YXkgb24gbG93ZXN0IExldmVsXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdFxuICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5vbkVycm9yT3V0ID0gZnVuY3Rpb24gb25FcnJvck91dChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF9kYXRhJGVycm9yQWN0aW9uO1xuICAgICAgc3dpdGNoICgoX2RhdGEkZXJyb3JBY3Rpb24gPSBkYXRhLmVycm9yQWN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkZXJyb3JBY3Rpb24uYWN0aW9uKSB7XG4gICAgICAgIGNhc2UgTmV0d29ya0Vycm9yQWN0aW9uLkRvTm90aGluZzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDpcbiAgICAgICAgICB0aGlzLnNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZGF0YSk7XG4gICAgICAgICAgaWYgKCFkYXRhLmVycm9yQWN0aW9uLnJlc29sdmVkICYmIGRhdGEuZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQKSB7XG4gICAgICAgICAgICBkYXRhLmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKC9NZWRpYVNvdXJjZSByZWFkeVN0YXRlOiBlbmRlZC8udGVzdChkYXRhLmVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oXCJNZWRpYVNvdXJjZSBlbmRlZCBhZnRlciBcXFwiXCIgKyBkYXRhLnNvdXJjZUJ1ZmZlck5hbWUgKyBcIlxcXCIgc291cmNlQnVmZmVyIGFwcGVuZCBlcnJvci4gQXR0ZW1wdGluZyB0byByZWNvdmVyIGZyb20gbWVkaWEgZXJyb3IuXCIpO1xuICAgICAgICAgICAgdGhpcy5obHMucmVjb3Zlck1lZGlhRXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICB0aGlzLmhscy5zdG9wTG9hZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCA9IGZ1bmN0aW9uIHNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZGF0YSkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgdmFyIGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbjtcbiAgICAgIGlmICghZXJyb3JBY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGZsYWdzID0gZXJyb3JBY3Rpb24uZmxhZ3MsXG4gICAgICAgIGhkY3BMZXZlbCA9IGVycm9yQWN0aW9uLmhkY3BMZXZlbCxcbiAgICAgICAgbmV4dEF1dG9MZXZlbCA9IGVycm9yQWN0aW9uLm5leHRBdXRvTGV2ZWw7XG4gICAgICBzd2l0Y2ggKGZsYWdzKSB7XG4gICAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Ob25lOlxuICAgICAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YSwgbmV4dEF1dG9MZXZlbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUDpcbiAgICAgICAgICBpZiAoaGRjcExldmVsKSB7XG4gICAgICAgICAgICBobHMubWF4SGRjcExldmVsID0gSGRjcExldmVsc1tIZGNwTGV2ZWxzLmluZGV4T2YoaGRjcExldmVsKSAtIDFdO1xuICAgICAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLndhcm4oXCJSZXN0cmljdGluZyBwbGF5YmFjayB0byBIRENQLUxFVkVMIG9mIFxcXCJcIiArIGhscy5tYXhIZGNwTGV2ZWwgKyBcIlxcXCIgb3IgbG93ZXJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBJZiBub3QgcmVzb2x2ZWQgYnkgcHJldmlvdXMgYWN0aW9ucyB0cnkgdG8gc3dpdGNoIHRvIG5leHQgbGV2ZWxcbiAgICAgIGlmICghZXJyb3JBY3Rpb24ucmVzb2x2ZWQpIHtcbiAgICAgICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLCBuZXh0QXV0b0xldmVsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zd2l0Y2hMZXZlbCA9IGZ1bmN0aW9uIHN3aXRjaExldmVsKGRhdGEsIGxldmVsSW5kZXgpIHtcbiAgICAgIGlmIChsZXZlbEluZGV4ICE9PSB1bmRlZmluZWQgJiYgZGF0YS5lcnJvckFjdGlvbikge1xuICAgICAgICB0aGlzLndhcm4oXCJzd2l0Y2hpbmcgdG8gbGV2ZWwgXCIgKyBsZXZlbEluZGV4ICsgXCIgYWZ0ZXIgXCIgKyBkYXRhLmRldGFpbHMpO1xuICAgICAgICB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gbGV2ZWxJbmRleDtcbiAgICAgICAgZGF0YS5lcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIC8vIFN0cmVhbSBjb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0aGlzIGJ1dCB3b24ndCBzd2l0Y2ggb24gZmFsc2Ugc3RhcnRcbiAgICAgICAgdGhpcy5obHMubmV4dExvYWRMZXZlbCA9IHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRXJyb3JDb250cm9sbGVyO1xuICB9KCk7XG5cbiAgdmFyIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIoaGxzLCBsb2dQcmVmaXgpIHtcbiAgICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgdGhpcy50aW1lciA9IC0xO1xuICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gLTE7XG4gICAgICB0aGlzLmNhbkxvYWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nID0gdm9pZCAwO1xuICAgICAgdGhpcy53YXJuID0gdm9pZCAwO1xuICAgICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBsb2dQcmVmaXggKyBcIjpcIik7XG4gICAgICB0aGlzLndhcm4gPSBsb2dnZXIud2Fybi5iaW5kKGxvZ2dlciwgbG9nUHJlZml4ICsgXCI6XCIpO1xuICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBCYXNlUGxheWxpc3RDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuaGxzID0gdGhpcy5sb2cgPSB0aGlzLndhcm4gPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLmNsZWFyVGltZXIgPSBmdW5jdGlvbiBjbGVhclRpbWVyKCkge1xuICAgICAgaWYgKHRoaXMudGltZXIgIT09IC0xKSB7XG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gLTE7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKCkge1xuICAgICAgdGhpcy5jYW5Mb2FkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IC0xO1xuICAgICAgdGhpcy5sb2FkUGxheWxpc3QoKTtcbiAgICB9O1xuICAgIF9wcm90by5zdG9wTG9hZCA9IGZ1bmN0aW9uIHN0b3BMb2FkKCkge1xuICAgICAgdGhpcy5jYW5Mb2FkID0gZmFsc2U7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB9O1xuICAgIF9wcm90by5zd2l0Y2hQYXJhbXMgPSBmdW5jdGlvbiBzd2l0Y2hQYXJhbXMocGxheWxpc3RVcmksIHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgICB2YXIgcmVuZGl0aW9uUmVwb3J0cyA9IHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5yZW5kaXRpb25SZXBvcnRzO1xuICAgICAgaWYgKHJlbmRpdGlvblJlcG9ydHMpIHtcbiAgICAgICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW5kaXRpb25SZXBvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGF0dHIgPSByZW5kaXRpb25SZXBvcnRzW2ldO1xuICAgICAgICAgIHZhciB1cmkgPSB2b2lkIDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVyaSA9IG5ldyBzZWxmLlVSTChhdHRyLlVSSSwgcHJldmlvdXMudXJsKS5ocmVmO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIkNvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCBmb3IgUmVuZGl0aW9uIFJlcG9ydDogXCIgKyBlcnJvcik7XG4gICAgICAgICAgICB1cmkgPSBhdHRyLlVSSSB8fCAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVXNlIGV4YWN0IG1hdGNoLiBPdGhlcndpc2UsIHRoZSBsYXN0IHBhcnRpYWwgbWF0Y2gsIGlmIGFueSwgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgLy8gKFBsYXlsaXN0IFVSSSBpbmNsdWRlcyBhIHF1ZXJ5IHN0cmluZyB0aGF0IHRoZSBSZW5kaXRpb24gUmVwb3J0IGRvZXMgbm90KVxuICAgICAgICAgIGlmICh1cmkgPT09IHBsYXlsaXN0VXJpKSB7XG4gICAgICAgICAgICBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAodXJpID09PSBwbGF5bGlzdFVyaS5zdWJzdHJpbmcoMCwgdXJpLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGZvdW5kSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB2YXIgX2F0dHIgPSByZW5kaXRpb25SZXBvcnRzW2ZvdW5kSW5kZXhdO1xuICAgICAgICAgIHZhciBtc24gPSBwYXJzZUludChfYXR0clsnTEFTVC1NU04nXSkgfHwgKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5sYXN0UGFydFNuKTtcbiAgICAgICAgICB2YXIgcGFydCA9IHBhcnNlSW50KF9hdHRyWydMQVNULVBBUlQnXSkgfHwgKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5sYXN0UGFydEluZGV4KTtcbiAgICAgICAgICBpZiAodGhpcy5obHMuY29uZmlnLmxvd0xhdGVuY3lNb2RlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEdvYWwgPSBNYXRoLm1pbihwcmV2aW91cy5hZ2UgLSBwcmV2aW91cy5wYXJ0VGFyZ2V0LCBwcmV2aW91cy50YXJnZXRkdXJhdGlvbik7XG4gICAgICAgICAgICBpZiAocGFydCA+PSAwICYmIGN1cnJlbnRHb2FsID4gcHJldmlvdXMucGFydFRhcmdldCkge1xuICAgICAgICAgICAgICBwYXJ0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBza2lwID0gY3VycmVudCAmJiBnZXRTa2lwVmFsdWUoY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBIbHNVcmxQYXJhbWV0ZXJzKG1zbiwgcGFydCA+PSAwID8gcGFydCA6IHVuZGVmaW5lZCwgc2tpcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5sb2FkUGxheWxpc3QgPSBmdW5jdGlvbiBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgICAgaWYgKHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIC8vIExvYWRpbmcgaXMgaGFuZGxlZCBieSB0aGUgc3ViY2xhc3Nlc1xuICAgIH07XG4gICAgX3Byb3RvLnNob3VsZExvYWRQbGF5bGlzdCA9IGZ1bmN0aW9uIHNob3VsZExvYWRQbGF5bGlzdChwbGF5bGlzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FuTG9hZCAmJiAhIXBsYXlsaXN0ICYmICEhcGxheWxpc3QudXJsICYmICghcGxheWxpc3QuZGV0YWlscyB8fCBwbGF5bGlzdC5kZXRhaWxzLmxpdmUpO1xuICAgIH07XG4gICAgX3Byb3RvLnNob3VsZFJlbG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gc2hvdWxkUmVsb2FkUGxheWxpc3QocGxheWxpc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbWVyID09PSAtMSAmJiB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPT09IC0xICYmIHRoaXMuc2hvdWxkTG9hZFBsYXlsaXN0KHBsYXlsaXN0KTtcbiAgICB9O1xuICAgIF9wcm90by5wbGF5bGlzdExvYWRlZCA9IGZ1bmN0aW9uIHBsYXlsaXN0TG9hZGVkKGluZGV4LCBkYXRhLCBwcmV2aW91c0RldGFpbHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgZGV0YWlscyA9IGRhdGEuZGV0YWlscyxcbiAgICAgICAgc3RhdHMgPSBkYXRhLnN0YXRzO1xuXG4gICAgICAvLyBTZXQgbGFzdCB1cGRhdGVkIGRhdGUtdGltZVxuICAgICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB2YXIgZWxhcHNlZCA9IHN0YXRzLmxvYWRpbmcuZmlyc3QgPyBNYXRoLm1heCgwLCBub3cgLSBzdGF0cy5sb2FkaW5nLmZpcnN0KSA6IDA7XG4gICAgICBkZXRhaWxzLmFkdmFuY2VkRGF0ZVRpbWUgPSBEYXRlLm5vdygpIC0gZWxhcHNlZDtcblxuICAgICAgLy8gaWYgY3VycmVudCBwbGF5bGlzdCBpcyBhIGxpdmUgcGxheWxpc3QsIGFybSBhIHRpbWVyIHRvIHJlbG9hZCBpdFxuICAgICAgaWYgKGRldGFpbHMubGl2ZSB8fCBwcmV2aW91c0RldGFpbHMgIT0gbnVsbCAmJiBwcmV2aW91c0RldGFpbHMubGl2ZSkge1xuICAgICAgICBkZXRhaWxzLnJlbG9hZGVkKHByZXZpb3VzRGV0YWlscyk7XG4gICAgICAgIGlmIChwcmV2aW91c0RldGFpbHMpIHtcbiAgICAgICAgICB0aGlzLmxvZyhcImxpdmUgcGxheWxpc3QgXCIgKyBpbmRleCArIFwiIFwiICsgKGRldGFpbHMuYWR2YW5jZWQgPyAnUkVGUkVTSEVEICcgKyBkZXRhaWxzLmxhc3RQYXJ0U24gKyAnLScgKyBkZXRhaWxzLmxhc3RQYXJ0SW5kZXggOiBkZXRhaWxzLnVwZGF0ZWQgPyAnVVBEQVRFRCcgOiAnTUlTU0VEJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1lcmdlIGxpdmUgcGxheWxpc3RzIHRvIGFkanVzdCBmcmFnbWVudCBzdGFydHMgYW5kIGZpbGwgaW4gZGVsdGEgcGxheWxpc3Qgc2tpcHBlZCBzZWdtZW50c1xuICAgICAgICBpZiAocHJldmlvdXNEZXRhaWxzICYmIGRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBtZXJnZURldGFpbHMocHJldmlvdXNEZXRhaWxzLCBkZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2FuTG9hZCB8fCAhZGV0YWlscy5saXZlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxpdmVyeURpcmVjdGl2ZXM7XG4gICAgICAgIHZhciBtc24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBwYXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZGV0YWlscy5jYW5CbG9ja1JlbG9hZCAmJiBkZXRhaWxzLmVuZFNOICYmIGRldGFpbHMuYWR2YW5jZWQpIHtcbiAgICAgICAgICAvLyBMb2FkIGxldmVsIHdpdGggTEwtSExTIGRlbGl2ZXJ5IGRpcmVjdGl2ZXNcbiAgICAgICAgICB2YXIgbG93TGF0ZW5jeU1vZGUgPSB0aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGU7XG4gICAgICAgICAgdmFyIGxhc3RQYXJ0U24gPSBkZXRhaWxzLmxhc3RQYXJ0U247XG4gICAgICAgICAgdmFyIGVuZFNuID0gZGV0YWlscy5lbmRTTjtcbiAgICAgICAgICB2YXIgbGFzdFBhcnRJbmRleCA9IGRldGFpbHMubGFzdFBhcnRJbmRleDtcbiAgICAgICAgICB2YXIgaGFzUGFydHMgPSBsYXN0UGFydEluZGV4ICE9PSAtMTtcbiAgICAgICAgICB2YXIgbGFzdFBhcnQgPSBsYXN0UGFydFNuID09PSBlbmRTbjtcbiAgICAgICAgICAvLyBXaGVuIGxvdyBsYXRlbmN5IG1vZGUgaXMgZGlzYWJsZWQsIHdlJ2xsIHNraXAgcGFydCByZXF1ZXN0cyBvbmNlIHRoZSBsYXN0IHBhcnQgaW5kZXggaXMgZm91bmRcbiAgICAgICAgICB2YXIgbmV4dFNuU3RhcnRJbmRleCA9IGxvd0xhdGVuY3lNb2RlID8gMCA6IGxhc3RQYXJ0SW5kZXg7XG4gICAgICAgICAgaWYgKGhhc1BhcnRzKSB7XG4gICAgICAgICAgICBtc24gPSBsYXN0UGFydCA/IGVuZFNuICsgMSA6IGxhc3RQYXJ0U247XG4gICAgICAgICAgICBwYXJ0ID0gbGFzdFBhcnQgPyBuZXh0U25TdGFydEluZGV4IDogbGFzdFBhcnRJbmRleCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1zbiA9IGVuZFNuICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW46IFwiYWdlXCIgaGVhZGVyIGFuZCB0aW1lIHNpbmNlIGxvYWQgaW5kaWNhdGVzIHdlJ3JlIGJlaGluZCBieSBtb3JlIHRoYW4gb25lIHBhcnRcbiAgICAgICAgICAvLyBVcGRhdGUgZGlyZWN0aXZlcyB0byBvYnRhaW4gdGhlIFBsYXlsaXN0IHRoYXQgaGFzIHRoZSBlc3RpbWF0ZWQgYWRkaXRpb25hbCBkdXJhdGlvbiBvZiBtZWRpYVxuICAgICAgICAgIHZhciBsYXN0QWR2YW5jZWQgPSBkZXRhaWxzLmFnZTtcbiAgICAgICAgICB2YXIgY2RuQWdlID0gbGFzdEFkdmFuY2VkICsgZGV0YWlscy5hZ2VIZWFkZXI7XG4gICAgICAgICAgdmFyIGN1cnJlbnRHb2FsID0gTWF0aC5taW4oY2RuQWdlIC0gZGV0YWlscy5wYXJ0VGFyZ2V0LCBkZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMS41KTtcbiAgICAgICAgICBpZiAoY3VycmVudEdvYWwgPiAwKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNEZXRhaWxzICYmIGN1cnJlbnRHb2FsID4gcHJldmlvdXNEZXRhaWxzLnR1bmVJbkdvYWwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgd2UgYXR0ZW1wdGVkIHRvIGdldCB0aGUgbmV4dCBvciBsYXRlc3QgcGxheWxpc3QgdXBkYXRlLCBidXQgY3VycmVudEdvYWwgaW5jcmVhc2VkLFxuICAgICAgICAgICAgICAvLyB0aGVuIHdlIGVpdGhlciBjYW4ndCBjYXRjaHVwLCBvciB0aGUgXCJhZ2VcIiBoZWFkZXIgY2Fubm90IGJlIHRydXN0ZWQuXG4gICAgICAgICAgICAgIHRoaXMud2FybihcIkNETiBUdW5lLWluIGdvYWwgaW5jcmVhc2VkIGZyb206IFwiICsgcHJldmlvdXNEZXRhaWxzLnR1bmVJbkdvYWwgKyBcIiB0bzogXCIgKyBjdXJyZW50R29hbCArIFwiIHdpdGggcGxheWxpc3QgYWdlOiBcIiArIGRldGFpbHMuYWdlKTtcbiAgICAgICAgICAgICAgY3VycmVudEdvYWwgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gTWF0aC5mbG9vcihjdXJyZW50R29hbCAvIGRldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgICAgICAgICBtc24gKz0gc2VnbWVudHM7XG4gICAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBNYXRoLnJvdW5kKGN1cnJlbnRHb2FsICUgZGV0YWlscy50YXJnZXRkdXJhdGlvbiAvIGRldGFpbHMucGFydFRhcmdldCk7XG4gICAgICAgICAgICAgICAgcGFydCArPSBwYXJ0cztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmxvZyhcIkNETiBUdW5lLWluIGFnZTogXCIgKyBkZXRhaWxzLmFnZUhlYWRlciArIFwicyBsYXN0IGFkdmFuY2VkIFwiICsgbGFzdEFkdmFuY2VkLnRvRml4ZWQoMikgKyBcInMgZ29hbDogXCIgKyBjdXJyZW50R29hbCArIFwiIHNraXAgc24gXCIgKyBzZWdtZW50cyArIFwiIHRvIHBhcnQgXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRldGFpbHMudHVuZUluR29hbCA9IGN1cnJlbnRHb2FsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSB0aGlzLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyhkZXRhaWxzLCBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcywgbXNuLCBwYXJ0KTtcbiAgICAgICAgICBpZiAobG93TGF0ZW5jeU1vZGUgfHwgIWxhc3RQYXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdChkZWxpdmVyeURpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXRhaWxzLmNhbkJsb2NrUmVsb2FkIHx8IGRldGFpbHMuY2FuU2tpcFVudGlsKSB7XG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzID0gdGhpcy5nZXREZWxpdmVyeURpcmVjdGl2ZXMoZGV0YWlscywgZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMsIG1zbiwgcGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZmZlckluZm8gPSB0aGlzLmhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm87XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGJ1ZmZlckluZm8gPyBidWZmZXJJbmZvLmVuZCAtIGJ1ZmZlckluZm8ubGVuIDogMDtcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9MaXZlRWRnZU1zID0gKGRldGFpbHMuZWRnZSAtIHBvc2l0aW9uKSAqIDEwMDA7XG4gICAgICAgIHZhciByZWxvYWRJbnRlcnZhbCA9IGNvbXB1dGVSZWxvYWRJbnRlcnZhbChkZXRhaWxzLCBkaXN0YW5jZVRvTGl2ZUVkZ2VNcyk7XG4gICAgICAgIGlmIChkZXRhaWxzLnVwZGF0ZWQgJiYgbm93ID4gdGhpcy5yZXF1ZXN0U2NoZWR1bGVkICsgcmVsb2FkSW50ZXJ2YWwpIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSBzdGF0cy5sb2FkaW5nLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtc24gIT09IHVuZGVmaW5lZCAmJiBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkKSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gc3RhdHMubG9hZGluZy5maXJzdCArIHJlbG9hZEludGVydmFsIC0gKGRldGFpbHMucGFydFRhcmdldCAqIDEwMDAgfHwgMTAwMCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXF1ZXN0U2NoZWR1bGVkID09PSAtMSB8fCB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgKyByZWxvYWRJbnRlcnZhbCA8IG5vdykge1xuICAgICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IG5vdztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlcXVlc3RTY2hlZHVsZWQgLSBub3cgPD0gMCkge1xuICAgICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCArPSByZWxvYWRJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlID0gdGhpcy5yZXF1ZXN0U2NoZWR1bGVkIC0gbm93O1xuICAgICAgICBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgPSBNYXRoLm1heCgwLCBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUpO1xuICAgICAgICB0aGlzLmxvZyhcInJlbG9hZCBsaXZlIHBsYXlsaXN0IFwiICsgaW5kZXggKyBcIiBpbiBcIiArIE1hdGgucm91bmQoZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlKSArIFwiIG1zXCIpO1xuICAgICAgICAvLyB0aGlzLmxvZyhcbiAgICAgICAgLy8gICBgbGl2ZSByZWxvYWQgJHtkZXRhaWxzLnVwZGF0ZWQgPyAnUkVGUkVTSEVEJyA6ICdNSVNTRUQnfVxuICAgICAgICAvLyByZWxvYWQgaW4gJHtlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgLyAxMDAwfVxuICAgICAgICAvLyByb3VuZCB0cmlwICR7KHN0YXRzLmxvYWRpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5zdGFydCkgLyAxMDAwfVxuICAgICAgICAvLyBkaWZmICR7XG4gICAgICAgIC8vICAgKHJlbG9hZEludGVydmFsIC1cbiAgICAgICAgLy8gICAgIChlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgK1xuICAgICAgICAvLyAgICAgICBzdGF0cy5sb2FkaW5nLmVuZCAtXG4gICAgICAgIC8vICAgICAgIHN0YXRzLmxvYWRpbmcuc3RhcnQpKSAvXG4gICAgICAgIC8vICAgMTAwMFxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIHJlbG9hZCBpbnRlcnZhbCAke3JlbG9hZEludGVydmFsIC8gMTAwMH1cbiAgICAgICAgLy8gdGFyZ2V0IGR1cmF0aW9uICR7ZGV0YWlscy50YXJnZXRkdXJhdGlvbn1cbiAgICAgICAgLy8gZGlzdGFuY2UgdG8gZWRnZSAke2Rpc3RhbmNlVG9MaXZlRWRnZU1zIC8gMTAwMH1gXG4gICAgICAgIC8vICk7XG5cbiAgICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmxvYWRQbGF5bGlzdChkZWxpdmVyeURpcmVjdGl2ZXMpO1xuICAgICAgICB9LCBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0RGVsaXZlcnlEaXJlY3RpdmVzID0gZnVuY3Rpb24gZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKGRldGFpbHMsIHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLCBtc24sIHBhcnQpIHtcbiAgICAgIHZhciBza2lwID0gZ2V0U2tpcFZhbHVlKGRldGFpbHMpO1xuICAgICAgaWYgKHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzICE9IG51bGwgJiYgcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMuc2tpcCAmJiBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICAgIG1zbiA9IHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLm1zbjtcbiAgICAgICAgcGFydCA9IHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLnBhcnQ7XG4gICAgICAgIHNraXAgPSBIbHNTa2lwLk5vO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBIbHNVcmxQYXJhbWV0ZXJzKG1zbiwgcGFydCwgc2tpcCk7XG4gICAgfTtcbiAgICBfcHJvdG8uY2hlY2tSZXRyeSA9IGZ1bmN0aW9uIGNoZWNrUmV0cnkoZXJyb3JFdmVudCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgZXJyb3JEZXRhaWxzID0gZXJyb3JFdmVudC5kZXRhaWxzO1xuICAgICAgdmFyIGlzVGltZW91dCA9IGlzVGltZW91dEVycm9yKGVycm9yRXZlbnQpO1xuICAgICAgdmFyIGVycm9yQWN0aW9uID0gZXJyb3JFdmVudC5lcnJvckFjdGlvbjtcbiAgICAgIHZhciBfcmVmID0gZXJyb3JBY3Rpb24gfHwge30sXG4gICAgICAgIGFjdGlvbiA9IF9yZWYuYWN0aW9uLFxuICAgICAgICBfcmVmJHJldHJ5Q291bnQgPSBfcmVmLnJldHJ5Q291bnQsXG4gICAgICAgIHJldHJ5Q291bnQgPSBfcmVmJHJldHJ5Q291bnQgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHJldHJ5Q291bnQsXG4gICAgICAgIHJldHJ5Q29uZmlnID0gX3JlZi5yZXRyeUNvbmZpZztcbiAgICAgIHZhciByZXRyeSA9ICEhZXJyb3JBY3Rpb24gJiYgISFyZXRyeUNvbmZpZyAmJiAoYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0IHx8ICFlcnJvckFjdGlvbi5yZXNvbHZlZCAmJiBhY3Rpb24gPT09IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94KTtcbiAgICAgIGlmIChyZXRyeSkge1xuICAgICAgICB2YXIgX2Vycm9yRXZlbnQkY29udGV4dDtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gLTE7XG4gICAgICAgIGlmIChyZXRyeUNvdW50ID49IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RpbWVvdXQgJiYgKF9lcnJvckV2ZW50JGNvbnRleHQgPSBlcnJvckV2ZW50LmNvbnRleHQpICE9IG51bGwgJiYgX2Vycm9yRXZlbnQkY29udGV4dC5kZWxpdmVyeURpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAvLyBUaGUgTEwtSExTIHJlcXVlc3QgYWxyZWFkeSB0aW1lZCBvdXQgc28gcmV0cnkgaW1tZWRpYXRlbHlcbiAgICAgICAgICB0aGlzLndhcm4oXCJSZXRyeWluZyBwbGF5bGlzdCBsb2FkaW5nIFwiICsgKHJldHJ5Q291bnQgKyAxKSArIFwiL1wiICsgcmV0cnlDb25maWcubWF4TnVtUmV0cnkgKyBcIiBhZnRlciBcXFwiXCIgKyBlcnJvckRldGFpbHMgKyBcIlxcXCIgd2l0aG91dCBkZWxpdmVyeS1kaXJlY3RpdmVzXCIpO1xuICAgICAgICAgIHRoaXMubG9hZFBsYXlsaXN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRlbGF5ID0gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCk7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgbGV2ZWwvdHJhY2sgcmVsb2FkXG4gICAgICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLmxvYWRQbGF5bGlzdCgpO1xuICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICB0aGlzLndhcm4oXCJSZXRyeWluZyBwbGF5bGlzdCBsb2FkaW5nIFwiICsgKHJldHJ5Q291bnQgKyAxKSArIFwiL1wiICsgcmV0cnlDb25maWcubWF4TnVtUmV0cnkgKyBcIiBhZnRlciBcXFwiXCIgKyBlcnJvckRldGFpbHMgKyBcIlxcXCIgaW4gXCIgKyBkZWxheSArIFwibXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYGxldmVsUmV0cnkgPSB0cnVlYCB1c2VkIHRvIGluZm9ybSBvdGhlciBjb250cm9sbGVycyB0aGF0IGEgcmV0cnkgaXMgaGFwcGVuaW5nXG4gICAgICAgIGVycm9yRXZlbnQubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRyeTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlUGxheWxpc3RDb250cm9sbGVyO1xuICB9KCk7XG5cbiAgLypcbiAgICogY29tcHV0ZSBhbiBFeHBvbmVudGlhbCBXZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZVxuICAgKiAtIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vdmluZ19hdmVyYWdlI0V4cG9uZW50aWFsX21vdmluZ19hdmVyYWdlXG4gICAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAgICovXG4gIHZhciBFV01BID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAvLyAgQWJvdXQgaGFsZiBvZiB0aGUgZXN0aW1hdGVkIHZhbHVlIHdpbGwgYmUgZnJvbSB0aGUgbGFzdCB8aGFsZkxpZmV8IHNhbXBsZXMgYnkgd2VpZ2h0LlxuICAgIGZ1bmN0aW9uIEVXTUEoaGFsZkxpZmUsIGVzdGltYXRlLCB3ZWlnaHQpIHtcbiAgICAgIGlmIChlc3RpbWF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGVzdGltYXRlID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh3ZWlnaHQgPT09IHZvaWQgMCkge1xuICAgICAgICB3ZWlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5oYWxmTGlmZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuYWxwaGFfID0gdm9pZCAwO1xuICAgICAgdGhpcy5lc3RpbWF0ZV8gPSB2b2lkIDA7XG4gICAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaGFsZkxpZmUgPSBoYWxmTGlmZTtcbiAgICAgIC8vIExhcmdlciB2YWx1ZXMgb2YgYWxwaGEgZXhwaXJlIGhpc3RvcmljYWwgZGF0YSBtb3JlIHNsb3dseS5cbiAgICAgIHRoaXMuYWxwaGFfID0gaGFsZkxpZmUgPyBNYXRoLmV4cChNYXRoLmxvZygwLjUpIC8gaGFsZkxpZmUpIDogMDtcbiAgICAgIHRoaXMuZXN0aW1hdGVfID0gZXN0aW1hdGU7XG4gICAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IHdlaWdodDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IEVXTUEucHJvdG90eXBlO1xuICAgIF9wcm90by5zYW1wbGUgPSBmdW5jdGlvbiBzYW1wbGUod2VpZ2h0LCB2YWx1ZSkge1xuICAgICAgdmFyIGFkakFscGhhID0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHdlaWdodCk7XG4gICAgICB0aGlzLmVzdGltYXRlXyA9IHZhbHVlICogKDEgLSBhZGpBbHBoYSkgKyBhZGpBbHBoYSAqIHRoaXMuZXN0aW1hdGVfO1xuICAgICAgdGhpcy50b3RhbFdlaWdodF8gKz0gd2VpZ2h0O1xuICAgIH07XG4gICAgX3Byb3RvLmdldFRvdGFsV2VpZ2h0ID0gZnVuY3Rpb24gZ2V0VG90YWxXZWlnaHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0RXN0aW1hdGUgPSBmdW5jdGlvbiBnZXRFc3RpbWF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmFscGhhXykge1xuICAgICAgICB2YXIgemVyb0ZhY3RvciA9IDEgLSBNYXRoLnBvdyh0aGlzLmFscGhhXywgdGhpcy50b3RhbFdlaWdodF8pO1xuICAgICAgICBpZiAoemVyb0ZhY3Rvcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXyAvIHplcm9GYWN0b3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVzdGltYXRlXztcbiAgICB9O1xuICAgIHJldHVybiBFV01BO1xuICB9KCk7XG5cbiAgLypcbiAgICogRVdNQSBCYW5kd2lkdGggRXN0aW1hdG9yXG4gICAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAgICogVHJhY2tzIGJhbmR3aWR0aCBzYW1wbGVzIGFuZCBlc3RpbWF0ZXMgYXZhaWxhYmxlIGJhbmR3aWR0aC5cbiAgICogQmFzZWQgb24gdGhlIG1pbmltdW0gb2YgdHdvIGV4cG9uZW50aWFsbHktd2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VzIHdpdGhcbiAgICogZGlmZmVyZW50IGhhbGYtbGl2ZXMuXG4gICAqL1xuXG4gIHZhciBFd21hQmFuZFdpZHRoRXN0aW1hdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFd21hQmFuZFdpZHRoRXN0aW1hdG9yKHNsb3csIGZhc3QsIGRlZmF1bHRFc3RpbWF0ZSwgZGVmYXVsdFRURkIpIHtcbiAgICAgIGlmIChkZWZhdWx0VFRGQiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlZmF1bHRUVEZCID0gMTAwO1xuICAgICAgfVxuICAgICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gdm9pZCAwO1xuICAgICAgdGhpcy5taW5XZWlnaHRfID0gdm9pZCAwO1xuICAgICAgdGhpcy5taW5EZWxheU1zXyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuc2xvd18gPSB2b2lkIDA7XG4gICAgICB0aGlzLmZhc3RfID0gdm9pZCAwO1xuICAgICAgdGhpcy5kZWZhdWx0VFRGQl8gPSB2b2lkIDA7XG4gICAgICB0aGlzLnR0ZmJfID0gdm9pZCAwO1xuICAgICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gZGVmYXVsdEVzdGltYXRlO1xuICAgICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgICB0aGlzLm1pbkRlbGF5TXNfID0gNTA7XG4gICAgICB0aGlzLnNsb3dfID0gbmV3IEVXTUEoc2xvdyk7XG4gICAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCk7XG4gICAgICB0aGlzLmRlZmF1bHRUVEZCXyA9IGRlZmF1bHRUVEZCO1xuICAgICAgdGhpcy50dGZiXyA9IG5ldyBFV01BKHNsb3cpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gRXdtYUJhbmRXaWR0aEVzdGltYXRvci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzbG93LCBmYXN0KSB7XG4gICAgICB2YXIgc2xvd18gPSB0aGlzLnNsb3dfLFxuICAgICAgICBmYXN0XyA9IHRoaXMuZmFzdF8sXG4gICAgICAgIHR0ZmJfID0gdGhpcy50dGZiXztcbiAgICAgIGlmIChzbG93Xy5oYWxmTGlmZSAhPT0gc2xvdykge1xuICAgICAgICB0aGlzLnNsb3dfID0gbmV3IEVXTUEoc2xvdywgc2xvd18uZ2V0RXN0aW1hdGUoKSwgc2xvd18uZ2V0VG90YWxXZWlnaHQoKSk7XG4gICAgICB9XG4gICAgICBpZiAoZmFzdF8uaGFsZkxpZmUgIT09IGZhc3QpIHtcbiAgICAgICAgdGhpcy5mYXN0XyA9IG5ldyBFV01BKGZhc3QsIGZhc3RfLmdldEVzdGltYXRlKCksIGZhc3RfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgICAgfVxuICAgICAgaWYgKHR0ZmJfLmhhbGZMaWZlICE9PSBzbG93KSB7XG4gICAgICAgIHRoaXMudHRmYl8gPSBuZXcgRVdNQShzbG93LCB0dGZiXy5nZXRFc3RpbWF0ZSgpLCB0dGZiXy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zYW1wbGUgPSBmdW5jdGlvbiBzYW1wbGUoZHVyYXRpb25NcywgbnVtQnl0ZXMpIHtcbiAgICAgIGR1cmF0aW9uTXMgPSBNYXRoLm1heChkdXJhdGlvbk1zLCB0aGlzLm1pbkRlbGF5TXNfKTtcbiAgICAgIHZhciBudW1CaXRzID0gOCAqIG51bUJ5dGVzO1xuICAgICAgLy8gd2VpZ2h0IGlzIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICAgIHZhciBkdXJhdGlvblMgPSBkdXJhdGlvbk1zIC8gMTAwMDtcbiAgICAgIC8vIHZhbHVlIGlzIGJhbmR3aWR0aCBpbiBiaXRzL3NcbiAgICAgIHZhciBiYW5kd2lkdGhJbkJwcyA9IG51bUJpdHMgLyBkdXJhdGlvblM7XG4gICAgICB0aGlzLmZhc3RfLnNhbXBsZShkdXJhdGlvblMsIGJhbmR3aWR0aEluQnBzKTtcbiAgICAgIHRoaXMuc2xvd18uc2FtcGxlKGR1cmF0aW9uUywgYmFuZHdpZHRoSW5CcHMpO1xuICAgIH07XG4gICAgX3Byb3RvLnNhbXBsZVRURkIgPSBmdW5jdGlvbiBzYW1wbGVUVEZCKHR0ZmIpIHtcbiAgICAgIC8vIHdlaWdodCBpcyBmcmVxdWVuY3kgY3VydmUgYXBwbGllZCB0byBUVEZCIGluIHNlY29uZHNcbiAgICAgIC8vIChsb25nZXIgdGltZXMgaGF2ZSBsZXNzIHdlaWdodCB3aXRoIGV4cGVjdGVkIGlucHV0IHVuZGVyIDEgc2Vjb25kKVxuICAgICAgdmFyIHNlY29uZHMgPSB0dGZiIC8gMTAwMDtcbiAgICAgIHZhciB3ZWlnaHQgPSBNYXRoLnNxcnQoMikgKiBNYXRoLmV4cCgtTWF0aC5wb3coc2Vjb25kcywgMikgLyAyKTtcbiAgICAgIHRoaXMudHRmYl8uc2FtcGxlKHdlaWdodCwgTWF0aC5tYXgodHRmYiwgNSkpO1xuICAgIH07XG4gICAgX3Byb3RvLmNhbkVzdGltYXRlID0gZnVuY3Rpb24gY2FuRXN0aW1hdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYXN0Xy5nZXRUb3RhbFdlaWdodCgpID49IHRoaXMubWluV2VpZ2h0XztcbiAgICB9O1xuICAgIF9wcm90by5nZXRFc3RpbWF0ZSA9IGZ1bmN0aW9uIGdldEVzdGltYXRlKCkge1xuICAgICAgaWYgKHRoaXMuY2FuRXN0aW1hdGUoKSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnc2xvdyBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnZmFzdCBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgICAvLyBUYWtlIHRoZSBtaW5pbXVtIG9mIHRoZXNlIHR3byBlc3RpbWF0ZXMuICBUaGlzIHNob3VsZCBoYXZlIHRoZSBlZmZlY3Qgb2ZcbiAgICAgICAgLy8gYWRhcHRpbmcgZG93biBxdWlja2x5LCBidXQgdXAgbW9yZSBzbG93bHkuXG4gICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZhc3RfLmdldEVzdGltYXRlKCksIHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdldEVzdGltYXRlVFRGQiA9IGZ1bmN0aW9uIGdldEVzdGltYXRlVFRGQigpIHtcbiAgICAgIGlmICh0aGlzLnR0ZmJfLmdldFRvdGFsV2VpZ2h0KCkgPj0gdGhpcy5taW5XZWlnaHRfKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR0ZmJfLmdldEVzdGltYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0VFRGQl87XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fTtcbiAgICByZXR1cm4gRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcbiAgfSgpO1xuXG4gIHZhciBTVVBQT1JURURfSU5GT19ERUZBVUxUID0ge1xuICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICBjb25maWd1cmF0aW9uczogW10sXG4gICAgZGVjb2RpbmdJbmZvUmVzdWx0czogW3tcbiAgICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICAgIHBvd2VyRWZmaWNpZW50OiB0cnVlLFxuICAgICAgc21vb3RoOiB0cnVlXG4gICAgfV1cbiAgfTtcbiAgdmFyIFNVUFBPUlRFRF9JTkZPX0NBQ0hFID0ge307XG4gIGZ1bmN0aW9uIHJlcXVpcmVzTWVkaWFDYXBhYmlsaXRpZXNEZWNvZGluZ0luZm8obGV2ZWwsIGF1ZGlvVHJhY2tzQnlHcm91cCwgY3VycmVudFZpZGVvUmFuZ2UsIGN1cnJlbnRGcmFtZVJhdGUsIGN1cnJlbnRCdywgYXVkaW9QcmVmZXJlbmNlKSB7XG4gICAgLy8gT25seSB0ZXN0IHN1cHBvcnQgd2hlbiBjb25maWd1cmF0aW9uIGlzIGV4Y2VlZHMgbWluaW11bSBvcHRpb25zXG4gICAgdmFyIGF1ZGlvR3JvdXBzID0gbGV2ZWwuYXVkaW9Db2RlYyA/IGxldmVsLmF1ZGlvR3JvdXBzIDogbnVsbDtcbiAgICB2YXIgYXVkaW9Db2RlY1ByZWZlcmVuY2UgPSBhdWRpb1ByZWZlcmVuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGF1ZGlvUHJlZmVyZW5jZS5hdWRpb0NvZGVjO1xuICAgIHZhciBjaGFubmVsc1ByZWZlcmVuY2UgPSBhdWRpb1ByZWZlcmVuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGF1ZGlvUHJlZmVyZW5jZS5jaGFubmVscztcbiAgICB2YXIgbWF4Q2hhbm5lbHMgPSBjaGFubmVsc1ByZWZlcmVuY2UgPyBwYXJzZUludChjaGFubmVsc1ByZWZlcmVuY2UpIDogYXVkaW9Db2RlY1ByZWZlcmVuY2UgPyBJbmZpbml0eSA6IDI7XG4gICAgdmFyIGF1ZGlvQ2hhbm5lbHMgPSBudWxsO1xuICAgIGlmIChhdWRpb0dyb3VwcyAhPSBudWxsICYmIGF1ZGlvR3JvdXBzLmxlbmd0aCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGF1ZGlvR3JvdXBzLmxlbmd0aCA9PT0gMSAmJiBhdWRpb0dyb3Vwc1swXSkge1xuICAgICAgICAgIGF1ZGlvQ2hhbm5lbHMgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW2F1ZGlvR3JvdXBzWzBdXS5jaGFubmVscztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdWRpb0NoYW5uZWxzID0gYXVkaW9Hcm91cHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGdyb3VwSWQpIHtcbiAgICAgICAgICAgIGlmIChncm91cElkKSB7XG4gICAgICAgICAgICAgIHZhciBhdWRpb1RyYWNrR3JvdXAgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgICAgICAgICBpZiAoIWF1ZGlvVHJhY2tHcm91cCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1ZGlvIHRyYWNrIGdyb3VwIFwiICsgZ3JvdXBJZCArIFwiIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBTdW0gYWxsIGNoYW5uZWwga2V5IHZhbHVlc1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhdWRpb1RyYWNrR3JvdXAuY2hhbm5lbHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gKGFjY1trZXldIHx8IDApICsgYXVkaW9UcmFja0dyb3VwLmNoYW5uZWxzW2tleV07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAyOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGV2ZWwudmlkZW9Db2RlYyAhPT0gdW5kZWZpbmVkICYmIChsZXZlbC53aWR0aCA+IDE5MjAgJiYgbGV2ZWwuaGVpZ2h0ID4gMTA4OCB8fCBsZXZlbC5oZWlnaHQgPiAxOTIwICYmIGxldmVsLndpZHRoID4gMTA4OCB8fCBsZXZlbC5mcmFtZVJhdGUgPiBNYXRoLm1heChjdXJyZW50RnJhbWVSYXRlLCAzMCkgfHwgbGV2ZWwudmlkZW9SYW5nZSAhPT0gJ1NEUicgJiYgbGV2ZWwudmlkZW9SYW5nZSAhPT0gY3VycmVudFZpZGVvUmFuZ2UgfHwgbGV2ZWwuYml0cmF0ZSA+IE1hdGgubWF4KGN1cnJlbnRCdywgOGU2KSkgfHwgISFhdWRpb0NoYW5uZWxzICYmIGlzRmluaXRlTnVtYmVyKG1heENoYW5uZWxzKSAmJiBPYmplY3Qua2V5cyhhdWRpb0NoYW5uZWxzKS5zb21lKGZ1bmN0aW9uIChjaGFubmVscykge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGNoYW5uZWxzKSA+IG1heENoYW5uZWxzO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldE1lZGlhRGVjb2RpbmdJbmZvUHJvbWlzZShsZXZlbCwgYXVkaW9UcmFja3NCeUdyb3VwLCBtZWRpYUNhcGFiaWxpdGllcykge1xuICAgIHZhciB2aWRlb0NvZGVjcyA9IGxldmVsLnZpZGVvQ29kZWM7XG4gICAgdmFyIGF1ZGlvQ29kZWNzID0gbGV2ZWwuYXVkaW9Db2RlYztcbiAgICBpZiAoIXZpZGVvQ29kZWNzIHx8ICFhdWRpb0NvZGVjcyB8fCAhbWVkaWFDYXBhYmlsaXRpZXMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoU1VQUE9SVEVEX0lORk9fREVGQVVMVCk7XG4gICAgfVxuICAgIHZhciBiYXNlVmlkZW9Db25maWd1cmF0aW9uID0ge1xuICAgICAgd2lkdGg6IGxldmVsLndpZHRoLFxuICAgICAgaGVpZ2h0OiBsZXZlbC5oZWlnaHQsXG4gICAgICBiaXRyYXRlOiBNYXRoLmNlaWwoTWF0aC5tYXgobGV2ZWwuYml0cmF0ZSAqIDAuOSwgbGV2ZWwuYXZlcmFnZUJpdHJhdGUpKSxcbiAgICAgIC8vIEFzc3VtZSBhIGZyYW1lcmF0ZSBvZiAzMGZwcyBzaW5jZSBNZWRpYUNhcGFiaWxpdGllcyB3aWxsIG5vdCBhY2NlcHQgTGV2ZWwgZGVmYXVsdCBvZiAwLlxuICAgICAgZnJhbWVyYXRlOiBsZXZlbC5mcmFtZVJhdGUgfHwgMzBcbiAgICB9O1xuICAgIHZhciB2aWRlb1JhbmdlID0gbGV2ZWwudmlkZW9SYW5nZTtcbiAgICBpZiAodmlkZW9SYW5nZSAhPT0gJ1NEUicpIHtcbiAgICAgIGJhc2VWaWRlb0NvbmZpZ3VyYXRpb24udHJhbnNmZXJGdW5jdGlvbiA9IHZpZGVvUmFuZ2UudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgdmFyIGNvbmZpZ3VyYXRpb25zID0gdmlkZW9Db2RlY3Muc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHZpZGVvQ29kZWMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdtZWRpYS1zb3VyY2UnLFxuICAgICAgICB2aWRlbzogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VWaWRlb0NvbmZpZ3VyYXRpb24pLCB7fSwge1xuICAgICAgICAgIGNvbnRlbnRUeXBlOiBtaW1lVHlwZUZvckNvZGVjKHZpZGVvQ29kZWMsICd2aWRlbycpXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGlmIChhdWRpb0NvZGVjcyAmJiBsZXZlbC5hdWRpb0dyb3Vwcykge1xuICAgICAgbGV2ZWwuYXVkaW9Hcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoYXVkaW9Hcm91cElkKSB7XG4gICAgICAgIHZhciBfYXVkaW9UcmFja3NCeUdyb3VwJGc7XG4gICAgICAgIGlmICghYXVkaW9Hcm91cElkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIChfYXVkaW9UcmFja3NCeUdyb3VwJGcgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW2F1ZGlvR3JvdXBJZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYXVkaW9UcmFja3NCeUdyb3VwJGcudHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGF1ZGlvVHJhY2spIHtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFjay5ncm91cElkID09PSBhdWRpb0dyb3VwSWQpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVscyA9IGF1ZGlvVHJhY2suY2hhbm5lbHMgfHwgJyc7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbHNOdW1iZXIgPSBwYXJzZUZsb2F0KGNoYW5uZWxzKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihjaGFubmVsc051bWJlcikgJiYgY2hhbm5lbHNOdW1iZXIgPiAyKSB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25zLnB1c2guYXBwbHkoY29uZmlndXJhdGlvbnMsIGF1ZGlvQ29kZWNzLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChhdWRpb0NvZGVjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdtZWRpYS1zb3VyY2UnLFxuICAgICAgICAgICAgICAgICAgYXVkaW86IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IG1pbWVUeXBlRm9yQ29kZWMoYXVkaW9Db2RlYywgJ2F1ZGlvJyksXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzOiAnJyArIGNoYW5uZWxzTnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwYXRpYWxSZW5kZXJpbmc6XG4gICAgICAgICAgICAgICAgICAgIC8vICAgYXVkaW9Db2RlYyA9PT0gJ2VjLTMnICYmIGNoYW5uZWxzLmluZGV4T2YoJ0pPQycpLFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChjb25maWd1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIC8vIENhY2hlIE1lZGlhQ2FwYWJpbGl0aWVzIHByb21pc2VzXG4gICAgICB2YXIgZGVjb2RpbmdJbmZvS2V5ID0gZ2V0TWVkaWFEZWNvZGluZ0luZm9LZXkoY29uZmlndXJhdGlvbik7XG4gICAgICByZXR1cm4gU1VQUE9SVEVEX0lORk9fQ0FDSEVbZGVjb2RpbmdJbmZvS2V5XSB8fCAoU1VQUE9SVEVEX0lORk9fQ0FDSEVbZGVjb2RpbmdJbmZvS2V5XSA9IG1lZGlhQ2FwYWJpbGl0aWVzLmRlY29kaW5nSW5mbyhjb25maWd1cmF0aW9uKSk7XG4gICAgfSkpLnRoZW4oZnVuY3Rpb24gKGRlY29kaW5nSW5mb1Jlc3VsdHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1cHBvcnRlZDogIWRlY29kaW5nSW5mb1Jlc3VsdHMuc29tZShmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgIHJldHVybiAhaW5mby5zdXBwb3J0ZWQ7XG4gICAgICAgIH0pLFxuICAgICAgICBjb25maWd1cmF0aW9uczogY29uZmlndXJhdGlvbnMsXG4gICAgICAgIGRlY29kaW5nSW5mb1Jlc3VsdHM6IGRlY29kaW5nSW5mb1Jlc3VsdHNcbiAgICAgIH07XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdXBwb3J0ZWQ6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmF0aW9uczogY29uZmlndXJhdGlvbnMsXG4gICAgICAgIGRlY29kaW5nSW5mb1Jlc3VsdHM6IFtdLFxuICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TWVkaWFEZWNvZGluZ0luZm9LZXkoY29uZmlnKSB7XG4gICAgdmFyIGF1ZGlvID0gY29uZmlnLmF1ZGlvLFxuICAgICAgdmlkZW8gPSBjb25maWcudmlkZW87XG4gICAgdmFyIG1lZGlhQ29uZmlnID0gdmlkZW8gfHwgYXVkaW87XG4gICAgaWYgKG1lZGlhQ29uZmlnKSB7XG4gICAgICB2YXIgY29kZWMgPSBtZWRpYUNvbmZpZy5jb250ZW50VHlwZS5zcGxpdCgnXCInKVsxXTtcbiAgICAgIGlmICh2aWRlbykge1xuICAgICAgICByZXR1cm4gXCJyXCIgKyB2aWRlby5oZWlnaHQgKyBcInhcIiArIHZpZGVvLndpZHRoICsgXCJmXCIgKyBNYXRoLmNlaWwodmlkZW8uZnJhbWVyYXRlKSArICh2aWRlby50cmFuc2ZlckZ1bmN0aW9uIHx8ICdzZCcpICsgXCJfXCIgKyBjb2RlYyArIFwiX1wiICsgTWF0aC5jZWlsKHZpZGVvLmJpdHJhdGUgLyAxZTUpO1xuICAgICAgfVxuICAgICAgaWYgKGF1ZGlvKSB7XG4gICAgICAgIHJldHVybiBcImNcIiArIGF1ZGlvLmNoYW5uZWxzICsgKGF1ZGlvLnNwYXRpYWxSZW5kZXJpbmcgPyAncycgOiAnbicpICsgXCJfXCIgKyBjb2RlYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgd2UgY2FuIGRldGVjdCBhbmQgdmFsaWRhdGUgSERSIGNhcGFiaWxpdHkgd2l0aGluIHRoZSB3aW5kb3cgY29udGV4dFxuICAgKi9cbiAgZnVuY3Rpb24gaXNIZHJTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKHR5cGVvZiBtYXRjaE1lZGlhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgbWVkaWFRdWVyeUxpc3QgPSBtYXRjaE1lZGlhKCcoZHluYW1pYy1yYW5nZTogaGlnaCknKTtcbiAgICAgIHZhciBiYWRRdWVyeSA9IG1hdGNoTWVkaWEoJ2JhZCBxdWVyeScpO1xuICAgICAgaWYgKG1lZGlhUXVlcnlMaXN0Lm1lZGlhICE9PSBiYWRRdWVyeS5tZWRpYSkge1xuICAgICAgICByZXR1cm4gbWVkaWFRdWVyeUxpc3QubWF0Y2hlcyA9PT0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhbml0aXplcyBpbnB1dHMgdG8gcmV0dXJuIHRoZSBhY3RpdmUgdmlkZW8gc2VsZWN0aW9uIG9wdGlvbnMgZm9yIEhEUi9TRFIuXG4gICAqIFdoZW4gYm90aCBpbnB1dHMgYXJlIG51bGw6XG4gICAqXG4gICAqICAgIGB7IHByZWZlckhEUjogZmFsc2UsIGFsbG93ZWRWaWRlb1JhbmdlczogW10gfWBcbiAgICpcbiAgICogV2hlbiBgY3VycmVudFZpZGVvUmFuZ2VgIG5vbi1udWxsLCBtYWludGFpbiB0aGUgYWN0aXZlIHJhbmdlOlxuICAgKlxuICAgKiAgICBgeyBwcmVmZXJIRFI6IGN1cnJlbnRWaWRlb1JhbmdlICE9PSAnU0RSJywgYWxsb3dlZFZpZGVvUmFuZ2VzOiBbY3VycmVudFZpZGVvUmFuZ2VdIH1gXG4gICAqXG4gICAqIFdoZW4gVmlkZW9TZWxlY3Rpb25PcHRpb24gbm9uLW51bGw6XG4gICAqXG4gICAqICAtIEFsbG93IGFsbCB2aWRlbyByYW5nZXMgaWYgYGFsbG93ZWRWaWRlb1Jhbmdlc2AgdW5zcGVjaWZpZWQuXG4gICAqICAtIElmIGBwcmVmZXJIRFJgIGlzIG5vbi1udWxsIHVzZSB0aGUgdmFsdWUgdG8gZmlsdGVyIGBhbGxvd2VkVmlkZW9SYW5nZXNgLlxuICAgKiAgLSBFbHNlIGNoZWNrIHdpbmRvdyBmb3IgSERSIHN1cHBvcnQgYW5kIHNldCBgcHJlZmVySERSYCB0byB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBAcGFyYW0gY3VycmVudFZpZGVvUmFuZ2VcbiAgICogQHBhcmFtIHZpZGVvUHJlZmVyZW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmlkZW9TZWxlY3Rpb25PcHRpb25zKGN1cnJlbnRWaWRlb1JhbmdlLCB2aWRlb1ByZWZlcmVuY2UpIHtcbiAgICB2YXIgcHJlZmVySERSID0gZmFsc2U7XG4gICAgdmFyIGFsbG93ZWRWaWRlb1JhbmdlcyA9IFtdO1xuICAgIGlmIChjdXJyZW50VmlkZW9SYW5nZSkge1xuICAgICAgcHJlZmVySERSID0gY3VycmVudFZpZGVvUmFuZ2UgIT09ICdTRFInO1xuICAgICAgYWxsb3dlZFZpZGVvUmFuZ2VzID0gW2N1cnJlbnRWaWRlb1JhbmdlXTtcbiAgICB9XG4gICAgaWYgKHZpZGVvUHJlZmVyZW5jZSkge1xuICAgICAgYWxsb3dlZFZpZGVvUmFuZ2VzID0gdmlkZW9QcmVmZXJlbmNlLmFsbG93ZWRWaWRlb1JhbmdlcyB8fCBWaWRlb1JhbmdlVmFsdWVzLnNsaWNlKDApO1xuICAgICAgcHJlZmVySERSID0gdmlkZW9QcmVmZXJlbmNlLnByZWZlckhEUiAhPT0gdW5kZWZpbmVkID8gdmlkZW9QcmVmZXJlbmNlLnByZWZlckhEUiA6IGlzSGRyU3VwcG9ydGVkKCk7XG4gICAgICBpZiAocHJlZmVySERSKSB7XG4gICAgICAgIGFsbG93ZWRWaWRlb1JhbmdlcyA9IGFsbG93ZWRWaWRlb1Jhbmdlcy5maWx0ZXIoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlICE9PSAnU0RSJztcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd2VkVmlkZW9SYW5nZXMgPSBbJ1NEUiddO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcHJlZmVySERSOiBwcmVmZXJIRFIsXG4gICAgICBhbGxvd2VkVmlkZW9SYW5nZXM6IGFsbG93ZWRWaWRlb1Jhbmdlc1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdGFydENvZGVjVGllcihjb2RlY1RpZXJzLCBjdXJyZW50VmlkZW9SYW5nZSwgY3VycmVudEJ3LCBhdWRpb1ByZWZlcmVuY2UsIHZpZGVvUHJlZmVyZW5jZSkge1xuICAgIHZhciBjb2RlY1NldHMgPSBPYmplY3Qua2V5cyhjb2RlY1RpZXJzKTtcbiAgICB2YXIgY2hhbm5lbHNQcmVmZXJlbmNlID0gYXVkaW9QcmVmZXJlbmNlID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb1ByZWZlcmVuY2UuY2hhbm5lbHM7XG4gICAgdmFyIGF1ZGlvQ29kZWNQcmVmZXJlbmNlID0gYXVkaW9QcmVmZXJlbmNlID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb1ByZWZlcmVuY2UuYXVkaW9Db2RlYztcbiAgICB2YXIgcHJlZmVyU3RlcmVvID0gY2hhbm5lbHNQcmVmZXJlbmNlICYmIHBhcnNlSW50KGNoYW5uZWxzUHJlZmVyZW5jZSkgPT09IDI7XG4gICAgLy8gVXNlIGZpcnN0IGxldmVsIHNldCB0byBkZXRlcm1pbmUgc3RlcmVvLCBhbmQgbWluaW11bSByZXNvbHV0aW9uIGFuZCBmcmFtZXJhdGVcbiAgICB2YXIgaGFzU3RlcmVvID0gdHJ1ZTtcbiAgICB2YXIgaGFzQ3VycmVudFZpZGVvUmFuZ2UgPSBmYWxzZTtcbiAgICB2YXIgbWluSGVpZ2h0ID0gSW5maW5pdHk7XG4gICAgdmFyIG1pbkZyYW1lcmF0ZSA9IEluZmluaXR5O1xuICAgIHZhciBtaW5CaXRyYXRlID0gSW5maW5pdHk7XG4gICAgdmFyIHNlbGVjdGVkU2NvcmUgPSAwO1xuICAgIHZhciB2aWRlb1JhbmdlcyA9IFtdO1xuICAgIHZhciBfZ2V0VmlkZW9TZWxlY3Rpb25PcHQgPSBnZXRWaWRlb1NlbGVjdGlvbk9wdGlvbnMoY3VycmVudFZpZGVvUmFuZ2UsIHZpZGVvUHJlZmVyZW5jZSksXG4gICAgICBwcmVmZXJIRFIgPSBfZ2V0VmlkZW9TZWxlY3Rpb25PcHQucHJlZmVySERSLFxuICAgICAgYWxsb3dlZFZpZGVvUmFuZ2VzID0gX2dldFZpZGVvU2VsZWN0aW9uT3B0LmFsbG93ZWRWaWRlb1JhbmdlcztcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciB0aWVyID0gY29kZWNUaWVyc1tjb2RlY1NldHNbaV1dO1xuICAgICAgaGFzU3RlcmVvID0gdGllci5jaGFubmVsc1syXSA+IDA7XG4gICAgICBtaW5IZWlnaHQgPSBNYXRoLm1pbihtaW5IZWlnaHQsIHRpZXIubWluSGVpZ2h0KTtcbiAgICAgIG1pbkZyYW1lcmF0ZSA9IE1hdGgubWluKG1pbkZyYW1lcmF0ZSwgdGllci5taW5GcmFtZXJhdGUpO1xuICAgICAgbWluQml0cmF0ZSA9IE1hdGgubWluKG1pbkJpdHJhdGUsIHRpZXIubWluQml0cmF0ZSk7XG4gICAgICB2YXIgbWF0Y2hpbmdWaWRlb1JhbmdlcyA9IGFsbG93ZWRWaWRlb1Jhbmdlcy5maWx0ZXIoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aWVyLnZpZGVvUmFuZ2VzW3JhbmdlXSA+IDA7XG4gICAgICB9KTtcbiAgICAgIGlmIChtYXRjaGluZ1ZpZGVvUmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaGFzQ3VycmVudFZpZGVvUmFuZ2UgPSB0cnVlO1xuICAgICAgICB2aWRlb1JhbmdlcyA9IG1hdGNoaW5nVmlkZW9SYW5nZXM7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gY29kZWNTZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgX2xvb3AoKTtcbiAgICB9XG4gICAgbWluSGVpZ2h0ID0gaXNGaW5pdGVOdW1iZXIobWluSGVpZ2h0KSA/IG1pbkhlaWdodCA6IDA7XG4gICAgbWluRnJhbWVyYXRlID0gaXNGaW5pdGVOdW1iZXIobWluRnJhbWVyYXRlKSA/IG1pbkZyYW1lcmF0ZSA6IDA7XG4gICAgdmFyIG1heEhlaWdodCA9IE1hdGgubWF4KDEwODAsIG1pbkhlaWdodCk7XG4gICAgdmFyIG1heEZyYW1lcmF0ZSA9IE1hdGgubWF4KDMwLCBtaW5GcmFtZXJhdGUpO1xuICAgIG1pbkJpdHJhdGUgPSBpc0Zpbml0ZU51bWJlcihtaW5CaXRyYXRlKSA/IG1pbkJpdHJhdGUgOiBjdXJyZW50Qnc7XG4gICAgY3VycmVudEJ3ID0gTWF0aC5tYXgobWluQml0cmF0ZSwgY3VycmVudEJ3KTtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gdmFyaWFudHMgd2l0aCBtYXRjaGluZyBwcmVmZXJlbmNlLCBzZXQgY3VycmVudFZpZGVvUmFuZ2UgdG8gdW5kZWZpbmVkXG4gICAgaWYgKCFoYXNDdXJyZW50VmlkZW9SYW5nZSkge1xuICAgICAgY3VycmVudFZpZGVvUmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICB2aWRlb1JhbmdlcyA9IFtdO1xuICAgIH1cbiAgICB2YXIgY29kZWNTZXQgPSBjb2RlY1NldHMucmVkdWNlKGZ1bmN0aW9uIChzZWxlY3RlZCwgY2FuZGlkYXRlKSB7XG4gICAgICAvLyBSZW1vdmUgY2FuZGlhdGVzIHdoaWNoIGRvIG5vdCBtZWV0IGJpdHJhdGUsIGRlZmF1bHQgYXVkaW8sIHN0ZXJlbyBvciBjaGFubmVscyBwcmVmZXJlbmNlLCAxMDgwcCBvciBsb3dlciwgMzBmcHMgb3IgbG93ZXIsIG9yIFNEUi9IRFIgc2VsZWN0aW9uIGlmIHByZXNlbnRcbiAgICAgIHZhciBjYW5kaWRhdGVUaWVyID0gY29kZWNUaWVyc1tjYW5kaWRhdGVdO1xuICAgICAgaWYgKGNhbmRpZGF0ZSA9PT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZVRpZXIubWluQml0cmF0ZSA+IGN1cnJlbnRCdykge1xuICAgICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjYW5kaWRhdGUsIFwibWluIGJpdHJhdGUgb2YgXCIgKyBjYW5kaWRhdGVUaWVyLm1pbkJpdHJhdGUgKyBcIiA+IGN1cnJlbnQgZXN0aW1hdGUgb2YgXCIgKyBjdXJyZW50QncpO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWNhbmRpZGF0ZVRpZXIuaGFzRGVmYXVsdEF1ZGlvKSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgXCJubyByZW5kaXRpb25zIHdpdGggZGVmYXVsdCBvciBhdXRvLXNlbGVjdCBzb3VuZCBmb3VuZFwiKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgaWYgKGF1ZGlvQ29kZWNQcmVmZXJlbmNlICYmIGNhbmRpZGF0ZS5pbmRleE9mKGF1ZGlvQ29kZWNQcmVmZXJlbmNlLnN1YnN0cmluZygwLCA0KSkgJSA1ICE9PSAwKSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgXCJhdWRpbyBjb2RlYyBwcmVmZXJlbmNlIFxcXCJcIiArIGF1ZGlvQ29kZWNQcmVmZXJlbmNlICsgXCJcXFwiIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW5uZWxzUHJlZmVyZW5jZSAmJiAhcHJlZmVyU3RlcmVvKSB7XG4gICAgICAgIGlmICghY2FuZGlkYXRlVGllci5jaGFubmVsc1tjaGFubmVsc1ByZWZlcmVuY2VdKSB7XG4gICAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBcIm5vIHJlbmRpdGlvbnMgd2l0aCBcIiArIGNoYW5uZWxzUHJlZmVyZW5jZSArIFwiIGNoYW5uZWwgc291bmQgZm91bmQgKGNoYW5uZWxzIG9wdGlvbnM6IFwiICsgT2JqZWN0LmtleXMoY2FuZGlkYXRlVGllci5jaGFubmVscykgKyBcIilcIik7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCghYXVkaW9Db2RlY1ByZWZlcmVuY2UgfHwgcHJlZmVyU3RlcmVvKSAmJiBoYXNTdGVyZW8gJiYgY2FuZGlkYXRlVGllci5jaGFubmVsc1snMiddID09PSAwKSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgXCJubyByZW5kaXRpb25zIHdpdGggc3RlcmVvIHNvdW5kIGZvdW5kXCIpO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlVGllci5taW5IZWlnaHQgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBcIm1pbiByZXNvbHV0aW9uIG9mIFwiICsgY2FuZGlkYXRlVGllci5taW5IZWlnaHQgKyBcIiA+IG1heGltdW0gb2YgXCIgKyBtYXhIZWlnaHQpO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlVGllci5taW5GcmFtZXJhdGUgPiBtYXhGcmFtZXJhdGUpIHtcbiAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBcIm1pbiBmcmFtZXJhdGUgb2YgXCIgKyBjYW5kaWRhdGVUaWVyLm1pbkZyYW1lcmF0ZSArIFwiID4gbWF4aW11bSBvZiBcIiArIG1heEZyYW1lcmF0ZSk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmICghdmlkZW9SYW5nZXMuc29tZShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZVRpZXIudmlkZW9SYW5nZXNbcmFuZ2VdID4gMDtcbiAgICAgIH0pKSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgXCJubyB2YXJpYW50cyB3aXRoIFZJREVPLVJBTkdFIG9mIFwiICsgSlNPTi5zdHJpbmdpZnkodmlkZW9SYW5nZXMpICsgXCIgZm91bmRcIik7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGVUaWVyLm1heFNjb3JlIDwgc2VsZWN0ZWRTY29yZSkge1xuICAgICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjYW5kaWRhdGUsIFwibWF4IHNjb3JlIG9mIFwiICsgY2FuZGlkYXRlVGllci5tYXhTY29yZSArIFwiIDwgc2VsZWN0ZWQgbWF4IG9mIFwiICsgc2VsZWN0ZWRTY29yZSk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBjYW5kaWF0ZXMgd2l0aCBsZXNzIHByZWZlcnJlZCBjb2RlY3Mgb3IgbW9yZSBlcnJvcnNcbiAgICAgIGlmIChzZWxlY3RlZCAmJiAoY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKGNhbmRpZGF0ZSkgPj0gY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKHNlbGVjdGVkKSB8fCBjYW5kaWRhdGVUaWVyLmZyYWdtZW50RXJyb3IgPiBjb2RlY1RpZXJzW3NlbGVjdGVkXS5mcmFnbWVudEVycm9yKSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBzZWxlY3RlZFNjb3JlID0gY2FuZGlkYXRlVGllci5tYXhTY29yZTtcbiAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfSwgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZWNTZXQ6IGNvZGVjU2V0LFxuICAgICAgdmlkZW9SYW5nZXM6IHZpZGVvUmFuZ2VzLFxuICAgICAgcHJlZmVySERSOiBwcmVmZXJIRFIsXG4gICAgICBtaW5GcmFtZXJhdGU6IG1pbkZyYW1lcmF0ZSxcbiAgICAgIG1pbkJpdHJhdGU6IG1pbkJpdHJhdGVcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNvZGVTZXQsIHJlYXNvbikge1xuICAgIGxvZ2dlci5sb2coXCJbYWJyXSBzdGFydCBjYW5kaWRhdGVzIHdpdGggXFxcIlwiICsgY29kZVNldCArIFwiXFxcIiBpZ25vcmVkIGJlY2F1c2UgXCIgKyByZWFzb24pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEF1ZGlvVHJhY2tzQnlHcm91cChhbGxBdWRpb1RyYWNrcykge1xuICAgIHJldHVybiBhbGxBdWRpb1RyYWNrcy5yZWR1Y2UoZnVuY3Rpb24gKGF1ZGlvVHJhY2tzQnlHcm91cCwgdHJhY2spIHtcbiAgICAgIHZhciB0cmFja0dyb3VwID0gYXVkaW9UcmFja3NCeUdyb3VwLmdyb3Vwc1t0cmFjay5ncm91cElkXTtcbiAgICAgIGlmICghdHJhY2tHcm91cCkge1xuICAgICAgICB0cmFja0dyb3VwID0gYXVkaW9UcmFja3NCeUdyb3VwLmdyb3Vwc1t0cmFjay5ncm91cElkXSA9IHtcbiAgICAgICAgICB0cmFja3M6IFtdLFxuICAgICAgICAgIGNoYW5uZWxzOiB7XG4gICAgICAgICAgICAyOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYXNEZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICBoYXNBdXRvU2VsZWN0OiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdHJhY2tHcm91cC50cmFja3MucHVzaCh0cmFjayk7XG4gICAgICB2YXIgY2hhbm5lbHNLZXkgPSB0cmFjay5jaGFubmVscyB8fCAnMic7XG4gICAgICB0cmFja0dyb3VwLmNoYW5uZWxzW2NoYW5uZWxzS2V5XSA9ICh0cmFja0dyb3VwLmNoYW5uZWxzW2NoYW5uZWxzS2V5XSB8fCAwKSArIDE7XG4gICAgICB0cmFja0dyb3VwLmhhc0RlZmF1bHQgPSB0cmFja0dyb3VwLmhhc0RlZmF1bHQgfHwgdHJhY2suZGVmYXVsdDtcbiAgICAgIHRyYWNrR3JvdXAuaGFzQXV0b1NlbGVjdCA9IHRyYWNrR3JvdXAuaGFzQXV0b1NlbGVjdCB8fCB0cmFjay5hdXRvc2VsZWN0O1xuICAgICAgaWYgKHRyYWNrR3JvdXAuaGFzRGVmYXVsdCkge1xuICAgICAgICBhdWRpb1RyYWNrc0J5R3JvdXAuaGFzRGVmYXVsdEF1ZGlvID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFja0dyb3VwLmhhc0F1dG9TZWxlY3QpIHtcbiAgICAgICAgYXVkaW9UcmFja3NCeUdyb3VwLmhhc0F1dG9TZWxlY3RBdWRpbyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXVkaW9UcmFja3NCeUdyb3VwO1xuICAgIH0sIHtcbiAgICAgIGhhc0RlZmF1bHRBdWRpbzogZmFsc2UsXG4gICAgICBoYXNBdXRvU2VsZWN0QXVkaW86IGZhbHNlLFxuICAgICAgZ3JvdXBzOiB7fVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldENvZGVjVGllcnMobGV2ZWxzLCBhdWRpb1RyYWNrc0J5R3JvdXAsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsKSB7XG4gICAgcmV0dXJuIGxldmVscy5zbGljZShtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCArIDEpLnJlZHVjZShmdW5jdGlvbiAodGllcnMsIGxldmVsKSB7XG4gICAgICBpZiAoIWxldmVsLmNvZGVjU2V0KSB7XG4gICAgICAgIHJldHVybiB0aWVycztcbiAgICAgIH1cbiAgICAgIHZhciBhdWRpb0dyb3VwcyA9IGxldmVsLmF1ZGlvR3JvdXBzO1xuICAgICAgdmFyIHRpZXIgPSB0aWVyc1tsZXZlbC5jb2RlY1NldF07XG4gICAgICBpZiAoIXRpZXIpIHtcbiAgICAgICAgdGllcnNbbGV2ZWwuY29kZWNTZXRdID0gdGllciA9IHtcbiAgICAgICAgICBtaW5CaXRyYXRlOiBJbmZpbml0eSxcbiAgICAgICAgICBtaW5IZWlnaHQ6IEluZmluaXR5LFxuICAgICAgICAgIG1pbkZyYW1lcmF0ZTogSW5maW5pdHksXG4gICAgICAgICAgbWF4U2NvcmU6IDAsXG4gICAgICAgICAgdmlkZW9SYW5nZXM6IHtcbiAgICAgICAgICAgIFNEUjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hhbm5lbHM6IHtcbiAgICAgICAgICAgICcyJzogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFzRGVmYXVsdEF1ZGlvOiAhYXVkaW9Hcm91cHMsXG4gICAgICAgICAgZnJhZ21lbnRFcnJvcjogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGllci5taW5CaXRyYXRlID0gTWF0aC5taW4odGllci5taW5CaXRyYXRlLCBsZXZlbC5iaXRyYXRlKTtcbiAgICAgIHZhciBsZXNzZXJXaWR0aE9ySGVpZ2h0ID0gTWF0aC5taW4obGV2ZWwuaGVpZ2h0LCBsZXZlbC53aWR0aCk7XG4gICAgICB0aWVyLm1pbkhlaWdodCA9IE1hdGgubWluKHRpZXIubWluSGVpZ2h0LCBsZXNzZXJXaWR0aE9ySGVpZ2h0KTtcbiAgICAgIHRpZXIubWluRnJhbWVyYXRlID0gTWF0aC5taW4odGllci5taW5GcmFtZXJhdGUsIGxldmVsLmZyYW1lUmF0ZSk7XG4gICAgICB0aWVyLm1heFNjb3JlID0gTWF0aC5tYXgodGllci5tYXhTY29yZSwgbGV2ZWwuc2NvcmUpO1xuICAgICAgdGllci5mcmFnbWVudEVycm9yICs9IGxldmVsLmZyYWdtZW50RXJyb3I7XG4gICAgICB0aWVyLnZpZGVvUmFuZ2VzW2xldmVsLnZpZGVvUmFuZ2VdID0gKHRpZXIudmlkZW9SYW5nZXNbbGV2ZWwudmlkZW9SYW5nZV0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGF1ZGlvR3JvdXBzKSB7XG4gICAgICAgIGF1ZGlvR3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgIGlmICghYXVkaW9Hcm91cElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhdWRpb0dyb3VwID0gYXVkaW9UcmFja3NCeUdyb3VwLmdyb3Vwc1thdWRpb0dyb3VwSWRdO1xuICAgICAgICAgIGlmICghYXVkaW9Hcm91cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEZWZhdWx0IGF1ZGlvIGlzIGFueSBncm91cCB3aXRoIERFRkFVTFQ9WUVTLCBvciBpZiBtaXNzaW5nIHRoZW4gYW55IGdyb3VwIHdpdGggQVVUT1NFTEVDVD1ZRVMsIG9yIGFsbCB2YXJpYW50c1xuICAgICAgICAgIHRpZXIuaGFzRGVmYXVsdEF1ZGlvID0gdGllci5oYXNEZWZhdWx0QXVkaW8gfHwgYXVkaW9UcmFja3NCeUdyb3VwLmhhc0RlZmF1bHRBdWRpbyA/IGF1ZGlvR3JvdXAuaGFzRGVmYXVsdCA6IGF1ZGlvR3JvdXAuaGFzQXV0b1NlbGVjdCB8fCAhYXVkaW9UcmFja3NCeUdyb3VwLmhhc0RlZmF1bHRBdWRpbyAmJiAhYXVkaW9UcmFja3NCeUdyb3VwLmhhc0F1dG9TZWxlY3RBdWRpbztcbiAgICAgICAgICBPYmplY3Qua2V5cyhhdWRpb0dyb3VwLmNoYW5uZWxzKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVscykge1xuICAgICAgICAgICAgdGllci5jaGFubmVsc1tjaGFubmVsc10gPSAodGllci5jaGFubmVsc1tjaGFubmVsc10gfHwgMCkgKyBhdWRpb0dyb3VwLmNoYW5uZWxzW2NoYW5uZWxzXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGllcnM7XG4gICAgfSwge30pO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRNYXRjaGluZ09wdGlvbihvcHRpb24sIHRyYWNrcywgbWF0Y2hQcmVkaWNhdGUpIHtcbiAgICBpZiAoJ2F0dHJzJyBpbiBvcHRpb24pIHtcbiAgICAgIHZhciBpbmRleCA9IHRyYWNrcy5pbmRleE9mKG9wdGlvbik7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICBpZiAobWF0Y2hlc09wdGlvbihvcHRpb24sIF90cmFjaywgbWF0Y2hQcmVkaWNhdGUpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hlc09wdGlvbihvcHRpb24sIHRyYWNrLCBtYXRjaFByZWRpY2F0ZSkge1xuICAgIHZhciBncm91cElkID0gb3B0aW9uLmdyb3VwSWQsXG4gICAgICBuYW1lID0gb3B0aW9uLm5hbWUsXG4gICAgICBsYW5nID0gb3B0aW9uLmxhbmcsXG4gICAgICBhc3NvY0xhbmcgPSBvcHRpb24uYXNzb2NMYW5nLFxuICAgICAgY2hhcmFjdGVyaXN0aWNzID0gb3B0aW9uLmNoYXJhY3RlcmlzdGljcyxcbiAgICAgIGlzRGVmYXVsdCA9IG9wdGlvbi5kZWZhdWx0O1xuICAgIHZhciBmb3JjZWQgPSBvcHRpb24uZm9yY2VkO1xuICAgIHJldHVybiAoZ3JvdXBJZCA9PT0gdW5kZWZpbmVkIHx8IHRyYWNrLmdyb3VwSWQgPT09IGdyb3VwSWQpICYmIChuYW1lID09PSB1bmRlZmluZWQgfHwgdHJhY2submFtZSA9PT0gbmFtZSkgJiYgKGxhbmcgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5sYW5nID09PSBsYW5nKSAmJiAobGFuZyA9PT0gdW5kZWZpbmVkIHx8IHRyYWNrLmFzc29jTGFuZyA9PT0gYXNzb2NMYW5nKSAmJiAoaXNEZWZhdWx0ID09PSB1bmRlZmluZWQgfHwgdHJhY2suZGVmYXVsdCA9PT0gaXNEZWZhdWx0KSAmJiAoZm9yY2VkID09PSB1bmRlZmluZWQgfHwgdHJhY2suZm9yY2VkID09PSBmb3JjZWQpICYmIChjaGFyYWN0ZXJpc3RpY3MgPT09IHVuZGVmaW5lZCB8fCBjaGFyYWN0ZXJpc3RpY3NNYXRjaChjaGFyYWN0ZXJpc3RpY3MsIHRyYWNrLmNoYXJhY3RlcmlzdGljcykpICYmIChtYXRjaFByZWRpY2F0ZSA9PT0gdW5kZWZpbmVkIHx8IG1hdGNoUHJlZGljYXRlKG9wdGlvbiwgdHJhY2spKTtcbiAgfVxuICBmdW5jdGlvbiBjaGFyYWN0ZXJpc3RpY3NNYXRjaChjaGFyYWN0ZXJpc3RpY3NBLCBjaGFyYWN0ZXJpc3RpY3NCKSB7XG4gICAgaWYgKGNoYXJhY3RlcmlzdGljc0IgPT09IHZvaWQgMCkge1xuICAgICAgY2hhcmFjdGVyaXN0aWNzQiA9ICcnO1xuICAgIH1cbiAgICB2YXIgYXJyQSA9IGNoYXJhY3RlcmlzdGljc0Euc3BsaXQoJywnKTtcbiAgICB2YXIgYXJyQiA9IGNoYXJhY3RlcmlzdGljc0Iuc3BsaXQoJywnKTtcbiAgICAvLyBFeHBlY3RzIGVhY2ggaXRlbSB0byBiZSB1bmlxdWU6XG4gICAgcmV0dXJuIGFyckEubGVuZ3RoID09PSBhcnJCLmxlbmd0aCAmJiAhYXJyQS5zb21lKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGFyckIuaW5kZXhPZihlbCkgPT09IC0xO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGF1ZGlvTWF0Y2hQcmVkaWNhdGUob3B0aW9uLCB0cmFjaykge1xuICAgIHZhciBhdWRpb0NvZGVjID0gb3B0aW9uLmF1ZGlvQ29kZWMsXG4gICAgICBjaGFubmVscyA9IG9wdGlvbi5jaGFubmVscztcbiAgICByZXR1cm4gKGF1ZGlvQ29kZWMgPT09IHVuZGVmaW5lZCB8fCAodHJhY2suYXVkaW9Db2RlYyB8fCAnJykuc3Vic3RyaW5nKDAsIDQpID09PSBhdWRpb0NvZGVjLnN1YnN0cmluZygwLCA0KSkgJiYgKGNoYW5uZWxzID09PSB1bmRlZmluZWQgfHwgY2hhbm5lbHMgPT09ICh0cmFjay5jaGFubmVscyB8fCAnMicpKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kQ2xvc2VzdExldmVsV2l0aEF1ZGlvR3JvdXAob3B0aW9uLCBsZXZlbHMsIGFsbEF1ZGlvVHJhY2tzLCBzZWFyY2hJbmRleCwgbWF0Y2hQcmVkaWNhdGUpIHtcbiAgICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzW3NlYXJjaEluZGV4XTtcbiAgICAvLyBBcmUgdGhlcmUgdmFyaWFudHMgd2l0aCBzYW1lIFVSSSBhcyBjdXJyZW50IGxldmVsP1xuICAgIC8vIElmIHNvLCBmaW5kIGEgbWF0Y2ggdGhhdCBkb2VzIG5vdCByZXF1aXJlIGFueSBsZXZlbCBVUkkgY2hhbmdlXG4gICAgdmFyIHZhcmlhbnRzID0gbGV2ZWxzLnJlZHVjZShmdW5jdGlvbiAodmFyaWFudE1hcCwgbGV2ZWwsIGluZGV4KSB7XG4gICAgICB2YXIgdXJpID0gbGV2ZWwudXJpO1xuICAgICAgdmFyIHJlbmRpdGlvbnMgPSB2YXJpYW50TWFwW3VyaV0gfHwgKHZhcmlhbnRNYXBbdXJpXSA9IFtdKTtcbiAgICAgIHJlbmRpdGlvbnMucHVzaChpbmRleCk7XG4gICAgICByZXR1cm4gdmFyaWFudE1hcDtcbiAgICB9LCB7fSk7XG4gICAgdmFyIHJlbmRpdGlvbnMgPSB2YXJpYW50c1tjdXJyZW50TGV2ZWwudXJpXTtcbiAgICBpZiAocmVuZGl0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICBzZWFyY2hJbmRleCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHJlbmRpdGlvbnMpO1xuICAgIH1cbiAgICAvLyBGaW5kIGJlc3QgbWF0Y2hcbiAgICB2YXIgY3VycmVudFZpZGVvUmFuZ2UgPSBjdXJyZW50TGV2ZWwudmlkZW9SYW5nZTtcbiAgICB2YXIgY3VycmVudEZyYW1lUmF0ZSA9IGN1cnJlbnRMZXZlbC5mcmFtZVJhdGU7XG4gICAgdmFyIGN1cnJlbnRWaWRlb0NvZGVjID0gY3VycmVudExldmVsLmNvZGVjU2V0LnN1YnN0cmluZygwLCA0KTtcbiAgICB2YXIgbWF0Y2hpbmdWaWRlbyA9IHNlYXJjaERvd25BbmRVcExpc3QobGV2ZWxzLCBzZWFyY2hJbmRleCwgZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICBpZiAobGV2ZWwudmlkZW9SYW5nZSAhPT0gY3VycmVudFZpZGVvUmFuZ2UgfHwgbGV2ZWwuZnJhbWVSYXRlICE9PSBjdXJyZW50RnJhbWVSYXRlIHx8IGxldmVsLmNvZGVjU2V0LnN1YnN0cmluZygwLCA0KSAhPT0gY3VycmVudFZpZGVvQ29kZWMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGF1ZGlvR3JvdXBzID0gbGV2ZWwuYXVkaW9Hcm91cHM7XG4gICAgICB2YXIgdHJhY2tzID0gYWxsQXVkaW9UcmFja3MuZmlsdGVyKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gIWF1ZGlvR3JvdXBzIHx8IGF1ZGlvR3JvdXBzLmluZGV4T2YodHJhY2suZ3JvdXBJZCkgIT09IC0xO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmluZE1hdGNoaW5nT3B0aW9uKG9wdGlvbiwgdHJhY2tzLCBtYXRjaFByZWRpY2F0ZSkgPiAtMTtcbiAgICB9KTtcbiAgICBpZiAobWF0Y2hpbmdWaWRlbyA+IC0xKSB7XG4gICAgICByZXR1cm4gbWF0Y2hpbmdWaWRlbztcbiAgICB9XG4gICAgcmV0dXJuIHNlYXJjaERvd25BbmRVcExpc3QobGV2ZWxzLCBzZWFyY2hJbmRleCwgZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICB2YXIgYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0dyb3VwcztcbiAgICAgIHZhciB0cmFja3MgPSBhbGxBdWRpb1RyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHJldHVybiAhYXVkaW9Hcm91cHMgfHwgYXVkaW9Hcm91cHMuaW5kZXhPZih0cmFjay5ncm91cElkKSAhPT0gLTE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmaW5kTWF0Y2hpbmdPcHRpb24ob3B0aW9uLCB0cmFja3MsIG1hdGNoUHJlZGljYXRlKSA+IC0xO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNlYXJjaERvd25BbmRVcExpc3QoYXJyLCBzZWFyY2hJbmRleCwgcHJlZGljYXRlKSB7XG4gICAgZm9yICh2YXIgaSA9IHNlYXJjaEluZGV4OyBpID4gLTE7IGktLSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJbaV0pKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IHNlYXJjaEluZGV4ICsgMTsgX2kgPCBhcnIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycltfaV0pKSB7XG4gICAgICAgIHJldHVybiBfaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdmFyIEFickNvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFickNvbnRyb2xsZXIoX2hscykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5sYXN0TGV2ZWxMb2FkU2VjID0gMDtcbiAgICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IC0xO1xuICAgICAgdGhpcy5maXJzdFNlbGVjdGlvbiA9IC0xO1xuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgICAgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID0gJyc7XG4gICAgICB0aGlzLmF1ZGlvVHJhY2tzQnlHcm91cCA9IG51bGw7XG4gICAgICB0aGlzLmNvZGVjVGllcnMgPSBudWxsO1xuICAgICAgdGhpcy50aW1lciA9IC0xO1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3REZWxheSA9IDA7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yID0gdm9pZCAwO1xuICAgICAgLypcbiAgICAgICAgICBUaGlzIG1ldGhvZCBtb25pdG9ycyB0aGUgZG93bmxvYWQgcmF0ZSBvZiB0aGUgY3VycmVudCBmcmFnbWVudCwgYW5kIHdpbGwgZG93bnN3aXRjaCBpZiB0aGF0IGZyYWdtZW50IHdpbGwgbm90IGxvYWRcbiAgICAgICAgICBxdWlja2x5IGVub3VnaCB0byBwcmV2ZW50IHVuZGVyYnVmZmVyaW5nXG4gICAgICAgICovXG4gICAgICB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBfdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgICBwYXJ0ID0gX3RoaXMucGFydEN1cnJlbnQsXG4gICAgICAgICAgaGxzID0gX3RoaXMuaGxzO1xuICAgICAgICB2YXIgYXV0b0xldmVsRW5hYmxlZCA9IGhscy5hdXRvTGV2ZWxFbmFibGVkLFxuICAgICAgICAgIG1lZGlhID0gaGxzLm1lZGlhO1xuICAgICAgICBpZiAoIWZyYWcgfHwgIW1lZGlhKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdmFyIHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBwYXJ0ID8gcGFydC5kdXJhdGlvbiA6IGZyYWcuZHVyYXRpb247XG4gICAgICAgIHZhciB0aW1lTG9hZGluZyA9IG5vdyAtIHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgICAgIHZhciBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xuICAgICAgICAvLyBJZiBmcmFnIGxvYWRpbmcgaXMgYWJvcnRlZCwgY29tcGxldGUsIG9yIGZyb20gbG93ZXN0IGxldmVsLCBzdG9wIHRpbWVyIGFuZCByZXR1cm5cbiAgICAgICAgaWYgKHN0YXRzLmFib3J0ZWQgfHwgc3RhdHMubG9hZGVkICYmIHN0YXRzLmxvYWRlZCA9PT0gc3RhdHMudG90YWwgfHwgZnJhZy5sZXZlbCA8PSBtaW5BdXRvTGV2ZWwpIHtcbiAgICAgICAgICBfdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAgICAgLy8gcmVzZXQgZm9yY2VkIGF1dG8gbGV2ZWwgdmFsdWUgc28gdGhhdCBuZXh0IGxldmVsIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICAgICAgICBfdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgb25seSBydW5zIGlmIHdlJ3JlIGluIEFCUiBtb2RlIGFuZCBhY3R1YWxseSBwbGF5aW5nXG4gICAgICAgIGlmICghYXV0b0xldmVsRW5hYmxlZCB8fCBtZWRpYS5wYXVzZWQgfHwgIW1lZGlhLnBsYXliYWNrUmF0ZSB8fCAhbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVySW5mbyA9IGhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm87XG4gICAgICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0dGZiRXN0aW1hdGUgPSBfdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKTtcbiAgICAgICAgdmFyIHBsYXliYWNrUmF0ZSA9IE1hdGguYWJzKG1lZGlhLnBsYXliYWNrUmF0ZSk7XG4gICAgICAgIC8vIFRvIG1haW50YWluIHN0YWJsZSBhZGFwdGl2ZSBwbGF5YmFjaywgb25seSBiZWdpbiBtb25pdG9yaW5nIGZyYWcgbG9hZGluZyBhZnRlciBoYWxmIG9yIG1vcmUgb2YgaXRzIHBsYXliYWNrIGR1cmF0aW9uIGhhcyBwYXNzZWRcbiAgICAgICAgaWYgKHRpbWVMb2FkaW5nIDw9IE1hdGgubWF4KHR0ZmJFc3RpbWF0ZSwgMTAwMCAqIChkdXJhdGlvbiAvIChwbGF5YmFja1JhdGUgKiAyKSkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIGFuIGVzdGltYXRlIG9mIHRoZSBhbW91bnQgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGV4aGF1c3QgdGhlIGJ1ZmZlclxuICAgICAgICB2YXIgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gYnVmZmVySW5mby5sZW4gLyBwbGF5YmFja1JhdGU7XG4gICAgICAgIHZhciB0dGZiID0gc3RhdHMubG9hZGluZy5maXJzdCA/IHN0YXRzLmxvYWRpbmcuZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0IDogLTE7XG4gICAgICAgIHZhciBsb2FkZWRGaXJzdEJ5dGUgPSBzdGF0cy5sb2FkZWQgJiYgdHRmYiA+IC0xO1xuICAgICAgICB2YXIgYndFc3RpbWF0ZSA9IF90aGlzLmdldEJ3RXN0aW1hdGUoKTtcbiAgICAgICAgdmFyIGxldmVscyA9IGhscy5sZXZlbHM7XG4gICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgICAgdmFyIGV4cGVjdGVkTGVuID0gc3RhdHMudG90YWwgfHwgTWF0aC5tYXgoc3RhdHMubG9hZGVkLCBNYXRoLnJvdW5kKGR1cmF0aW9uICogbGV2ZWwuYXZlcmFnZUJpdHJhdGUgLyA4KSk7XG4gICAgICAgIHZhciB0aW1lU3RyZWFtaW5nID0gbG9hZGVkRmlyc3RCeXRlID8gdGltZUxvYWRpbmcgLSB0dGZiIDogdGltZUxvYWRpbmc7XG4gICAgICAgIGlmICh0aW1lU3RyZWFtaW5nIDwgMSAmJiBsb2FkZWRGaXJzdEJ5dGUpIHtcbiAgICAgICAgICB0aW1lU3RyZWFtaW5nID0gTWF0aC5taW4odGltZUxvYWRpbmcsIHN0YXRzLmxvYWRlZCAqIDggLyBid0VzdGltYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9hZFJhdGUgPSBsb2FkZWRGaXJzdEJ5dGUgPyBzdGF0cy5sb2FkZWQgKiAxMDAwIC8gdGltZVN0cmVhbWluZyA6IDA7XG4gICAgICAgIC8vIGZyYWdMb2FkRGVsYXkgaXMgYW4gZXN0aW1hdGUgb2YgdGhlIHRpbWUgKGluIHNlY29uZHMpIGl0IHdpbGwgdGFrZSB0byBidWZmZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgZnJhZ21lbnRcbiAgICAgICAgdmFyIGZyYWdMb2FkZWREZWxheSA9IGxvYWRSYXRlID8gKGV4cGVjdGVkTGVuIC0gc3RhdHMubG9hZGVkKSAvIGxvYWRSYXRlIDogZXhwZWN0ZWRMZW4gKiA4IC8gYndFc3RpbWF0ZSArIHR0ZmJFc3RpbWF0ZSAvIDEwMDA7XG4gICAgICAgIC8vIE9ubHkgZG93bnN3aXRjaCBpZiB0aGUgdGltZSB0byBmaW5pc2ggbG9hZGluZyB0aGUgY3VycmVudCBmcmFnbWVudCBpcyBncmVhdGVyIHRoYW4gdGhlIGFtb3VudCBvZiBidWZmZXIgbGVmdFxuICAgICAgICBpZiAoZnJhZ0xvYWRlZERlbGF5IDw9IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYndlID0gbG9hZFJhdGUgPyBsb2FkUmF0ZSAqIDggOiBid0VzdGltYXRlO1xuICAgICAgICB2YXIgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB2YXIgbmV4dExvYWRMZXZlbDtcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGxvd2VyIGxldmVsIGFuZCB0cnkgdG8gZmluZCB0aGUgbGFyZ2VzdCBvbmUgdGhhdCBhdm9pZHMgcmVidWZmZXJpbmdcbiAgICAgICAgZm9yIChuZXh0TG9hZExldmVsID0gZnJhZy5sZXZlbCAtIDE7IG5leHRMb2FkTGV2ZWwgPiBtaW5BdXRvTGV2ZWw7IG5leHRMb2FkTGV2ZWwtLSkge1xuICAgICAgICAgIC8vIGNvbXB1dGUgdGltZSB0byBsb2FkIG5leHQgZnJhZ21lbnQgYXQgbG93ZXIgbGV2ZWxcbiAgICAgICAgICAvLyA4ID0gYml0cyBwZXIgYnl0ZSAoYnBzL0JwcylcbiAgICAgICAgICB2YXIgbGV2ZWxOZXh0Qml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5tYXhCaXRyYXRlO1xuICAgICAgICAgIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IF90aGlzLmdldFRpbWVUb0xvYWRGcmFnKHR0ZmJFc3RpbWF0ZSAvIDEwMDAsIGJ3ZSwgZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlLCAhbGV2ZWxzW25leHRMb2FkTGV2ZWxdLmRldGFpbHMpO1xuICAgICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGVtZXJnZW5jeSBzd2l0Y2ggZG93biBpZiBpdCB0YWtlcyBsZXNzIHRpbWUgdG8gbG9hZCBhIG5ldyBmcmFnbWVudCBhdCBsb3dlc3QgbGV2ZWwgaW5zdGVhZCBvZiBjb250aW51aW5nXG4gICAgICAgIC8vIHRvIGxvYWQgdGhlIGN1cnJlbnQgb25lXG4gICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPj0gZnJhZ0xvYWRlZERlbGF5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgZXN0aW1hdGVkIGxvYWQgdGltZSBvZiBuZXcgc2VnbWVudCBpcyBjb21wbGV0ZWx5IHVucmVhc29uYWJsZSwgaWdub3JlIGFuZCBkbyBub3QgZW1lcmdlbmN5IHN3aXRjaCBkb3duXG4gICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPiBkdXJhdGlvbiAqIDEwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhscy5uZXh0TG9hZExldmVsID0gaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TG9hZExldmVsO1xuICAgICAgICBpZiAobG9hZGVkRmlyc3RCeXRlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgaGFzIGJlZW4gbG9hZGluZyBwcm9ncmVzcywgc2FtcGxlIGJhbmR3aWR0aCB1c2luZyBsb2FkaW5nIHRpbWUgb2Zmc2V0IGJ5IG1pbmltdW0gVFRGQiB0aW1lXG4gICAgICAgICAgX3RoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHRpbWVMb2FkaW5nIC0gTWF0aC5taW4odHRmYkVzdGltYXRlLCB0dGZiKSwgc3RhdHMubG9hZGVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBoYXMgYmVlbiBubyBsb2FkaW5nIHByb2dyZXNzLCBzYW1wbGUgVFRGQlxuICAgICAgICAgIF90aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZVRURkIodGltZUxvYWRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0TG9hZExldmVsQml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5tYXhCaXRyYXRlO1xuICAgICAgICBpZiAoX3RoaXMuZ2V0QndFc3RpbWF0ZSgpICogX3RoaXMuaGxzLmNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvciA+IG5leHRMb2FkTGV2ZWxCaXRyYXRlKSB7XG4gICAgICAgICAgX3RoaXMucmVzZXRFc3RpbWF0b3IobmV4dExvYWRMZXZlbEJpdHJhdGUpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJbYWJyXSBGcmFnbWVudCBcIiArIGZyYWcuc24gKyAocGFydCA/ICcgcGFydCAnICsgcGFydC5pbmRleCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIGlzIGxvYWRpbmcgdG9vIHNsb3dseTtcXG4gICAgICBUaW1lIHRvIHVuZGVyYnVmZmVyOiBcIiArIGJ1ZmZlclN0YXJ2YXRpb25EZWxheS50b0ZpeGVkKDMpICsgXCIgc1xcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIGN1cnJlbnQgZnJhZ21lbnQ6IFwiICsgZnJhZ0xvYWRlZERlbGF5LnRvRml4ZWQoMykgKyBcIiBzXFxuICAgICAgRXN0aW1hdGVkIGxvYWQgdGltZSBmb3IgZG93biBzd2l0Y2ggZnJhZ21lbnQ6IFwiICsgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LnRvRml4ZWQoMykgKyBcIiBzXFxuICAgICAgVFRGQiBlc3RpbWF0ZTogXCIgKyAodHRmYiB8IDApICsgXCIgbXNcXG4gICAgICBDdXJyZW50IEJXIGVzdGltYXRlOiBcIiArIChpc0Zpbml0ZU51bWJlcihid0VzdGltYXRlKSA/IGJ3RXN0aW1hdGUgfCAwIDogJ1Vua25vd24nKSArIFwiIGJwc1xcbiAgICAgIE5ldyBCVyBlc3RpbWF0ZTogXCIgKyAoX3RoaXMuZ2V0QndFc3RpbWF0ZSgpIHwgMCkgKyBcIiBicHNcXG4gICAgICBTd2l0Y2hpbmcgdG8gbGV2ZWwgXCIgKyBuZXh0TG9hZExldmVsICsgXCIgQCBcIiArIChuZXh0TG9hZExldmVsQml0cmF0ZSB8IDApICsgXCIgYnBzXCIpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB7XG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgIHN0YXRzOiBzdGF0c1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmhscyA9IF9obHM7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yID0gdGhpcy5pbml0RXN0aW1hdG9yKCk7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBBYnJDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVzZXRFc3RpbWF0b3IgPSBmdW5jdGlvbiByZXNldEVzdGltYXRvcihhYnJFd21hRGVmYXVsdEVzdGltYXRlKSB7XG4gICAgICBpZiAoYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkge1xuICAgICAgICBsb2dnZXIubG9nKFwic2V0dGluZyBpbml0aWFsIGJ3ZSB0byBcIiArIGFickV3bWFEZWZhdWx0RXN0aW1hdGUpO1xuICAgICAgICB0aGlzLmhscy5jb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSA9IGFickV3bWFEZWZhdWx0RXN0aW1hdGU7XG4gICAgICB9XG4gICAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yID0gdGhpcy5pbml0RXN0aW1hdG9yKCk7XG4gICAgfTtcbiAgICBfcHJvdG8uaW5pdEVzdGltYXRvciA9IGZ1bmN0aW9uIGluaXRFc3RpbWF0b3IoKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgICAgcmV0dXJuIG5ldyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yKGNvbmZpZy5hYnJFd21hU2xvd1ZvRCwgY29uZmlnLmFickV3bWFGYXN0Vm9ELCBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQVhfQVVUT19MRVZFTF9VUERBVEVELCB0aGlzLm9uTWF4QXV0b0xldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKCFobHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFYX0FVVE9fTEVWRUxfVVBEQVRFRCwgdGhpcy5vbk1heEF1dG9MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5obHMgPSB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjayA9IG51bGw7XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gLTE7XG4gICAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgICB0aGlzLmxhc3RMZXZlbExvYWRTZWMgPSAwO1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5vbkxldmVsc1VwZGF0ZWQoKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTGV2ZWxzVXBkYXRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxzVXBkYXRlZCgpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPiAtMSAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IHRoaXMuZnJhZ0N1cnJlbnQubGV2ZWw7XG4gICAgICB9XG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICB0aGlzLm9uTWF4QXV0b0xldmVsVXBkYXRlZCgpO1xuICAgICAgdGhpcy5jb2RlY1RpZXJzID0gbnVsbDtcbiAgICAgIHRoaXMuYXVkaW9UcmFja3NCeUdyb3VwID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5vbk1heEF1dG9MZXZlbFVwZGF0ZWQgPSBmdW5jdGlvbiBvbk1heEF1dG9MZXZlbFVwZGF0ZWQoKSB7XG4gICAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgICB0aGlzLm5leHRBdXRvTGV2ZWxLZXkgPSAnJztcbiAgICB9O1xuICAgIF9wcm90by5vbkZyYWdMb2FkaW5nID0gZnVuY3Rpb24gb25GcmFnTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgdmFyIF9kYXRhJHBhcnQ7XG4gICAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgICB0aGlzLnBhcnRDdXJyZW50ID0gKF9kYXRhJHBhcnQgPSBkYXRhLnBhcnQpICE9IG51bGwgPyBfZGF0YSRwYXJ0IDogbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5fYWJhbmRvblJ1bGVzQ2hlY2ssIDEwMCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbFN3aXRjaGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SOlxuICAgICAgICAgIC8vIFJlc2V0IGxhc3QgbG9hZGVkIGxldmVsIHNvIHRoYXQgYSBuZXcgc2VsZWN0aW9uIGNhbiBiZSBtYWRlIGFmdGVyIGNhbGxpbmcgcmVjb3Zlck1lZGlhRXJyb3JcbiAgICAgICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAtMTtcbiAgICAgICAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VUOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgICAgICAgICAgcGFydCA9IHRoaXMucGFydEN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoZnJhZyAmJiBmcmFnQ3VycmVudCAmJiBmcmFnLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJiBmcmFnLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCkge1xuICAgICAgICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgIHZhciBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgICAgICAgICAgdmFyIHRpbWVMb2FkaW5nID0gbm93IC0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICAgICAgICAgICAgdmFyIHR0ZmIgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ID8gc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQgOiAtMTtcbiAgICAgICAgICAgICAgdmFyIGxvYWRlZEZpcnN0Qnl0ZSA9IHN0YXRzLmxvYWRlZCAmJiB0dGZiID4gLTE7XG4gICAgICAgICAgICAgIGlmIChsb2FkZWRGaXJzdEJ5dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHRmYkVzdGltYXRlID0gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZSh0aW1lTG9hZGluZyAtIE1hdGgubWluKHR0ZmJFc3RpbWF0ZSwgdHRmYiksIHN0YXRzLmxvYWRlZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGVUVEZCKHRpbWVMb2FkaW5nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdldFRpbWVUb0xvYWRGcmFnID0gZnVuY3Rpb24gZ2V0VGltZVRvTG9hZEZyYWcodGltZVRvRmlyc3RCeXRlU2VjLCBiYW5kd2lkdGgsIGZyYWdTaXplQml0cywgaXNTd2l0Y2gpIHtcbiAgICAgIHZhciBmcmFnTG9hZFNlYyA9IHRpbWVUb0ZpcnN0Qnl0ZVNlYyArIGZyYWdTaXplQml0cyAvIGJhbmR3aWR0aDtcbiAgICAgIHZhciBwbGF5bGlzdExvYWRTZWMgPSBpc1N3aXRjaCA/IHRoaXMubGFzdExldmVsTG9hZFNlYyA6IDA7XG4gICAgICByZXR1cm4gZnJhZ0xvYWRTZWMgKyBwbGF5bGlzdExvYWRTZWM7XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgICB2YXIgbG9hZGluZyA9IGRhdGEuc3RhdHMubG9hZGluZztcbiAgICAgIHZhciB0aW1lTG9hZGluZ01zID0gbG9hZGluZy5lbmQgLSBsb2FkaW5nLnN0YXJ0O1xuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKHRpbWVMb2FkaW5nTXMpKSB7XG4gICAgICAgIHRoaXMubGFzdExldmVsTG9hZFNlYyA9IHRpbWVMb2FkaW5nTXMgLyAxMDAwO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuZGV0YWlscy5saXZlKSB7XG4gICAgICAgIHRoaXMuYndFc3RpbWF0b3IudXBkYXRlKGNvbmZpZy5hYnJFd21hU2xvd0xpdmUsIGNvbmZpZy5hYnJFd21hRmFzdExpdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5id0VzdGltYXRvci51cGRhdGUoY29uZmlnLmFickV3bWFTbG93Vm9ELCBjb25maWcuYWJyRXdtYUZhc3RWb0QpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uRnJhZ0xvYWRlZCA9IGZ1bmN0aW9uIG9uRnJhZ0xvYWRlZChldmVudCwgX3JlZikge1xuICAgICAgdmFyIGZyYWcgPSBfcmVmLmZyYWcsXG4gICAgICAgIHBhcnQgPSBfcmVmLnBhcnQ7XG4gICAgICB2YXIgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgICBpZiAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlVFRGQihzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBzdG9wIG1vbml0b3JpbmcgYncgb25jZSBmcmFnIGxvYWRlZFxuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuICAgICAgaWYgKGZyYWcubGV2ZWwgPT09IHRoaXMuX25leHRBdXRvTGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJzdFNlbGVjdGlvbiA9IC0xO1xuXG4gICAgICAvLyBjb21wdXRlIGxldmVsIGF2ZXJhZ2UgYml0cmF0ZVxuICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5hYnJNYXhXaXRoUmVhbEJpdHJhdGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gcGFydCA/IHBhcnQuZHVyYXRpb24gOiBmcmFnLmR1cmF0aW9uO1xuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICAgIHZhciBsb2FkZWRCeXRlcyA9IChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuYnl0ZXMgOiAwKSArIHN0YXRzLmxvYWRlZDtcbiAgICAgICAgdmFyIGxvYWRlZER1cmF0aW9uID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZHVyYXRpb247XG4gICAgICAgIGxldmVsLmxvYWRlZCA9IHtcbiAgICAgICAgICBieXRlczogbG9hZGVkQnl0ZXMsXG4gICAgICAgICAgZHVyYXRpb246IGxvYWRlZER1cmF0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGxldmVsLnJlYWxCaXRyYXRlID0gTWF0aC5yb3VuZCg4ICogbG9hZGVkQnl0ZXMgLyBsb2FkZWREdXJhdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgICB2YXIgZnJhZ0J1ZmZlcmVkRGF0YSA9IHtcbiAgICAgICAgICBzdGF0czogc3RhdHMsXG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgIGlkOiBmcmFnLnR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkZyYWdCdWZmZXJlZChFdmVudHMuRlJBR19CVUZGRVJFRCwgZnJhZ0J1ZmZlcmVkRGF0YSk7XG4gICAgICAgIGZyYWcuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0b3JlIGxldmVsIGlkIGFmdGVyIHN1Y2Nlc3NmdWwgZnJhZ21lbnQgbG9hZCBmb3IgcGxheWJhY2tcbiAgICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkZyYWdCdWZmZXJlZCA9IGZ1bmN0aW9uIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgcGFydCA9IGRhdGEucGFydDtcbiAgICAgIHZhciBzdGF0cyA9IHBhcnQgIT0gbnVsbCAmJiBwYXJ0LnN0YXRzLmxvYWRlZCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaWdub3JlRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gcGFyc2luZyBhbmQgcmVxdWVzdCBpbnN0ZWFkIG9mIGJ1ZmZlcmluZyBhbmQgcmVxdWVzdCB0byBjb21wdXRlIGZyYWdMb2FkaW5nUHJvY2Vzc2luZztcbiAgICAgIC8vIHJhdGlvbmFsZSBpcyB0aGF0IGJ1ZmZlciBhcHBlbmRpbmcgb25seSBoYXBwZW5zIG9uY2UgbWVkaWEgaXMgYXR0YWNoZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaFxuICAgICAgLy8gaXMgdXNlZC4gSWYgd2UgdXNlZCBidWZmZXJpbmcgaW4gdGhhdCBjYXNlLCBvdXIgQlcgZXN0aW1hdGUgc2FtcGxlIHdpbGwgYmUgdmVyeSBsYXJnZS5cbiAgICAgIHZhciBwcm9jZXNzaW5nTXMgPSBzdGF0cy5wYXJzaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQgLSBNYXRoLm1pbihzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCwgdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKSk7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZShwcm9jZXNzaW5nTXMsIHN0YXRzLmxvYWRlZCk7XG4gICAgICBzdGF0cy5id0VzdGltYXRlID0gdGhpcy5nZXRCd0VzdGltYXRlKCk7XG4gICAgICBpZiAoZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSBwcm9jZXNzaW5nTXMgLyAxMDAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5pZ25vcmVGcmFnbWVudCA9IGZ1bmN0aW9uIGlnbm9yZUZyYWdtZW50KGZyYWcpIHtcbiAgICAgIC8vIE9ubHkgY291bnQgbm9uLWFsdC1hdWRpbyBmcmFncyB3aGljaCB3ZXJlIGFjdHVhbGx5IGJ1ZmZlcmVkIGluIG91ciBCVyBjYWxjdWxhdGlvbnNcbiAgICAgIHJldHVybiBmcmFnLnR5cGUgIT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JztcbiAgICB9O1xuICAgIF9wcm90by5jbGVhclRpbWVyID0gZnVuY3Rpb24gY2xlYXJUaW1lcigpIHtcbiAgICAgIGlmICh0aGlzLnRpbWVyID4gLTEpIHtcbiAgICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gLTE7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0QXV0b0xldmVsS2V5ID0gZnVuY3Rpb24gZ2V0QXV0b0xldmVsS2V5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QndFc3RpbWF0ZSgpICsgXCJfXCIgKyB0aGlzLmdldFN0YXJ2YXRpb25EZWxheSgpLnRvRml4ZWQoMik7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TmV4dEFCUkF1dG9MZXZlbCA9IGZ1bmN0aW9uIGdldE5leHRBQlJBdXRvTGV2ZWwoKSB7XG4gICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgICBwYXJ0Q3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQsXG4gICAgICAgIGhscyA9IHRoaXMuaGxzO1xuICAgICAgdmFyIG1heEF1dG9MZXZlbCA9IGhscy5tYXhBdXRvTGV2ZWwsXG4gICAgICAgIGNvbmZpZyA9IGhscy5jb25maWcsXG4gICAgICAgIG1pbkF1dG9MZXZlbCA9IGhscy5taW5BdXRvTGV2ZWw7XG4gICAgICB2YXIgY3VycmVudEZyYWdEdXJhdGlvbiA9IHBhcnRDdXJyZW50ID8gcGFydEN1cnJlbnQuZHVyYXRpb24gOiBmcmFnQ3VycmVudCA/IGZyYWdDdXJyZW50LmR1cmF0aW9uIDogMDtcbiAgICAgIHZhciBhdmdidyA9IHRoaXMuZ2V0QndFc3RpbWF0ZSgpO1xuICAgICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIHRoZSB3YWxsLWNsb2NrIHRpbWUgbGVmdCB1bnRpbCB0aGUgcGxheWJhY2sgYnVmZmVyIGlzIGV4aGF1c3RlZC5cbiAgICAgIHZhciBidWZmZXJTdGFydmF0aW9uRGVsYXkgPSB0aGlzLmdldFN0YXJ2YXRpb25EZWxheSgpO1xuICAgICAgdmFyIGJ3RmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aEZhY3RvcjtcbiAgICAgIHZhciBid1VwRmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yO1xuXG4gICAgICAvLyBGaXJzdCwgbG9vayB0byBzZWUgaWYgd2UgY2FuIGZpbmQgYSBsZXZlbCBtYXRjaGluZyB3aXRoIG91ciBhdmcgYmFuZHdpZHRoIEFORCB0aGF0IGNvdWxkIGFsc28gZ3VhcmFudGVlIG5vIHJlYnVmZmVyaW5nIGF0IGFsbFxuICAgICAgaWYgKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgICB2YXIgX2Jlc3RMZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbChhdmdidywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgMCwgYndGYWN0b3IsIGJ3VXBGYWN0b3IpO1xuICAgICAgICBpZiAoX2Jlc3RMZXZlbCA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIF9iZXN0TGV2ZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nLi4uIHRyeSB0byBmaW5kIGxldmVsIHRoYXQgd2lsbCBndWFyYW50ZWUgbGVzcyB0aGFuIG1heFN0YXJ2YXRpb25EZWxheSBvZiByZWJ1ZmZlcmluZ1xuICAgICAgdmFyIG1heFN0YXJ2YXRpb25EZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb24gPyBNYXRoLm1pbihjdXJyZW50RnJhZ0R1cmF0aW9uLCBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5KSA6IGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXk7XG4gICAgICBpZiAoIWJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgICAvLyBpbiBjYXNlIGJ1ZmZlciBpcyBlbXB0eSwgbGV0J3MgY2hlY2sgaWYgcHJldmlvdXMgZnJhZ21lbnQgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0XG4gICAgICAgIHZhciBiaXRyYXRlVGVzdERlbGF5ID0gdGhpcy5iaXRyYXRlVGVzdERlbGF5O1xuICAgICAgICBpZiAoYml0cmF0ZVRlc3REZWxheSkge1xuICAgICAgICAgIC8vIGlmIGl0IGlzIHRoZSBjYXNlLCB0aGVuIHdlIG5lZWQgdG8gYWRqdXN0IG91ciBtYXggc3RhcnZhdGlvbiBkZWxheSB1c2luZyBtYXhMb2FkaW5nRGVsYXkgY29uZmlnIHZhbHVlXG4gICAgICAgICAgLy8gbWF4IHZpZGVvIGxvYWRpbmcgZGVsYXkgdXNlZCBpbiAgYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiA6XG4gICAgICAgICAgLy8gaW4gdGhhdCBtb2RlIEFCUiBjb250cm9sbGVyIHdpbGwgZW5zdXJlIHRoYXQgdmlkZW8gbG9hZGluZyB0aW1lIChpZSB0aGUgdGltZSB0byBmZXRjaCB0aGUgZmlyc3QgZnJhZ21lbnQgYXQgbG93ZXN0IHF1YWxpdHkgbGV2ZWwgK1xuICAgICAgICAgIC8vIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmcmFnbWVudCBhdCB0aGUgYXBwcm9wcmlhdGUgcXVhbGl0eSBsZXZlbCBpcyBsZXNzIHRoYW4gYGBgbWF4TG9hZGluZ0RlbGF5YGBgIClcbiAgICAgICAgICAvLyBjYXAgbWF4TG9hZGluZ0RlbGF5IGFuZCBlbnN1cmUgaXQgaXMgbm90IGJpZ2dlciAndGhhbiBiaXRyYXRlIHRlc3QnIGZyYWcgZHVyYXRpb25cbiAgICAgICAgICB2YXIgbWF4TG9hZGluZ0RlbGF5ID0gY3VycmVudEZyYWdEdXJhdGlvbiA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhMb2FkaW5nRGVsYXkpIDogY29uZmlnLm1heExvYWRpbmdEZWxheTtcbiAgICAgICAgICBtYXhTdGFydmF0aW9uRGVsYXkgPSBtYXhMb2FkaW5nRGVsYXkgLSBiaXRyYXRlVGVzdERlbGF5O1xuICAgICAgICAgIGxvZ2dlci5pbmZvKFwiW2Ficl0gYml0cmF0ZSB0ZXN0IHRvb2sgXCIgKyBNYXRoLnJvdW5kKDEwMDAgKiBiaXRyYXRlVGVzdERlbGF5KSArIFwibXMsIHNldCBmaXJzdCBmcmFnbWVudCBtYXggZmV0Y2hEdXJhdGlvbiB0byBcIiArIE1hdGgucm91bmQoMTAwMCAqIG1heFN0YXJ2YXRpb25EZWxheSkgKyBcIiBtc1wiKTtcbiAgICAgICAgICAvLyBkb24ndCB1c2UgY29uc2VydmF0aXZlIGZhY3RvciBvbiBiaXRyYXRlIHRlc3RcbiAgICAgICAgICBid0ZhY3RvciA9IGJ3VXBGYWN0b3IgPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKGF2Z2J3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LCBtYXhTdGFydmF0aW9uRGVsYXksIGJ3RmFjdG9yLCBid1VwRmFjdG9yKTtcbiAgICAgIGxvZ2dlci5pbmZvKFwiW2Ficl0gXCIgKyAoYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID8gJ3JlYnVmZmVyaW5nIGV4cGVjdGVkJyA6ICdidWZmZXIgaXMgZW1wdHknKSArIFwiLCBvcHRpbWFsIHF1YWxpdHkgbGV2ZWwgXCIgKyBiZXN0TGV2ZWwpO1xuICAgICAgaWYgKGJlc3RMZXZlbCA+IC0xKSB7XG4gICAgICAgIHJldHVybiBiZXN0TGV2ZWw7XG4gICAgICB9XG4gICAgICAvLyBJZiBubyBtYXRjaGluZyBsZXZlbCBmb3VuZCwgc2VlIGlmIG1pbiBhdXRvIGxldmVsIHdvdWxkIGJlIGEgYmV0dGVyIG9wdGlvblxuICAgICAgdmFyIG1pbkxldmVsID0gaGxzLmxldmVsc1ttaW5BdXRvTGV2ZWxdO1xuICAgICAgdmFyIGF1dG9MZXZlbCA9IGhscy5sZXZlbHNbaGxzLmxvYWRMZXZlbF07XG4gICAgICBpZiAoKG1pbkxldmVsID09IG51bGwgPyB2b2lkIDAgOiBtaW5MZXZlbC5iaXRyYXRlKSA8IChhdXRvTGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGF1dG9MZXZlbC5iaXRyYXRlKSkge1xuICAgICAgICByZXR1cm4gbWluQXV0b0xldmVsO1xuICAgICAgfVxuICAgICAgLy8gb3IgaWYgYml0cmF0ZSBpcyBub3QgbG93ZXIsIGNvbnRpbnVlIHRvIHVzZSBsb2FkTGV2ZWxcbiAgICAgIHJldHVybiBobHMubG9hZExldmVsO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFN0YXJ2YXRpb25EZWxheSA9IGZ1bmN0aW9uIGdldFN0YXJ2YXRpb25EZWxheSgpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIHZhciBtZWRpYSA9IGhscy5tZWRpYTtcbiAgICAgIGlmICghbWVkaWEpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgICAgLy8gcGxheWJhY2tSYXRlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgcGxheWJhY2sgcmF0ZTsgaWYgbWVkaWEucGxheWJhY2tSYXRlIGlzIDAsIHdlIHVzZSAxIHRvIGxvYWQgYXNcbiAgICAgIC8vIGlmIHdlJ3JlIHBsYXlpbmcgYmFjayBhdCB0aGUgbm9ybWFsIHJhdGUuXG4gICAgICB2YXIgcGxheWJhY2tSYXRlID0gbWVkaWEgJiYgbWVkaWEucGxheWJhY2tSYXRlICE9PSAwID8gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKSA6IDEuMDtcbiAgICAgIHZhciBidWZmZXJJbmZvID0gaGxzLm1haW5Gb3J3YXJkQnVmZmVySW5mbztcbiAgICAgIHJldHVybiAoYnVmZmVySW5mbyA/IGJ1ZmZlckluZm8ubGVuIDogMCkgLyBwbGF5YmFja1JhdGU7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0QndFc3RpbWF0ZSA9IGZ1bmN0aW9uIGdldEJ3RXN0aW1hdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5id0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpID8gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpIDogdGhpcy5obHMuY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGU7XG4gICAgfTtcbiAgICBfcHJvdG8uZmluZEJlc3RMZXZlbCA9IGZ1bmN0aW9uIGZpbmRCZXN0TGV2ZWwoY3VycmVudEJ3LCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCwgYnVmZmVyU3RhcnZhdGlvbkRlbGF5LCBtYXhTdGFydmF0aW9uRGVsYXksIGJ3RmFjdG9yLCBid1VwRmFjdG9yKSB7XG4gICAgICB2YXIgX2xldmVsJGRldGFpbHMsXG4gICAgICAgIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgbWF4RmV0Y2hEdXJhdGlvbiA9IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSArIG1heFN0YXJ2YXRpb25EZWxheTtcbiAgICAgIHZhciBsYXN0TG9hZGVkRnJhZ0xldmVsID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsO1xuICAgICAgdmFyIHNlbGVjdGlvbkJhc2VMZXZlbCA9IGxhc3RMb2FkZWRGcmFnTGV2ZWwgPT09IC0xID8gdGhpcy5obHMuZmlyc3RMZXZlbCA6IGxhc3RMb2FkZWRGcmFnTGV2ZWw7XG4gICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgICBwYXJ0Q3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQ7XG4gICAgICB2YXIgX3RoaXMkaGxzID0gdGhpcy5obHMsXG4gICAgICAgIGxldmVscyA9IF90aGlzJGhscy5sZXZlbHMsXG4gICAgICAgIGFsbEF1ZGlvVHJhY2tzID0gX3RoaXMkaGxzLmFsbEF1ZGlvVHJhY2tzLFxuICAgICAgICBsb2FkTGV2ZWwgPSBfdGhpcyRobHMubG9hZExldmVsLFxuICAgICAgICBjb25maWcgPSBfdGhpcyRobHMuY29uZmlnO1xuICAgICAgaWYgKGxldmVscy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbc2VsZWN0aW9uQmFzZUxldmVsXTtcbiAgICAgIHZhciBsaXZlID0gISEobGV2ZWwgIT0gbnVsbCAmJiAoX2xldmVsJGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzKSAhPSBudWxsICYmIF9sZXZlbCRkZXRhaWxzLmxpdmUpO1xuICAgICAgdmFyIGZpcnN0U2VsZWN0aW9uID0gbG9hZExldmVsID09PSAtMSB8fCBsYXN0TG9hZGVkRnJhZ0xldmVsID09PSAtMTtcbiAgICAgIHZhciBjdXJyZW50Q29kZWNTZXQ7XG4gICAgICB2YXIgY3VycmVudFZpZGVvUmFuZ2UgPSAnU0RSJztcbiAgICAgIHZhciBjdXJyZW50RnJhbWVSYXRlID0gKGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5mcmFtZVJhdGUpIHx8IDA7XG4gICAgICB2YXIgYXVkaW9QcmVmZXJlbmNlID0gY29uZmlnLmF1ZGlvUHJlZmVyZW5jZSxcbiAgICAgICAgdmlkZW9QcmVmZXJlbmNlID0gY29uZmlnLnZpZGVvUHJlZmVyZW5jZTtcbiAgICAgIHZhciBhdWRpb1RyYWNrc0J5R3JvdXAgPSB0aGlzLmF1ZGlvVHJhY2tzQnlHcm91cCB8fCAodGhpcy5hdWRpb1RyYWNrc0J5R3JvdXAgPSBnZXRBdWRpb1RyYWNrc0J5R3JvdXAoYWxsQXVkaW9UcmFja3MpKTtcbiAgICAgIGlmIChmaXJzdFNlbGVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5maXJzdFNlbGVjdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdFNlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29kZWNUaWVycyA9IHRoaXMuY29kZWNUaWVycyB8fCAodGhpcy5jb2RlY1RpZXJzID0gZ2V0Q29kZWNUaWVycyhsZXZlbHMsIGF1ZGlvVHJhY2tzQnlHcm91cCwgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwpKTtcbiAgICAgICAgdmFyIHN0YXJ0VGllciA9IGdldFN0YXJ0Q29kZWNUaWVyKGNvZGVjVGllcnMsIGN1cnJlbnRWaWRlb1JhbmdlLCBjdXJyZW50QncsIGF1ZGlvUHJlZmVyZW5jZSwgdmlkZW9QcmVmZXJlbmNlKTtcbiAgICAgICAgdmFyIGNvZGVjU2V0ID0gc3RhcnRUaWVyLmNvZGVjU2V0LFxuICAgICAgICAgIHZpZGVvUmFuZ2VzID0gc3RhcnRUaWVyLnZpZGVvUmFuZ2VzLFxuICAgICAgICAgIG1pbkZyYW1lcmF0ZSA9IHN0YXJ0VGllci5taW5GcmFtZXJhdGUsXG4gICAgICAgICAgbWluQml0cmF0ZSA9IHN0YXJ0VGllci5taW5CaXRyYXRlLFxuICAgICAgICAgIHByZWZlckhEUiA9IHN0YXJ0VGllci5wcmVmZXJIRFI7XG4gICAgICAgIGN1cnJlbnRDb2RlY1NldCA9IGNvZGVjU2V0O1xuICAgICAgICBjdXJyZW50VmlkZW9SYW5nZSA9IHByZWZlckhEUiA/IHZpZGVvUmFuZ2VzW3ZpZGVvUmFuZ2VzLmxlbmd0aCAtIDFdIDogdmlkZW9SYW5nZXNbMF07XG4gICAgICAgIGN1cnJlbnRGcmFtZVJhdGUgPSBtaW5GcmFtZXJhdGU7XG4gICAgICAgIGN1cnJlbnRCdyA9IE1hdGgubWF4KGN1cnJlbnRCdywgbWluQml0cmF0ZSk7XG4gICAgICAgIGxvZ2dlci5sb2coXCJbYWJyXSBwaWNrZWQgc3RhcnQgdGllciBcIiArIEpTT04uc3RyaW5naWZ5KHN0YXJ0VGllcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudENvZGVjU2V0ID0gbGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLmNvZGVjU2V0O1xuICAgICAgICBjdXJyZW50VmlkZW9SYW5nZSA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC52aWRlb1JhbmdlO1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRGcmFnRHVyYXRpb24gPSBwYXJ0Q3VycmVudCA/IHBhcnRDdXJyZW50LmR1cmF0aW9uIDogZnJhZ0N1cnJlbnQgPyBmcmFnQ3VycmVudC5kdXJhdGlvbiA6IDA7XG4gICAgICB2YXIgdHRmYkVzdGltYXRlU2VjID0gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKSAvIDEwMDA7XG4gICAgICB2YXIgbGV2ZWxzU2tpcHBlZCA9IFtdO1xuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgICAgdmFyIF9sZXZlbEluZm8kc3VwcG9ydGVkUjtcbiAgICAgICAgICB2YXIgbGV2ZWxJbmZvID0gbGV2ZWxzW2ldO1xuICAgICAgICAgIHZhciB1cFN3aXRjaCA9IGkgPiBzZWxlY3Rpb25CYXNlTGV2ZWw7XG4gICAgICAgICAgaWYgKCFsZXZlbEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29uZmlnLnVzZU1lZGlhQ2FwYWJpbGl0aWVzICYmICFsZXZlbEluZm8uc3VwcG9ydGVkUmVzdWx0ICYmICFsZXZlbEluZm8uc3VwcG9ydGVkUHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIG1lZGlhQ2FwYWJpbGl0aWVzID0gbmF2aWdhdG9yLm1lZGlhQ2FwYWJpbGl0aWVzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAobWVkaWFDYXBhYmlsaXRpZXMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhQ2FwYWJpbGl0aWVzLmRlY29kaW5nSW5mbykgPT09ICdmdW5jdGlvbicgJiYgcmVxdWlyZXNNZWRpYUNhcGFiaWxpdGllc0RlY29kaW5nSW5mbyhsZXZlbEluZm8sIGF1ZGlvVHJhY2tzQnlHcm91cCwgY3VycmVudFZpZGVvUmFuZ2UsIGN1cnJlbnRGcmFtZVJhdGUsIGN1cnJlbnRCdywgYXVkaW9QcmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICBsZXZlbEluZm8uc3VwcG9ydGVkUHJvbWlzZSA9IGdldE1lZGlhRGVjb2RpbmdJbmZvUHJvbWlzZShsZXZlbEluZm8sIGF1ZGlvVHJhY2tzQnlHcm91cCwgbWVkaWFDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgICBsZXZlbEluZm8uc3VwcG9ydGVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkZWNvZGluZ0luZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzMi5obHMpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV2ZWxJbmZvLnN1cHBvcnRlZFJlc3VsdCA9IGRlY29kaW5nSW5mbztcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWxzID0gX3RoaXMyLmhscy5sZXZlbHM7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGV2ZWxzLmluZGV4T2YobGV2ZWxJbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjb2RpbmdJbmZvLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIlthYnJdIE1lZGlhQ2FwYWJpbGl0aWVzIGRlY29kaW5nSW5mbyBlcnJvcjogXFxcIlwiICsgZGVjb2RpbmdJbmZvLmVycm9yICsgXCJcXFwiIGZvciBsZXZlbCBcIiArIGluZGV4ICsgXCIgXCIgKyBKU09OLnN0cmluZ2lmeShkZWNvZGluZ0luZm8pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFkZWNvZGluZ0luZm8uc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIlthYnJdIFVuc3VwcG9ydGVkIE1lZGlhQ2FwYWJpbGl0aWVzIGRlY29kaW5nSW5mbyByZXN1bHQgZm9yIGxldmVsIFwiICsgaW5kZXggKyBcIiBcIiArIEpTT04uc3RyaW5naWZ5KGRlY29kaW5nSW5mbykpO1xuICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEgJiYgbGV2ZWxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlthYnJdIFJlbW92aW5nIHVuc3VwcG9ydGVkIGxldmVsIFwiICsgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIuaGxzLnJlbW92ZUxldmVsKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV2ZWxJbmZvLnN1cHBvcnRlZFJlc3VsdCA9IFNVUFBPUlRFRF9JTkZPX0RFRkFVTFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc2tpcCBjYW5kaWRhdGVzIHdoaWNoIGNoYW5nZSBjb2RlYy1mYW1pbHkgb3IgdmlkZW8tcmFuZ2UsXG4gICAgICAgICAgLy8gYW5kIHdoaWNoIGRlY3JlYXNlIG9yIGluY3JlYXNlIGZyYW1lLXJhdGUgZm9yIHVwIGFuZCBkb3duLXN3aXRjaCByZXNwZWN0ZnVsbHlcbiAgICAgICAgICBpZiAoY3VycmVudENvZGVjU2V0ICYmIGxldmVsSW5mby5jb2RlY1NldCAhPT0gY3VycmVudENvZGVjU2V0IHx8IGN1cnJlbnRWaWRlb1JhbmdlICYmIGxldmVsSW5mby52aWRlb1JhbmdlICE9PSBjdXJyZW50VmlkZW9SYW5nZSB8fCB1cFN3aXRjaCAmJiBjdXJyZW50RnJhbWVSYXRlID4gbGV2ZWxJbmZvLmZyYW1lUmF0ZSB8fCAhdXBTd2l0Y2ggJiYgY3VycmVudEZyYW1lUmF0ZSA+IDAgJiYgY3VycmVudEZyYW1lUmF0ZSA8IGxldmVsSW5mby5mcmFtZVJhdGUgfHwgbGV2ZWxJbmZvLnN1cHBvcnRlZFJlc3VsdCAmJiAhKChfbGV2ZWxJbmZvJHN1cHBvcnRlZFIgPSBsZXZlbEluZm8uc3VwcG9ydGVkUmVzdWx0LmRlY29kaW5nSW5mb1Jlc3VsdHMpICE9IG51bGwgJiYgX2xldmVsSW5mbyRzdXBwb3J0ZWRSWzBdLnNtb290aCkpIHtcbiAgICAgICAgICAgIGxldmVsc1NraXBwZWQucHVzaChpKTtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgICAgICAgdmFyIGF2Z0R1cmF0aW9uID0gKHBhcnRDdXJyZW50ID8gbGV2ZWxEZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbERldGFpbHMucGFydFRhcmdldCA6IGxldmVsRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxEZXRhaWxzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbikgfHwgY3VycmVudEZyYWdEdXJhdGlvbjtcbiAgICAgICAgICB2YXIgYWRqdXN0ZWRidztcbiAgICAgICAgICAvLyBmb2xsb3cgYWxnb3JpdGhtIGNhcHR1cmVkIGZyb20gc3RhZ2VmcmlnaHQgOlxuICAgICAgICAgIC8vIGh0dHBzOi8vYW5kcm9pZC5nb29nbGVzb3VyY2UuY29tL3BsYXRmb3JtL2ZyYW1ld29ya3MvYXYvKy9tYXN0ZXIvbWVkaWEvbGlic3RhZ2VmcmlnaHQvaHR0cGxpdmUvTGl2ZVNlc3Npb24uY3BwXG4gICAgICAgICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXG4gICAgICAgICAgLy8gY29uc2lkZXIgb25seSA4MCUgb2YgdGhlIGF2YWlsYWJsZSBiYW5kd2lkdGgsIGJ1dCBpZiB3ZSBhcmUgc3dpdGNoaW5nIHVwLFxuICAgICAgICAgIC8vIGJlIGV2ZW4gbW9yZSBjb25zZXJ2YXRpdmUgKDcwJSkgdG8gYXZvaWQgb3ZlcmVzdGltYXRpbmcgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAgICAgLy8gc3dpdGNoaW5nIGJhY2suXG4gICAgICAgICAgaWYgKCF1cFN3aXRjaCkge1xuICAgICAgICAgICAgYWRqdXN0ZWRidyA9IGJ3RmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGp1c3RlZGJ3ID0gYndVcEZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVc2UgYXZlcmFnZSBiaXRyYXRlIHdoZW4gc3RhcnZhdGlvbiBkZWxheSAoYnVmZmVyIGxlbmd0aCkgaXMgZ3Qgb3IgZXEgdHdvIHNlZ21lbnQgZHVyYXRpb25zIGFuZCByZWJ1ZmZlcmluZyBpcyBub3QgZXhwZWN0ZWQgKG1heFN0YXJ2YXRpb25EZWxheSA+IDApXG4gICAgICAgICAgdmFyIGJpdHJhdGUgPSBjdXJyZW50RnJhZ0R1cmF0aW9uICYmIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSA+PSBjdXJyZW50RnJhZ0R1cmF0aW9uICogMiAmJiBtYXhTdGFydmF0aW9uRGVsYXkgPT09IDAgPyBsZXZlbHNbaV0uYXZlcmFnZUJpdHJhdGUgOiBsZXZlbHNbaV0ubWF4Qml0cmF0ZTtcbiAgICAgICAgICB2YXIgZmV0Y2hEdXJhdGlvbiA9IF90aGlzMi5nZXRUaW1lVG9Mb2FkRnJhZyh0dGZiRXN0aW1hdGVTZWMsIGFkanVzdGVkYncsIGJpdHJhdGUgKiBhdmdEdXJhdGlvbiwgbGV2ZWxEZXRhaWxzID09PSB1bmRlZmluZWQpO1xuICAgICAgICAgIHZhciBjYW5Td2l0Y2hXaXRoaW5Ub2xlcmFuY2UgPVxuICAgICAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgICAgIGFkanVzdGVkYncgPj0gYml0cmF0ZSAmJiAoXG4gICAgICAgICAgLy8gbm8gbGV2ZWwgY2hhbmdlLCBvciBuZXcgbGV2ZWwgaGFzIG5vIGVycm9yIGhpc3RvcnlcbiAgICAgICAgICBpID09PSBsYXN0TG9hZGVkRnJhZ0xldmVsIHx8IGxldmVsSW5mby5sb2FkRXJyb3IgPT09IDAgJiYgbGV2ZWxJbmZvLmZyYWdtZW50RXJyb3IgPT09IDApICYmIChcbiAgICAgICAgICAvLyBmcmFnbWVudCBmZXRjaER1cmF0aW9uIHVua25vd24gT1IgbGl2ZSBzdHJlYW0gT1IgZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiBsZXNzIHRoYW4gbWF4IGFsbG93ZWQgZmV0Y2ggZHVyYXRpb24sIHRoZW4gdGhpcyBsZXZlbCBtYXRjaGVzXG4gICAgICAgICAgLy8gd2UgZG9uJ3QgYWNjb3VudCBmb3IgbWF4IEZldGNoIER1cmF0aW9uIGZvciBsaXZlIHN0cmVhbXMsIHRoaXMgaXMgdG8gYXZvaWQgc3dpdGNoaW5nIGRvd24gd2hlbiBuZWFyIHRoZSBlZGdlIG9mIGxpdmUgc2xpZGluZyB3aW5kb3cgLi4uXG4gICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgc3RhcnRMZXZlbCA9IC0xIChiaXRyYXRlVGVzdCkgb24gbGl2ZSBzdHJlYW1zIDogaW4gdGhhdCBjYXNlIHdlIHNob3VsZCBub3QgZXhpdCBsb29wIHNvIHRoYXQgZmluZEJlc3RMZXZlbCB3aWxsIHJldHVybiAtMVxuICAgICAgICAgIGZldGNoRHVyYXRpb24gPD0gdHRmYkVzdGltYXRlU2VjIHx8ICFpc0Zpbml0ZU51bWJlcihmZXRjaER1cmF0aW9uKSB8fCBsaXZlICYmICFfdGhpczIuYml0cmF0ZVRlc3REZWxheSB8fCBmZXRjaER1cmF0aW9uIDwgbWF4RmV0Y2hEdXJhdGlvbik7XG4gICAgICAgICAgaWYgKGNhblN3aXRjaFdpdGhpblRvbGVyYW5jZSkge1xuICAgICAgICAgICAgdmFyIGZvcmNlZEF1dG9MZXZlbCA9IF90aGlzMi5mb3JjZWRBdXRvTGV2ZWw7XG4gICAgICAgICAgICBpZiAoaSAhPT0gbG9hZExldmVsICYmIChmb3JjZWRBdXRvTGV2ZWwgPT09IC0xIHx8IGZvcmNlZEF1dG9MZXZlbCAhPT0gbG9hZExldmVsKSkge1xuICAgICAgICAgICAgICBpZiAobGV2ZWxzU2tpcHBlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoXCJbYWJyXSBTa2lwcGVkIGxldmVsKHMpIFwiICsgbGV2ZWxzU2tpcHBlZC5qb2luKCcsJykgKyBcIiBvZiBcIiArIG1heEF1dG9MZXZlbCArIFwiIG1heCB3aXRoIENPREVDUyBhbmQgVklERU8tUkFOR0U6XFxcIlwiICsgbGV2ZWxzW2xldmVsc1NraXBwZWRbMF1dLmNvZGVjcyArIFwiXFxcIiBcIiArIGxldmVsc1tsZXZlbHNTa2lwcGVkWzBdXS52aWRlb1JhbmdlICsgXCI7IG5vdCBjb21wYXRpYmxlIHdpdGggXFxcIlwiICsgbGV2ZWwuY29kZWNzICsgXCJcXFwiIFwiICsgY3VycmVudFZpZGVvUmFuZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiW2Ficl0gc3dpdGNoIGNhbmRpZGF0ZTpcIiArIHNlbGVjdGlvbkJhc2VMZXZlbCArIFwiLT5cIiArIGkgKyBcIiBhZGp1c3RlZGJ3KFwiICsgTWF0aC5yb3VuZChhZGp1c3RlZGJ3KSArIFwiKS1iaXRyYXRlPVwiICsgTWF0aC5yb3VuZChhZGp1c3RlZGJ3IC0gYml0cmF0ZSkgKyBcIiB0dGZiOlwiICsgdHRmYkVzdGltYXRlU2VjLnRvRml4ZWQoMSkgKyBcIiBhdmdEdXJhdGlvbjpcIiArIGF2Z0R1cmF0aW9uLnRvRml4ZWQoMSkgKyBcIiBtYXhGZXRjaER1cmF0aW9uOlwiICsgbWF4RmV0Y2hEdXJhdGlvbi50b0ZpeGVkKDEpICsgXCIgZmV0Y2hEdXJhdGlvbjpcIiArIGZldGNoRHVyYXRpb24udG9GaXhlZCgxKSArIFwiIGZpcnN0U2VsZWN0aW9uOlwiICsgZmlyc3RTZWxlY3Rpb24gKyBcIiBjb2RlY1NldDpcIiArIGN1cnJlbnRDb2RlY1NldCArIFwiIHZpZGVvUmFuZ2U6XCIgKyBjdXJyZW50VmlkZW9SYW5nZSArIFwiIGhscy5sb2FkTGV2ZWw6XCIgKyBsb2FkTGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5maXJzdFNlbGVjdGlvbiA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcyB3ZSBhcmUgbG9vcGluZyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGFjaGlldmFibGUgcXVhbGl0eSBsZXZlbFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdjogaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9yZXQ7XG4gICAgICBmb3IgKHZhciBpID0gbWF4QXV0b0xldmVsOyBpID49IG1pbkF1dG9MZXZlbDsgaS0tKSB7XG4gICAgICAgIF9yZXQgPSBfbG9vcCgpO1xuICAgICAgICBpZiAoX3JldCA9PT0gMCkgY29udGludWU7XG4gICAgICAgIGlmIChfcmV0KSByZXR1cm4gX3JldC52O1xuICAgICAgfVxuICAgICAgLy8gbm90IGVub3VnaCB0aW1lIGJ1ZGdldCBldmVuIHdpdGggcXVhbGl0eSBsZXZlbCAwIC4uLiByZWJ1ZmZlcmluZyBtaWdodCBoYXBwZW5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIF9jcmVhdGVDbGFzcyhBYnJDb250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcImZpcnN0QXV0b0xldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIF90aGlzJGhsczIgPSB0aGlzLmhscyxcbiAgICAgICAgICBtYXhBdXRvTGV2ZWwgPSBfdGhpcyRobHMyLm1heEF1dG9MZXZlbCxcbiAgICAgICAgICBtaW5BdXRvTGV2ZWwgPSBfdGhpcyRobHMyLm1pbkF1dG9MZXZlbDtcbiAgICAgICAgdmFyIGJ3RXN0aW1hdGUgPSB0aGlzLmdldEJ3RXN0aW1hdGUoKTtcbiAgICAgICAgdmFyIG1heFN0YXJ0RGVsYXkgPSB0aGlzLmhscy5jb25maWcubWF4U3RhcnZhdGlvbkRlbGF5O1xuICAgICAgICB2YXIgYWJyQXV0b0xldmVsID0gdGhpcy5maW5kQmVzdExldmVsKGJ3RXN0aW1hdGUsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCAwLCBtYXhTdGFydERlbGF5LCAxLCAxKTtcbiAgICAgICAgaWYgKGFickF1dG9MZXZlbCA+IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGFickF1dG9MZXZlbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3RMZXZlbCA9IHRoaXMuaGxzLmZpcnN0TGV2ZWw7XG4gICAgICAgIHZhciBjbGFtcGVkID0gTWF0aC5taW4oTWF0aC5tYXgoZmlyc3RMZXZlbCwgbWluQXV0b0xldmVsKSwgbWF4QXV0b0xldmVsKTtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJbYWJyXSBDb3VsZCBub3QgZmluZCBiZXN0IHN0YXJ0aW5nIGF1dG8gbGV2ZWwuIERlZmF1bHRpbmcgdG8gZmlyc3QgaW4gcGxheWxpc3QgXCIgKyBmaXJzdExldmVsICsgXCIgY2xhbXBlZCB0byBcIiArIGNsYW1wZWQpO1xuICAgICAgICByZXR1cm4gY2xhbXBlZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZm9yY2VkQXV0b0xldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dEF1dG9MZXZlbEtleSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbmV4dEF1dG9MZXZlbDtcbiAgICAgIH1cblxuICAgICAgLy8gcmV0dXJuIG5leHQgYXV0byBsZXZlbFxuICAgIH0sIHtcbiAgICAgIGtleTogXCJuZXh0QXV0b0xldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGZvcmNlZEF1dG9MZXZlbCA9IHRoaXMuZm9yY2VkQXV0b0xldmVsO1xuICAgICAgICB2YXIgYndFc3RpbWF0b3IgPSB0aGlzLmJ3RXN0aW1hdG9yO1xuICAgICAgICB2YXIgdXNlRXN0aW1hdGUgPSBid0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpO1xuICAgICAgICB2YXIgbG9hZGVkRmlyc3RGcmFnID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID4gLTE7XG4gICAgICAgIC8vIGluIGNhc2UgbmV4dCBhdXRvIGxldmVsIGhhcyBiZWVuIGZvcmNlZCwgYW5kIGJ3IG5vdCBhdmFpbGFibGUgb3Igbm90IHJlbGlhYmxlLCByZXR1cm4gZm9yY2VkIHZhbHVlXG4gICAgICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmICghdXNlRXN0aW1hdGUgfHwgIWxvYWRlZEZpcnN0RnJhZyB8fCB0aGlzLm5leHRBdXRvTGV2ZWxLZXkgPT09IHRoaXMuZ2V0QXV0b0xldmVsS2V5KCkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbXB1dGUgbmV4dCBsZXZlbCB1c2luZyBBQlIgbG9naWNcbiAgICAgICAgdmFyIG5leHRBQlJBdXRvTGV2ZWwgPSB1c2VFc3RpbWF0ZSAmJiBsb2FkZWRGaXJzdEZyYWcgPyB0aGlzLmdldE5leHRBQlJBdXRvTGV2ZWwoKSA6IHRoaXMuZmlyc3RBdXRvTGV2ZWw7XG5cbiAgICAgICAgLy8gdXNlIGZvcmNlZCBhdXRvIGxldmVsIHdoaWxlIGl0IGhhc24ndCBlcnJvcmVkIG1vcmUgdGhhbiBBQlIgc2VsZWN0aW9uXG4gICAgICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICAgICAgdmFyIGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICAgICAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IE1hdGgubWF4KGZvcmNlZEF1dG9MZXZlbCwgbmV4dEFCUkF1dG9MZXZlbCkgJiYgbGV2ZWxzW2ZvcmNlZEF1dG9MZXZlbF0ubG9hZEVycm9yIDw9IGxldmVsc1tuZXh0QUJSQXV0b0xldmVsXS5sb2FkRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JjZWRBdXRvTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2F2ZSByZXN1bHQgdW50aWwgc3RhdGUgaGFzIGNoYW5nZWRcbiAgICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IG5leHRBQlJBdXRvTGV2ZWw7XG4gICAgICAgIHRoaXMubmV4dEF1dG9MZXZlbEtleSA9IHRoaXMuZ2V0QXV0b0xldmVsS2V5KCk7XG4gICAgICAgIHJldHVybiBuZXh0QUJSQXV0b0xldmVsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5leHRMZXZlbCkge1xuICAgICAgICB2YXIgX3RoaXMkaGxzMyA9IHRoaXMuaGxzLFxuICAgICAgICAgIG1heEF1dG9MZXZlbCA9IF90aGlzJGhsczMubWF4QXV0b0xldmVsLFxuICAgICAgICAgIG1pbkF1dG9MZXZlbCA9IF90aGlzJGhsczMubWluQXV0b0xldmVsO1xuICAgICAgICB2YXIgdmFsdWUgPSBNYXRoLm1pbihNYXRoLm1heChuZXh0TGV2ZWwsIG1pbkF1dG9MZXZlbCksIG1heEF1dG9MZXZlbCk7XG4gICAgICAgIGlmICh0aGlzLl9uZXh0QXV0b0xldmVsICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMubmV4dEF1dG9MZXZlbEtleSA9ICcnO1xuICAgICAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQWJyQ29udHJvbGxlcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqIFN1Yi1jbGFzcyBzcGVjaWFsaXphdGlvbiBvZiBFdmVudEhhbmRsZXIgYmFzZSBjbGFzcy5cbiAgICpcbiAgICogVGFza0xvb3AgYWxsb3dzIHRvIHNjaGVkdWxlIGEgdGFzayBmdW5jdGlvbiBiZWluZyBjYWxsZWQgKG9wdGlvbm5hbHkgcmVwZWF0ZWRseSkgb24gdGhlIG1haW4gbG9vcCxcbiAgICogc2NoZWR1bGVkIGFzeW5jaHJvbmVvdXNseSwgYXZvaWRpbmcgcmVjdXJzaXZlIGNhbGxzIGluIHRoZSBzYW1lIHRpY2suXG4gICAqXG4gICAqIFRoZSB0YXNrIGl0c2VsZiBpcyBpbXBsZW1lbnRlZCBpbiBgZG9UaWNrYC4gSXQgY2FuIGJlIHJlcXVlc3RlZCBhbmQgY2FsbGVkIGZvciBzaW5nbGUgZXhlY3V0aW9uXG4gICAqIHVzaW5nIHRoZSBgdGlja2AgbWV0aG9kLlxuICAgKlxuICAgKiBJdCB3aWxsIGJlIGFzc3VyZWQgdGhhdCB0aGUgdGFzayBleGVjdXRpb24gbWV0aG9kIChgdGlja2ApIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBwZXIgbWFpbiBsb29wIFwidGlja1wiLFxuICAgKiBubyBtYXR0ZXIgaG93IG9mdGVuIGl0IGdldHMgcmVxdWVzdGVkIGZvciBleGVjdXRpb24uIEV4ZWN1dGlvbiBpbiBmdXJ0aGVyIHRpY2tzIHdpbGwgYmUgc2NoZWR1bGVkIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBJZiBmdXJ0aGVyIGV4ZWN1dGlvbiByZXF1ZXN0cyBoYXZlIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQgb24gdGhlIG5leHQgdGljaywgaXQgY2FuIGJlIGNoZWNrZWQgd2l0aCBgaGFzTmV4dFRpY2tgLFxuICAgKiBhbmQgY2FuY2VsbGVkIHdpdGggYGNsZWFyTmV4dFRpY2tgLlxuICAgKlxuICAgKiBUaGUgdGFzayBjYW4gYmUgc2NoZWR1bGVkIGFzIGFuIGludGVydmFsIHJlcGVhdGVkbHkgd2l0aCBhIHBlcmlvZCBhcyBwYXJhbWV0ZXIgKHNlZSBgc2V0SW50ZXJ2YWxgLCBgY2xlYXJJbnRlcnZhbGApLlxuICAgKlxuICAgKiBTdWItY2xhc3NlcyBuZWVkIHRvIGltcGxlbWVudCB0aGUgYGRvVGlja2AgbWV0aG9kIHdoaWNoIHdpbGwgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgdGFzayBleGVjdXRpb24gcm91dGluZS5cbiAgICpcbiAgICogRnVydGhlciBleHBsYW5hdGlvbnM6XG4gICAqXG4gICAqIFRoZSBiYXNlY2xhc3MgaGFzIGEgYHRpY2tgIG1ldGhvZCB0aGF0IHdpbGwgc2NoZWR1bGUgdGhlIGRvVGljayBjYWxsLiBJdCBtYXkgYmUgY2FsbGVkIHN5bmNocm9uZW91c2x5XG4gICAqIG9ubHkgZm9yIGEgc3RhY2stZGVwdGggb2Ygb25lLiBPbiByZS1lbnRyYW50IGNhbGxzLCBzdWItc2VxdWVudCBjYWxscyBhcmUgc2NoZWR1bGVkIGZvciBuZXh0IG1haW4gbG9vcCB0aWNrcy5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFzayBleGVjdXRpb24gKGB0aWNrYCBtZXRob2QpIGlzIGNhbGxlZCBpbiByZS1lbnRyYW50IHdheSB0aGlzIGlzIGRldGVjdGVkIGFuZFxuICAgKiB3ZSBhcmUgbGltaXRpbmcgdGhlIHRhc2sgZXhlY3V0aW9uIHBlciBjYWxsIHN0YWNrIHRvIGV4YWN0bHkgb25lLCBidXQgc2NoZWR1bGluZy9wb3N0LXBvbmluZyBmdXJ0aGVyXG4gICAqIHRhc2sgcHJvY2Vzc2luZyBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIChhbHNvIGtub3duIGFzIFwibmV4dCB0aWNrXCIgaW4gdGhlIE5vZGUvSlMgcnVudGltZSBsaW5nbykuXG4gICAqL1xuICB2YXIgVGFza0xvb3AgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhc2tMb29wKCkge1xuICAgICAgdGhpcy5fYm91bmRUaWNrID0gdm9pZCAwO1xuICAgICAgdGhpcy5fdGlja1RpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICB0aGlzLl90aWNrQ2FsbENvdW50ID0gMDtcbiAgICAgIHRoaXMuX2JvdW5kVGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gVGFza0xvb3AucHJvdG90eXBlO1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMub25IYW5kbGVyRGVzdHJveWluZygpO1xuICAgICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95ZWQoKTtcbiAgICB9O1xuICAgIF9wcm90by5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICAgIC8vIGNsZWFyIGFsbCB0aW1lcnMgYmVmb3JlIHVucmVnaXN0ZXJpbmcgZnJvbSBldmVudCBidXNcbiAgICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWVkID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWVkKCkge307XG4gICAgX3Byb3RvLmhhc0ludGVydmFsID0gZnVuY3Rpb24gaGFzSW50ZXJ2YWwoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl90aWNrSW50ZXJ2YWw7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFzTmV4dFRpY2sgPSBmdW5jdGlvbiBoYXNOZXh0VGljaygpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX3RpY2tUaW1lcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbWlsbGlzIC0gSW50ZXJ2YWwgdGltZSAobXMpXG4gICAgICogQGV0dXJucyBUcnVlIHdoZW4gaW50ZXJ2YWwgaGFzIGJlZW4gc2NoZWR1bGVkLCBmYWxzZSB3aGVuIGFscmVhZHkgc2NoZWR1bGVkIChubyBlZmZlY3QpXG4gICAgICovO1xuICAgIF9wcm90by5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIHNldEludGVydmFsKG1pbGxpcykge1xuICAgICAgaWYgKCF0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5fYm91bmRUaWNrLCBtaWxsaXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUcnVlIHdoZW4gaW50ZXJ2YWwgd2FzIGNsZWFyZWQsIGZhbHNlIHdoZW4gbm9uZSB3YXMgc2V0IChubyBlZmZlY3QpXG4gICAgICovO1xuICAgIF9wcm90by5jbGVhckludGVydmFsID0gZnVuY3Rpb24gY2xlYXJJbnRlcnZhbCgpIHtcbiAgICAgIGlmICh0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuX3RpY2tJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRydWUgd2hlbiB0aW1lb3V0IHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgICAqLztcbiAgICBfcHJvdG8uY2xlYXJOZXh0VGljayA9IGZ1bmN0aW9uIGNsZWFyTmV4dFRpY2soKSB7XG4gICAgICBpZiAodGhpcy5fdGlja1RpbWVyKSB7XG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMuX3RpY2tUaW1lcik7XG4gICAgICAgIHRoaXMuX3RpY2tUaW1lciA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgY2FsbCB0aGUgc3ViY2xhc3MgZG9UaWNrIGltcGxlbWVudGF0aW9uIGluIHRoaXMgbWFpbiBsb29wIHRpY2tcbiAgICAgKiBvciBpbiB0aGUgbmV4dCBvbmUgKHZpYSBzZXRUaW1lb3V0KCwwKSkgaW4gY2FzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFxuICAgICAqIGluIHRoaXMgdGljayAoaW4gY2FzZSB0aGlzIGlzIGEgcmUtZW50cmFudCBjYWxsKS5cbiAgICAgKi87XG4gICAgX3Byb3RvLnRpY2sgPSBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCsrO1xuICAgICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPT09IDEpIHtcbiAgICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgICAgLy8gcmUtZW50cmFudCBjYWxsIHRvIHRpY2sgZnJvbSBwcmV2aW91cyBkb1RpY2sgY2FsbCBzdGFja1xuICAgICAgICAvLyAtPiBzY2hlZHVsZSBhIGNhbGwgb24gdGhlIG5leHQgbWFpbiBsb29wIGl0ZXJhdGlvbiB0byBwcm9jZXNzIHRoaXMgdGFzayBwcm9jZXNzaW5nIHJlcXVlc3RcbiAgICAgICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPiAxKSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIG9ubHkgb25lIHRpbWVyIGV4aXN0cyBhdCBhbnkgdGltZSBhdCBtYXhcbiAgICAgICAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90aWNrQ2FsbENvdW50ID0gMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50aWNrSW1tZWRpYXRlID0gZnVuY3Rpb24gdGlja0ltbWVkaWF0ZSgpIHtcbiAgICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgICAgdGhpcy5fdGlja1RpbWVyID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMuX2JvdW5kVGljaywgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIHN1YmNsYXNzIHRvIGltcGxlbWVudCB0YXNrIGxvZ2ljXG4gICAgICogQGFic3RyYWN0XG4gICAgICovO1xuICAgIF9wcm90by5kb1RpY2sgPSBmdW5jdGlvbiBkb1RpY2soKSB7fTtcbiAgICByZXR1cm4gVGFza0xvb3A7XG4gIH0oKTtcblxuICB2YXIgRnJhZ21lbnRTdGF0ZSA9IHtcbiAgICBOT1RfTE9BREVEOiBcIk5PVF9MT0FERURcIixcbiAgICBBUFBFTkRJTkc6IFwiQVBQRU5ESU5HXCIsXG4gICAgUEFSVElBTDogXCJQQVJUSUFMXCIsXG4gICAgT0s6IFwiT0tcIlxuICB9O1xuICB2YXIgRnJhZ21lbnRUcmFja2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcmFnbWVudFRyYWNrZXIoaGxzKSB7XG4gICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5mcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuYnVmZmVyUGFkZGluZyA9IDAuMjtcbiAgICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5oYXNHYXBzID0gZmFsc2U7XG4gICAgICB0aGlzLmhscyA9IGhscztcbiAgICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBGcmFnbWVudFRyYWNrZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub24oRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuZnJhZ21lbnRzID1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuYWN0aXZlUGFydExpc3RzID1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuZW5kTGlzdEZyYWdtZW50cyA9IHRoaXMudGltZVJhbmdlcyA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgRnJhZ21lbnQgb3IgUGFydCB3aXRoIGFuIGFwcGVuZGVkIHJhbmdlIHRoYXQgbWF0Y2hlcyB0aGUgcG9zaXRpb24gYW5kIGxldmVsVHlwZVxuICAgICAqIE90aGVyd2lzZSwgcmV0dXJuIG51bGxcbiAgICAgKi87XG4gICAgX3Byb3RvLmdldEFwcGVuZGVkRnJhZyA9IGZ1bmN0aW9uIGdldEFwcGVuZGVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKSB7XG4gICAgICB2YXIgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tsZXZlbFR5cGVdO1xuICAgICAgaWYgKGFjdGl2ZVBhcnRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBhY3RpdmVQYXJ0cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICB2YXIgYWN0aXZlUGFydCA9IGFjdGl2ZVBhcnRzW2ldO1xuICAgICAgICAgIGlmICghYWN0aXZlUGFydCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhcHBlbmRlZFBUUyA9IGFjdGl2ZVBhcnQuZW5kO1xuICAgICAgICAgIGlmIChhY3RpdmVQYXJ0LnN0YXJ0IDw9IHBvc2l0aW9uICYmIGFwcGVuZGVkUFRTICE9PSBudWxsICYmIHBvc2l0aW9uIDw9IGFwcGVuZGVkUFRTKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlUGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgbGV2ZWxUeXBlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBidWZmZXJlZCBGcmFnbWVudCB0aGF0IG1hdGNoZXMgdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGUuXG4gICAgICogQSBidWZmZXJlZCBGcmFnbWVudCBpcyBvbmUgd2hvc2UgbG9hZGluZywgcGFyc2luZyBhbmQgYXBwZW5kaW5nIGlzIGRvbmUgKGNvbXBsZXRlZCBvciBcInBhcnRpYWxcIiBtZWFuaW5nIGFib3J0ZWQpLlxuICAgICAqIElmIG5vdCBmb3VuZCBhbnkgRnJhZ21lbnQsIHJldHVybiBudWxsXG4gICAgICovO1xuICAgIF9wcm90by5nZXRCdWZmZXJlZEZyYWcgPSBmdW5jdGlvbiBnZXRCdWZmZXJlZEZyYWcocG9zaXRpb24sIGxldmVsVHlwZSkge1xuICAgICAgdmFyIGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudHMpO1xuICAgICAgZm9yICh2YXIgaSA9IGtleXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIHZhciBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXlzW2ldXTtcbiAgICAgICAgaWYgKChmcmFnbWVudEVudGl0eSA9PSBudWxsID8gdm9pZCAwIDogZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlKSA9PT0gbGV2ZWxUeXBlICYmIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSB7XG4gICAgICAgICAgdmFyIGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgICAgIGlmIChmcmFnLnN0YXJ0IDw9IHBvc2l0aW9uICYmIHBvc2l0aW9uIDw9IGZyYWcuZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnRpYWwgZnJhZ21lbnRzIGVmZmVjdGVkIGJ5IGNvZGVkIGZyYW1lIGV2aWN0aW9uIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqIFRoZSBicm93c2VyIHdpbGwgdW5sb2FkIHBhcnRzIG9mIHRoZSBidWZmZXIgdG8gZnJlZSB1cCBtZW1vcnkgZm9yIG5ldyBidWZmZXIgZGF0YVxuICAgICAqIEZyYWdtZW50cyB3aWxsIG5lZWQgdG8gYmUgcmVsb2FkZWQgd2hlbiB0aGUgYnVmZmVyIGlzIGZyZWVkIHVwLCByZW1vdmluZyBwYXJ0aWFsIGZyYWdtZW50cyB3aWxsIGFsbG93IHRoZW0gdG8gcmVsb2FkKHNpbmNlIHRoZXJlIG1pZ2h0IGJlIHBhcnRzIHRoYXQgYXJlIHN0aWxsIHBsYXlhYmxlKVxuICAgICAqLztcbiAgICBfcHJvdG8uZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyA9IGZ1bmN0aW9uIGRldGVjdEV2aWN0ZWRGcmFnbWVudHMoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlLCBwbGF5bGlzdFR5cGUsIGFwcGVuZGVkUGFydCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLnRpbWVSYW5nZXMpIHtcbiAgICAgICAgdGhpcy50aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dID0gdGltZVJhbmdlO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgYW55IGZsYWdnZWQgZnJhZ21lbnRzIGhhdmUgYmVlbiB1bmxvYWRlZFxuICAgICAgLy8gZXhjbHVkaW5nIGFueXRoaW5nIG5ld2VyIHRoYW4gYXBwZW5kZWRQYXJ0U25cbiAgICAgIHZhciBhcHBlbmRlZFBhcnRTbiA9IChhcHBlbmRlZFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVuZGVkUGFydC5mcmFnbWVudC5zbikgfHwgLTE7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBmcmFnbWVudEVudGl0eSA9IF90aGlzLmZyYWdtZW50c1trZXldO1xuICAgICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcHBlbmRlZFBhcnRTbiA+PSBmcmFnbWVudEVudGl0eS5ib2R5LnNuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgJiYgIWZyYWdtZW50RW50aXR5LmxvYWRlZCkge1xuICAgICAgICAgIGlmIChmcmFnbWVudEVudGl0eS5ib2R5LnR5cGUgPT09IHBsYXlsaXN0VHlwZSkge1xuICAgICAgICAgICAgX3RoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXNEYXRhID0gZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICAgIGlmICghZXNEYXRhKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVzRGF0YS50aW1lLnNvbWUoZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICB2YXIgaXNOb3RCdWZmZXJlZCA9ICFfdGhpcy5pc1RpbWVCdWZmZXJlZCh0aW1lLnN0YXJ0UFRTLCB0aW1lLmVuZFBUUywgdGltZVJhbmdlKTtcbiAgICAgICAgICBpZiAoaXNOb3RCdWZmZXJlZCkge1xuICAgICAgICAgICAgLy8gVW5yZWdpc3RlciBwYXJ0aWFsIGZyYWdtZW50IGFzIGl0IG5lZWRzIHRvIGxvYWQgYWdhaW4gdG8gYmUgcmV1c2VkXG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzTm90QnVmZmVyZWQ7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBmcmFnbWVudCBwYXNzZWQgaW4gaXMgbG9hZGVkIGluIHRoZSBidWZmZXIgcHJvcGVybHlcbiAgICAgKiBQYXJ0aWFsbHkgbG9hZGVkIGZyYWdtZW50cyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgICovO1xuICAgIF9wcm90by5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzID0gZnVuY3Rpb24gZGV0ZWN0UGFydGlhbEZyYWdtZW50cyhkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciB0aW1lUmFuZ2VzID0gdGhpcy50aW1lUmFuZ2VzO1xuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQ7XG4gICAgICBpZiAoIXRpbWVSYW5nZXMgfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5IHx8IGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkICYmIGZyYWcuZ2FwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpc0ZyYWdIaW50ID0gIWZyYWcucmVsdXJsO1xuICAgICAgT2JqZWN0LmtleXModGltZVJhbmdlcykuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudGFyeVN0cmVhbSkge1xuICAgICAgICB2YXIgc3RyZWFtSW5mbyA9IGZyYWcuZWxlbWVudGFyeVN0cmVhbXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICAgIGlmICghc3RyZWFtSW5mbykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGltZVJhbmdlID0gdGltZVJhbmdlc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgICAgdmFyIHBhcnRpYWwgPSBpc0ZyYWdIaW50IHx8IHN0cmVhbUluZm8ucGFydGlhbCA9PT0gdHJ1ZTtcbiAgICAgICAgZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV0gPSBfdGhpczIuZ2V0QnVmZmVyZWRUaW1lcyhmcmFnLCBwYXJ0LCBwYXJ0aWFsLCB0aW1lUmFuZ2UpO1xuICAgICAgfSk7XG4gICAgICBmcmFnbWVudEVudGl0eS5sb2FkZWQgPSBudWxsO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGZyYWdtZW50RW50aXR5LnJhbmdlKS5sZW5ndGgpIHtcbiAgICAgICAgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPSB0cnVlO1xuICAgICAgICB2YXIgZW5kTGlzdCA9IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kTGlzdCA9IGZyYWcuZW5kTGlzdCB8fCBmcmFnbWVudEVudGl0eS5ib2R5LmVuZExpc3Q7XG4gICAgICAgIGlmIChlbmRMaXN0KSB7XG4gICAgICAgICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzW2ZyYWdtZW50RW50aXR5LmJvZHkudHlwZV0gPSBmcmFnbWVudEVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUGFydGlhbChmcmFnbWVudEVudGl0eSkpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgb2xkZXIgZnJhZ21lbnQgcGFydHMgZnJvbSBsb29rdXAgYWZ0ZXIgZnJhZyBpcyB0cmFja2VkIGFzIGJ1ZmZlcmVkXG4gICAgICAgICAgdGhpcy5yZW1vdmVQYXJ0cyhmcmFnLnNuIC0gMSwgZnJhZy50eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIGZyYWdtZW50IGlmIG5vdGhpbmcgd2FzIGFwcGVuZGVkXG4gICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlUGFydHMgPSBmdW5jdGlvbiByZW1vdmVQYXJ0cyhzblRvS2VlcCwgbGV2ZWxUeXBlKSB7XG4gICAgICB2YXIgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tsZXZlbFR5cGVdO1xuICAgICAgaWYgKCFhY3RpdmVQYXJ0cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tsZXZlbFR5cGVdID0gYWN0aXZlUGFydHMuZmlsdGVyKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIHJldHVybiBwYXJ0LmZyYWdtZW50LnNuID49IHNuVG9LZWVwO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZnJhZ0J1ZmZlcmVkID0gZnVuY3Rpb24gZnJhZ0J1ZmZlcmVkKGZyYWcsIGZvcmNlKSB7XG4gICAgICB2YXIgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5ICYmIGZvcmNlKSB7XG4gICAgICAgIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV0gPSB7XG4gICAgICAgICAgYm9keTogZnJhZyxcbiAgICAgICAgICBhcHBlbmRlZFBUUzogbnVsbCxcbiAgICAgICAgICBsb2FkZWQ6IG51bGwsXG4gICAgICAgICAgYnVmZmVyZWQ6IGZhbHNlLFxuICAgICAgICAgIHJhbmdlOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmcmFnLmdhcCkge1xuICAgICAgICAgIHRoaXMuaGFzR2FwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmcmFnbWVudEVudGl0eSkge1xuICAgICAgICBmcmFnbWVudEVudGl0eS5sb2FkZWQgPSBudWxsO1xuICAgICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0QnVmZmVyZWRUaW1lcyA9IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkVGltZXMoZnJhZ21lbnQsIHBhcnQsIHBhcnRpYWwsIHRpbWVSYW5nZSkge1xuICAgICAgdmFyIGJ1ZmZlcmVkID0ge1xuICAgICAgICB0aW1lOiBbXSxcbiAgICAgICAgcGFydGlhbDogcGFydGlhbFxuICAgICAgfTtcbiAgICAgIHZhciBzdGFydFBUUyA9IGZyYWdtZW50LnN0YXJ0O1xuICAgICAgdmFyIGVuZFBUUyA9IGZyYWdtZW50LmVuZDtcbiAgICAgIHZhciBtaW5FbmRQVFMgPSBmcmFnbWVudC5taW5FbmRQVFMgfHwgZW5kUFRTO1xuICAgICAgdmFyIG1heFN0YXJ0UFRTID0gZnJhZ21lbnQubWF4U3RhcnRQVFMgfHwgc3RhcnRQVFM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgICB2YXIgZW5kVGltZSA9IHRpbWVSYW5nZS5lbmQoaSkgKyB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICAgIGlmIChtYXhTdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgbWluRW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgICAvLyBGcmFnbWVudCBpcyBlbnRpcmVseSBjb250YWluZWQgaW4gYnVmZmVyXG4gICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgb3RoZXIgdGltZVJhbmdlIHRpbWVzIHNpbmNlIGl0J3MgY29tcGxldGVseSBwbGF5YWJsZVxuICAgICAgICAgIGJ1ZmZlcmVkLnRpbWUucHVzaCh7XG4gICAgICAgICAgICBzdGFydFBUUzogTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSksXG4gICAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydFBUUyA8IGVuZFRpbWUgJiYgZW5kUFRTID4gc3RhcnRUaW1lKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSk7XG4gICAgICAgICAgdmFyIGVuZCA9IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSk7XG4gICAgICAgICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgICAgICBidWZmZXJlZC5wYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aCBidWZmZXJcbiAgICAgICAgICAgIC8vIEdldCBwbGF5YWJsZSBzZWN0aW9ucyBvZiB0aGUgZnJhZ21lbnRcbiAgICAgICAgICAgIGJ1ZmZlcmVkLnRpbWUucHVzaCh7XG4gICAgICAgICAgICAgIHN0YXJ0UFRTOiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kUFRTOiBlbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXJlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvciBhIGNlcnRhaW4gdGltZVxuICAgICAqLztcbiAgICBfcHJvdG8uZ2V0UGFydGlhbEZyYWdtZW50ID0gZnVuY3Rpb24gZ2V0UGFydGlhbEZyYWdtZW50KHRpbWUpIHtcbiAgICAgIHZhciBiZXN0RnJhZ21lbnQgPSBudWxsO1xuICAgICAgdmFyIHRpbWVQYWRkaW5nO1xuICAgICAgdmFyIHN0YXJ0VGltZTtcbiAgICAgIHZhciBlbmRUaW1lO1xuICAgICAgdmFyIGJlc3RPdmVybGFwID0gMDtcbiAgICAgIHZhciBidWZmZXJQYWRkaW5nID0gdGhpcy5idWZmZXJQYWRkaW5nLFxuICAgICAgICBmcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cztcbiAgICAgIE9iamVjdC5rZXlzKGZyYWdtZW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBmcmFnbWVudEVudGl0eSA9IGZyYWdtZW50c1trZXldO1xuICAgICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgICAgc3RhcnRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5zdGFydCAtIGJ1ZmZlclBhZGRpbmc7XG4gICAgICAgICAgZW5kVGltZSA9IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kICsgYnVmZmVyUGFkZGluZztcbiAgICAgICAgICBpZiAodGltZSA+PSBzdGFydFRpbWUgJiYgdGltZSA8PSBlbmRUaW1lKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGZyYWdtZW50IHRoYXQgaGFzIHRoZSBtb3N0IHBhZGRpbmcgZnJvbSBzdGFydCBhbmQgZW5kIHRpbWVcbiAgICAgICAgICAgIHRpbWVQYWRkaW5nID0gTWF0aC5taW4odGltZSAtIHN0YXJ0VGltZSwgZW5kVGltZSAtIHRpbWUpO1xuICAgICAgICAgICAgaWYgKGJlc3RPdmVybGFwIDw9IHRpbWVQYWRkaW5nKSB7XG4gICAgICAgICAgICAgIGJlc3RGcmFnbWVudCA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICAgICAgICAgIGJlc3RPdmVybGFwID0gdGltZVBhZGRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiZXN0RnJhZ21lbnQ7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNFbmRMaXN0QXBwZW5kZWQgPSBmdW5jdGlvbiBpc0VuZExpc3RBcHBlbmRlZCh0eXBlKSB7XG4gICAgICB2YXIgbGFzdEZyYWdtZW50RW50aXR5ID0gdGhpcy5lbmRMaXN0RnJhZ21lbnRzW3R5cGVdO1xuICAgICAgcmV0dXJuIGxhc3RGcmFnbWVudEVudGl0eSAhPT0gdW5kZWZpbmVkICYmIChsYXN0RnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgfHwgaXNQYXJ0aWFsKGxhc3RGcmFnbWVudEVudGl0eSkpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUoZnJhZ21lbnQpIHtcbiAgICAgIHZhciBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgICAgdmFyIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgaWYgKCFmcmFnbWVudEVudGl0eS5idWZmZXJlZCkge1xuICAgICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLkFQUEVORElORztcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcnRpYWwoZnJhZ21lbnRFbnRpdHkpKSB7XG4gICAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuUEFSVElBTDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5PSztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRDtcbiAgICB9O1xuICAgIF9wcm90by5pc1RpbWVCdWZmZXJlZCA9IGZ1bmN0aW9uIGlzVGltZUJ1ZmZlcmVkKHN0YXJ0UFRTLCBlbmRQVFMsIHRpbWVSYW5nZSkge1xuICAgICAgdmFyIHN0YXJ0VGltZTtcbiAgICAgIHZhciBlbmRUaW1lO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgICBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgICAgaWYgKHN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBlbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gb25GcmFnTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgcGFydCA9IGRhdGEucGFydDtcbiAgICAgIC8vIGRvbid0IHRyYWNrIGluaXRzZWdtZW50IChmb3Igd2hpY2ggc24gaXMgbm90IGEgbnVtYmVyKVxuICAgICAgLy8gZG9uJ3QgdHJhY2sgZnJhZ3MgdXNlZCBmb3IgYml0cmF0ZVRlc3QsIHRoZXkncmUgaXJyZWxldmFudC5cbiAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnIHx8IGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGcmFnbWVudCBlbnRpdHkgYGxvYWRlZGAgRnJhZ0xvYWRlZERhdGEgaXMgbnVsbCB3aGVuIGxvYWRpbmcgcGFydHNcbiAgICAgIHZhciBsb2FkZWQgPSBwYXJ0ID8gbnVsbCA6IGRhdGE7XG4gICAgICB2YXIgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgICAgdGhpcy5mcmFnbWVudHNbZnJhZ0tleV0gPSB7XG4gICAgICAgIGJvZHk6IGZyYWcsXG4gICAgICAgIGFwcGVuZGVkUFRTOiBudWxsLFxuICAgICAgICBsb2FkZWQ6IGxvYWRlZCxcbiAgICAgICAgYnVmZmVyZWQ6IGZhbHNlLFxuICAgICAgICByYW5nZTogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5vbkJ1ZmZlckFwcGVuZGVkID0gZnVuY3Rpb24gb25CdWZmZXJBcHBlbmRlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgcGFydCA9IGRhdGEucGFydCxcbiAgICAgICAgdGltZVJhbmdlcyA9IGRhdGEudGltZVJhbmdlcztcbiAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwbGF5bGlzdFR5cGUgPSBmcmFnLnR5cGU7XG4gICAgICBpZiAocGFydCkge1xuICAgICAgICB2YXIgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1twbGF5bGlzdFR5cGVdO1xuICAgICAgICBpZiAoIWFjdGl2ZVBhcnRzKSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHNbcGxheWxpc3RUeXBlXSA9IGFjdGl2ZVBhcnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUGFydHMucHVzaChwYXJ0KTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIHRoZSBsYXRlc3QgdGltZVJhbmdlcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlclxuICAgICAgdGhpcy50aW1lUmFuZ2VzID0gdGltZVJhbmdlcztcbiAgICAgIE9iamVjdC5rZXlzKHRpbWVSYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnRhcnlTdHJlYW0pIHtcbiAgICAgICAgdmFyIHRpbWVSYW5nZSA9IHRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICAgIF90aGlzMy5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKGVsZW1lbnRhcnlTdHJlYW0sIHRpbWVSYW5nZSwgcGxheWxpc3RUeXBlLCBwYXJ0KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLm9uRnJhZ0J1ZmZlcmVkID0gZnVuY3Rpb24gb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyhkYXRhKTtcbiAgICB9O1xuICAgIF9wcm90by5oYXNGcmFnbWVudCA9IGZ1bmN0aW9uIGhhc0ZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgICB2YXIgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICAgIHJldHVybiAhIXRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIH07XG4gICAgX3Byb3RvLmhhc1BhcnRzID0gZnVuY3Rpb24gaGFzUGFydHModHlwZSkge1xuICAgICAgdmFyIF90aGlzJGFjdGl2ZVBhcnRMaXN0cztcbiAgICAgIHJldHVybiAhISgoX3RoaXMkYWN0aXZlUGFydExpc3RzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbdHlwZV0pICE9IG51bGwgJiYgX3RoaXMkYWN0aXZlUGFydExpc3RzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZSA9IGZ1bmN0aW9uIHJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnQsIGVuZCwgcGxheWxpc3RUeXBlLCB3aXRoR2FwT25seSwgdW5idWZmZXJlZE9ubHkpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgaWYgKHdpdGhHYXBPbmx5ICYmICF0aGlzLmhhc0dhcHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgZnJhZ21lbnRFbnRpdHkgPSBfdGhpczQuZnJhZ21lbnRzW2tleV07XG4gICAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgICBpZiAoZnJhZy50eXBlICE9PSBwbGF5bGlzdFR5cGUgfHwgd2l0aEdhcE9ubHkgJiYgIWZyYWcuZ2FwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnLnN0YXJ0IDwgZW5kICYmIGZyYWcuZW5kID4gc3RhcnQgJiYgKGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkIHx8IHVuYnVmZmVyZWRPbmx5KSkge1xuICAgICAgICAgIF90aGlzNC5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlRnJhZ21lbnQgPSBmdW5jdGlvbiByZW1vdmVGcmFnbWVudChmcmFnbWVudCkge1xuICAgICAgdmFyIGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgICBmcmFnbWVudC5zdGF0cy5sb2FkZWQgPSAwO1xuICAgICAgZnJhZ21lbnQuY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpO1xuICAgICAgdmFyIGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbZnJhZ21lbnQudHlwZV07XG4gICAgICBpZiAoYWN0aXZlUGFydHMpIHtcbiAgICAgICAgdmFyIHNuVG9SZW1vdmUgPSBmcmFnbWVudC5zbjtcbiAgICAgICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHNbZnJhZ21lbnQudHlwZV0gPSBhY3RpdmVQYXJ0cy5maWx0ZXIoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFydC5mcmFnbWVudC5zbiAhPT0gc25Ub1JlbW92ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgICBpZiAoZnJhZ21lbnQuZW5kTGlzdCkge1xuICAgICAgICBkZWxldGUgdGhpcy5lbmRMaXN0RnJhZ21lbnRzW2ZyYWdtZW50LnR5cGVdO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUFsbEZyYWdtZW50cyA9IGZ1bmN0aW9uIHJlbW92ZUFsbEZyYWdtZW50cygpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuZW5kTGlzdEZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmhhc0dhcHMgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBGcmFnbWVudFRyYWNrZXI7XG4gIH0oKTtcbiAgZnVuY3Rpb24gaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSB7XG4gICAgdmFyIF9mcmFnbWVudEVudGl0eSRyYW5nZSwgX2ZyYWdtZW50RW50aXR5JHJhbmdlMiwgX2ZyYWdtZW50RW50aXR5JHJhbmdlMztcbiAgICByZXR1cm4gZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgJiYgKGZyYWdtZW50RW50aXR5LmJvZHkuZ2FwIHx8ICgoX2ZyYWdtZW50RW50aXR5JHJhbmdlID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UudmlkZW8pID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UucGFydGlhbCkgfHwgKChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW8pID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyLnBhcnRpYWwpIHx8ICgoX2ZyYWdtZW50RW50aXR5JHJhbmdlMyA9IGZyYWdtZW50RW50aXR5LnJhbmdlLmF1ZGlvdmlkZW8pID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UzLnBhcnRpYWwpKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRGcmFnbWVudEtleShmcmFnbWVudCkge1xuICAgIHJldHVybiBmcmFnbWVudC50eXBlICsgXCJfXCIgKyBmcmFnbWVudC5sZXZlbCArIFwiX1wiICsgZnJhZ21lbnQuc247XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZXMgbWV0aG9kcyBkZWFsaW5nIHdpdGggYnVmZmVyIGxlbmd0aCByZXRyaWV2YWwgZm9yIGV4YW1wbGUuXG4gICAqXG4gICAqIEluIGdlbmVyYWwsIGEgaGVscGVyIGFyb3VuZCBIVE1MNSBNZWRpYUVsZW1lbnQgVGltZVJhbmdlcyBnYXRoZXJlZCBmcm9tIGBidWZmZXJlZGAgcHJvcGVydHkuXG4gICAqXG4gICAqIEFsc28gQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9idWZmZXJlZFxuICAgKi9cblxuICB2YXIgbm9vcEJ1ZmZlcmVkID0ge1xuICAgIGxlbmd0aDogMCxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuICB2YXIgQnVmZmVySGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJIZWxwZXIoKSB7fVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIGBtZWRpYWAncyBidWZmZXJlZCBpbmNsdWRlIGBwb3NpdGlvbmBcbiAgICAgKi9cbiAgICBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCA9IGZ1bmN0aW9uIGlzQnVmZmVyZWQobWVkaWEsIHBvc2l0aW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICB2YXIgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBidWZmZXJlZC5zdGFydChpKSAmJiBwb3NpdGlvbiA8PSBidWZmZXJlZC5lbmQoaSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyB0aGlzIGlzIHRvIGNhdGNoXG4gICAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgICAvLyBUaGlzIFNvdXJjZUJ1ZmZlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudCBtZWRpYSBzb3VyY2VcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvID0gZnVuY3Rpb24gYnVmZmVySW5mbyhtZWRpYSwgcG9zLCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgIHZhciB2YnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgICAgIHZhciBidWZmZXJlZCA9IFtdO1xuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJ1ZmZlcmVkLnB1c2goe1xuICAgICAgICAgICAgICBzdGFydDogdmJ1ZmZlcmVkLnN0YXJ0KGkpLFxuICAgICAgICAgICAgICBlbmQ6IHZidWZmZXJlZC5lbmQoaSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJlZEluZm8oYnVmZmVyZWQsIHBvcywgbWF4SG9sZUR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0byBjYXRjaFxuICAgICAgICAvLyBJbnZhbGlkU3RhdGVFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdidWZmZXJlZCcgcHJvcGVydHkgZnJvbSAnU291cmNlQnVmZmVyJzpcbiAgICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZW46IDAsXG4gICAgICAgIHN0YXJ0OiBwb3MsXG4gICAgICAgIGVuZDogcG9zLFxuICAgICAgICBuZXh0U3RhcnQ6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9O1xuICAgIEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm8gPSBmdW5jdGlvbiBidWZmZXJlZEluZm8oYnVmZmVyZWQsIHBvcywgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICBwb3MgPSBNYXRoLm1heCgwLCBwb3MpO1xuICAgICAgLy8gc29ydCBvbiBidWZmZXIuc3RhcnQvc21hbGxlciBlbmQgKElFIGRvZXMgbm90IGFsd2F5cyByZXR1cm4gc29ydGVkIGJ1ZmZlcmVkIHJhbmdlKVxuICAgICAgYnVmZmVyZWQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgZGlmZiA9IGEuc3RhcnQgLSBiLnN0YXJ0O1xuICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBiLmVuZCAtIGEuZW5kO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBidWZmZXJlZDIgPSBbXTtcbiAgICAgIGlmIChtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgc29tZSBzbWFsbCBob2xlcyBiZXR3ZWVuIGJ1ZmZlciB0aW1lIHJhbmdlXG4gICAgICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgICAgICAvLyBidWZmZXIgdGltZSByYW5nZSByZXByZXNlbnRhdGlvbnMgdGhhdCBkaXNjYXJkcyB0aG9zZSBob2xlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGJ1ZjJsZW4gPSBidWZmZXJlZDIubGVuZ3RoO1xuICAgICAgICAgIGlmIChidWYybGVuKSB7XG4gICAgICAgICAgICB2YXIgYnVmMmVuZCA9IGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kO1xuICAgICAgICAgICAgLy8gaWYgc21hbGwgaG9sZSAodmFsdWUgYmV0d2VlbiAwIG9yIG1heEhvbGVEdXJhdGlvbiApIG9yIG92ZXJsYXBwaW5nIChuZWdhdGl2ZSlcbiAgICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5zdGFydCAtIGJ1ZjJlbmQgPCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gbWVyZ2Ugb3ZlcmxhcHBpbmcgdGltZSByYW5nZXNcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIGxhc3RSYW5nZS5lbmQgb25seSBpZiBzbWFsbGVyIHRoYW4gaXRlbS5lbmRcbiAgICAgICAgICAgICAgLy8gZS5nLiAgWyAxLCAxNV0gd2l0aCAgWyAyLDhdID0+IFsgMSwxNV0gKG5vIG5lZWQgdG8gbW9kaWZ5IGxhc3RSYW5nZS5lbmQpXG4gICAgICAgICAgICAgIC8vIHdoZXJlYXMgWyAxLCA4XSB3aXRoICBbIDIsMTVdID0+IFsgMSwxNV0gKCBsYXN0UmFuZ2Ugc2hvdWxkIHN3aXRjaCBmcm9tIFsxLDhdIHRvIFsxLDE1XSlcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLmVuZCA+IGJ1ZjJlbmQpIHtcbiAgICAgICAgICAgICAgICBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZCA9IGJ1ZmZlcmVkW2ldLmVuZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYmlnIGhvbGVcbiAgICAgICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmaXJzdCB2YWx1ZVxuICAgICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyZWQyID0gYnVmZmVyZWQ7XG4gICAgICB9XG4gICAgICB2YXIgYnVmZmVyTGVuID0gMDtcblxuICAgICAgLy8gYnVmZmVyU3RhcnROZXh0IGNhbiBwb3NzaWJseSBiZSB1bmRlZmluZWQgYmFzZWQgb24gdGhlIGNvbmRpdGlvbmFsIGxvZ2ljIGJlbG93XG4gICAgICB2YXIgYnVmZmVyU3RhcnROZXh0O1xuXG4gICAgICAvLyBidWZmZXJTdGFydCBhbmQgYnVmZmVyRW5kIGFyZSBidWZmZXIgYm91bmRhcmllcyBhcm91bmQgY3VycmVudCB2aWRlbyBwb3NpdGlvblxuICAgICAgdmFyIGJ1ZmZlclN0YXJ0ID0gcG9zO1xuICAgICAgdmFyIGJ1ZmZlckVuZCA9IHBvcztcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBidWZmZXJlZDIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkMltfaV0uc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSBidWZmZXJlZDJbX2ldLmVuZDtcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnYnVmIHN0YXJ0L2VuZDonICsgYnVmZmVyZWQuc3RhcnQoaSkgKyAnLycgKyBidWZmZXJlZC5lbmQoaSkpO1xuICAgICAgICBpZiAocG9zICsgbWF4SG9sZUR1cmF0aW9uID49IHN0YXJ0ICYmIHBvcyA8IGVuZCkge1xuICAgICAgICAgIC8vIHBsYXkgcG9zaXRpb24gaXMgaW5zaWRlIHRoaXMgYnVmZmVyIFRpbWVSYW5nZSwgcmV0cmlldmUgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvbiBhbmQgYnVmZmVyIGxlbmd0aFxuICAgICAgICAgIGJ1ZmZlclN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgYnVmZmVyRW5kID0gZW5kO1xuICAgICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckVuZCAtIHBvcztcbiAgICAgICAgfSBlbHNlIGlmIChwb3MgKyBtYXhIb2xlRHVyYXRpb24gPCBzdGFydCkge1xuICAgICAgICAgIGJ1ZmZlclN0YXJ0TmV4dCA9IHN0YXJ0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZW46IGJ1ZmZlckxlbixcbiAgICAgICAgc3RhcnQ6IGJ1ZmZlclN0YXJ0IHx8IDAsXG4gICAgICAgIGVuZDogYnVmZmVyRW5kIHx8IDAsXG4gICAgICAgIG5leHRTdGFydDogYnVmZmVyU3RhcnROZXh0XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhZmUgbWV0aG9kIHRvIGdldCBidWZmZXJlZCBwcm9wZXJ0eS5cbiAgICAgKiBTb3VyY2VCdWZmZXIuYnVmZmVyZWQgbWF5IHRocm93IGlmIFNvdXJjZUJ1ZmZlciBpcyByZW1vdmVkIGZyb20gaXQncyBNZWRpYVNvdXJjZVxuICAgICAqLztcbiAgICBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQgPSBmdW5jdGlvbiBnZXRCdWZmZXJlZChtZWRpYSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1lZGlhLmJ1ZmZlcmVkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIubG9nKCdmYWlsZWQgdG8gZ2V0IG1lZGlhLmJ1ZmZlcmVkJywgZSk7XG4gICAgICAgIHJldHVybiBub29wQnVmZmVyZWQ7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVySGVscGVyO1xuICB9KCk7XG5cbiAgdmFyIENodW5rTWV0YWRhdGEgPSBmdW5jdGlvbiBDaHVua01ldGFkYXRhKGxldmVsLCBzbiwgaWQsIHNpemUsIHBhcnQsIHBhcnRpYWwpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzaXplID0gMDtcbiAgICB9XG4gICAgaWYgKHBhcnQgPT09IHZvaWQgMCkge1xuICAgICAgcGFydCA9IC0xO1xuICAgIH1cbiAgICBpZiAocGFydGlhbCA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJ0aWFsID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubGV2ZWwgPSB2b2lkIDA7XG4gICAgdGhpcy5zbiA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLnNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJ0aWFsID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNtdXhpbmcgPSBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpO1xuICAgIHRoaXMuYnVmZmVyaW5nID0ge1xuICAgICAgYXVkaW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCksXG4gICAgICB2aWRlbzogZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKSxcbiAgICAgIGF1ZGlvdmlkZW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKClcbiAgICB9O1xuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLnNuID0gc247XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICB0aGlzLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICB9O1xuICBmdW5jdGlvbiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBleGVjdXRlU3RhcnQ6IDAsXG4gICAgICBleGVjdXRlRW5kOiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRGaXJzdEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCBjYykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmcmFnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBfZnJhZ21lbnRzJGk7XG4gICAgICBpZiAoKChfZnJhZ21lbnRzJGkgPSBmcmFnbWVudHNbaV0pID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZ21lbnRzJGkuY2MpID09PSBjYykge1xuICAgICAgICByZXR1cm4gZnJhZ21lbnRzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBzd2l0Y2hEZXRhaWxzLCBkZXRhaWxzKSB7XG4gICAgaWYgKHN3aXRjaERldGFpbHMpIHtcbiAgICAgIGlmIChkZXRhaWxzLmVuZENDID4gZGV0YWlscy5zdGFydENDIHx8IGxhc3RGcmFnICYmIGxhc3RGcmFnLmNjIDwgZGV0YWlscy5zdGFydENDKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBGaW5kIHRoZSBmaXJzdCBmcmFnIGluIHRoZSBwcmV2aW91cyBsZXZlbCB3aGljaCBtYXRjaGVzIHRoZSBDQyBvZiB0aGUgZmlyc3QgZnJhZyBvZiB0aGUgbmV3IGxldmVsXG4gIGZ1bmN0aW9uIGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhwcmV2RGV0YWlscywgY3VyRGV0YWlscykge1xuICAgIHZhciBwcmV2RnJhZ3MgPSBwcmV2RGV0YWlscy5mcmFnbWVudHM7XG4gICAgdmFyIGN1ckZyYWdzID0gY3VyRGV0YWlscy5mcmFnbWVudHM7XG4gICAgaWYgKCFjdXJGcmFncy5sZW5ndGggfHwgIXByZXZGcmFncy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coJ05vIGZyYWdtZW50cyB0byBhbGlnbicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJldlN0YXJ0RnJhZyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0MocHJldkZyYWdzLCBjdXJGcmFnc1swXS5jYyk7XG4gICAgaWYgKCFwcmV2U3RhcnRGcmFnIHx8IHByZXZTdGFydEZyYWcgJiYgIXByZXZTdGFydEZyYWcuc3RhcnRQVFMpIHtcbiAgICAgIGxvZ2dlci5sb2coJ05vIGZyYWcgaW4gcHJldmlvdXMgbGV2ZWwgdG8gYWxpZ24gb24nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZTdGFydEZyYWc7XG4gIH1cbiAgZnVuY3Rpb24gYWRqdXN0RnJhZ21lbnRTdGFydChmcmFnLCBzbGlkaW5nKSB7XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIHZhciBzdGFydCA9IGZyYWcuc3RhcnQgKyBzbGlkaW5nO1xuICAgICAgZnJhZy5zdGFydCA9IGZyYWcuc3RhcnRQVFMgPSBzdGFydDtcbiAgICAgIGZyYWcuZW5kUFRTID0gc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhZGp1c3RTbGlkaW5nU3RhcnQoc2xpZGluZywgZGV0YWlscykge1xuICAgIC8vIFVwZGF0ZSBzZWdtZW50c1xuICAgIHZhciBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZnJhZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhZGp1c3RGcmFnbWVudFN0YXJ0KGZyYWdtZW50c1tpXSwgc2xpZGluZyk7XG4gICAgfVxuICAgIC8vIFVwZGF0ZSBMTC1ITFMgcGFydHMgYXQgdGhlIGVuZCBvZiB0aGUgcGxheWxpc3RcbiAgICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAgIGFkanVzdEZyYWdtZW50U3RhcnQoZGV0YWlscy5mcmFnbWVudEhpbnQsIHNsaWRpbmcpO1xuICAgIH1cbiAgICBkZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2luZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgbGFzdCBsZXZlbCwgdGhpcyBmdW5jdGlvbiBjb21wdXRlcyBQVFMnIG9mIHRoZSBuZXcgZnJhZ21lbnRzIHNvIHRoYXQgdGhleSBmb3JtIGFcbiAgICogY29udGlndW91cyBzdHJlYW0gd2l0aCB0aGUgbGFzdCBmcmFnbWVudHMuXG4gICAqIFRoZSBQVFMgb2YgYSBmcmFnbWVudCBsZXRzIEhscy5qcyBrbm93IHdoZXJlIGl0IGZpdHMgaW50byBhIHN0cmVhbSAtIGJ5IGtub3dpbmcgZXZlcnkgUFRTLCB3ZSBrbm93IHdoaWNoIGZyYWdtZW50IHRvXG4gICAqIGRvd25sb2FkIGF0IGFueSBnaXZlbiB0aW1lLiBQVFMgaXMgbm9ybWFsbHkgY29tcHV0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgaXMgZGVtdXhlZCwgc28gdGFraW5nIHRoaXMgc3RlcCBzYXZlcyB1cyB0aW1lXG4gICAqIGFuZCBhbiBleHRyYSBkb3dubG9hZC5cbiAgICogQHBhcmFtIGxhc3RGcmFnXG4gICAqIEBwYXJhbSBsYXN0TGV2ZWxcbiAgICogQHBhcmFtIGRldGFpbHNcbiAgICovXG4gIGZ1bmN0aW9uIGFsaWduU3RyZWFtKGxhc3RGcmFnLCBzd2l0Y2hEZXRhaWxzLCBkZXRhaWxzKSB7XG4gICAgaWYgKCFzd2l0Y2hEZXRhaWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFsaWduRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBkZXRhaWxzLCBzd2l0Y2hEZXRhaWxzKTtcbiAgICBpZiAoIWRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgc3dpdGNoRGV0YWlscykge1xuICAgICAgLy8gSWYgdGhlIFBUUyB3YXNuJ3QgZmlndXJlZCBvdXQgdmlhIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgdGhhdCBtZWFucyB0aGVyZSB3YXMgbm8gQ0MgaW5jcmVhc2Ugd2l0aGluIHRoZSBsZXZlbC5cbiAgICAgIC8vIEFsaWduaW5nIHZpYSBQcm9ncmFtIERhdGUgVGltZSBzaG91bGQgdGhlcmVmb3JlIGJlIHJlbGlhYmxlLCBzaW5jZSBQRFQgc2hvdWxkIGJlIHRoZSBzYW1lIHdpdGhpbiB0aGUgc2FtZVxuICAgICAgLy8gZGlzY29udGludWl0eSBzZXF1ZW5jZS5cbiAgICAgIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKGRldGFpbHMsIHN3aXRjaERldGFpbHMpO1xuICAgIH1cbiAgICBpZiAoIWRldGFpbHMuYWxpZ25lZFNsaWRpbmcgJiYgc3dpdGNoRGV0YWlscyAmJiAhZGV0YWlscy5za2lwcGVkU2VnbWVudHMpIHtcbiAgICAgIC8vIFRyeSB0byBhbGlnbiBvbiBzbiBzbyB0aGF0IHdlIHBpY2sgYSBiZXR0ZXIgc3RhcnQgZnJhZ21lbnQuXG4gICAgICAvLyBEbyBub3QgcGVyZm9ybSB0aGlzIG9uIHBsYXlsaXN0cyB3aXRoIGRlbHRhIHVwZGF0ZXMgYXMgdGhpcyBpcyBvbmx5IHRvIGFsaWduIGxldmVscyBvbiBzd2l0Y2hcbiAgICAgIC8vIGFuZCBhZGp1c3RTbGlkaW5nIG9ubHkgYWRqdXN0cyBmcmFnbWVudHMgYWZ0ZXIgc2tpcHBlZFNlZ21lbnRzLlxuICAgICAgYWRqdXN0U2xpZGluZyhzd2l0Y2hEZXRhaWxzLCBkZXRhaWxzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIFBUUyBpZiBhIG5ldyBsZXZlbCdzIGZyYWdtZW50cyB1c2luZyB0aGUgUFRTIG9mIGEgZnJhZ21lbnQgaW4gdGhlIGxhc3QgbGV2ZWwgd2hpY2ggc2hhcmVzIHRoZSBzYW1lXG4gICAqIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSBsYXN0RnJhZyAtIFRoZSBsYXN0IEZyYWdtZW50IHdoaWNoIHNoYXJlcyB0aGUgc2FtZSBkaXNjb250aW51aXR5IHNlcXVlbmNlXG4gICAqIEBwYXJhbSBsYXN0TGV2ZWwgLSBUaGUgZGV0YWlscyBvZiB0aGUgbGFzdCBsb2FkZWQgbGV2ZWxcbiAgICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgbmV3IGxldmVsXG4gICAqL1xuICBmdW5jdGlvbiBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgc3dpdGNoRGV0YWlscykge1xuICAgIGlmIChzaG91bGRBbGlnbk9uRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBzd2l0Y2hEZXRhaWxzLCBkZXRhaWxzKSkge1xuICAgICAgdmFyIHJlZmVyZW5jZUZyYWcgPSBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcoc3dpdGNoRGV0YWlscywgZGV0YWlscyk7XG4gICAgICBpZiAocmVmZXJlbmNlRnJhZyAmJiBpc0Zpbml0ZU51bWJlcihyZWZlcmVuY2VGcmFnLnN0YXJ0KSkge1xuICAgICAgICBsb2dnZXIubG9nKFwiQWRqdXN0aW5nIFBUUyB1c2luZyBsYXN0IGxldmVsIGR1ZSB0byBDQyBpbmNyZWFzZSB3aXRoaW4gY3VycmVudCBsZXZlbCBcIiArIGRldGFpbHMudXJsKTtcbiAgICAgICAgYWRqdXN0U2xpZGluZ1N0YXJ0KHJlZmVyZW5jZUZyYWcuc3RhcnQsIGRldGFpbHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIGFwcHJvcHJpYXRlIHRpbWUtYWxpZ25tZW50IGJldHdlZW4gcmVuZGl0aW9ucyBiYXNlZCBvbiBQRFQuXG4gICAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGUgdGltZWxpbmVzIHJlcHJlc2VudGVkIGluIGByZWZEZXRhaWxzYCBhcmUgYWNjdXJhdGUsIGluY2x1ZGluZyB0aGUgUERUc1xuICAgKiBmb3IgdGhlIGxhc3QgZGlzY29udGludWl0eSBzZXF1ZW5jZSBudW1iZXIgc2hhcmVkIGJ5IGJvdGggcGxheWxpc3RzIHdoZW4gcHJlc2VudCxcbiAgICogYW5kIHVzZXMgdGhlIFwid2FsbGNsb2NrXCIvUERUIHRpbWVsaW5lIGFzIGEgY3Jvc3MtcmVmZXJlbmNlIHRvIGBkZXRhaWxzYCwgYWRqdXN0aW5nIHRoZSBwcmVzZW50YXRpb25cbiAgICogdGltZXMvdGltZWxpbmVzIG9mIGBkZXRhaWxzYCBhY2NvcmRpbmdseS5cbiAgICogR2l2ZW4gdGhlIGFzeW5jaHJvbm91cyBuYXR1cmUgb2YgZmV0Y2hlcyBhbmQgaW5pdGlhbCBsb2FkcyBvZiBsaXZlIGBtYWluYCBhbmQgYXVkaW8vc3VidGl0bGUgdHJhY2tzLFxuICAgKiB0aGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdG8gZW5zdXJlIHRoZSBcImxvY2FsIHRpbWVsaW5lc1wiIG9mIGF1ZGlvL3N1YnRpdGxlIHRyYWNrc1xuICAgKiBhcmUgYWxpZ25lZCB0byB0aGUgbWFpbi92aWRlbyB0aW1lbGluZSwgdXNpbmcgUERUIGFzIHRoZSBjcm9zcy1yZWZlcmVuY2UvXCJhbmNob3JcIiB0aGF0IHNob3VsZFxuICAgKiBiZSBjb25zaXN0ZW50IGFjcm9zcyBwbGF5bGlzdHMsIHBlciB0aGUgSExTIHNwZWMuXG4gICAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIHJlbmRpdGlvbiB5b3UnZCBsaWtlIHRvIHRpbWUtYWxpZ24gKGUuZy4gYW4gYXVkaW8gcmVuZGl0aW9uKS5cbiAgICogQHBhcmFtIHJlZkRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgcmVmZXJlbmNlIHJlbmRpdGlvbiB3aXRoIHN0YXJ0IGFuZCBQRFQgdGltZXMgZm9yIGFsaWdubWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKGRldGFpbHMsIHJlZkRldGFpbHMpIHtcbiAgICBpZiAoIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFyZWZEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gICAgdmFyIHJlZkZyYWdtZW50cyA9IHJlZkRldGFpbHMuZnJhZ21lbnRzO1xuICAgIGlmICghZnJhZ21lbnRzLmxlbmd0aCB8fCAhcmVmRnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBhIGRlbHRhIHRvIGFwcGx5IHRvIGFsbCBmcmFnbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBkZWx0YSBpbiBQRFQgdGltZXMgYW5kIHN0YXJ0IHRpbWVzXG4gICAgLy8gb2YgYSBmcmFnbWVudCBpbiB0aGUgcmVmZXJlbmNlIGRldGFpbHMsIGFuZCBhIGZyYWdtZW50IGluIHRoZSB0YXJnZXQgZGV0YWlscyBvZiB0aGUgc2FtZSBkaXNjb250aW51aXR5LlxuICAgIC8vIElmIGEgZnJhZ21lbnQgb2YgdGhlIHNhbWUgZGlzY29udGludWl0eSB3YXMgbm90IGZvdW5kIHVzZSB0aGUgbWlkZGxlIGZyYWdtZW50IG9mIGJvdGguXG4gICAgdmFyIHJlZkZyYWc7XG4gICAgdmFyIGZyYWc7XG4gICAgdmFyIHRhcmdldENDID0gTWF0aC5taW4ocmVmRGV0YWlscy5lbmRDQywgZGV0YWlscy5lbmRDQyk7XG4gICAgaWYgKHJlZkRldGFpbHMuc3RhcnRDQyA8IHRhcmdldENDICYmIGRldGFpbHMuc3RhcnRDQyA8IHRhcmdldENDKSB7XG4gICAgICByZWZGcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhyZWZGcmFnbWVudHMsIHRhcmdldENDKTtcbiAgICAgIGZyYWcgPSBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50cywgdGFyZ2V0Q0MpO1xuICAgIH1cbiAgICBpZiAoIXJlZkZyYWcgfHwgIWZyYWcpIHtcbiAgICAgIHJlZkZyYWcgPSByZWZGcmFnbWVudHNbTWF0aC5mbG9vcihyZWZGcmFnbWVudHMubGVuZ3RoIC8gMildO1xuICAgICAgZnJhZyA9IGZpbmRGaXJzdEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCByZWZGcmFnLmNjKSB8fCBmcmFnbWVudHNbTWF0aC5mbG9vcihmcmFnbWVudHMubGVuZ3RoIC8gMildO1xuICAgIH1cbiAgICB2YXIgcmVmUERUID0gcmVmRnJhZy5wcm9ncmFtRGF0ZVRpbWU7XG4gICAgdmFyIHRhcmdldFBEVCA9IGZyYWcucHJvZ3JhbURhdGVUaW1lO1xuICAgIGlmICghcmVmUERUIHx8ICF0YXJnZXRQRFQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRlbHRhID0gKHRhcmdldFBEVCAtIHJlZlBEVCkgLyAxMDAwIC0gKGZyYWcuc3RhcnQgLSByZWZGcmFnLnN0YXJ0KTtcbiAgICBhZGp1c3RTbGlkaW5nU3RhcnQoZGVsdGEsIGRldGFpbHMpO1xuICB9XG5cbiAgdmFyIE1JTl9DSFVOS19TSVpFID0gTWF0aC5wb3coMiwgMTcpOyAvLyAxMjhrYlxuICB2YXIgRnJhZ21lbnRMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZyYWdtZW50TG9hZGVyKGNvbmZpZykge1xuICAgICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgICB0aGlzLnBhcnRMb2FkVGltZW91dCA9IC0xO1xuICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBGcmFnbWVudExvYWRlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgICAgLy8gQWJvcnQgdGhlIGxvYWRlciBmb3IgY3VycmVudCBmcmFnbWVudC4gT25seSBvbmUgbWF5IGxvYWQgYXQgYW55IGdpdmVuIHRpbWVcbiAgICAgICAgdGhpcy5sb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChmcmFnLCBfb25Qcm9ncmVzcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciB1cmwgPSBmcmFnLnVybDtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiRnJhZ21lbnQgZG9lcyBub3QgaGF2ZSBhIFwiICsgKHVybCA/ICdwYXJ0IGxpc3QnIDogJ3VybCcpKSxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbnVsbFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFib3J0KCk7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICB2YXIgRnJhZ21lbnRJTG9hZGVyID0gY29uZmlnLmZMb2FkZXI7XG4gICAgICB2YXIgRGVmYXVsdElMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKF90aGlzLmxvYWRlcikge1xuICAgICAgICAgIF90aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWcuZ2FwKSB7XG4gICAgICAgICAgaWYgKGZyYWcudGFnTGlzdC5zb21lKGZ1bmN0aW9uICh0YWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnc1swXSA9PT0gJ0dBUCc7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJlamVjdChjcmVhdGVHYXBMb2FkRXJyb3IoZnJhZykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXNldCB0ZW1wb3JhcnkgdHJlYXRtZW50IGFzIEdBUCB0YWdcbiAgICAgICAgICAgIGZyYWcuZ2FwID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBsb2FkZXIgPSBfdGhpcy5sb2FkZXIgPSBmcmFnLmxvYWRlciA9IEZyYWdtZW50SUxvYWRlciA/IG5ldyBGcmFnbWVudElMb2FkZXIoY29uZmlnKSA6IG5ldyBEZWZhdWx0SUxvYWRlcihjb25maWcpO1xuICAgICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZyk7XG4gICAgICAgIHZhciBsb2FkUG9saWN5ID0gZ2V0TG9hZGVyQ29uZmlnV2l0aG91dFJldGllcyhjb25maWcuZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdCk7XG4gICAgICAgIHZhciBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgICAgbG9hZFBvbGljeTogbG9hZFBvbGljeSxcbiAgICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5OiAwLFxuICAgICAgICAgIGhpZ2hXYXRlck1hcms6IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgPyBJbmZpbml0eSA6IE1JTl9DSFVOS19TSVpFXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFzc2lnbiBmcmFnIHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcbiAgICAgICAgZnJhZy5zdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAgICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCB7XG4gICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgICAgX3RoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnJlc2V0SVYgJiYgZnJhZy5kZWNyeXB0ZGF0YSkge1xuICAgICAgICAgICAgICBmcmFnLmRlY3J5cHRkYXRhLml2ID0gbmV3IFVpbnQ4QXJyYXkocGF5bG9hZC5zbGljZSgwLCAxNikpO1xuICAgICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5zbGljZSgxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykge1xuICAgICAgICAgICAgX3RoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH0sIHJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIkhUVFAgRXJyb3IgXCIgKyByZXNwb25zZS5jb2RlICsgXCIgXCIgKyByZXNwb25zZS50ZXh0KSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0czogc3RhdHNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQWJvcnQ6IGZ1bmN0aW9uIG9uQWJvcnQoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgICBfdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoJ0Fib3J0ZWQnKSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0czogc3RhdHNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uVGltZW91dDogZnVuY3Rpb24gb25UaW1lb3V0KHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgICAgX3RoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIlRpbWVvdXQgYWZ0ZXIgXCIgKyBsb2FkZXJDb25maWcudGltZW91dCArIFwibXNcIiksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgICAgc3RhdHM6IHN0YXRzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBkYXRhLCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgICAgaWYgKF9vblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIF9vblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbmV0d29ya0RldGFpbHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRQYXJ0ID0gZnVuY3Rpb24gbG9hZFBhcnQoZnJhZywgcGFydCwgb25Qcm9ncmVzcykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB0aGlzLmFib3J0KCk7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICB2YXIgRnJhZ21lbnRJTG9hZGVyID0gY29uZmlnLmZMb2FkZXI7XG4gICAgICB2YXIgRGVmYXVsdElMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKF90aGlzMi5sb2FkZXIpIHtcbiAgICAgICAgICBfdGhpczIubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZy5nYXAgfHwgcGFydC5nYXApIHtcbiAgICAgICAgICByZWplY3QoY3JlYXRlR2FwTG9hZEVycm9yKGZyYWcsIHBhcnQpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvYWRlciA9IF90aGlzMi5sb2FkZXIgPSBmcmFnLmxvYWRlciA9IEZyYWdtZW50SUxvYWRlciA/IG5ldyBGcmFnbWVudElMb2FkZXIoY29uZmlnKSA6IG5ldyBEZWZhdWx0SUxvYWRlcihjb25maWcpO1xuICAgICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZywgcGFydCk7XG4gICAgICAgIC8vIFNob3VsZCB3ZSBkZWZpbmUgYW5vdGhlciBsb2FkIHBvbGljeSBmb3IgcGFydHM/XG4gICAgICAgIHZhciBsb2FkUG9saWN5ID0gZ2V0TG9hZGVyQ29uZmlnV2l0aG91dFJldGllcyhjb25maWcuZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdCk7XG4gICAgICAgIHZhciBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgICAgbG9hZFBvbGljeTogbG9hZFBvbGljeSxcbiAgICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5OiAwLFxuICAgICAgICAgIGhpZ2hXYXRlck1hcms6IE1JTl9DSFVOS19TSVpFXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFzc2lnbiBwYXJ0IHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcbiAgICAgICAgcGFydC5zdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAgICAgbG9hZGVyLmxvYWQobG9hZGVyQ29udGV4dCwgbG9hZGVyQ29uZmlnLCB7XG4gICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgICAgX3RoaXMyLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgICBfdGhpczIudXBkYXRlU3RhdHNGcm9tUGFydChmcmFnLCBwYXJ0KTtcbiAgICAgICAgICAgIHZhciBwYXJ0TG9hZGVkRGF0YSA9IHtcbiAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICAgICAgcGF5bG9hZDogcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgICAgICByZXNvbHZlKHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykge1xuICAgICAgICAgICAgX3RoaXMyLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgICByZXNwb25zZTogX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH0sIHJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIkhUVFAgRXJyb3IgXCIgKyByZXNwb25zZS5jb2RlICsgXCIgXCIgKyByZXNwb25zZS50ZXh0KSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0czogc3RhdHNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQWJvcnQ6IGZ1bmN0aW9uIG9uQWJvcnQoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgICBmcmFnLnN0YXRzLmFib3J0ZWQgPSBwYXJ0LnN0YXRzLmFib3J0ZWQ7XG4gICAgICAgICAgICBfdGhpczIucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfQUJPUlRFRCxcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdBYm9ydGVkJyksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgICAgc3RhdHM6IHN0YXRzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblRpbWVvdXQ6IGZ1bmN0aW9uIG9uVGltZW91dChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICAgIF90aGlzMi5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiVGltZW91dCBhZnRlciBcIiArIGxvYWRlckNvbmZpZy50aW1lb3V0ICsgXCJtc1wiKSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0czogc3RhdHNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8udXBkYXRlU3RhdHNGcm9tUGFydCA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRzRnJvbVBhcnQoZnJhZywgcGFydCkge1xuICAgICAgdmFyIGZyYWdTdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgICB2YXIgcGFydFN0YXRzID0gcGFydC5zdGF0cztcbiAgICAgIHZhciBwYXJ0VG90YWwgPSBwYXJ0U3RhdHMudG90YWw7XG4gICAgICBmcmFnU3RhdHMubG9hZGVkICs9IHBhcnRTdGF0cy5sb2FkZWQ7XG4gICAgICBpZiAocGFydFRvdGFsKSB7XG4gICAgICAgIHZhciBlc3RUb3RhbFBhcnRzID0gTWF0aC5yb3VuZChmcmFnLmR1cmF0aW9uIC8gcGFydC5kdXJhdGlvbik7XG4gICAgICAgIHZhciBlc3RMb2FkZWRQYXJ0cyA9IE1hdGgubWluKE1hdGgucm91bmQoZnJhZ1N0YXRzLmxvYWRlZCAvIHBhcnRUb3RhbCksIGVzdFRvdGFsUGFydHMpO1xuICAgICAgICB2YXIgZXN0UmVtYWluaW5nUGFydHMgPSBlc3RUb3RhbFBhcnRzIC0gZXN0TG9hZGVkUGFydHM7XG4gICAgICAgIHZhciBlc3RSZW1haW5pbmdCeXRlcyA9IGVzdFJlbWFpbmluZ1BhcnRzICogTWF0aC5yb3VuZChmcmFnU3RhdHMubG9hZGVkIC8gZXN0TG9hZGVkUGFydHMpO1xuICAgICAgICBmcmFnU3RhdHMudG90YWwgPSBmcmFnU3RhdHMubG9hZGVkICsgZXN0UmVtYWluaW5nQnl0ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnU3RhdHMudG90YWwgPSBNYXRoLm1heChmcmFnU3RhdHMubG9hZGVkLCBmcmFnU3RhdHMudG90YWwpO1xuICAgICAgfVxuICAgICAgdmFyIGZyYWdMb2FkaW5nID0gZnJhZ1N0YXRzLmxvYWRpbmc7XG4gICAgICB2YXIgcGFydExvYWRpbmcgPSBwYXJ0U3RhdHMubG9hZGluZztcbiAgICAgIGlmIChmcmFnTG9hZGluZy5zdGFydCkge1xuICAgICAgICAvLyBhZGQgdG8gZnJhZ21lbnQgbG9hZGVyIGxhdGVuY3lcbiAgICAgICAgZnJhZ0xvYWRpbmcuZmlyc3QgKz0gcGFydExvYWRpbmcuZmlyc3QgLSBwYXJ0TG9hZGluZy5zdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdMb2FkaW5nLnN0YXJ0ID0gcGFydExvYWRpbmcuc3RhcnQ7XG4gICAgICAgIGZyYWdMb2FkaW5nLmZpcnN0ID0gcGFydExvYWRpbmcuZmlyc3Q7XG4gICAgICB9XG4gICAgICBmcmFnTG9hZGluZy5lbmQgPSBwYXJ0TG9hZGluZy5lbmQ7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRMb2FkZXIgPSBmdW5jdGlvbiByZXNldExvYWRlcihmcmFnLCBsb2FkZXIpIHtcbiAgICAgIGZyYWcubG9hZGVyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmxvYWRlciA9PT0gbG9hZGVyKSB7XG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucGFydExvYWRUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBGcmFnbWVudExvYWRlcjtcbiAgfSgpO1xuICBmdW5jdGlvbiBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcsIHBhcnQpIHtcbiAgICBpZiAocGFydCA9PT0gdm9pZCAwKSB7XG4gICAgICBwYXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHNlZ21lbnQgPSBwYXJ0IHx8IGZyYWc7XG4gICAgdmFyIGxvYWRlckNvbnRleHQgPSB7XG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAgcGFydDogcGFydCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICAgIHVybDogc2VnbWVudC51cmwsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgICByYW5nZUVuZDogMFxuICAgIH07XG4gICAgdmFyIHN0YXJ0ID0gc2VnbWVudC5ieXRlUmFuZ2VTdGFydE9mZnNldDtcbiAgICB2YXIgZW5kID0gc2VnbWVudC5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHN0YXJ0KSAmJiBpc0Zpbml0ZU51bWJlcihlbmQpKSB7XG4gICAgICB2YXIgX2ZyYWckZGVjcnlwdGRhdGE7XG4gICAgICB2YXIgYnl0ZVJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICAgIHZhciBieXRlUmFuZ2VFbmQgPSBlbmQ7XG4gICAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyAmJiAoKF9mcmFnJGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnJGRlY3J5cHRkYXRhLm1ldGhvZCkgPT09ICdBRVMtMTI4Jykge1xuICAgICAgICAvLyBNQVAgc2VnbWVudCBlbmNyeXB0ZWQgd2l0aCBtZXRob2QgJ0FFUy0xMjgnLCB3aGVuIHNlcnZlZCB3aXRoIEhUVFAgUmFuZ2UsXG4gICAgICAgIC8vIGhhcyB0aGUgdW5lbmNyeXB0ZWQgc2l6ZSBzcGVjaWZpZWQgaW4gdGhlIHJhbmdlLlxuICAgICAgICAvLyBSZWY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1wYW50b3MtaGxzLXJmYzgyMTZiaXMtMDgjc2VjdGlvbi02LjMuNlxuICAgICAgICB2YXIgZnJhZ21lbnRMZW4gPSBlbmQgLSBzdGFydDtcbiAgICAgICAgaWYgKGZyYWdtZW50TGVuICUgMTYpIHtcbiAgICAgICAgICBieXRlUmFuZ2VFbmQgPSBlbmQgKyAoMTYgLSBmcmFnbWVudExlbiAlIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgIT09IDApIHtcbiAgICAgICAgICBsb2FkZXJDb250ZXh0LnJlc2V0SVYgPSB0cnVlO1xuICAgICAgICAgIGJ5dGVSYW5nZVN0YXJ0ID0gc3RhcnQgLSAxNjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9hZGVyQ29udGV4dC5yYW5nZVN0YXJ0ID0gYnl0ZVJhbmdlU3RhcnQ7XG4gICAgICBsb2FkZXJDb250ZXh0LnJhbmdlRW5kID0gYnl0ZVJhbmdlRW5kO1xuICAgIH1cbiAgICByZXR1cm4gbG9hZGVyQ29udGV4dDtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVHYXBMb2FkRXJyb3IoZnJhZywgcGFydCkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkdBUCBcIiArIChmcmFnLmdhcCA/ICd0YWcnIDogJ2F0dHJpYnV0ZScpICsgXCIgZm91bmRcIik7XG4gICAgdmFyIGVycm9yRGF0YSA9IHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19HQVAsXG4gICAgICBmYXRhbDogZmFsc2UsXG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgICB9O1xuICAgIGlmIChwYXJ0KSB7XG4gICAgICBlcnJvckRhdGEucGFydCA9IHBhcnQ7XG4gICAgfVxuICAgIChwYXJ0ID8gcGFydCA6IGZyYWcpLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgIHJldHVybiBuZXcgTG9hZEVycm9yKGVycm9yRGF0YSk7XG4gIH1cbiAgdmFyIExvYWRFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTG9hZEVycm9yLCBfRXJyb3IpO1xuICAgIGZ1bmN0aW9uIExvYWRFcnJvcihkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMzO1xuICAgICAgX3RoaXMzID0gX0Vycm9yLmNhbGwodGhpcywgZGF0YS5lcnJvci5tZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgX3RoaXMzLmRhdGEgPSB2b2lkIDA7XG4gICAgICBfdGhpczMuZGF0YSA9IGRhdGE7XG4gICAgICByZXR1cm4gX3RoaXMzO1xuICAgIH1cbiAgICByZXR1cm4gTG9hZEVycm9yO1xuICB9KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG4gIHZhciBBRVNDcnlwdG8gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFFU0NyeXB0byhzdWJ0bGUsIGl2KSB7XG4gICAgICB0aGlzLnN1YnRsZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuYWVzSVYgPSB2b2lkIDA7XG4gICAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICAgIHRoaXMuYWVzSVYgPSBpdjtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IEFFU0NyeXB0by5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmRlY3J5cHQgPSBmdW5jdGlvbiBkZWNyeXB0KGRhdGEsIGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3VidGxlLmRlY3J5cHQoe1xuICAgICAgICBuYW1lOiAnQUVTLUNCQycsXG4gICAgICAgIGl2OiB0aGlzLmFlc0lWXG4gICAgICB9LCBrZXksIGRhdGEpO1xuICAgIH07XG4gICAgcmV0dXJuIEFFU0NyeXB0bztcbiAgfSgpO1xuXG4gIHZhciBGYXN0QUVTS2V5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGYXN0QUVTS2V5KHN1YnRsZSwga2V5KSB7XG4gICAgICB0aGlzLnN1YnRsZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IEZhc3RBRVNLZXkucHJvdG90eXBlO1xuICAgIF9wcm90by5leHBhbmRLZXkgPSBmdW5jdGlvbiBleHBhbmRLZXkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCB0aGlzLmtleSwge1xuICAgICAgICBuYW1lOiAnQUVTLUNCQydcbiAgICAgIH0sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgICB9O1xuICAgIHJldHVybiBGYXN0QUVTS2V5O1xuICB9KCk7XG5cbiAgLy8gUEtDUzdcbiAgZnVuY3Rpb24gcmVtb3ZlUGFkZGluZyhhcnJheSkge1xuICAgIHZhciBvdXRwdXRCeXRlcyA9IGFycmF5LmJ5dGVMZW5ndGg7XG4gICAgdmFyIHBhZGRpbmdCeXRlcyA9IG91dHB1dEJ5dGVzICYmIG5ldyBEYXRhVmlldyhhcnJheS5idWZmZXIpLmdldFVpbnQ4KG91dHB1dEJ5dGVzIC0gMSk7XG4gICAgaWYgKHBhZGRpbmdCeXRlcykge1xuICAgICAgcmV0dXJuIHNsaWNlVWludDgoYXJyYXksIDAsIG91dHB1dEJ5dGVzIC0gcGFkZGluZ0J5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIHZhciBBRVNEZWNyeXB0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFFU0RlY3J5cHRvcigpIHtcbiAgICAgIHRoaXMucmNvbiA9IFsweDAsIDB4MSwgMHgyLCAweDQsIDB4OCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG4gICAgICB0aGlzLnN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgICB0aGlzLmludlN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgICB0aGlzLnNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICAgIHRoaXMuaW52U0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgICAgdGhpcy5rZXkgPSBuZXcgVWludDMyQXJyYXkoMCk7XG4gICAgICB0aGlzLmtzUm93cyA9IDA7XG4gICAgICB0aGlzLmtleVNpemUgPSAwO1xuICAgICAgdGhpcy5rZXlTY2hlZHVsZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaW52S2V5U2NoZWR1bGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLmluaXRUYWJsZSgpO1xuICAgIH1cblxuICAgIC8vIFVzaW5nIHZpZXcuZ2V0VWludDMyKCkgYWxzbyBzd2FwcyB0aGUgYnl0ZSBvcmRlci5cbiAgICB2YXIgX3Byb3RvID0gQUVTRGVjcnlwdG9yLnByb3RvdHlwZTtcbiAgICBfcHJvdG8udWludDhBcnJheVRvVWludDMyQXJyYXlfID0gZnVuY3Rpb24gdWludDhBcnJheVRvVWludDMyQXJyYXlfKGFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgICB2YXIgbmV3QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICB9O1xuICAgIF9wcm90by5pbml0VGFibGUgPSBmdW5jdGlvbiBpbml0VGFibGUoKSB7XG4gICAgICB2YXIgc0JveCA9IHRoaXMuc0JveDtcbiAgICAgIHZhciBpbnZTQm94ID0gdGhpcy5pbnZTQm94O1xuICAgICAgdmFyIHN1Yk1peCA9IHRoaXMuc3ViTWl4O1xuICAgICAgdmFyIHN1Yk1peDAgPSBzdWJNaXhbMF07XG4gICAgICB2YXIgc3ViTWl4MSA9IHN1Yk1peFsxXTtcbiAgICAgIHZhciBzdWJNaXgyID0gc3ViTWl4WzJdO1xuICAgICAgdmFyIHN1Yk1peDMgPSBzdWJNaXhbM107XG4gICAgICB2YXIgaW52U3ViTWl4ID0gdGhpcy5pbnZTdWJNaXg7XG4gICAgICB2YXIgaW52U3ViTWl4MCA9IGludlN1Yk1peFswXTtcbiAgICAgIHZhciBpbnZTdWJNaXgxID0gaW52U3ViTWl4WzFdO1xuICAgICAgdmFyIGludlN1Yk1peDIgPSBpbnZTdWJNaXhbMl07XG4gICAgICB2YXIgaW52U3ViTWl4MyA9IGludlN1Yk1peFszXTtcbiAgICAgIHZhciBkID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgICB2YXIgeCA9IDA7XG4gICAgICB2YXIgeGkgPSAwO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgICAgZFtpXSA9IGkgPDwgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkW2ldID0gaSA8PCAxIF4gMHgxMWI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICB2YXIgc3ggPSB4aSBeIHhpIDw8IDEgXiB4aSA8PCAyIF4geGkgPDwgMyBeIHhpIDw8IDQ7XG4gICAgICAgIHN4ID0gc3ggPj4+IDggXiBzeCAmIDB4ZmYgXiAweDYzO1xuICAgICAgICBzQm94W3hdID0gc3g7XG4gICAgICAgIGludlNCb3hbc3hdID0geDtcblxuICAgICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG4gICAgICAgIHZhciB4MiA9IGRbeF07XG4gICAgICAgIHZhciB4NCA9IGRbeDJdO1xuICAgICAgICB2YXIgeDggPSBkW3g0XTtcblxuICAgICAgICAvLyBDb21wdXRlIHN1Yi9pbnZTdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgICB2YXIgdCA9IGRbc3hdICogMHgxMDEgXiBzeCAqIDB4MTAxMDEwMDtcbiAgICAgICAgc3ViTWl4MFt4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xuICAgICAgICBzdWJNaXgxW3hdID0gdCA8PCAxNiB8IHQgPj4+IDE2O1xuICAgICAgICBzdWJNaXgyW3hdID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XG4gICAgICAgIHN1Yk1peDNbeF0gPSB0O1xuXG4gICAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgICB0ID0geDggKiAweDEwMTAxMDEgXiB4NCAqIDB4MTAwMDEgXiB4MiAqIDB4MTAxIF4geCAqIDB4MTAxMDEwMDtcbiAgICAgICAgaW52U3ViTWl4MFtzeF0gPSB0IDw8IDI0IHwgdCA+Pj4gODtcbiAgICAgICAgaW52U3ViTWl4MVtzeF0gPSB0IDw8IDE2IHwgdCA+Pj4gMTY7XG4gICAgICAgIGludlN1Yk1peDJbc3hdID0gdCA8PCA4IHwgdCA+Pj4gMjQ7XG4gICAgICAgIGludlN1Yk1peDNbc3hdID0gdDtcblxuICAgICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuICAgICAgICBpZiAoIXgpIHtcbiAgICAgICAgICB4ID0geGkgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG4gICAgICAgICAgeGkgXj0gZFtkW3hpXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5leHBhbmRLZXkgPSBmdW5jdGlvbiBleHBhbmRLZXkoa2V5QnVmZmVyKSB7XG4gICAgICAvLyBjb252ZXJ0IGtleUJ1ZmZlciB0byBVaW50MzJBcnJheVxuICAgICAgdmFyIGtleSA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGtleUJ1ZmZlcik7XG4gICAgICB2YXIgc2FtZUtleSA9IHRydWU7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHdoaWxlIChvZmZzZXQgPCBrZXkubGVuZ3RoICYmIHNhbWVLZXkpIHtcbiAgICAgICAgc2FtZUtleSA9IGtleVtvZmZzZXRdID09PSB0aGlzLmtleVtvZmZzZXRdO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICAgIGlmIChzYW1lS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgdmFyIGtleVNpemUgPSB0aGlzLmtleVNpemUgPSBrZXkubGVuZ3RoO1xuICAgICAgaWYgKGtleVNpemUgIT09IDQgJiYga2V5U2l6ZSAhPT0gNiAmJiBrZXlTaXplICE9PSA4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemU9JyArIGtleVNpemUpO1xuICAgICAgfVxuICAgICAgdmFyIGtzUm93cyA9IHRoaXMua3NSb3dzID0gKGtleVNpemUgKyA2ICsgMSkgKiA0O1xuICAgICAgdmFyIGtzUm93O1xuICAgICAgdmFyIGludktzUm93O1xuICAgICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5rZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgICAgdmFyIGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgICAgdmFyIHNib3ggPSB0aGlzLnNCb3g7XG4gICAgICB2YXIgcmNvbiA9IHRoaXMucmNvbjtcbiAgICAgIHZhciBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICAgIHZhciBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgICAgdmFyIGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgICB2YXIgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICAgIHZhciBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgICAgdmFyIHByZXY7XG4gICAgICB2YXIgdDtcbiAgICAgIGZvciAoa3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuICAgICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG4gICAgICAgICAgcHJldiA9IGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVtrc1Jvd107XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdCA9IHByZXY7XG4gICAgICAgIGlmIChrc1JvdyAlIGtleVNpemUgPT09IDApIHtcbiAgICAgICAgICAvLyBSb3Qgd29yZFxuICAgICAgICAgIHQgPSB0IDw8IDggfCB0ID4+PiAyNDtcblxuICAgICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgICAgdCA9IHNib3hbdCA+Pj4gMjRdIDw8IDI0IHwgc2JveFt0ID4+PiAxNiAmIDB4ZmZdIDw8IDE2IHwgc2JveFt0ID4+PiA4ICYgMHhmZl0gPDwgOCB8IHNib3hbdCAmIDB4ZmZdO1xuXG4gICAgICAgICAgLy8gTWl4IFJjb25cbiAgICAgICAgICB0IF49IHJjb25ba3NSb3cgLyBrZXlTaXplIHwgMF0gPDwgMjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgICB0ID0gc2JveFt0ID4+PiAyNF0gPDwgMjQgfCBzYm94W3QgPj4+IDE2ICYgMHhmZl0gPDwgMTYgfCBzYm94W3QgPj4+IDggJiAweGZmXSA8PCA4IHwgc2JveFt0ICYgMHhmZl07XG4gICAgICAgIH1cbiAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0gcHJldiA9IChrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdCkgPj4+IDA7XG4gICAgICB9XG4gICAgICBmb3IgKGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcbiAgICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcbiAgICAgICAgaWYgKGludktzUm93ICYgMykge1xuICAgICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG4gICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBpbnZTdWJNaXgwW3Nib3hbdCA+Pj4gMjRdXSBeIGludlN1Yk1peDFbc2JveFt0ID4+PiAxNiAmIDB4ZmZdXSBeIGludlN1Yk1peDJbc2JveFt0ID4+PiA4ICYgMHhmZl1dIF4gaW52U3ViTWl4M1tzYm94W3QgJiAweGZmXV07XG4gICAgICAgIH1cbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID4+PiAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZGluZyB0aGlzIGFzIGEgbWV0aG9kIGdyZWF0bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2UuXG4gICAgO1xuICAgIF9wcm90by5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwID0gZnVuY3Rpb24gbmV0d29ya1RvSG9zdE9yZGVyU3dhcCh3b3JkKSB7XG4gICAgICByZXR1cm4gd29yZCA8PCAyNCB8ICh3b3JkICYgMHhmZjAwKSA8PCA4IHwgKHdvcmQgJiAweGZmMDAwMCkgPj4gOCB8IHdvcmQgPj4+IDI0O1xuICAgIH07XG4gICAgX3Byb3RvLmRlY3J5cHQgPSBmdW5jdGlvbiBkZWNyeXB0KGlucHV0QXJyYXlCdWZmZXIsIG9mZnNldCwgYWVzSVYpIHtcbiAgICAgIHZhciBuUm91bmRzID0gdGhpcy5rZXlTaXplICsgNjtcbiAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuaW52S2V5U2NoZWR1bGU7XG4gICAgICB2YXIgaW52U0JPWCA9IHRoaXMuaW52U0JveDtcbiAgICAgIHZhciBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICAgIHZhciBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgICAgdmFyIGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgICB2YXIgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICAgIHZhciBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgICAgdmFyIGluaXRWZWN0b3IgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhZXNJVik7XG4gICAgICB2YXIgaW5pdFZlY3RvcjAgPSBpbml0VmVjdG9yWzBdO1xuICAgICAgdmFyIGluaXRWZWN0b3IxID0gaW5pdFZlY3RvclsxXTtcbiAgICAgIHZhciBpbml0VmVjdG9yMiA9IGluaXRWZWN0b3JbMl07XG4gICAgICB2YXIgaW5pdFZlY3RvcjMgPSBpbml0VmVjdG9yWzNdO1xuICAgICAgdmFyIGlucHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEFycmF5QnVmZmVyKTtcbiAgICAgIHZhciBvdXRwdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0SW50MzIubGVuZ3RoKTtcbiAgICAgIHZhciB0MCwgdDEsIHQyLCB0MztcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcbiAgICAgIHZhciBpbnB1dFdvcmRzMCwgaW5wdXRXb3JkczEsIGlucHV0V29yZHMyLCBpbnB1dFdvcmRzMztcbiAgICAgIHZhciBrc1JvdywgaTtcbiAgICAgIHZhciBzd2FwV29yZCA9IHRoaXMubmV0d29ya1RvSG9zdE9yZGVyU3dhcDtcbiAgICAgIHdoaWxlIChvZmZzZXQgPCBpbnB1dEludDMyLmxlbmd0aCkge1xuICAgICAgICBpbnB1dFdvcmRzMCA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0XSk7XG4gICAgICAgIGlucHV0V29yZHMxID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XG4gICAgICAgIGlucHV0V29yZHMyID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAyXSk7XG4gICAgICAgIGlucHV0V29yZHMzID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAzXSk7XG4gICAgICAgIHMwID0gaW5wdXRXb3JkczAgXiBpbnZLZXlTY2hlZHVsZVswXTtcbiAgICAgICAgczEgPSBpbnB1dFdvcmRzMyBeIGludktleVNjaGVkdWxlWzFdO1xuICAgICAgICBzMiA9IGlucHV0V29yZHMyIF4gaW52S2V5U2NoZWR1bGVbMl07XG4gICAgICAgIHMzID0gaW5wdXRXb3JkczEgXiBpbnZLZXlTY2hlZHVsZVszXTtcbiAgICAgICAga3NSb3cgPSA0O1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcm91bmRzIG9mIGRlY3J5cHRpb25cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG5Sb3VuZHM7IGkrKykge1xuICAgICAgICAgIHQwID0gaW52U3ViTWl4MFtzMCA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMSA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMiA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgICAgdDEgPSBpbnZTdWJNaXgwW3MxID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MyID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MzID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICAgICAgdDIgPSBpbnZTdWJNaXgwW3MyID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MzID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MwID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICAgICAgdDMgPSBpbnZTdWJNaXgwW3MzID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MwID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MxID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG4gICAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgICAgICAgczAgPSB0MDtcbiAgICAgICAgICBzMSA9IHQxO1xuICAgICAgICAgIHMyID0gdDI7XG4gICAgICAgICAgczMgPSB0MztcbiAgICAgICAgICBrc1JvdyA9IGtzUm93ICsgNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuICAgICAgICB0MCA9IGludlNCT1hbczAgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczEgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczIgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MzICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICAgIHQxID0gaW52U0JPWFtzMSA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMiA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMyA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICAgIHQyID0gaW52U0JPWFtzMiA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMyA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMCA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczEgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMl07XG4gICAgICAgIHQzID0gaW52U0JPWFtzMyA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMCA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMSA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczIgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgM107XG5cbiAgICAgICAgLy8gV3JpdGVcbiAgICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0XSA9IHN3YXBXb3JkKHQwIF4gaW5pdFZlY3RvcjApO1xuICAgICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAxXSA9IHN3YXBXb3JkKHQzIF4gaW5pdFZlY3RvcjEpO1xuICAgICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAyXSA9IHN3YXBXb3JkKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAzXSA9IHN3YXBXb3JkKHQxIF4gaW5pdFZlY3RvcjMpO1xuXG4gICAgICAgIC8vIHJlc2V0IGluaXRWZWN0b3IgdG8gbGFzdCA0IHVuc2lnbmVkIGludFxuICAgICAgICBpbml0VmVjdG9yMCA9IGlucHV0V29yZHMwO1xuICAgICAgICBpbml0VmVjdG9yMSA9IGlucHV0V29yZHMxO1xuICAgICAgICBpbml0VmVjdG9yMiA9IGlucHV0V29yZHMyO1xuICAgICAgICBpbml0VmVjdG9yMyA9IGlucHV0V29yZHMzO1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyA0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dEludDMyLmJ1ZmZlcjtcbiAgICB9O1xuICAgIHJldHVybiBBRVNEZWNyeXB0b3I7XG4gIH0oKTtcblxuICB2YXIgQ0hVTktfU0laRSA9IDE2OyAvLyAxNiBieXRlcywgMTI4IGJpdHNcbiAgdmFyIERlY3J5cHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVjcnlwdGVyKGNvbmZpZywgX3RlbXApIHtcbiAgICAgIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIF9yZWYkcmVtb3ZlUEtDUzdQYWRkaSA9IF9yZWYucmVtb3ZlUEtDUzdQYWRkaW5nLFxuICAgICAgICByZW1vdmVQS0NTN1BhZGRpbmcgPSBfcmVmJHJlbW92ZVBLQ1M3UGFkZGkgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJHJlbW92ZVBLQ1M3UGFkZGk7XG4gICAgICB0aGlzLmxvZ0VuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcgPSB2b2lkIDA7XG4gICAgICB0aGlzLnN1YnRsZSA9IG51bGw7XG4gICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICAgIHRoaXMuZmFzdEFlc0tleSA9IG51bGw7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50UmVzdWx0ID0gbnVsbDtcbiAgICAgIHRoaXMudXNlU29mdHdhcmUgPSB2b2lkIDA7XG4gICAgICB0aGlzLnVzZVNvZnR3YXJlID0gY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTO1xuICAgICAgdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcgPSByZW1vdmVQS0NTN1BhZGRpbmc7XG4gICAgICAvLyBidWlsdCBpbiBkZWNyeXB0b3IgZXhwZWN0cyBQS0NTNyBwYWRkaW5nXG4gICAgICBpZiAocmVtb3ZlUEtDUzdQYWRkaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGJyb3dzZXJDcnlwdG8gPSBzZWxmLmNyeXB0bztcbiAgICAgICAgICBpZiAoYnJvd3NlckNyeXB0bykge1xuICAgICAgICAgICAgdGhpcy5zdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvKiBuby1vcCAqL1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVzZVNvZnR3YXJlID0gIXRoaXMuc3VidGxlO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gRGVjcnlwdGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnN1YnRsZSA9IG51bGw7XG4gICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICAgIHRoaXMuZmFzdEFlc0tleSA9IG51bGw7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50UmVzdWx0ID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5pc1N5bmMgPSBmdW5jdGlvbiBpc1N5bmMoKSB7XG4gICAgICByZXR1cm4gdGhpcy51c2VTb2Z0d2FyZTtcbiAgICB9O1xuICAgIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgdmFyIGN1cnJlbnRSZXN1bHQgPSB0aGlzLmN1cnJlbnRSZXN1bHQsXG4gICAgICAgIHJlbWFpbmRlckRhdGEgPSB0aGlzLnJlbWFpbmRlckRhdGE7XG4gICAgICBpZiAoIWN1cnJlbnRSZXN1bHQgfHwgcmVtYWluZGVyRGF0YSkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShjdXJyZW50UmVzdWx0KTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIGlmICh0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgICByZXR1cm4gcmVtb3ZlUGFkZGluZyhkYXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLnNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmRlY3J5cHQgPSBmdW5jdGlvbiBkZWNyeXB0KGRhdGEsIGtleSwgaXYpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy51c2VTb2Z0d2FyZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIF90aGlzLnNvZnR3YXJlRGVjcnlwdChuZXcgVWludDhBcnJheShkYXRhKSwga2V5LCBpdik7XG4gICAgICAgICAgdmFyIGRlY3J5cHRSZXN1bHQgPSBfdGhpcy5mbHVzaCgpO1xuICAgICAgICAgIGlmIChkZWNyeXB0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXNvbHZlKGRlY3J5cHRSZXN1bHQuYnVmZmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignW3NvZnR3YXJlRGVjcnlwdF0gRmFpbGVkIHRvIGRlY3J5cHQgZGF0YScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2ViQ3J5cHRvRGVjcnlwdChuZXcgVWludDhBcnJheShkYXRhKSwga2V5LCBpdik7XG4gICAgfVxuXG4gICAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBwcm9ncmVzc2l2ZS4gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBtYXkgbm90IHJldHVybiBhIHJlc3VsdCBvbiBlYWNoIGNhbGwuIEFueSBjYWNoZWRcbiAgICAvLyBkYXRhIGlzIGhhbmRsZWQgaW4gdGhlIGZsdXNoKCkgY2FsbFxuICAgIDtcbiAgICBfcHJvdG8uc29mdHdhcmVEZWNyeXB0ID0gZnVuY3Rpb24gc29mdHdhcmVEZWNyeXB0KGRhdGEsIGtleSwgaXYpIHtcbiAgICAgIHZhciBjdXJyZW50SVYgPSB0aGlzLmN1cnJlbnRJVixcbiAgICAgICAgY3VycmVudFJlc3VsdCA9IHRoaXMuY3VycmVudFJlc3VsdCxcbiAgICAgICAgcmVtYWluZGVyRGF0YSA9IHRoaXMucmVtYWluZGVyRGF0YTtcbiAgICAgIHRoaXMubG9nT25jZSgnSlMgQUVTIGRlY3J5cHQnKTtcbiAgICAgIC8vIFRoZSBvdXRwdXQgaXMgc3RhZ2dlcmVkIGR1cmluZyBwcm9ncmVzc2l2ZSBwYXJzaW5nIC0gdGhlIGN1cnJlbnQgcmVzdWx0IGlzIGNhY2hlZCwgYW5kIGVtaXR0ZWQgb24gdGhlIG5leHQgY2FsbFxuICAgICAgLy8gVGhpcyBpcyBkb25lIGluIG9yZGVyIHRvIHN0cmlwIFBLQ1M3IHBhZGRpbmcsIHdoaWNoIGlzIGZvdW5kIGF0IHRoZSBlbmQgb2YgZWFjaCBzZWdtZW50LiBXZSBvbmx5IGtub3cgd2UndmUgcmVhY2hlZFxuICAgICAgLy8gdGhlIGVuZCBvbiBmbHVzaCgpLCBidXQgYnkgdGhhdCB0aW1lIHdlIGhhdmUgYWxyZWFkeSByZWNlaXZlZCBhbGwgYnl0ZXMgZm9yIHRoZSBzZWdtZW50LlxuICAgICAgLy8gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBkb2VzIG5vdCB3b3JrIHdpdGggV2ViQ3J5cHRvXG5cbiAgICAgIGlmIChyZW1haW5kZXJEYXRhKSB7XG4gICAgICAgIGRhdGEgPSBhcHBlbmRVaW50OEFycmF5KHJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBCeXRlIGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYgKEFFUy0xMjggPSAxMjggYml0IGJsb2NrcyA9IDE2IGJ5dGVzKVxuICAgICAgdmFyIGN1cnJlbnRDaHVuayA9IHRoaXMuZ2V0VmFsaWRDaHVuayhkYXRhKTtcbiAgICAgIGlmICghY3VycmVudENodW5rLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50SVYpIHtcbiAgICAgICAgaXYgPSBjdXJyZW50SVY7XG4gICAgICB9XG4gICAgICB2YXIgc29mdHdhcmVEZWNyeXB0ZXIgPSB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyO1xuICAgICAgaWYgKCFzb2Z0d2FyZURlY3J5cHRlcikge1xuICAgICAgICBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBuZXcgQUVTRGVjcnlwdG9yKCk7XG4gICAgICB9XG4gICAgICBzb2Z0d2FyZURlY3J5cHRlci5leHBhbmRLZXkoa2V5KTtcbiAgICAgIHZhciByZXN1bHQgPSBjdXJyZW50UmVzdWx0O1xuICAgICAgdGhpcy5jdXJyZW50UmVzdWx0ID0gc29mdHdhcmVEZWNyeXB0ZXIuZGVjcnlwdChjdXJyZW50Q2h1bmsuYnVmZmVyLCAwLCBpdik7XG4gICAgICB0aGlzLmN1cnJlbnRJViA9IHNsaWNlVWludDgoY3VycmVudENodW5rLCAtMTYpLmJ1ZmZlcjtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIF9wcm90by53ZWJDcnlwdG9EZWNyeXB0ID0gZnVuY3Rpb24gd2ViQ3J5cHRvRGVjcnlwdChkYXRhLCBrZXksIGl2KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGlmICh0aGlzLmtleSAhPT0ga2V5IHx8ICF0aGlzLmZhc3RBZXNLZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1YnRsZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5vbldlYkNyeXB0b0Vycm9yKGRhdGEsIGtleSwgaXYpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5mYXN0QWVzS2V5ID0gbmV3IEZhc3RBRVNLZXkodGhpcy5zdWJ0bGUsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5mYXN0QWVzS2V5LmV4cGFuZEtleSgpLnRoZW4oZnVuY3Rpb24gKGFlc0tleSkge1xuICAgICAgICAvLyBkZWNyeXB0IHVzaW5nIHdlYiBjcnlwdG9cbiAgICAgICAgaWYgKCFfdGhpczIuc3VidGxlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignd2ViIGNyeXB0byBub3QgaW5pdGlhbGl6ZWQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMyLmxvZ09uY2UoJ1dlYkNyeXB0byBBRVMgZGVjcnlwdCcpO1xuICAgICAgICB2YXIgY3J5cHRvID0gbmV3IEFFU0NyeXB0byhfdGhpczIuc3VidGxlLCBuZXcgVWludDhBcnJheShpdikpO1xuICAgICAgICByZXR1cm4gY3J5cHRvLmRlY3J5cHQoZGF0YS5idWZmZXIsIGFlc0tleSk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiW2RlY3J5cHRlcl06IFdlYkNyeXB0byBFcnJvciwgZGlzYWJsZSBXZWJDcnlwdG8gQVBJLCBcIiArIGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gX3RoaXMyLm9uV2ViQ3J5cHRvRXJyb3IoZGF0YSwga2V5LCBpdik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5vbldlYkNyeXB0b0Vycm9yID0gZnVuY3Rpb24gb25XZWJDcnlwdG9FcnJvcihkYXRhLCBrZXksIGl2KSB7XG4gICAgICB0aGlzLnVzZVNvZnR3YXJlID0gdHJ1ZTtcbiAgICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdChkYXRhLCBrZXksIGl2KTtcbiAgICAgIHZhciBkZWNyeXB0UmVzdWx0ID0gdGhpcy5mbHVzaCgpO1xuICAgICAgaWYgKGRlY3J5cHRSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGRlY3J5cHRSZXN1bHQuYnVmZmVyO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJDcnlwdG8gYW5kIHNvZnR3YXJlRGVjcnlwdDogZmFpbGVkIHRvIGRlY3J5cHQgZGF0YScpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFZhbGlkQ2h1bmsgPSBmdW5jdGlvbiBnZXRWYWxpZENodW5rKGRhdGEpIHtcbiAgICAgIHZhciBjdXJyZW50Q2h1bmsgPSBkYXRhO1xuICAgICAgdmFyIHNwbGl0UG9pbnQgPSBkYXRhLmxlbmd0aCAtIGRhdGEubGVuZ3RoICUgQ0hVTktfU0laRTtcbiAgICAgIGlmIChzcGxpdFBvaW50ICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICBjdXJyZW50Q2h1bmsgPSBzbGljZVVpbnQ4KGRhdGEsIDAsIHNwbGl0UG9pbnQpO1xuICAgICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBzbGljZVVpbnQ4KGRhdGEsIHNwbGl0UG9pbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnRDaHVuaztcbiAgICB9O1xuICAgIF9wcm90by5sb2dPbmNlID0gZnVuY3Rpb24gbG9nT25jZShtc2cpIHtcbiAgICAgIGlmICghdGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5sb2coXCJbZGVjcnlwdGVyXTogXCIgKyBtc2cpO1xuICAgICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjcnlwdGVyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqICBUaW1lUmFuZ2VzIHRvIHN0cmluZyBoZWxwZXJcbiAgICovXG5cbiAgdmFyIFRpbWVSYW5nZXMgPSB7XG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKHIpIHtcbiAgICAgIHZhciBsb2cgPSAnJztcbiAgICAgIHZhciBsZW4gPSByLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbG9nICs9IFwiW1wiICsgci5zdGFydChpKS50b0ZpeGVkKDMpICsgXCItXCIgKyByLmVuZChpKS50b0ZpeGVkKDMpICsgXCJdXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9nO1xuICAgIH1cbiAgfTtcblxuICB2YXIgU3RhdGUgPSB7XG4gICAgU1RPUFBFRDogJ1NUT1BQRUQnLFxuICAgIElETEU6ICdJRExFJyxcbiAgICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcbiAgICBGUkFHX0xPQURJTkc6ICdGUkFHX0xPQURJTkcnLFxuICAgIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICAgIFdBSVRJTkdfVFJBQ0s6ICdXQUlUSU5HX1RSQUNLJyxcbiAgICBQQVJTSU5HOiAnUEFSU0lORycsXG4gICAgUEFSU0VEOiAnUEFSU0VEJyxcbiAgICBFTkRFRDogJ0VOREVEJyxcbiAgICBFUlJPUjogJ0VSUk9SJyxcbiAgICBXQUlUSU5HX0lOSVRfUFRTOiAnV0FJVElOR19JTklUX1BUUycsXG4gICAgV0FJVElOR19MRVZFTDogJ1dBSVRJTkdfTEVWRUwnXG4gIH07XG4gIHZhciBCYXNlU3RyZWFtQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Rhc2tMb29wKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoQmFzZVN0cmVhbUNvbnRyb2xsZXIsIF9UYXNrTG9vcCk7XG4gICAgZnVuY3Rpb24gQmFzZVN0cmVhbUNvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciwgbG9nUHJlZml4LCBwbGF5bGlzdFR5cGUpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF90aGlzID0gX1Rhc2tMb29wLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgIF90aGlzLmhscyA9IHZvaWQgMDtcbiAgICAgIF90aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICBfdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICBfdGhpcy5mcmFnbWVudFRyYWNrZXIgPSB2b2lkIDA7XG4gICAgICBfdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICAgIF90aGlzLl9zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgICBfdGhpcy5wbGF5bGlzdFR5cGUgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICBfdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgICBfdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgX3RoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICAgIF90aGlzLm5leHRMb2FkUG9zaXRpb24gPSAwO1xuICAgICAgX3RoaXMuc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICBfdGhpcy5zdGFydFRpbWVPZmZzZXQgPSBudWxsO1xuICAgICAgX3RoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIF90aGlzLnJldHJ5RGF0ZSA9IDA7XG4gICAgICBfdGhpcy5sZXZlbHMgPSBudWxsO1xuICAgICAgX3RoaXMuZnJhZ21lbnRMb2FkZXIgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5rZXlMb2FkZXIgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBudWxsO1xuICAgICAgX3RoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICBfdGhpcy5kZWNyeXB0ZXIgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5pbml0UFRTID0gW107XG4gICAgICBfdGhpcy5vbnZzZWVraW5nID0gbnVsbDtcbiAgICAgIF90aGlzLm9udmVuZGVkID0gbnVsbDtcbiAgICAgIF90aGlzLmxvZ1ByZWZpeCA9ICcnO1xuICAgICAgX3RoaXMubG9nID0gdm9pZCAwO1xuICAgICAgX3RoaXMud2FybiA9IHZvaWQgMDtcbiAgICAgIF90aGlzLnBsYXlsaXN0VHlwZSA9IHBsYXlsaXN0VHlwZTtcbiAgICAgIF90aGlzLmxvZ1ByZWZpeCA9IGxvZ1ByZWZpeDtcbiAgICAgIF90aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIGxvZ1ByZWZpeCArIFwiOlwiKTtcbiAgICAgIF90aGlzLndhcm4gPSBsb2dnZXIud2Fybi5iaW5kKGxvZ2dlciwgbG9nUHJlZml4ICsgXCI6XCIpO1xuICAgICAgX3RoaXMuaGxzID0gaGxzO1xuICAgICAgX3RoaXMuZnJhZ21lbnRMb2FkZXIgPSBuZXcgRnJhZ21lbnRMb2FkZXIoaGxzLmNvbmZpZyk7XG4gICAgICBfdGhpcy5rZXlMb2FkZXIgPSBrZXlMb2FkZXI7XG4gICAgICBfdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgICBfdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgICAgX3RoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcihobHMuY29uZmlnKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCBfdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBCYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmRvVGljayA9IGZ1bmN0aW9uIGRvVGljaygpIHtcbiAgICAgIHRoaXMub25UaWNrRW5kKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25UaWNrRW5kID0gZnVuY3Rpb24gb25UaWNrRW5kKCkge31cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICA7XG4gICAgX3Byb3RvLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7fTtcbiAgICBfcHJvdG8uc3RvcExvYWQgPSBmdW5jdGlvbiBzdG9wTG9hZCgpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIuYWJvcnQoKTtcbiAgICAgIHRoaXMua2V5TG9hZGVyLmFib3J0KHRoaXMucGxheWxpc3RUeXBlKTtcbiAgICAgIHZhciBmcmFnID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIGlmIChmcmFnICE9IG51bGwgJiYgZnJhZy5sb2FkZXIpIHtcbiAgICAgICAgZnJhZy5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH07XG4gICAgX3Byb3RvLl9zdHJlYW1FbmRlZCA9IGZ1bmN0aW9uIF9zdHJlYW1FbmRlZChidWZmZXJJbmZvLCBsZXZlbERldGFpbHMpIHtcbiAgICAgIC8vIElmIHBsYXlsaXN0IGlzIGxpdmUsIHRoZXJlIGlzIGFub3RoZXIgYnVmZmVyZWQgcmFuZ2UgYWZ0ZXIgdGhlIGN1cnJlbnQgcmFuZ2UsIG5vdGhpbmcgYnVmZmVyZWQsIG1lZGlhIGlzIGRldGFjaGVkLFxuICAgICAgLy8gb2Ygbm90aGluZyBsb2FkaW5nL2xvYWRlZCByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSB8fCBidWZmZXJJbmZvLm5leHRTdGFydCB8fCAhYnVmZmVySW5mby5lbmQgfHwgIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBhcnRMaXN0ID0gbGV2ZWxEZXRhaWxzLnBhcnRMaXN0O1xuICAgICAgLy8gU2luY2UgdGhlIGxhc3QgcGFydCBpc24ndCBndWFyYW50ZWVkIHRvIGNvcnJlc3BvbmQgdG8gdGhlIGxhc3QgcGxheWxpc3Qgc2VnbWVudCBmb3IgTG93LUxhdGVuY3kgSExTLFxuICAgICAgLy8gY2hlY2sgaW5zdGVhZCBpZiB0aGUgbGFzdCBwYXJ0IGlzIGJ1ZmZlcmVkLlxuICAgICAgaWYgKHBhcnRMaXN0ICE9IG51bGwgJiYgcGFydExpc3QubGVuZ3RoKSB7XG4gICAgICAgIHZhciBsYXN0UGFydCA9IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIC8vIENoZWNraW5nIHRoZSBtaWRwb2ludCBvZiB0aGUgcGFydCBmb3IgcG90ZW50aWFsIG1hcmdpbiBvZiBlcnJvciBhbmQgcmVsYXRlZCBpc3N1ZXMuXG4gICAgICAgIC8vIE5PVEU6IFRlY2huaWNhbGx5IEkgYmVsaWV2ZSBwYXJ0cyBjb3VsZCB5aWVsZCBjb250ZW50IHRoYXQgaXMgPCB0aGUgY29tcHV0ZWQgZHVyYXRpb24gKGluY2x1ZGluZyBwb3RlbnRpYWwgYSBkdXJhdGlvbiBvZiAwKVxuICAgICAgICAvLyBhbmQgc3RpbGwgYmUgc3BlYy1jb21wbGlhbnQsIHNvIHRoZXJlIG1heSBzdGlsbCBiZSBlZGdlIGNhc2VzIGhlcmUuIExpa2V3aXNlLCB0aGVyZSBjb3VsZCBiZSBpc3N1ZXMgaW4gZW5kIG9mIHN0cmVhbVxuICAgICAgICAvLyBwYXJ0IG1pc21hdGNoZXMgZm9yIGluZGVwZW5kZW50IGF1ZGlvIGFuZCB2aWRlbyBwbGF5bGlzdHMvc2VnbWVudHMuXG4gICAgICAgIHZhciBsYXN0UGFydEJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodGhpcy5tZWRpYSwgbGFzdFBhcnQuc3RhcnQgKyBsYXN0UGFydC5kdXJhdGlvbiAvIDIpO1xuICAgICAgICByZXR1cm4gbGFzdFBhcnRCdWZmZXJlZDtcbiAgICAgIH1cbiAgICAgIHZhciBwbGF5bGlzdFR5cGUgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2xldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV0udHlwZTtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50VHJhY2tlci5pc0VuZExpc3RBcHBlbmRlZChwbGF5bGlzdFR5cGUpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldExldmVsRGV0YWlscyA9IGZ1bmN0aW9uIGdldExldmVsRGV0YWlscygpIHtcbiAgICAgIGlmICh0aGlzLmxldmVscyAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3RoaXMkbGV2ZWxMYXN0TG9hZGVkO1xuICAgICAgICByZXR1cm4gKF90aGlzJGxldmVsTGFzdExvYWRlZCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbGV2ZWxMYXN0TG9hZGVkLmRldGFpbHM7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IGRhdGEubWVkaWE7XG4gICAgICB0aGlzLm9udnNlZWtpbmcgPSB0aGlzLm9uTWVkaWFTZWVraW5nLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLm9udmVuZGVkID0gdGhpcy5vbk1lZGlhRW5kZWQuYmluZCh0aGlzKTtcbiAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIGlmICh0aGlzLmxldmVscyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICAgIHRoaXMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAobWVkaWEgIT0gbnVsbCAmJiBtZWRpYS5lbmRlZCkge1xuICAgICAgICB0aGlzLmxvZygnTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb24nKTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgdmlkZW8gbGlzdGVuZXJzXG4gICAgICBpZiAobWVkaWEgJiYgdGhpcy5vbnZzZWVraW5nICYmIHRoaXMub252ZW5kZWQpIHtcbiAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2luZycsIHRoaXMub252c2Vla2luZyk7XG4gICAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMua2V5TG9hZGVyKSB7XG4gICAgICAgIHRoaXMua2V5TG9hZGVyLmRldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYVNlZWtpbmcgPSBmdW5jdGlvbiBvbk1lZGlhU2Vla2luZygpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50LFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlcixcbiAgICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IDA7XG4gICAgICB2YXIgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhQnVmZmVyID8gbWVkaWFCdWZmZXIgOiBtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICAgIHRoaXMubG9nKFwibWVkaWEgc2Vla2luZyB0byBcIiArIChpc0Zpbml0ZU51bWJlcihjdXJyZW50VGltZSkgPyBjdXJyZW50VGltZS50b0ZpeGVkKDMpIDogY3VycmVudFRpbWUpICsgXCIsIHN0YXRlOiBcIiArIHN0YXRlKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKGZyYWdDdXJyZW50KSB7XG4gICAgICAgIC8vIFNlZWtpbmcgd2hpbGUgZnJhZyBsb2FkIGlzIGluIHByb2dyZXNzXG4gICAgICAgIHZhciB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgICAgdmFyIGZyYWdTdGFydE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0IC0gdG9sZXJhbmNlO1xuICAgICAgICB2YXIgZnJhZ0VuZE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0ICsgZnJhZ0N1cnJlbnQuZHVyYXRpb24gKyB0b2xlcmFuY2U7XG4gICAgICAgIC8vIGlmIHNlZWtpbmcgb3V0IG9mIGJ1ZmZlcmVkIHJhbmdlIG9yIGludG8gbmV3IG9uZVxuICAgICAgICBpZiAoIWJ1ZmZlckluZm8ubGVuIHx8IGZyYWdFbmRPZmZzZXQgPCBidWZmZXJJbmZvLnN0YXJ0IHx8IGZyYWdTdGFydE9mZnNldCA+IGJ1ZmZlckluZm8uZW5kKSB7XG4gICAgICAgICAgdmFyIHBhc3RGcmFnbWVudCA9IGN1cnJlbnRUaW1lID4gZnJhZ0VuZE9mZnNldDtcbiAgICAgICAgICAvLyBpZiB0aGUgc2VlayBwb3NpdGlvbiBpcyBvdXRzaWRlIHRoZSBjdXJyZW50IGZyYWdtZW50IHJhbmdlXG4gICAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgZnJhZ1N0YXJ0T2Zmc2V0IHx8IHBhc3RGcmFnbWVudCkge1xuICAgICAgICAgICAgaWYgKHBhc3RGcmFnbWVudCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgd2hpbGUgZnJhZ21lbnQgbG9hZCBpbiBwcm9ncmVzcywgY2FuY2VsIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGdhcCBmcmFnbWVudHNcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShjdXJyZW50VGltZSwgSW5maW5pdHksIHRoaXMucGxheWxpc3RUeXBlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cblxuICAgICAgLy8gaW4gY2FzZSBzZWVraW5nIG9jY3VycyBhbHRob3VnaCBubyBtZWRpYSBidWZmZXJlZCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gYW5kIG5leHRMb2FkUG9zaXRpb24gdG8gc2VlayB0YXJnZXRcbiAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiAhYnVmZmVySW5mby5sZW4pIHtcbiAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gY3VycmVudFRpbWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEFzeW5jIHRpY2sgdG8gc3BlZWQgdXAgcHJvY2Vzc2luZ1xuICAgICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYUVuZGVkID0gZnVuY3Rpb24gb25NZWRpYUVuZGVkKCkge1xuICAgICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gZGF0YS5zdGFydFRpbWVPZmZzZXQ7XG4gICAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICB9O1xuICAgIF9wcm90by5vbkhhbmRsZXJEZXN0cm95aW5nID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgX1Rhc2tMb29wLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95aW5nLmNhbGwodGhpcyk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmhscyA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWVkID0gZnVuY3Rpb24gb25IYW5kbGVyRGVzdHJveWVkKCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgICBpZiAodGhpcy5mcmFnbWVudExvYWRlcikge1xuICAgICAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmtleUxvYWRlcikge1xuICAgICAgICB0aGlzLmtleUxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kZWNyeXB0ZXIpIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0ZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMgPSB0aGlzLmxvZyA9IHRoaXMud2FybiA9IHRoaXMuZGVjcnlwdGVyID0gdGhpcy5rZXlMb2FkZXIgPSB0aGlzLmZyYWdtZW50TG9hZGVyID0gdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBudWxsO1xuICAgICAgX1Rhc2tMb29wLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95ZWQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5sb2FkRnJhZ21lbnQgPSBmdW5jdGlvbiBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAgIHRoaXMuX2xvYWRGcmFnRm9yUGxheWJhY2soZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgIH07XG4gICAgX3Byb3RvLl9sb2FkRnJhZ0ZvclBsYXliYWNrID0gZnVuY3Rpb24gX2xvYWRGcmFnRm9yUGxheWJhY2soZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHByb2dyZXNzQ2FsbGJhY2sgPSBmdW5jdGlvbiBwcm9ncmVzc0NhbGxiYWNrKGRhdGEpIHtcbiAgICAgICAgaWYgKF90aGlzMi5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgICBfdGhpczIud2FybihcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIChkYXRhLnBhcnQgPyAnIHA6ICcgKyBkYXRhLnBhcnQuaW5kZXggOiAnJykgKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiB3YXMgZHJvcHBlZCBkdXJpbmcgZG93bmxvYWQuXCIpO1xuICAgICAgICAgIF90aGlzMi5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZyYWcuc3RhdHMuY2h1bmtDb3VudCsrO1xuICAgICAgICBfdGhpczIuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgLy8gaWYgd2UncmUgaGVyZSB3ZSBwcm9iYWJseSBuZWVkZWQgdG8gYmFja3RyYWNrIG9yIGFyZSB3YWl0aW5nIGZvciBtb3JlIHBhcnRzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IF90aGlzMi5zdGF0ZTtcbiAgICAgICAgaWYgKF90aGlzMi5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyB8fCAhX3RoaXMyLmZyYWdDdXJyZW50ICYmIHN0YXRlID09PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgICAgICBfdGhpczIuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICAgICAgX3RoaXMyLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgncGF5bG9hZCcgaW4gZGF0YSkge1xuICAgICAgICAgIF90aGlzMi5sb2coXCJMb2FkZWQgZnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsKTtcbiAgICAgICAgICBfdGhpczIuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BREVELCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgd2hvbGUgcGF5bG9hZDsgY29udHJvbGxlcnMgbm90IGltcGxlbWVudGluZyBwcm9ncmVzc2l2ZSBsb2FkaW5nIHJlY2VpdmUgZGF0YSBmcm9tIHRoaXMgY2FsbGJhY2tcbiAgICAgICAgX3RoaXMyLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShkYXRhKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKF90aGlzMi5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCB8fCBfdGhpczIuc3RhdGUgPT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzMi53YXJuKFwiRnJhZyBlcnJvcjogXCIgKyAoKHJlYXNvbiA9PSBudWxsID8gdm9pZCAwIDogcmVhc29uLm1lc3NhZ2UpIHx8IHJlYXNvbikpO1xuICAgICAgICBfdGhpczIucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5jbGVhclRyYWNrZXJJZk5lZWRlZCA9IGZ1bmN0aW9uIGNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpIHtcbiAgICAgIHZhciBfdGhpcyRtZWRpYUJ1ZmZlcjtcbiAgICAgIHZhciBmcmFnbWVudFRyYWNrZXIgPSB0aGlzLmZyYWdtZW50VHJhY2tlcjtcbiAgICAgIHZhciBmcmFnU3RhdGUgPSBmcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgICBpZiAoZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLkFQUEVORElORykge1xuICAgICAgICAvLyBMb3dlciB0aGUgbWF4IGJ1ZmZlciBsZW5ndGggYW5kIHRyeSBhZ2FpblxuICAgICAgICB2YXIgcGxheWxpc3RUeXBlID0gZnJhZy50eXBlO1xuICAgICAgICB2YXIgYnVmZmVyZWRJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIsIHBsYXlsaXN0VHlwZSk7XG4gICAgICAgIHZhciBtaW5Gb3J3YXJkQnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoZnJhZy5kdXJhdGlvbiwgYnVmZmVyZWRJbmZvID8gYnVmZmVyZWRJbmZvLmxlbiA6IHRoaXMuY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICAgIC8vIElmIGJhY2t0cmFja2luZywgYWx3YXlzIHJlbW92ZSBmcm9tIHRoZSB0cmFja2VyIHdpdGhvdXQgcmVkdWNpbmcgbWF4IGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgdmFyIGJhY2t0cmFja0ZyYWdtZW50ID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudDtcbiAgICAgICAgdmFyIGJhY2t0cmFja2VkID0gYmFja3RyYWNrRnJhZ21lbnQgPyBmcmFnLnNuIC0gYmFja3RyYWNrRnJhZ21lbnQuc24gOiAwO1xuICAgICAgICBpZiAoYmFja3RyYWNrZWQgPT09IDEgfHwgdGhpcy5yZWR1Y2VNYXhCdWZmZXJMZW5ndGgobWluRm9yd2FyZEJ1ZmZlckxlbmd0aCwgZnJhZy5kdXJhdGlvbikpIHtcbiAgICAgICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKChfdGhpcyRtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYUJ1ZmZlci5idWZmZXJlZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgIC8vIFN0b3AgZ2FwIGZvciBiYWQgdHJhY2tlciAvIGJ1ZmZlciBmbHVzaCBiZWhhdmlvclxuICAgICAgICBmcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgICB9IGVsc2UgaWYgKGZyYWdtZW50VHJhY2tlci5oYXNQYXJ0cyhmcmFnLnR5cGUpKSB7XG4gICAgICAgIC8vIEluIGxvdyBsYXRlbmN5IG1vZGUsIHJlbW92ZSBmcmFnbWVudHMgZm9yIHdoaWNoIG9ubHkgc29tZSBwYXJ0cyB3ZXJlIGJ1ZmZlcmVkXG4gICAgICAgIGZyYWdtZW50VHJhY2tlci5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKHtcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgc3RhdHM6IGZyYWcuc3RhdHMsXG4gICAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XG4gICAgICAgICAgZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY2hlY2tMaXZlVXBkYXRlID0gZnVuY3Rpb24gY2hlY2tMaXZlVXBkYXRlKGRldGFpbHMpIHtcbiAgICAgIGlmIChkZXRhaWxzLnVwZGF0ZWQgJiYgIWRldGFpbHMubGl2ZSkge1xuICAgICAgICAvLyBMaXZlIHN0cmVhbSBlbmRlZCwgdXBkYXRlIGZyYWdtZW50IHRyYWNrZXJcbiAgICAgICAgdmFyIGxhc3RGcmFnbWVudCA9IGRldGFpbHMuZnJhZ21lbnRzW2RldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKHtcbiAgICAgICAgICBmcmFnOiBsYXN0RnJhZ21lbnQsXG4gICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICBzdGF0czogbGFzdEZyYWdtZW50LnN0YXRzLFxuICAgICAgICAgIGlkOiBsYXN0RnJhZ21lbnQudHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghZGV0YWlscy5mcmFnbWVudHNbMF0pIHtcbiAgICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2hNYWluQnVmZmVyID0gZnVuY3Rpb24gZmx1c2hNYWluQnVmZmVyKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgdHlwZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIShzdGFydE9mZnNldCAtIGVuZE9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gV2hlbiBhbHRlcm5hdGUgYXVkaW8gaXMgcGxheWluZywgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgYXVkaW8gYnVmZmVyLiBPdGhlcndpc2UsXG4gICAgICAvLyBwYXNzaW5nIGEgbnVsbCB0eXBlIGZsdXNoZXMgYm90aCBidWZmZXJzXG4gICAgICB2YXIgZmx1c2hTY29wZSA9IHtcbiAgICAgICAgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICBlbmRPZmZzZXQ6IGVuZE9mZnNldCxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gICAgfTtcbiAgICBfcHJvdG8uX2xvYWRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIF9sb2FkSW5pdFNlZ21lbnQoZnJhZywgbGV2ZWwpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnLCBsZXZlbCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEgfHwgX3RoaXMzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB8fCAhX3RoaXMzLmxldmVscykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBsb2FkIGFib3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGhscyA9IF90aGlzMy5obHM7XG4gICAgICAgIHZhciBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgICAgICB2YXIgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuXG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBkZWNyeXB0ZWRcbiAgICAgICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5ieXRlTGVuZ3RoID4gMCAmJiBkZWNyeXB0RGF0YSAhPSBudWxsICYmIGRlY3J5cHREYXRhLmtleSAmJiBkZWNyeXB0RGF0YS5pdiAmJiBkZWNyeXB0RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4Jykge1xuICAgICAgICAgIHZhciBzdGFydFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIC8vIGRlY3J5cHQgaW5pdCBzZWdtZW50IGRhdGFcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLmRlY3J5cHRlci5kZWNyeXB0KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBkZWNyeXB0RGF0YS5rZXkuYnVmZmVyLCBkZWNyeXB0RGF0YS5pdi5idWZmZXIpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgIHJlYXNvbjogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZyYWc6IGZyYWdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICAgIHZhciBlbmRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBkZWNyeXB0ZWREYXRhLFxuICAgICAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgICAgIHRzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIHRkZWNyeXB0OiBlbmRUaW1lXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YS5wYXlsb2FkID0gZGVjcnlwdGVkRGF0YTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuY29tcGxldGVJbml0U2VnbWVudExvYWQoZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzMy5jb21wbGV0ZUluaXRTZWdtZW50TG9hZChkYXRhKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKF90aGlzMy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCB8fCBfdGhpczMuc3RhdGUgPT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzMy53YXJuKHJlYXNvbik7XG4gICAgICAgIF90aGlzMy5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmNvbXBsZXRlSW5pdFNlZ21lbnRMb2FkID0gZnVuY3Rpb24gY29tcGxldGVJbml0U2VnbWVudExvYWQoZGF0YSkge1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IGxvYWQgYWJvcnRlZCwgbWlzc2luZyBsZXZlbHMnKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdGF0cyA9IGRhdGEuZnJhZy5zdGF0cztcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgZGF0YS5mcmFnLmRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLnBheWxvYWQpO1xuICAgICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHN0YXRzLmJ1ZmZlcmluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBzdGF0cy5wYXJzaW5nLmVuZCA9IHN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZnJhZ0NvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpIHtcbiAgICAgIHZhciBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICByZXR1cm4gIWZyYWcgfHwgIWZyYWdDdXJyZW50IHx8IGZyYWcuc24gIT09IGZyYWdDdXJyZW50LnNuIHx8IGZyYWcubGV2ZWwgIT09IGZyYWdDdXJyZW50LmxldmVsO1xuICAgIH07XG4gICAgX3Byb3RvLmZyYWdCdWZmZXJlZENvbXBsZXRlID0gZnVuY3Rpb24gZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCkge1xuICAgICAgdmFyIF9mcmFnJHN0YXJ0UFRTLCBfZnJhZyRlbmRQVFMsIF90aGlzJGZyYWdDdXJyZW50LCBfdGhpcyRmcmFnUHJldmlvdXM7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICB0aGlzLmxvZyhcIkJ1ZmZlcmVkIFwiICsgZnJhZy50eXBlICsgXCIgc246IFwiICsgZnJhZy5zbiArIChwYXJ0ID8gJyBwYXJ0OiAnICsgcGFydC5pbmRleCA6ICcnKSArIFwiIG9mIFwiICsgKHRoaXMucGxheWxpc3RUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gJ2xldmVsJyA6ICd0cmFjaycpICsgXCIgXCIgKyBmcmFnLmxldmVsICsgXCIgKGZyYWc6W1wiICsgKChfZnJhZyRzdGFydFBUUyA9IGZyYWcuc3RhcnRQVFMpICE9IG51bGwgPyBfZnJhZyRzdGFydFBUUyA6IE5hTikudG9GaXhlZCgzKSArIFwiLVwiICsgKChfZnJhZyRlbmRQVFMgPSBmcmFnLmVuZFBUUykgIT0gbnVsbCA/IF9mcmFnJGVuZFBUUyA6IE5hTikudG9GaXhlZCgzKSArIFwiXSA+IGJ1ZmZlcjpcIiArIChtZWRpYSA/IFRpbWVSYW5nZXMudG9TdHJpbmcoQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKSkgOiAnKGRldGFjaGVkKScpICsgXCIpXCIpO1xuICAgICAgaWYgKGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgdmFyIF90aGlzJGxldmVscztcbiAgICAgICAgaWYgKGZyYWcudHlwZSAhPT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgICAgICB2YXIgZWwgPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZWwpLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWVsW3R5cGVdO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBzZWdtZW50XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxldmVsID0gKF90aGlzJGxldmVscyA9IHRoaXMubGV2ZWxzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgICBpZiAobGV2ZWwgIT0gbnVsbCAmJiBsZXZlbC5mcmFnbWVudEVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJSZXNldHRpbmcgbGV2ZWwgZnJhZ21lbnQgZXJyb3IgY291bnQgb2YgXCIgKyBsZXZlbC5mcmFnbWVudEVycm9yICsgXCIgb24gZnJhZyBidWZmZXJlZFwiKTtcbiAgICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICBpZiAoIW1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBmcmFnLnR5cGUgPT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiAmJiBtZWRpYS5idWZmZXJlZC5sZW5ndGggJiYgKChfdGhpcyRmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRmcmFnQ3VycmVudC5zbikgPT09ICgoX3RoaXMkZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRmcmFnUHJldmlvdXMuc24pKSB7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlZWtUb1N0YXJ0UG9zKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICB9O1xuICAgIF9wcm90by5zZWVrVG9TdGFydFBvcyA9IGZ1bmN0aW9uIHNlZWtUb1N0YXJ0UG9zKCkge307XG4gICAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRW5kRGF0YSkge1xuICAgICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXI7XG4gICAgICBpZiAoIXRyYW5zbXV4ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGZyYWcgPSBmcmFnTG9hZGVkRW5kRGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZnJhZ0xvYWRlZEVuZERhdGEucGFydCxcbiAgICAgICAgcGFydHNMb2FkZWQgPSBmcmFnTG9hZGVkRW5kRGF0YS5wYXJ0c0xvYWRlZDtcbiAgICAgIC8vIElmIHdlIGRpZCBub3QgbG9hZCBwYXJ0cywgb3IgbG9hZGVkIGFsbCBwYXJ0cywgd2UgaGF2ZSBjb21wbGV0ZSAobm90IHBhcnRpYWwpIGZyYWdtZW50IGRhdGFcbiAgICAgIHZhciBjb21wbGV0ZSA9ICFwYXJ0c0xvYWRlZCB8fCBwYXJ0c0xvYWRlZC5sZW5ndGggPT09IDAgfHwgcGFydHNMb2FkZWQuc29tZShmdW5jdGlvbiAoZnJhZ0xvYWRlZCkge1xuICAgICAgICByZXR1cm4gIWZyYWdMb2FkZWQ7XG4gICAgICB9KTtcbiAgICAgIHZhciBjaHVua01ldGEgPSBuZXcgQ2h1bmtNZXRhZGF0YShmcmFnLmxldmVsLCBmcmFnLnNuLCBmcmFnLnN0YXRzLmNodW5rQ291bnQgKyAxLCAwLCBwYXJ0ID8gcGFydC5pbmRleCA6IC0xLCAhY29tcGxldGUpO1xuICAgICAgdHJhbnNtdXhlci5mbHVzaChjaHVua01ldGEpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICA7XG4gICAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhmcmFnKSB7fTtcbiAgICBfcHJvdG8uX2RvRnJhZ0xvYWQgPSBmdW5jdGlvbiBfZG9GcmFnTG9hZChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgdmFyIF9mcmFnJGRlY3J5cHRkYXRhLFxuICAgICAgICBfdGhpczQgPSB0aGlzO1xuICAgICAgaWYgKHRhcmdldEJ1ZmZlclRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgICB0YXJnZXRCdWZmZXJUaW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBkZXRhaWxzID0gbGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLmRldGFpbHM7XG4gICAgICBpZiAoIXRoaXMubGV2ZWxzIHx8ICFkZXRhaWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZyYWcgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVsXCIgKyAoZGV0YWlscyA/ICcnIDogJyBkZXRhaWwnKSArIFwic1wiKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXlMb2FkaW5nUHJvbWlzZSA9IG51bGw7XG4gICAgICBpZiAoZnJhZy5lbmNyeXB0ZWQgJiYgISgoX2ZyYWckZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhKSAhPSBudWxsICYmIF9mcmFnJGRlY3J5cHRkYXRhLmtleSkpIHtcbiAgICAgICAgdGhpcy5sb2coXCJMb2FkaW5nIGtleSBmb3IgXCIgKyBmcmFnLnNuICsgXCIgb2YgW1wiICsgZGV0YWlscy5zdGFydFNOICsgXCItXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdLCBcIiArICh0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjaycpICsgXCIgXCIgKyBmcmFnLmxldmVsKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLktFWV9MT0FESU5HO1xuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgICAga2V5TG9hZGluZ1Byb21pc2UgPSB0aGlzLmtleUxvYWRlci5sb2FkKGZyYWcpLnRoZW4oZnVuY3Rpb24gKGtleUxvYWRlZERhdGEpIHtcbiAgICAgICAgICBpZiAoIV90aGlzNC5mcmFnQ29udGV4dENoYW5nZWQoa2V5TG9hZGVkRGF0YS5mcmFnKSkge1xuICAgICAgICAgICAgX3RoaXM0Lmhscy50cmlnZ2VyKEV2ZW50cy5LRVlfTE9BREVELCBrZXlMb2FkZWREYXRhKTtcbiAgICAgICAgICAgIGlmIChfdGhpczQuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICAgICAgICAgIF90aGlzNC5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5TG9hZGVkRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5LRVlfTE9BRElORywge1xuICAgICAgICAgIGZyYWc6IGZyYWdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAga2V5TG9hZGluZ1Byb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEtFWV9MT0FESU5HXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghZnJhZy5lbmNyeXB0ZWQgJiYgZGV0YWlscy5lbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMua2V5TG9hZGVyLmxvYWRDbGVhcihmcmFnLCBkZXRhaWxzLmVuY3J5cHRlZEZyYWdtZW50cyk7XG4gICAgICB9XG4gICAgICB0YXJnZXRCdWZmZXJUaW1lID0gTWF0aC5tYXgoZnJhZy5zdGFydCwgdGFyZ2V0QnVmZmVyVGltZSB8fCAwKTtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHZhciBwYXJ0TGlzdCA9IGRldGFpbHMucGFydExpc3Q7XG4gICAgICAgIGlmIChwYXJ0TGlzdCAmJiBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKHRhcmdldEJ1ZmZlclRpbWUgPiBmcmFnLmVuZCAmJiBkZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgICAgICAgICAgZnJhZyA9IGRldGFpbHMuZnJhZ21lbnRIaW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcGFydEluZGV4ID0gdGhpcy5nZXROZXh0UGFydChwYXJ0TGlzdCwgZnJhZywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICAgICAgaWYgKHBhcnRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRMaXN0W3BhcnRJbmRleF07XG4gICAgICAgICAgICB0aGlzLmxvZyhcIkxvYWRpbmcgcGFydCBzbjogXCIgKyBmcmFnLnNuICsgXCIgcDogXCIgKyBwYXJ0LmluZGV4ICsgXCIgY2M6IFwiICsgZnJhZy5jYyArIFwiIG9mIHBsYXlsaXN0IFtcIiArIGRldGFpbHMuc3RhcnRTTiArIFwiLVwiICsgZGV0YWlscy5lbmRTTiArIFwiXSBwYXJ0cyBbMC1cIiArIHBhcnRJbmRleCArIFwiLVwiICsgKHBhcnRMaXN0Lmxlbmd0aCAtIDEpICsgXCJdIFwiICsgKHRoaXMubG9nUHJlZml4ID09PSAnW3N0cmVhbS1jb250cm9sbGVyXScgPyAnbGV2ZWwnIDogJ3RyYWNrJykgKyBcIjogXCIgKyBmcmFnLmxldmVsICsgXCIsIHRhcmdldDogXCIgKyBwYXJzZUZsb2F0KHRhcmdldEJ1ZmZlclRpbWUudG9GaXhlZCgzKSkpO1xuICAgICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gcGFydC5zdGFydCArIHBhcnQuZHVyYXRpb247XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgICAgdmFyIF9yZXN1bHQ7XG4gICAgICAgICAgICBpZiAoa2V5TG9hZGluZ1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdCA9IGtleUxvYWRpbmdQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGtleUxvYWRlZERhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtleUxvYWRlZERhdGEgfHwgX3RoaXM0LmZyYWdDb250ZXh0Q2hhbmdlZChrZXlMb2FkZWREYXRhLmZyYWcpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5kb0ZyYWdQYXJ0c0xvYWQoZnJhZywgcGFydCwgbGV2ZWwsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0LmhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9yZXN1bHQgPSB0aGlzLmRvRnJhZ1BhcnRzTG9hZChmcmFnLCBwYXJ0LCBsZXZlbCwgcHJvZ3Jlc3NDYWxsYmFjaykuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURJTkcsIHtcbiAgICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICAgICAgdGFyZ2V0QnVmZmVyVGltZTogdGFyZ2V0QnVmZmVyVGltZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5mcmFnQ3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiZnJhZyBsb2FkIGFib3J0ZWQsIGNvbnRleHQgY2hhbmdlZCBpbiBGUkFHX0xPQURJTkcgcGFydHNcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghZnJhZy51cmwgfHwgdGhpcy5sb2FkZWRFbmRPZlBhcnRzKHBhcnRMaXN0LCB0YXJnZXRCdWZmZXJUaW1lKSkge1xuICAgICAgICAgICAgLy8gRnJhZ21lbnQgaGludCBoYXMgbm8gcGFydHNcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhcIkxvYWRpbmcgZnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgY2M6IFwiICsgZnJhZy5jYyArIFwiIFwiICsgKGRldGFpbHMgPyAnb2YgWycgKyBkZXRhaWxzLnN0YXJ0U04gKyAnLScgKyBkZXRhaWxzLmVuZFNOICsgJ10gJyA6ICcnKSArICh0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjaycpICsgXCI6IFwiICsgZnJhZy5sZXZlbCArIFwiLCB0YXJnZXQ6IFwiICsgcGFyc2VGbG9hdCh0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMykpKTtcbiAgICAgIC8vIERvbid0IHVwZGF0ZSBuZXh0TG9hZFBvc2l0aW9uIGZvciBmcmFnbWVudHMgd2hpY2ggYXJlIG5vdCBidWZmZXJlZFxuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGZyYWcuc24pICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcblxuICAgICAgLy8gTG9hZCBrZXkgYmVmb3JlIHN0cmVhbWluZyBmcmFnbWVudCBkYXRhXG4gICAgICB2YXIgZGF0YU9uUHJvZ3Jlc3MgPSB0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZTtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoZGF0YU9uUHJvZ3Jlc3MgJiYga2V5TG9hZGluZ1Byb21pc2UpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5TG9hZGluZ1Byb21pc2UudGhlbihmdW5jdGlvbiAoa2V5TG9hZGVkRGF0YSkge1xuICAgICAgICAgIGlmICgha2V5TG9hZGVkRGF0YSB8fCBfdGhpczQuZnJhZ0NvbnRleHRDaGFuZ2VkKGtleUxvYWRlZERhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGtleUxvYWRlZERhdGEuZnJhZykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmZyYWdtZW50TG9hZGVyLmxvYWQoZnJhZywgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBfdGhpczQuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbG9hZCB1bmVuY3J5cHRlZCBmcmFnbWVudCBkYXRhIHdpdGggcHJvZ3Jlc3MgZXZlbnQsXG4gICAgICAgIC8vIG9yIGhhbmRsZSBmcmFnbWVudCByZXN1bHQgYWZ0ZXIga2V5IGFuZCBmcmFnbWVudCBhcmUgZmluaXNoZWQgbG9hZGluZ1xuICAgICAgICByZXN1bHQgPSBQcm9taXNlLmFsbChbdGhpcy5mcmFnbWVudExvYWRlci5sb2FkKGZyYWcsIGRhdGFPblByb2dyZXNzID8gcHJvZ3Jlc3NDYWxsYmFjayA6IHVuZGVmaW5lZCksIGtleUxvYWRpbmdQcm9taXNlXSkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBmcmFnTG9hZGVkRGF0YSA9IF9yZWZbMF07XG4gICAgICAgICAgaWYgKCFkYXRhT25Qcm9ncmVzcyAmJiBmcmFnTG9hZGVkRGF0YSAmJiBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGZyYWdMb2FkZWREYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZyYWdMb2FkZWREYXRhO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BRElORywge1xuICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICB0YXJnZXRCdWZmZXJUaW1lOiB0YXJnZXRCdWZmZXJUaW1lXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEZSQUdfTE9BRElOR1wiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLmRvRnJhZ1BhcnRzTG9hZCA9IGZ1bmN0aW9uIGRvRnJhZ1BhcnRzTG9hZChmcmFnLCBmcm9tUGFydCwgbGV2ZWwsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuICAgICAgICB2YXIgcGFydHNMb2FkZWQgPSBbXTtcbiAgICAgICAgdmFyIGluaXRpYWxQYXJ0TGlzdCA9IChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfbGV2ZWwkZGV0YWlscy5wYXJ0TGlzdDtcbiAgICAgICAgdmFyIGxvYWRQYXJ0ID0gZnVuY3Rpb24gbG9hZFBhcnQocGFydCkge1xuICAgICAgICAgIF90aGlzNS5mcmFnbWVudExvYWRlci5sb2FkUGFydChmcmFnLCBwYXJ0LCBwcm9ncmVzc0NhbGxiYWNrKS50aGVuKGZ1bmN0aW9uIChwYXJ0TG9hZGVkRGF0YSkge1xuICAgICAgICAgICAgcGFydHNMb2FkZWRbcGFydC5pbmRleF0gPSBwYXJ0TG9hZGVkRGF0YTtcbiAgICAgICAgICAgIHZhciBsb2FkZWRQYXJ0ID0gcGFydExvYWRlZERhdGEucGFydDtcbiAgICAgICAgICAgIF90aGlzNS5obHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FERUQsIHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgICAgIHZhciBuZXh0UGFydCA9IGdldFBhcnRXaXRoKGxldmVsLCBmcmFnLnNuLCBwYXJ0LmluZGV4ICsgMSkgfHwgZmluZFBhcnQoaW5pdGlhbFBhcnRMaXN0LCBmcmFnLnNuLCBwYXJ0LmluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAobmV4dFBhcnQpIHtcbiAgICAgICAgICAgICAgbG9hZFBhcnQobmV4dFBhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICAgICAgcGFydDogbG9hZGVkUGFydCxcbiAgICAgICAgICAgICAgICBwYXJ0c0xvYWRlZDogcGFydHNMb2FkZWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgbG9hZFBhcnQoZnJvbVBhcnQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlRnJhZ0xvYWRFcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpIHtcbiAgICAgIGlmICgnZGF0YScgaW4gZXJyb3IpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBlcnJvci5kYXRhO1xuICAgICAgICBpZiAoZXJyb3IuZGF0YSAmJiBkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVEKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVGcmFnTG9hZEFib3J0ZWQoZGF0YS5mcmFnLCBkYXRhLnBhcnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sXG4gICAgICAgICAgZXJyOiBlcnJvcixcbiAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5faGFuZGxlVHJhbnNtdXhlckZsdXNoID0gZnVuY3Rpb24gX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaChjaHVua01ldGEpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuICAgICAgaWYgKCFjb250ZXh0IHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZyYWdDdXJyZW50ICYmIHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQgJiYgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZnJhZyA9IGNvbnRleHQuZnJhZyxcbiAgICAgICAgcGFydCA9IGNvbnRleHQucGFydCxcbiAgICAgICAgbGV2ZWwgPSBjb250ZXh0LmxldmVsO1xuICAgICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBmcmFnLnN0YXRzLnBhcnNpbmcuZW5kID0gbm93O1xuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgcGFydC5zdGF0cy5wYXJzaW5nLmVuZCA9IG5vdztcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlTGV2ZWxUaW1pbmcoZnJhZywgcGFydCwgbGV2ZWwsIGNodW5rTWV0YS5wYXJ0aWFsKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRDdXJyZW50Q29udGV4dCA9IGZ1bmN0aW9uIGdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSkge1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgICBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICB2YXIgbGV2ZWxJbmRleCA9IGNodW5rTWV0YS5sZXZlbCxcbiAgICAgICAgc24gPSBjaHVua01ldGEuc24sXG4gICAgICAgIHBhcnRJbmRleCA9IGNodW5rTWV0YS5wYXJ0O1xuICAgICAgaWYgKCEobGV2ZWxzICE9IG51bGwgJiYgbGV2ZWxzW2xldmVsSW5kZXhdKSkge1xuICAgICAgICB0aGlzLndhcm4oXCJMZXZlbHMgb2JqZWN0IHdhcyB1bnNldCB3aGlsZSBidWZmZXJpbmcgZnJhZ21lbnQgXCIgKyBzbiArIFwiIG9mIGxldmVsIFwiICsgbGV2ZWxJbmRleCArIFwiLiBUaGUgY3VycmVudCBjaHVuayB3aWxsIG5vdCBiZSBidWZmZXJlZC5cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgICAgdmFyIHBhcnQgPSBwYXJ0SW5kZXggPiAtMSA/IGdldFBhcnRXaXRoKGxldmVsLCBzbiwgcGFydEluZGV4KSA6IG51bGw7XG4gICAgICB2YXIgZnJhZyA9IHBhcnQgPyBwYXJ0LmZyYWdtZW50IDogZ2V0RnJhZ21lbnRXaXRoU04obGV2ZWwsIHNuLCBmcmFnQ3VycmVudCk7XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQgIT09IGZyYWcpIHtcbiAgICAgICAgZnJhZy5zdGF0cyA9IGZyYWdDdXJyZW50LnN0YXRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgbGV2ZWw6IGxldmVsXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmJ1ZmZlckZyYWdtZW50RGF0YSA9IGZ1bmN0aW9uIGJ1ZmZlckZyYWdtZW50RGF0YShkYXRhLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEsIG5vQmFja3RyYWNraW5nKSB7XG4gICAgICB2YXIgX2J1ZmZlcjtcbiAgICAgIGlmICghZGF0YSB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhMSA9IGRhdGEuZGF0YTEsXG4gICAgICAgIGRhdGEyID0gZGF0YS5kYXRhMjtcbiAgICAgIHZhciBidWZmZXIgPSBkYXRhMTtcbiAgICAgIGlmIChkYXRhMSAmJiBkYXRhMikge1xuICAgICAgICAvLyBDb21iaW5lIHRoZSBtb29mICsgbWRhdCBzbyB0aGF0IHdlIGJ1ZmZlciB3aXRoIGEgc2luZ2xlIGFwcGVuZFxuICAgICAgICBidWZmZXIgPSBhcHBlbmRVaW50OEFycmF5KGRhdGExLCBkYXRhMik7XG4gICAgICB9XG4gICAgICBpZiAoISgoX2J1ZmZlciA9IGJ1ZmZlcikgIT0gbnVsbCAmJiBfYnVmZmVyLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICBkYXRhOiBidWZmZXJcbiAgICAgIH07XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCBzZWdtZW50KTtcbiAgICAgIGlmIChkYXRhLmRyb3BwZWQgJiYgZGF0YS5pbmRlcGVuZGVudCAmJiAhcGFydCkge1xuICAgICAgICBpZiAobm9CYWNrdHJhY2tpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgYnVmZmVyIHNvIHRoYXQgd2UgcmVsb2FkIHByZXZpb3VzIHNlZ21lbnRzIHNlcXVlbnRpYWxseSBpZiByZXF1aXJlZFxuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyR2FwKGZyYWcpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoQnVmZmVyR2FwID0gZnVuY3Rpb24gZmx1c2hCdWZmZXJHYXAoZnJhZykge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmICghbWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gSWYgY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBjbGVhciB0aGUgYmFjayBidWZmZXIgc28gdGhhdCB3ZSBjYW4gYmFja3RyYWNrIGFzIG11Y2ggYXMgbmVlZGVkXG4gICAgICBpZiAoIUJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKG1lZGlhLCBtZWRpYS5jdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZy5zdGFydCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBiYWNrLWJ1ZmZlciB3aXRob3V0IGludGVycnVwdGluZyBwbGF5YmFjayB0byBhbGxvdyBiYWNrIHRyYWNraW5nXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIHZhciBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICAgIHZhciBmcmFnRHVyYXRpb24gPSBmcmFnLmR1cmF0aW9uO1xuICAgICAgdmFyIHNlZ21lbnRGcmFjdGlvbiA9IE1hdGgubWluKHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UgKiAyLCBmcmFnRHVyYXRpb24gKiAwLjI1KTtcbiAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KE1hdGgubWluKGZyYWcuc3RhcnQgLSBzZWdtZW50RnJhY3Rpb24sIGJ1ZmZlckluZm8uZW5kIC0gc2VnbWVudEZyYWN0aW9uKSwgY3VycmVudFRpbWUgKyBzZWdtZW50RnJhY3Rpb24pO1xuICAgICAgaWYgKGZyYWcuc3RhcnQgLSBzdGFydCA+IHNlZ21lbnRGcmFjdGlvbikge1xuICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihzdGFydCwgZnJhZy5zdGFydCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0RndkQnVmZmVySW5mbyA9IGZ1bmN0aW9uIGdldEZ3ZEJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgdHlwZSkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKHBvcykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRGd2RCdWZmZXJJbmZvQXRQb3MoYnVmZmVyYWJsZSwgcG9zLCB0eXBlKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRGd2RCdWZmZXJJbmZvQXRQb3MgPSBmdW5jdGlvbiBnZXRGd2RCdWZmZXJJbmZvQXRQb3MoYnVmZmVyYWJsZSwgcG9zLCB0eXBlKSB7XG4gICAgICB2YXIgbWF4QnVmZmVySG9sZSA9IHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGU7XG4gICAgICB2YXIgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKGJ1ZmZlcmFibGUsIHBvcywgbWF4QnVmZmVySG9sZSk7XG4gICAgICAvLyBXb3JrYXJvdW5kIGZsYXcgaW4gZ2V0dGluZyBmb3J3YXJkIGJ1ZmZlciB3aGVuIG1heEJ1ZmZlckhvbGUgaXMgc21hbGxlciB0aGFuIGdhcCBhdCBjdXJyZW50IHBvc1xuICAgICAgaWYgKGJ1ZmZlckluZm8ubGVuID09PSAwICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGJ1ZmZlcmVkRnJhZ0F0UG9zID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHBvcywgdHlwZSk7XG4gICAgICAgIGlmIChidWZmZXJlZEZyYWdBdFBvcyAmJiBidWZmZXJJbmZvLm5leHRTdGFydCA8IGJ1ZmZlcmVkRnJhZ0F0UG9zLmVuZCkge1xuICAgICAgICAgIHJldHVybiBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhidWZmZXJhYmxlLCBwb3MsIE1hdGgubWF4KGJ1ZmZlckluZm8ubmV4dFN0YXJ0LCBtYXhCdWZmZXJIb2xlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXJJbmZvO1xuICAgIH07XG4gICAgX3Byb3RvLmdldE1heEJ1ZmZlckxlbmd0aCA9IGZ1bmN0aW9uIGdldE1heEJ1ZmZlckxlbmd0aChsZXZlbEJpdHJhdGUpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIHZhciBtYXhCdWZMZW47XG4gICAgICBpZiAobGV2ZWxCaXRyYXRlKSB7XG4gICAgICAgIG1heEJ1ZkxlbiA9IE1hdGgubWF4KDggKiBjb25maWcubWF4QnVmZmVyU2l6ZSAvIGxldmVsQml0cmF0ZSwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgubWluKG1heEJ1ZkxlbiwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVkdWNlTWF4QnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKHRocmVzaG9sZCwgZnJhZ0R1cmF0aW9uKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICB2YXIgbWluTGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4odGhyZXNob2xkIC0gZnJhZ0R1cmF0aW9uLCBjb25maWcubWF4QnVmZmVyTGVuZ3RoKSwgZnJhZ0R1cmF0aW9uKTtcbiAgICAgIHZhciByZWR1Y2VkTGVuZ3RoID0gTWF0aC5tYXgodGhyZXNob2xkIC0gZnJhZ0R1cmF0aW9uICogMywgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAvIDIsIG1pbkxlbmd0aCk7XG4gICAgICBpZiAocmVkdWNlZExlbmd0aCA+PSBtaW5MZW5ndGgpIHtcbiAgICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXG4gICAgICAgIGNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGggPSByZWR1Y2VkTGVuZ3RoO1xuICAgICAgICB0aGlzLndhcm4oXCJSZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gXCIgKyByZWR1Y2VkTGVuZ3RoICsgXCJzXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRBcHBlbmRlZEZyYWcgPSBmdW5jdGlvbiBnZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIHBsYXlsaXN0VHlwZSkge1xuICAgICAgdmFyIGZyYWdPclBhcnQgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgaWYgKGZyYWdPclBhcnQgJiYgJ2ZyYWdtZW50JyBpbiBmcmFnT3JQYXJ0KSB7XG4gICAgICAgIHJldHVybiBmcmFnT3JQYXJ0LmZyYWdtZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdPclBhcnQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TmV4dEZyYWdtZW50ID0gZnVuY3Rpb24gZ2V0TmV4dEZyYWdtZW50KHBvcywgbGV2ZWxEZXRhaWxzKSB7XG4gICAgICB2YXIgZnJhZ21lbnRzID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50cztcbiAgICAgIHZhciBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgIGlmICghZnJhZ0xlbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIHZhciBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgIHZhciBmcmFnO1xuICAgICAgaWYgKGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICAgIHZhciBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSA9IGNvbmZpZy5pbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTtcbiAgICAgICAgaWYgKGZyYWdMZW4gPCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSkge1xuICAgICAgICAgIHRoaXMud2FybihcIk5vdCBlbm91Z2ggZnJhZ21lbnRzIHRvIHN0YXJ0IHBsYXliYWNrIChoYXZlOiBcIiArIGZyYWdMZW4gKyBcIiwgbmVlZDogXCIgKyBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSArIFwiKVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcmVhbCBmcmFnbWVudCBzdGFydCB0aW1lcyBmb3IgYSBsaXZlIHN0cmVhbSBhcmUgb25seSBrbm93biBhZnRlciB0aGUgUFRTIHJhbmdlIGZvciB0aGF0IGxldmVsIGlzIGtub3duLlxuICAgICAgICAvLyBJbiBvcmRlciB0byBkaXNjb3ZlciB0aGUgcmFuZ2UsIHdlIGxvYWQgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZm9yIHRoYXQgbGV2ZWwgYW5kIGRlbXV4IGl0LlxuICAgICAgICAvLyBEbyBub3QgbG9hZCB1c2luZyBsaXZlIGxvZ2ljIGlmIHRoZSBzdGFydGluZyBmcmFnIGlzIHJlcXVlc3RlZCAtIHdlIHdhbnQgdG8gdXNlIGdldEZyYWdtZW50QXRQb3NpdGlvbigpIHNvIHRoYXRcbiAgICAgICAgLy8gd2UgZ2V0IHRoZSBmcmFnbWVudCBtYXRjaGluZyB0aGF0IHN0YXJ0IHRpbWVcbiAgICAgICAgaWYgKCFsZXZlbERldGFpbHMuUFRTS25vd24gJiYgIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkICYmIHRoaXMuc3RhcnRQb3NpdGlvbiA9PT0gLTEgfHwgcG9zIDwgc3RhcnQpIHtcbiAgICAgICAgICBmcmFnID0gdGhpcy5nZXRJbml0aWFsTGl2ZUZyYWdtZW50KGxldmVsRGV0YWlscywgZnJhZ21lbnRzKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnID8gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbiB8fCBmcmFnLnN0YXJ0IDogcG9zO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBvcyA8PSBzdGFydCkge1xuICAgICAgICAvLyBWb0QgcGxheWxpc3Q6IGlmIGxvYWRQb3NpdGlvbiBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgICAgZnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBydW4gaW50byBhbnkgc3BlY2lhbCBjYXNlcyBhbHJlYWR5LCBqdXN0IGxvYWQgdGhlIGZyYWdtZW50IG1vc3QgY2xvc2VseSBtYXRjaGluZyB0aGUgcmVxdWVzdGVkIHBvc2l0aW9uXG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgdmFyIGVuZCA9IGNvbmZpZy5sb3dMYXRlbmN5TW9kZSA/IGxldmVsRGV0YWlscy5wYXJ0RW5kIDogbGV2ZWxEZXRhaWxzLmZyYWdtZW50RW5kO1xuICAgICAgICBmcmFnID0gdGhpcy5nZXRGcmFnbWVudEF0UG9zaXRpb24ocG9zLCBlbmQsIGxldmVsRGV0YWlscyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkKGZyYWcpO1xuICAgIH07XG4gICAgX3Byb3RvLmlzTG9vcExvYWRpbmcgPSBmdW5jdGlvbiBpc0xvb3BMb2FkaW5nKGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAgIHZhciB0cmFja2VyU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICAgIHJldHVybiAodHJhY2tlclN0YXRlID09PSBGcmFnbWVudFN0YXRlLk9LIHx8IHRyYWNrZXJTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMICYmICEhZnJhZy5nYXApICYmIHRoaXMubmV4dExvYWRQb3NpdGlvbiA+IHRhcmdldEJ1ZmZlclRpbWU7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TmV4dEZyYWdtZW50TG9vcExvYWRpbmcgPSBmdW5jdGlvbiBnZXROZXh0RnJhZ21lbnRMb29wTG9hZGluZyhmcmFnLCBsZXZlbERldGFpbHMsIGJ1ZmZlckluZm8sIHBsYXlsaXN0VHlwZSwgbWF4QnVmTGVuKSB7XG4gICAgICB2YXIgZ2FwU3RhcnQgPSBmcmFnLmdhcDtcbiAgICAgIHZhciBuZXh0RnJhZ21lbnQgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0aGlzLm5leHRMb2FkUG9zaXRpb24sIGxldmVsRGV0YWlscyk7XG4gICAgICBpZiAobmV4dEZyYWdtZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXh0RnJhZ21lbnQ7XG4gICAgICB9XG4gICAgICBmcmFnID0gbmV4dEZyYWdtZW50O1xuICAgICAgaWYgKGdhcFN0YXJ0ICYmIGZyYWcgJiYgIWZyYWcuZ2FwICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAgIC8vIE1lZGlhIGJ1ZmZlcmVkIGFmdGVyIEdBUCB0YWdzIHNob3VsZCBub3QgbWFrZSB0aGUgbmV4dCBidWZmZXIgdGltZXJhbmdlIGV4Y2VlZCBmb3J3YXJkIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgdmFyIG5leHRidWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvQXRQb3ModGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhLCBidWZmZXJJbmZvLm5leHRTdGFydCwgcGxheWxpc3RUeXBlKTtcbiAgICAgICAgaWYgKG5leHRidWZmZXJJbmZvICE9PSBudWxsICYmIGJ1ZmZlckluZm8ubGVuICsgbmV4dGJ1ZmZlckluZm8ubGVuID49IG1heEJ1Zkxlbikge1xuICAgICAgICAgIC8vIFJldHVybmluZyBoZXJlIG1pZ2h0IHJlc3VsdCBpbiBub3QgZmluZGluZyBhbiBhdWRpbyBhbmQgdmlkZW8gY2FuZGlhdGUgdG8gc2tpcCB0b1xuICAgICAgICAgIHRoaXMubG9nKFwiYnVmZmVyIGZ1bGwgYWZ0ZXIgZ2FwcyBpbiBcXFwiXCIgKyBwbGF5bGlzdFR5cGUgKyBcIlxcXCIgcGxheWxpc3Qgc3RhcnRpbmcgYXQgc246IFwiICsgZnJhZy5zbik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH07XG4gICAgX3Byb3RvLm1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQgPSBmdW5jdGlvbiBtYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkKGZyYWcpIHtcbiAgICAgIC8vIElmIGFuIGluaXRTZWdtZW50IGlzIHByZXNlbnQsIGl0IG11c3QgYmUgYnVmZmVyZWQgZmlyc3RcbiAgICAgIGlmIChmcmFnICE9IG51bGwgJiYgZnJhZy5pbml0U2VnbWVudCAmJiAhKGZyYWcgIT0gbnVsbCAmJiBmcmFnLmluaXRTZWdtZW50LmRhdGEpICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHJldHVybiBmcmFnLmluaXRTZWdtZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TmV4dFBhcnQgPSBmdW5jdGlvbiBnZXROZXh0UGFydChwYXJ0TGlzdCwgZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgICAgdmFyIG5leHRQYXJ0ID0gLTE7XG4gICAgICB2YXIgY29udGlndW91cyA9IGZhbHNlO1xuICAgICAgdmFyIGluZGVwZW5kZW50QXR0ck9taXR0ZWQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydExpc3RbaV07XG4gICAgICAgIGluZGVwZW5kZW50QXR0ck9taXR0ZWQgPSBpbmRlcGVuZGVudEF0dHJPbWl0dGVkICYmICFwYXJ0LmluZGVwZW5kZW50O1xuICAgICAgICBpZiAobmV4dFBhcnQgPiAtMSAmJiB0YXJnZXRCdWZmZXJUaW1lIDwgcGFydC5zdGFydCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2FkZWQgPSBwYXJ0LmxvYWRlZDtcbiAgICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICAgIG5leHRQYXJ0ID0gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnRpZ3VvdXMgfHwgcGFydC5pbmRlcGVuZGVudCB8fCBpbmRlcGVuZGVudEF0dHJPbWl0dGVkKSAmJiBwYXJ0LmZyYWdtZW50ID09PSBmcmFnKSB7XG4gICAgICAgICAgbmV4dFBhcnQgPSBpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpZ3VvdXMgPSBsb2FkZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dFBhcnQ7XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZGVkRW5kT2ZQYXJ0cyA9IGZ1bmN0aW9uIGxvYWRlZEVuZE9mUGFydHMocGFydExpc3QsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAgIHZhciBsYXN0UGFydCA9IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIGxhc3RQYXJ0ICYmIHRhcmdldEJ1ZmZlclRpbWUgPiBsYXN0UGFydC5zdGFydCAmJiBsYXN0UGFydC5sb2FkZWQ7XG4gICAgfVxuXG4gICAgLypcbiAgICAgVGhpcyBtZXRob2QgaXMgdXNlZCBmaW5kIHRoZSBiZXN0IG1hdGNoaW5nIGZpcnN0IGZyYWdtZW50IGZvciBhIGxpdmUgcGxheWxpc3QuIFRoaXMgZnJhZ21lbnQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlXG4gICAgIFwic2xpZGluZ1wiIG9mIHRoZSBwbGF5bGlzdCwgd2hpY2ggaXMgaXRzIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiBwbGF5YmFjay4gQWZ0ZXIgc2xpZGluZyB3ZSBjYW4gY29tcHV0ZSB0aGUgcmVhbFxuICAgICBzdGFydCBhbmQgZW5kIHRpbWVzIGZvciBlYWNoIGZyYWdtZW50IGluIHRoZSBwbGF5bGlzdCAoYWZ0ZXIgd2hpY2ggdGhpcyBtZXRob2Qgd2lsbCBub3QgbmVlZCB0byBiZSBjYWxsZWQpLlxuICAgICovO1xuICAgIF9wcm90by5nZXRJbml0aWFsTGl2ZUZyYWdtZW50ID0gZnVuY3Rpb24gZ2V0SW5pdGlhbExpdmVGcmFnbWVudChsZXZlbERldGFpbHMsIGZyYWdtZW50cykge1xuICAgICAgdmFyIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgICAgdmFyIGZyYWcgPSBudWxsO1xuICAgICAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgICAgICBpZiAobGV2ZWxEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAgIC8vIFByZWZlciB1c2luZyBQRFQsIGJlY2F1c2UgaXQgY2FuIGJlIGFjY3VyYXRlIGVub3VnaCB0byBjaG9vc2UgdGhlIGNvcnJlY3QgZnJhZ21lbnQgd2l0aG91dCBrbm93aW5nIHRoZSBsZXZlbCBzbGlkaW5nXG4gICAgICAgICAgdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgUERUOiBcIiArIGZyYWdQcmV2aW91cy5wcm9ncmFtRGF0ZVRpbWUpO1xuICAgICAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5lbmRQcm9ncmFtRGF0ZVRpbWUsIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZnJhZykge1xuICAgICAgICAgIC8vIFNOIGRvZXMgbm90IG5lZWQgdG8gYmUgYWNjdXJhdGUgYmV0d2VlbiByZW5kaXRpb25zLCBidXQgZGVwZW5kaW5nIG9uIHRoZSBwYWNrYWdpbmcgaXQgbWF5IGJlIHNvLlxuICAgICAgICAgIHZhciB0YXJnZXRTTiA9IGZyYWdQcmV2aW91cy5zbiArIDE7XG4gICAgICAgICAgaWYgKHRhcmdldFNOID49IGxldmVsRGV0YWlscy5zdGFydFNOICYmIHRhcmdldFNOIDw9IGxldmVsRGV0YWlscy5lbmRTTikge1xuICAgICAgICAgICAgdmFyIGZyYWdOZXh0ID0gZnJhZ21lbnRzW3RhcmdldFNOIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2UncmUgc3RheWluZyB3aXRoaW4gdGhlIGNvbnRpbnVpdHkgcmFuZ2UsIHNpbmNlIFBUUyByZXNldHMgdXBvbiBhIG5ldyByYW5nZVxuICAgICAgICAgICAgaWYgKGZyYWdQcmV2aW91cy5jYyA9PT0gZnJhZ05leHQuY2MpIHtcbiAgICAgICAgICAgICAgZnJhZyA9IGZyYWdOZXh0O1xuICAgICAgICAgICAgICB0aGlzLmxvZyhcIkxpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggbmV4dCBTTjogXCIgKyBmcmFnLnNuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gc3RheSB3aXRoaW4gdGhlIGNvbnRpbnVpdHkgcmFuZ2UgaWYgYXZhaWxhYmxlOyBvdGhlcndpc2UgdGhlIGZyYWdtZW50cyBpbiB0aGUgcGxheWxpc3RcbiAgICAgICAgICAvLyB3aWxsIGhhdmUgdGhlIHdyb25nIHN0YXJ0IHRpbWVzXG4gICAgICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgICAgICBmcmFnID0gZmluZEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCBmcmFnUHJldmlvdXMuY2MpO1xuICAgICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgQ0M6IFwiICsgZnJhZy5zbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaW5kIGEgbmV3IHN0YXJ0IGZyYWdtZW50IHdoZW4gZnJhZ1ByZXZpb3VzIGlzIG51bGxcbiAgICAgICAgdmFyIGxpdmVTdGFydCA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIGlmIChsaXZlU3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICBmcmFnID0gdGhpcy5nZXRGcmFnbWVudEF0UG9zaXRpb24obGl2ZVN0YXJ0LCB0aGlzLmJpdHJhdGVUZXN0ID8gbGV2ZWxEZXRhaWxzLmZyYWdtZW50RW5kIDogbGV2ZWxEZXRhaWxzLmVkZ2UsIGxldmVsRGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH1cblxuICAgIC8qXG4gICAgVGhpcyBtZXRob2QgZmluZHMgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZ2l2ZW4gdGhlIHByb3ZpZGVkIHBvc2l0aW9uLlxuICAgICAqLztcbiAgICBfcHJvdG8uZ2V0RnJhZ21lbnRBdFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKGJ1ZmZlckVuZCwgZW5kLCBsZXZlbERldGFpbHMpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIHZhciBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICAgIHZhciBmcmFnbWVudHMgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzLFxuICAgICAgICBlbmRTTiA9IGxldmVsRGV0YWlscy5lbmRTTjtcbiAgICAgIHZhciBmcmFnbWVudEhpbnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRIaW50O1xuICAgICAgdmFyIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgIHZhciBwYXJ0TGlzdCA9IGxldmVsRGV0YWlscy5wYXJ0TGlzdDtcbiAgICAgIHZhciBsb2FkaW5nUGFydHMgPSAhIShjb25maWcubG93TGF0ZW5jeU1vZGUgJiYgcGFydExpc3QgIT0gbnVsbCAmJiBwYXJ0TGlzdC5sZW5ndGggJiYgZnJhZ21lbnRIaW50KTtcbiAgICAgIGlmIChsb2FkaW5nUGFydHMgJiYgZnJhZ21lbnRIaW50ICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIC8vIEluY2x1ZGUgaW5jb21wbGV0ZSBmcmFnbWVudCB3aXRoIHBhcnRzIGF0IGVuZFxuICAgICAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMuY29uY2F0KGZyYWdtZW50SGludCk7XG4gICAgICAgIGVuZFNOID0gZnJhZ21lbnRIaW50LnNuO1xuICAgICAgfVxuICAgICAgdmFyIGZyYWc7XG4gICAgICBpZiAoYnVmZmVyRW5kIDwgZW5kKSB7XG4gICAgICAgIHZhciBsb29rdXBUb2xlcmFuY2UgPSBidWZmZXJFbmQgPiBlbmQgLSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID8gMCA6IG1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgdG9sZXJhbmNlIGlmIGl0IHdvdWxkIHB1dCB0aGUgYnVmZmVyRW5kIHBhc3QgdGhlIGFjdHVhbCBlbmQgb2Ygc3RyZWFtXG4gICAgICAgIC8vIFVzZXMgYnVmZmVyIGFuZCBzZXF1ZW5jZSBudW1iZXIgdG8gY2FsY3VsYXRlIHN3aXRjaCBzZWdtZW50IChyZXF1aXJlZCBpZiB1c2luZyBFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFKVxuICAgICAgICBmcmFnID0gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgbG9va3VwVG9sZXJhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlYWNoIGVuZCBvZiBwbGF5bGlzdFxuICAgICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIHZhciBjdXJTTklkeCA9IGZyYWcuc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTjtcbiAgICAgICAgLy8gTW92ZSBmcmFnUHJldmlvdXMgZm9yd2FyZCB0byBzdXBwb3J0IGZvcmNpbmcgdGhlIG5leHQgZnJhZ21lbnQgdG8gbG9hZFxuICAgICAgICAvLyB3aGVuIHRoZSBidWZmZXIgY2F0Y2hlcyB1cCB0byBhIHByZXZpb3VzbHkgYnVmZmVyZWQgcmFuZ2UuXG4gICAgICAgIHZhciBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICAgICAgaWYgKGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5PSyB8fCBmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCAmJiBmcmFnLmdhcCkge1xuICAgICAgICAgIGZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYWdQcmV2aW91cyAmJiBmcmFnLnNuID09PSBmcmFnUHJldmlvdXMuc24gJiYgKCFsb2FkaW5nUGFydHMgfHwgcGFydExpc3RbMF0uZnJhZ21lbnQuc24gPiBmcmFnLnNuKSkge1xuICAgICAgICAgIC8vIEZvcmNlIHRoZSBuZXh0IGZyYWdtZW50IHRvIGxvYWQgaWYgdGhlIHByZXZpb3VzIG9uZSB3YXMgYWxyZWFkeSBzZWxlY3RlZC4gVGhpcyBjYW4gb2NjYXNpb25hbGx5IGhhcHBlbiB3aXRoXG4gICAgICAgICAgLy8gbm9uLXVuaWZvcm0gZnJhZ21lbnQgZHVyYXRpb25zXG4gICAgICAgICAgdmFyIHNhbWVMZXZlbCA9IGZyYWdQcmV2aW91cyAmJiBmcmFnLmxldmVsID09PSBmcmFnUHJldmlvdXMubGV2ZWw7XG4gICAgICAgICAgaWYgKHNhbWVMZXZlbCkge1xuICAgICAgICAgICAgdmFyIG5leHRGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4ICsgMV07XG4gICAgICAgICAgICBpZiAoZnJhZy5zbiA8IGVuZFNOICYmIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKG5leHRGcmFnKSAhPT0gRnJhZ21lbnRTdGF0ZS5PSykge1xuICAgICAgICAgICAgICBmcmFnID0gbmV4dEZyYWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH07XG4gICAgX3Byb3RvLnN5bmNocm9uaXplVG9MaXZlRWRnZSA9IGZ1bmN0aW9uIHN5bmNocm9uaXplVG9MaXZlRWRnZShsZXZlbERldGFpbHMpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgaWYgKCFtZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGl2ZVN5bmNQb3NpdGlvbiA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb247XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIHZhciBzdGFydCA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICB2YXIgZW5kID0gbGV2ZWxEZXRhaWxzLmVkZ2U7XG4gICAgICB2YXIgd2l0aGluU2xpZGluZ1dpbmRvdyA9IGN1cnJlbnRUaW1lID49IHN0YXJ0IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UgJiYgY3VycmVudFRpbWUgPD0gZW5kO1xuICAgICAgLy8gQ29udGludWUgaWYgd2UgY2FuIHNlZWsgZm9yd2FyZCB0byBzeW5jIHBvc2l0aW9uIG9yIGlmIGN1cnJlbnQgdGltZSBpcyBvdXRzaWRlIG9mIHNsaWRpbmcgd2luZG93XG4gICAgICBpZiAobGl2ZVN5bmNQb3NpdGlvbiAhPT0gbnVsbCAmJiBtZWRpYS5kdXJhdGlvbiA+IGxpdmVTeW5jUG9zaXRpb24gJiYgKGN1cnJlbnRUaW1lIDwgbGl2ZVN5bmNQb3NpdGlvbiB8fCAhd2l0aGluU2xpZGluZ1dpbmRvdykpIHtcbiAgICAgICAgLy8gQ29udGludWUgaWYgYnVmZmVyIGlzIHN0YXJ2aW5nIG9yIGlmIGN1cnJlbnQgdGltZSBpcyBiZWhpbmQgbWF4IGxhdGVuY3lcbiAgICAgICAgdmFyIG1heExhdGVuY3kgPSBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gOiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICogbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgICBpZiAoIXdpdGhpblNsaWRpbmdXaW5kb3cgJiYgbWVkaWEucmVhZHlTdGF0ZSA8IDQgfHwgY3VycmVudFRpbWUgPCBlbmQgLSBtYXhMYXRlbmN5KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBsaXZlU3luY1Bvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPbmx5IHNlZWsgaWYgcmVhZHkgYW5kIHRoZXJlIGlzIG5vdCBhIHNpZ25pZmljYW50IGZvcndhcmQgYnVmZmVyIGF2YWlsYWJsZSBmb3IgcGxheWJhY2tcbiAgICAgICAgICBpZiAobWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy53YXJuKFwiUGxheWJhY2s6IFwiICsgY3VycmVudFRpbWUudG9GaXhlZCgzKSArIFwiIGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0OiBcIiArIGVuZCArIFwiLCByZXNldCBjdXJyZW50VGltZSB0byA6IFwiICsgbGl2ZVN5bmNQb3NpdGlvbi50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5hbGlnblBsYXlsaXN0cyA9IGZ1bmN0aW9uIGFsaWduUGxheWxpc3RzKGRldGFpbHMsIHByZXZpb3VzRGV0YWlscywgc3dpdGNoRGV0YWlscykge1xuICAgICAgLy8gRklYTUU6IElmIG5vdCBmb3IgYHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXNgIHJlcXVpcmluZyBmcmFnUHJldmlvdXMuY2MsXG4gICAgICAvLyAgdGhpcyBjb3VsZCBhbGwgZ28gaW4gbGV2ZWwtaGVscGVyIG1lcmdlRGV0YWlscygpXG4gICAgICB2YXIgbGVuZ3RoID0gZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgdGhpcy53YXJuKFwiTm8gZnJhZ21lbnRzIGluIGxpdmUgcGxheWxpc3RcIik7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgdmFyIHNsaWRpbmdTdGFydCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgdmFyIGZpcnN0TGV2ZWxMb2FkID0gIXByZXZpb3VzRGV0YWlscztcbiAgICAgIHZhciBhbGlnbmVkID0gZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJiBpc0Zpbml0ZU51bWJlcihzbGlkaW5nU3RhcnQpO1xuICAgICAgaWYgKGZpcnN0TGV2ZWxMb2FkIHx8ICFhbGlnbmVkICYmICFzbGlkaW5nU3RhcnQpIHtcbiAgICAgICAgdmFyIGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgICAgICBhbGlnblN0cmVhbShmcmFnUHJldmlvdXMsIHN3aXRjaERldGFpbHMsIGRldGFpbHMpO1xuICAgICAgICB2YXIgYWxpZ25lZFNsaWRpbmdTdGFydCA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgICB0aGlzLmxvZyhcIkxpdmUgcGxheWxpc3Qgc2xpZGluZzogXCIgKyBhbGlnbmVkU2xpZGluZ1N0YXJ0LnRvRml4ZWQoMikgKyBcIiBzdGFydC1zbjogXCIgKyAocHJldmlvdXNEZXRhaWxzID8gcHJldmlvdXNEZXRhaWxzLnN0YXJ0U04gOiAnbmEnKSArIFwiLT5cIiArIGRldGFpbHMuc3RhcnRTTiArIFwiIHByZXYtc246IFwiICsgKGZyYWdQcmV2aW91cyA/IGZyYWdQcmV2aW91cy5zbiA6ICduYScpICsgXCIgZnJhZ21lbnRzOiBcIiArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBhbGlnbmVkU2xpZGluZ1N0YXJ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWRpbmdTdGFydDtcbiAgICB9O1xuICAgIF9wcm90by53YWl0Rm9yQ2RuVHVuZUluID0gZnVuY3Rpb24gd2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSB7XG4gICAgICAvLyBXYWl0IGZvciBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbiB0byBnZXQgYW4gdXBkYXRlZCBwbGF5bGlzdFxuICAgICAgdmFyIGFkdmFuY2VQYXJ0TGltaXQgPSAzO1xuICAgICAgcmV0dXJuIGRldGFpbHMubGl2ZSAmJiBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkICYmIGRldGFpbHMucGFydFRhcmdldCAmJiBkZXRhaWxzLnR1bmVJbkdvYWwgPiBNYXRoLm1heChkZXRhaWxzLnBhcnRIb2xkQmFjaywgZGV0YWlscy5wYXJ0VGFyZ2V0ICogYWR2YW5jZVBhcnRMaW1pdCk7XG4gICAgfTtcbiAgICBfcHJvdG8uc2V0U3RhcnRQb3NpdGlvbiA9IGZ1bmN0aW9uIHNldFN0YXJ0UG9zaXRpb24oZGV0YWlscywgc2xpZGluZykge1xuICAgICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPCBzbGlkaW5nKSB7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydFBvc2l0aW9uID09PSAtMSB8fCB0aGlzLmxhc3RDdXJyZW50VGltZSA9PT0gLTEpIHtcbiAgICAgICAgLy8gVXNlIFBsYXlsaXN0IEVYVC1YLVNUQVJUOlRJTUUtT0ZGU0VUIHdoZW4gc2V0XG4gICAgICAgIC8vIFByaW9yaXRpemUgTXVsdGl2YXJpYW50IFBsYXlsaXN0IG9mZnNldCBzbyB0aGF0IG1haW4sIGF1ZGlvLCBhbmQgc3VidGl0bGUgc3RyZWFtLWNvbnRyb2xsZXIgc3RhcnQgdGltZXMgbWF0Y2hcbiAgICAgICAgdmFyIG9mZnNldEluTXVsdGl2YXJpYW50UGxheWxpc3QgPSB0aGlzLnN0YXJ0VGltZU9mZnNldCAhPT0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXJ0VGltZU9mZnNldCA9IG9mZnNldEluTXVsdGl2YXJpYW50UGxheWxpc3QgPyB0aGlzLnN0YXJ0VGltZU9mZnNldCA6IGRldGFpbHMuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0ICE9PSBudWxsICYmIGlzRmluaXRlTnVtYmVyKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgICBzdGFydFBvc2l0aW9uID0gc2xpZGluZyArIHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgICBpZiAoc3RhcnRUaW1lT2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiArPSBkZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSBNYXRoLm1pbihNYXRoLm1heChzbGlkaW5nLCBzdGFydFBvc2l0aW9uKSwgc2xpZGluZyArIGRldGFpbHMudG90YWxkdXJhdGlvbik7XG4gICAgICAgICAgdGhpcy5sb2coXCJTdGFydCB0aW1lIG9mZnNldCBcIiArIHN0YXJ0VGltZU9mZnNldCArIFwiIGZvdW5kIGluIFwiICsgKG9mZnNldEluTXVsdGl2YXJpYW50UGxheWxpc3QgPyAnbXVsdGl2YXJpYW50JyA6ICdtZWRpYScpICsgXCIgcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvIFwiICsgc3RhcnRQb3NpdGlvbik7XG4gICAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgICAvLyBMZWF2ZSB0aGlzLnN0YXJ0UG9zaXRpb24gYXQgLTEsIHNvIHRoYXQgd2UgY2FuIHVzZSBgZ2V0SW5pdGlhbExpdmVGcmFnbWVudGAgbG9naWMgd2hlbiBzdGFydFBvc2l0aW9uIGhhc1xuICAgICAgICAgIC8vIG5vdCBiZWVuIHNwZWNpZmllZCB2aWEgdGhlIGNvbmZpZyBvciBhbiBhcyBhbiBhcmd1bWVudCB0byBzdGFydExvYWQgKCMzNzM2KS5cbiAgICAgICAgICBzdGFydFBvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbiB8fCBzbGlkaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TG9hZFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0TG9hZFBvc2l0aW9uKCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgaWYgKHRoaXMubG9hZGVkbWV0YWRhdGEgJiYgbWVkaWEpIHtcbiAgICAgICAgcG9zID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dExvYWRQb3NpdGlvbikge1xuICAgICAgICBwb3MgPSB0aGlzLm5leHRMb2FkUG9zaXRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgX3Byb3RvLmhhbmRsZUZyYWdMb2FkQWJvcnRlZCA9IGZ1bmN0aW9uIGhhbmRsZUZyYWdMb2FkQWJvcnRlZChmcmFnLCBwYXJ0KSB7XG4gICAgICBpZiAodGhpcy50cmFuc211eGVyICYmIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcgJiYgZnJhZy5zdGF0cy5hYm9ydGVkKSB7XG4gICAgICAgIHRoaXMud2FybihcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIChwYXJ0ID8gJyBwYXJ0ICcgKyBwYXJ0LmluZGV4IDogJycpICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgd2FzIGFib3J0ZWRcIik7XG4gICAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRGcmFnbWVudExvYWRpbmcgPSBmdW5jdGlvbiByZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKSB7XG4gICAgICBpZiAoIXRoaXMuZnJhZ0N1cnJlbnQgfHwgIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpICYmIHRoaXMuc3RhdGUgIT09IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uRnJhZ21lbnRPcktleUxvYWRFcnJvciA9IGZ1bmN0aW9uIG9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihmaWx0ZXJUeXBlLCBkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5jaHVua01ldGEgJiYgIWRhdGEuZnJhZykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoZGF0YS5jaHVua01ldGEpO1xuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGRhdGEuZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICAvLyBIYW5kbGUgZnJhZyBlcnJvciByZWxhdGVkIHRvIGNhbGxlcidzIGZpbHRlclR5cGVcbiAgICAgIGlmICghZnJhZyB8fCBmcmFnLnR5cGUgIT09IGZpbHRlclR5cGUgfHwgIXRoaXMubGV2ZWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICB2YXIgX3RoaXMkZnJhZ0N1cnJlbnQyO1xuICAgICAgICB0aGlzLndhcm4oXCJGcmFnIGxvYWQgZXJyb3IgbXVzdCBtYXRjaCBjdXJyZW50IGZyYWcgdG8gcmV0cnkgXCIgKyBmcmFnLnVybCArIFwiID4gXCIgKyAoKF90aGlzJGZyYWdDdXJyZW50MiA9IHRoaXMuZnJhZ0N1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRmcmFnQ3VycmVudDIudXJsKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBnYXBUYWdFbmNvdW50ZXJlZCA9IGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQO1xuICAgICAgaWYgKGdhcFRhZ0VuY291bnRlcmVkKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIC8vIGtlZXAgcmV0cnlpbmcgdW50aWwgdGhlIGxpbWl0IHdpbGwgYmUgcmVhY2hlZFxuICAgICAgdmFyIGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbjtcbiAgICAgIHZhciBfcmVmMiA9IGVycm9yQWN0aW9uIHx8IHt9LFxuICAgICAgICBhY3Rpb24gPSBfcmVmMi5hY3Rpb24sXG4gICAgICAgIF9yZWYyJHJldHJ5Q291bnQgPSBfcmVmMi5yZXRyeUNvdW50LFxuICAgICAgICByZXRyeUNvdW50ID0gX3JlZjIkcmV0cnlDb3VudCA9PT0gdm9pZCAwID8gMCA6IF9yZWYyJHJldHJ5Q291bnQsXG4gICAgICAgIHJldHJ5Q29uZmlnID0gX3JlZjIucmV0cnlDb25maWc7XG4gICAgICBpZiAoZXJyb3JBY3Rpb24gJiYgYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0ICYmIHJldHJ5Q29uZmlnKSB7XG4gICAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQodGhpcy5sZXZlbExhc3RMb2FkZWQpO1xuICAgICAgICB2YXIgZGVsYXkgPSBnZXRSZXRyeURlbGF5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50KTtcbiAgICAgICAgdGhpcy53YXJuKFwiRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgXCIgKyBmaWx0ZXJUeXBlICsgXCIgXCIgKyBmcmFnLmxldmVsICsgXCIgZXJyb3JlZCB3aXRoIFwiICsgZGF0YS5kZXRhaWxzICsgXCIsIHJldHJ5aW5nIGxvYWRpbmcgXCIgKyAocmV0cnlDb3VudCArIDEpICsgXCIvXCIgKyByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSArIFwiIGluIFwiICsgZGVsYXkgKyBcIm1zXCIpO1xuICAgICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucmV0cnlEYXRlID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSArIGRlbGF5O1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgICB9IGVsc2UgaWYgKHJldHJ5Q29uZmlnICYmIGVycm9yQWN0aW9uKSB7XG4gICAgICAgIHRoaXMucmVzZXRGcmFnbWVudEVycm9ycyhmaWx0ZXJUeXBlKTtcbiAgICAgICAgaWYgKHJldHJ5Q291bnQgPCByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSkge1xuICAgICAgICAgIC8vIE5ldHdvcmsgcmV0cnkgaXMgc2tpcHBlZCB3aGVuIGxldmVsIHN3aXRjaCBpcyBwcmVmZXJyZWRcbiAgICAgICAgICBpZiAoIWdhcFRhZ0VuY291bnRlcmVkICYmIGFjdGlvbiAhPT0gTmV0d29ya0Vycm9yQWN0aW9uLlJlbW92ZUFsdGVybmF0ZVBlcm1hbmVudGx5KSB7XG4gICAgICAgICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGRhdGEuZGV0YWlscyArIFwiIHJlYWNoZWQgb3IgZXhjZWVkZWQgbWF4IHJldHJ5IChcIiArIHJldHJ5Q291bnQgKyBcIilcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChlcnJvckFjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogZXJyb3JBY3Rpb24uYWN0aW9uKSA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLldBSVRJTkdfTEVWRUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICB9XG4gICAgICAvLyBQZXJmb3JtIG5leHQgYXN5bmMgdGljayBzb29uZXIgdG8gc3BlZWQgdXAgZXJyb3IgYWN0aW9uIHJlc29sdXRpb25cbiAgICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyID0gZnVuY3Rpb24gcmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkge1xuICAgICAgLy8gaWYgaW4gYXBwZW5kaW5nIHN0YXRlXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgICAgIHZhciBwbGF5bGlzdFR5cGUgPSBkYXRhLnBhcmVudDtcbiAgICAgICAgdmFyIGJ1ZmZlcmVkSW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyLCBwbGF5bGlzdFR5cGUpO1xuICAgICAgICAvLyAwLjUgOiB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCBlbmRcbiAgICAgICAgLy8gcmVkdWNlIG1heCBidWYgbGVuIGlmIGN1cnJlbnQgcG9zaXRpb24gaXMgYnVmZmVyZWRcbiAgICAgICAgdmFyIGJ1ZmZlcmVkID0gYnVmZmVyZWRJbmZvICYmIGJ1ZmZlcmVkSW5mby5sZW4gPiAwLjU7XG4gICAgICAgIGlmIChidWZmZXJlZCkge1xuICAgICAgICAgIHRoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGJ1ZmZlcmVkSW5mby5sZW4sIChmcmFnID09IG51bGwgPyB2b2lkIDAgOiBmcmFnLmR1cmF0aW9uKSB8fCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZsdXNoQnVmZmVyID0gIWJ1ZmZlcmVkO1xuICAgICAgICBpZiAoZmx1c2hCdWZmZXIpIHtcbiAgICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGlzIG5vdCBidWZmZXJlZCwgYnV0IGJyb3dzZXIgaXMgc3RpbGwgY29tcGxhaW5pbmcgYWJvdXQgYnVmZmVyIGZ1bGwgZXJyb3JcbiAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC83MDhcbiAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGF1ZGlvIGJ1ZmZlciB0byByZWNvdmVyXG4gICAgICAgICAgdGhpcy53YXJuKFwiQnVmZmVyIGZ1bGwgZXJyb3Igd2hpbGUgbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCBcIiArIHBsYXlsaXN0VHlwZSArIFwiIGJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gZmx1c2hCdWZmZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRGcmFnbWVudEVycm9ycyA9IGZ1bmN0aW9uIHJlc2V0RnJhZ21lbnRFcnJvcnMoZmlsdGVyVHlwZSkge1xuICAgICAgaWYgKGZpbHRlclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKSB7XG4gICAgICAgIC8vIFJlc2V0IGN1cnJlbnQgZnJhZ21lbnQgc2luY2UgYXVkaW8gdHJhY2sgYXVkaW8gaXMgZXNzZW50aWFsIGFuZCBtYXkgbm90IGhhdmUgYSBmYWlsLW92ZXIgdHJhY2tcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBGcmFnbWVudCBlcnJvcnMgdGhhdCByZXN1bHQgaW4gYSBsZXZlbCBzd2l0Y2ggb3IgcmVkdW5kYW50IGZhaWwtb3ZlclxuICAgICAgLy8gc2hvdWxkIHJlc2V0IHRoZSBzdHJlYW0gY29udHJvbGxlciBzdGF0ZSB0byBpZGxlXG4gICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmFmdGVyQnVmZmVyRmx1c2hlZCA9IGZ1bmN0aW9uIGFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYSwgYnVmZmVyVHlwZSwgcGxheWxpc3RUeXBlKSB7XG4gICAgICBpZiAoIW1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEFmdGVyIHN1Y2Nlc3NmdWwgYnVmZmVyIGZsdXNoaW5nLCBmaWx0ZXIgZmx1c2hlZCBmcmFnbWVudHMgZnJvbSBidWZmZXJlZEZyYWdzIHVzZSBtZWRpYUJ1ZmZlcmVkIGluc3RlYWQgb2YgbWVkaWFcbiAgICAgIC8vIChzbyB0aGF0IHdlIHdpbGwgY2hlY2sgYWdhaW5zdCB2aWRlby5idWZmZXJlZCByYW5nZXMgaW4gY2FzZSBvZiBhbHQgYXVkaW8gdHJhY2spXG4gICAgICB2YXIgYnVmZmVyZWRUaW1lUmFuZ2VzID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoYnVmZmVyVHlwZSwgYnVmZmVyZWRUaW1lUmFuZ2VzLCBwbGF5bGlzdFR5cGUpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5yZXNldExvYWRpbmdTdGF0ZSA9IGZ1bmN0aW9uIHJlc2V0TG9hZGluZ1N0YXRlKCkge1xuICAgICAgdGhpcy5sb2coJ1Jlc2V0IGxvYWRpbmcgc3RhdGUnKTtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQgPSBmdW5jdGlvbiByZXNldFN0YXJ0V2hlbk5vdExvYWRlZChsZXZlbCkge1xuICAgICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCBmaXJzdCBmcmFnIHJlcXVlc3QgZmFpbGVkXG4gICAgICAvLyBpbiB0aGF0IGNhc2UsIHJlc2V0IHN0YXJ0RnJhZ1JlcXVlc3RlZCBmbGFnXG4gICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRldGFpbHMgPSBsZXZlbCA/IGxldmVsLmRldGFpbHMgOiBudWxsO1xuICAgICAgICBpZiAoZGV0YWlscyAhPSBudWxsICYmIGRldGFpbHMubGl2ZSkge1xuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhcnQgcG9zaXRpb24gYW5kIHJldHVybiB0byBJRExFIHRvIHJlY292ZXIgbGl2ZSBzdGFydFxuICAgICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IC0xO1xuICAgICAgICAgIHRoaXMuc2V0U3RhcnRQb3NpdGlvbihkZXRhaWxzLCAwKTtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRXaGVuTWlzc2luZ0NvbnRleHQgPSBmdW5jdGlvbiByZXNldFdoZW5NaXNzaW5nQ29udGV4dChjaHVua01ldGEpIHtcbiAgICAgIHRoaXMud2FybihcIlRoZSBsb2FkaW5nIGNvbnRleHQgY2hhbmdlZCB3aGlsZSBidWZmZXJpbmcgZnJhZ21lbnQgXCIgKyBjaHVua01ldGEuc24gKyBcIiBvZiBsZXZlbCBcIiArIGNodW5rTWV0YS5sZXZlbCArIFwiLiBUaGlzIGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLlwiKTtcbiAgICAgIHRoaXMucmVtb3ZlVW5idWZmZXJlZEZyYWdzKCk7XG4gICAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKHRoaXMubGV2ZWxMYXN0TG9hZGVkKTtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MgPSBmdW5jdGlvbiByZW1vdmVVbmJ1ZmZlcmVkRnJhZ3Moc3RhcnQpIHtcbiAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnQsIEluZmluaXR5LCB0aGlzLnBsYXlsaXN0VHlwZSwgZmFsc2UsIHRydWUpO1xuICAgIH07XG4gICAgX3Byb3RvLnVwZGF0ZUxldmVsVGltaW5nID0gZnVuY3Rpb24gdXBkYXRlTGV2ZWxUaW1pbmcoZnJhZywgcGFydCwgbGV2ZWwsIHBhcnRpYWwpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzLFxuICAgICAgICBfdGhpcyR0cmFuc211eGVyO1xuICAgICAgdmFyIGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMud2FybignbGV2ZWwuZGV0YWlscyB1bmRlZmluZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBhcnNlZCA9IE9iamVjdC5rZXlzKGZyYWcuZWxlbWVudGFyeVN0cmVhbXMpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCB0eXBlKSB7XG4gICAgICAgIHZhciBpbmZvID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtc1t0eXBlXTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICB2YXIgcGFyc2VkRHVyYXRpb24gPSBpbmZvLmVuZFBUUyAtIGluZm8uc3RhcnRQVFM7XG4gICAgICAgICAgaWYgKHBhcnNlZER1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAgIC8vIERlc3Ryb3kgdGhlIHRyYW5zbXV4ZXIgYWZ0ZXIgaXQncyBuZXh0IHRpbWUgb2Zmc2V0IGZhaWxlZCB0byBhZHZhbmNlIGJlY2F1c2UgZHVyYXRpb24gd2FzIDw9IDAuXG4gICAgICAgICAgICAvLyBUaGUgbmV3IHRyYW5zbXV4ZXIgd2lsbCBiZSBjb25maWd1cmVkIHdpdGggYSB0aW1lIG9mZnNldCBtYXRjaGluZyB0aGUgbmV4dCBmcmFnbWVudCBzdGFydCxcbiAgICAgICAgICAgIC8vIHByZXZlbnRpbmcgdGhlIHRpbWVsaW5lIGZyb20gc2hpZnRpbmcuXG4gICAgICAgICAgICBfdGhpczYud2FybihcIkNvdWxkIG5vdCBwYXJzZSBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBcIiArIHR5cGUgKyBcIiBkdXJhdGlvbiByZWxpYWJseSAoXCIgKyBwYXJzZWREdXJhdGlvbiArIFwiKVwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkcmlmdCA9IHBhcnRpYWwgPyAwIDogdXBkYXRlRnJhZ1BUU0RUUyhkZXRhaWxzLCBmcmFnLCBpbmZvLnN0YXJ0UFRTLCBpbmZvLmVuZFBUUywgaW5mby5zdGFydERUUywgaW5mby5lbmREVFMpO1xuICAgICAgICAgIF90aGlzNi5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfUFRTX1VQREFURUQsIHtcbiAgICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICBkcmlmdDogZHJpZnQsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHN0YXJ0OiBpbmZvLnN0YXJ0UFRTLFxuICAgICAgICAgICAgZW5kOiBpbmZvLmVuZFBUU1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCBmYWxzZSk7XG4gICAgICBpZiAoIXBhcnNlZCAmJiAoKF90aGlzJHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0cmFuc211eGVyLmVycm9yKSA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJGb3VuZCBubyBtZWRpYSBpbiBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiByZXNldHRpbmcgdHJhbnNtdXhlciB0byBmYWxsYmFjayB0byBwbGF5bGlzdCB0aW1pbmdcIik7XG4gICAgICAgIGlmIChsZXZlbC5mcmFnbWVudEVycm9yID09PSAwKSB7XG4gICAgICAgICAgLy8gTWFyayBhbmQgdHJhY2sgdGhlIG9kZCBlbXB0eSBzZWdtZW50IGFzIGEgZ2FwIHRvIGF2b2lkIHJlbG9hZGluZ1xuICAgICAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IrKztcbiAgICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKGZyYWcsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHJlYXNvbjogXCJGb3VuZCBubyBtZWRpYSBpbiBtc24gXCIgKyBmcmFnLnNuICsgXCIgb2YgbGV2ZWwgXFxcIlwiICsgbGV2ZWwudXJsICsgXCJcXFwiXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgICAgLy8gRm9yIHRoaXMgZXJyb3IgZmFsbHRocm91Z2guIE1hcmtpbmcgcGFyc2VkIHdpbGwgYWxsb3cgYWR2YW5jaW5nIHRvIG5leHQgZnJhZ21lbnQuXG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0VEO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTRUQsIHtcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcGFydDogcGFydFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRUcmFuc211eGVyID0gZnVuY3Rpb24gcmVzZXRUcmFuc211eGVyKCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNtdXhlcikge1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnJlY292ZXJXb3JrZXJFcnJvciA9IGZ1bmN0aW9uIHJlY292ZXJXb3JrZXJFcnJvcihkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5ldmVudCA9PT0gJ2RlbXV4ZXJXb3JrZXInKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKHRoaXMubGV2ZWxMYXN0TG9hZGVkKTtcbiAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX2NyZWF0ZUNsYXNzKEJhc2VTdHJlYW1Db250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcInN0YXRlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5leHRTdGF0ZSkge1xuICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgdGhpcy5sb2cocHJldmlvdXNTdGF0ZSArIFwiLT5cIiArIG5leHRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEJhc2VTdHJlYW1Db250cm9sbGVyO1xuICB9KFRhc2tMb29wKTtcblxuICB2YXIgQ2h1bmtDYWNoZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2h1bmtDYWNoZSgpIHtcbiAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ2h1bmtDYWNoZS5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnB1c2ggPSBmdW5jdGlvbiBwdXNoKGNodW5rKSB7XG4gICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgIHRoaXMuZGF0YUxlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgIHZhciBjaHVua3MgPSB0aGlzLmNodW5rcyxcbiAgICAgICAgZGF0YUxlbmd0aCA9IHRoaXMuZGF0YUxlbmd0aDtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAoIWNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgfSBlbHNlIGlmIChjaHVua3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJlc3VsdCA9IGNodW5rc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbmNhdFVpbnQ4QXJyYXlzKGNodW5rcywgZGF0YUxlbmd0aCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmNodW5rcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5kYXRhTGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIHJldHVybiBDaHVua0NhY2hlO1xuICB9KCk7XG4gIGZ1bmN0aW9uIGNvbmNhdFVpbnQ4QXJyYXlzKGNodW5rcywgZGF0YUxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhTGVuZ3RoKTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNodW5rID0gY2h1bmtzW2ldO1xuICAgICAgcmVzdWx0LnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBkdW1teVRyYWNrKHR5cGUsIGlucHV0VGltZVNjYWxlKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkge1xuICAgICAgdHlwZSA9ICcnO1xuICAgIH1cbiAgICBpZiAoaW5wdXRUaW1lU2NhbGUgPT09IHZvaWQgMCkge1xuICAgICAgaW5wdXRUaW1lU2NhbGUgPSA5MDAwMDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpZDogLTEsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IGlucHV0VGltZVNjYWxlLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IC0xLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBCYXNlQXVkaW9EZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlQXVkaW9EZW11eGVyKCkge1xuICAgICAgdGhpcy5fYXVkaW9UcmFjayA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2lkM1RyYWNrID0gdm9pZCAwO1xuICAgICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLmJhc2VQVFMgPSBudWxsO1xuICAgICAgdGhpcy5pbml0UFRTID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdFBUUyA9IG51bGw7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBCYXNlQXVkaW9EZW11eGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICAgIHRoaXMuX2lkM1RyYWNrID0ge1xuICAgICAgICB0eXBlOiAnaWQzJyxcbiAgICAgICAgaWQ6IDMsXG4gICAgICAgIHBpZDogLTEsXG4gICAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgICBkcm9wcGVkOiAwXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0VGltZVN0YW1wID0gZnVuY3Rpb24gcmVzZXRUaW1lU3RhbXAoZGVhdWx0VGltZXN0YW1wKSB7XG4gICAgICB0aGlzLmluaXRQVFMgPSBkZWF1bHRUaW1lc3RhbXA7XG4gICAgICB0aGlzLnJlc2V0Q29udGlndWl0eSgpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0Q29udGlndWl0eSA9IGZ1bmN0aW9uIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICAgIHRoaXMuYmFzZVBUUyA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RQVFMgPSBudWxsO1xuICAgICAgdGhpcy5mcmFtZUluZGV4ID0gMDtcbiAgICB9O1xuICAgIF9wcm90by5jYW5QYXJzZSA9IGZ1bmN0aW9uIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLmFwcGVuZEZyYW1lID0gZnVuY3Rpb24gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge31cblxuICAgIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgICA7XG4gICAgX3Byb3RvLmRlbXV4ID0gZnVuY3Rpb24gZGVtdXgoZGF0YSwgdGltZU9mZnNldCkge1xuICAgICAgaWYgKHRoaXMuY2FjaGVkRGF0YSkge1xuICAgICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheSh0aGlzLmNhY2hlZERhdGEsIGRhdGEpO1xuICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGlkM0RhdGEgPSBnZXRJRDNEYXRhKGRhdGEsIDApO1xuICAgICAgdmFyIG9mZnNldCA9IGlkM0RhdGEgPyBpZDNEYXRhLmxlbmd0aCA6IDA7XG4gICAgICB2YXIgbGFzdERhdGFJbmRleDtcbiAgICAgIHZhciB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgICB2YXIgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjaztcbiAgICAgIHZhciB0aW1lc3RhbXAgPSBpZDNEYXRhID8gZ2V0VGltZVN0YW1wKGlkM0RhdGEpIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuYmFzZVBUUyA9PT0gbnVsbCB8fCB0aGlzLmZyYW1lSW5kZXggPT09IDAgJiYgaXNGaW5pdGVOdW1iZXIodGltZXN0YW1wKSkge1xuICAgICAgICB0aGlzLmJhc2VQVFMgPSBpbml0UFRTRm4odGltZXN0YW1wLCB0aW1lT2Zmc2V0LCB0aGlzLmluaXRQVFMpO1xuICAgICAgICB0aGlzLmxhc3RQVFMgPSB0aGlzLmJhc2VQVFM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sYXN0UFRTID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMubGFzdFBUUyA9IHRoaXMuYmFzZVBUUztcbiAgICAgIH1cblxuICAgICAgLy8gbW9yZSBleHByZXNzaXZlIHRoYW4gYWx0ZXJuYXRpdmU6IGlkM0RhdGE/Lmxlbmd0aFxuICAgICAgaWYgKGlkM0RhdGEgJiYgaWQzRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgcHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgICAgZHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgICAgZGF0YTogaWQzRGF0YSxcbiAgICAgICAgICB0eXBlOiBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyxcbiAgICAgICAgICBkdXJhdGlvbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5jYW5QYXJzZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVJbmRleCsrO1xuICAgICAgICAgICAgdGhpcy5sYXN0UFRTID0gZnJhbWUuc2FtcGxlLnB0cztcbiAgICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICBsYXN0RGF0YUluZGV4ID0gb2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNhblBhcnNlJDIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgIC8vIGFmdGVyIGEgSUQzLmNhblBhcnNlLCBhIGNhbGwgdG8gSUQzLmdldElEM0RhdGEgKnNob3VsZCogYWx3YXlzIHJldHVybnMgc29tZSBkYXRhXG4gICAgICAgICAgaWQzRGF0YSA9IGdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgcHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgICAgICBkdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgICAgIGRhdGE6IGlkM0RhdGEsXG4gICAgICAgICAgICB0eXBlOiBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvZmZzZXQgKz0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICAgICAgbGFzdERhdGFJbmRleCA9IG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGggJiYgbGFzdERhdGFJbmRleCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhcnRpYWxEYXRhID0gc2xpY2VVaW50OChkYXRhLCBsYXN0RGF0YUluZGV4KTtcbiAgICAgICAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBhcHBlbmRVaW50OEFycmF5KHRoaXMuY2FjaGVkRGF0YSwgcGFydGlhbERhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBwYXJ0aWFsRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1ZGlvVHJhY2s6IHRyYWNrLFxuICAgICAgICB2aWRlb1RyYWNrOiBkdW1teVRyYWNrKCksXG4gICAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrOiBkdW1teVRyYWNrKClcbiAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uZGVtdXhTYW1wbGVBZXMgPSBmdW5jdGlvbiBkZW11eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiW1wiICsgdGhpcyArIFwiXSBUaGlzIGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTYW1wbGUtQUVTIGRlY3J5cHRpb25cIikpO1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2godGltZU9mZnNldCkge1xuICAgICAgLy8gUGFyc2UgY2FjaGUgaW4gY2FzZSBvZiByZW1haW5pbmcgZnJhbWVzLlxuICAgICAgdmFyIGNhY2hlZERhdGEgPSB0aGlzLmNhY2hlZERhdGE7XG4gICAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLmRlbXV4KGNhY2hlZERhdGEsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXVkaW9UcmFjazogdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgICAgdmlkZW9UcmFjazogZHVtbXlUcmFjaygpLFxuICAgICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjazogZHVtbXlUcmFjaygpXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge307XG4gICAgcmV0dXJuIEJhc2VBdWRpb0RlbXV4ZXI7XG4gIH0oKTtcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgUFRTXG4gICAqIDxwPlxuICAgKiAgICB1c2UgdGltZXN0YW1wIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsIE5hTiBvciBJbmZpbml0eVxuICAgKiA8L3A+XG4gICAqL1xuICB2YXIgaW5pdFBUU0ZuID0gZnVuY3Rpb24gaW5pdFBUU0ZuKHRpbWVzdGFtcCwgdGltZU9mZnNldCwgaW5pdFBUUykge1xuICAgIGlmIChpc0Zpbml0ZU51bWJlcih0aW1lc3RhbXApKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wICogOTA7XG4gICAgfVxuICAgIHZhciBpbml0OTBrSHogPSBpbml0UFRTID8gaW5pdFBUUy5iYXNlVGltZSAqIDkwMDAwIC8gaW5pdFBUUy50aW1lc2NhbGUgOiAwO1xuICAgIHJldHVybiB0aW1lT2Zmc2V0ICogOTAwMDAgKyBpbml0OTBrSHo7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFEVFMgcGFyc2VyIGhlbHBlclxuICAgKiBAbGluayBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QXVkaW9Db25maWcob2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xuICAgIHZhciBhZHRzT2JqZWN0VHlwZTtcbiAgICB2YXIgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXg7XG4gICAgdmFyIGFkdHNDaGFubmVsQ29uZmlnO1xuICAgIHZhciBjb25maWc7XG4gICAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbWFuaWZlc3RDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdmFyIGFkdHNTYW1wbGluZ1JhdGVzID0gWzk2MDAwLCA4ODIwMCwgNjQwMDAsIDQ4MDAwLCA0NDEwMCwgMzIwMDAsIDI0MDAwLCAyMjA1MCwgMTYwMDAsIDEyMDAwLCAxMTAyNSwgODAwMCwgNzM1MF07XG4gICAgLy8gYnl0ZSAyXG4gICAgYWR0c09iamVjdFR5cGUgPSAoKGRhdGFbb2Zmc2V0ICsgMl0gJiAweGMwKSA+Pj4gNikgKyAxO1xuICAgIHZhciBhZHRzU2FtcGxpbmdJbmRleCA9IChkYXRhW29mZnNldCArIDJdICYgMHgzYykgPj4+IDI7XG4gICAgaWYgKGFkdHNTYW1wbGluZ0luZGV4ID4gYWR0c1NhbXBsaW5nUmF0ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiaW52YWxpZCBBRFRTIHNhbXBsaW5nIGluZGV4OlwiICsgYWR0c1NhbXBsaW5nSW5kZXgpO1xuICAgICAgb2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhZHRzQ2hhbm5lbENvbmZpZyA9IChkYXRhW29mZnNldCArIDJdICYgMHgwMSkgPDwgMjtcbiAgICAvLyBieXRlIDNcbiAgICBhZHRzQ2hhbm5lbENvbmZpZyB8PSAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4YzApID4+PiA2O1xuICAgIGxvZ2dlci5sb2coXCJtYW5pZmVzdCBjb2RlYzpcIiArIGF1ZGlvQ29kZWMgKyBcIiwgQURUUyB0eXBlOlwiICsgYWR0c09iamVjdFR5cGUgKyBcIiwgc2FtcGxpbmdJbmRleDpcIiArIGFkdHNTYW1wbGluZ0luZGV4KTtcbiAgICAvLyBmaXJlZm94OiBmcmVxIGxlc3MgdGhhbiAyNGtIeiA9IEFBQyBTQlIgKEhFLUFBQylcbiAgICBpZiAoL2ZpcmVmb3gvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgIGlmIChhZHRzU2FtcGxpbmdJbmRleCA+PSA2KSB7XG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDQpO1xuICAgICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleCAtIDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZHRzT2JqZWN0VHlwZSA9IDI7XG4gICAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleDtcbiAgICAgIH1cbiAgICAgIC8vIEFuZHJvaWQgOiBhbHdheXMgdXNlIEFBQ1xuICAgIH0gZWxzZSBpZiAodXNlckFnZW50LmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEpIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpL09wZXJhIC4uLilcbiAgICAgICAgICBhbHdheXMgZm9yY2UgYXVkaW8gdHlwZSB0byBiZSBIRS1BQUMgU0JSLCBhcyBzb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGF1ZGlvIGNvZGVjIHN3aXRjaCBwcm9wZXJseSAobGlrZSBDaHJvbWUgLi4uKVxuICAgICAgKi9cbiAgICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSg0KTtcbiAgICAgIC8vIGlmIChtYW5pZmVzdCBjb2RlYyBpcyBIRS1BQUMgb3IgSEUtQUFDdjIpIE9SIChtYW5pZmVzdCBjb2RlYyBub3Qgc3BlY2lmaWVkIEFORCBmcmVxdWVuY3kgbGVzcyB0aGFuIDI0a0h6KVxuICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSB8fCBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkgfHwgIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsaW5nSW5kZXggPj0gNikge1xuICAgICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBmYWN0b3IgMiBiZXR3ZWVuIGZyYW1lIHNhbXBsZSByYXRlIGFuZCBvdXRwdXQgc2FtcGxlIHJhdGVcbiAgICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleCAtIDM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXG4gICAgICAgIC8vIENocm9tZSBmYWlscyB0byBwbGF5IGJhY2sgd2l0aCBsb3cgZnJlcXVlbmN5IEFBQyBMQyBtb25vIHdoZW4gaW5pdGlhbGl6ZWQgd2l0aCBIRS1BQUMuICBUaGlzIGlzIG5vdCBhIHByb2JsZW0gd2l0aCBzdGVyZW8uXG4gICAgICAgIGlmIChhdWRpb0NvZGVjICYmIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xICYmIChhZHRzU2FtcGxpbmdJbmRleCA+PSA2ICYmIGFkdHNDaGFubmVsQ29uZmlnID09PSAxIHx8IC92aXZhbGRpL2kudGVzdCh1c2VyQWdlbnQpKSB8fCAhYXVkaW9Db2RlYyAmJiBhZHRzQ2hhbm5lbENvbmZpZyA9PT0gMSkge1xuICAgICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgIH1cbiAgICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogcmVmZXIgdG8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI0F1ZGlvX1NwZWNpZmljX0NvbmZpZ1xuICAgICAgICBJU08gMTQ0OTYtMyAoQUFDKS5wZGYgLSBUYWJsZSAxLjEzIOKAlCBTeW50YXggb2YgQXVkaW9TcGVjaWZpY0NvbmZpZygpXG4gICAgICBBdWRpbyBQcm9maWxlIC8gQXVkaW8gT2JqZWN0IFR5cGVcbiAgICAgIDA6IE51bGxcbiAgICAgIDE6IEFBQyBNYWluXG4gICAgICAyOiBBQUMgTEMgKExvdyBDb21wbGV4aXR5KVxuICAgICAgMzogQUFDIFNTUiAoU2NhbGFibGUgU2FtcGxlIFJhdGUpXG4gICAgICA0OiBBQUMgTFRQIChMb25nIFRlcm0gUHJlZGljdGlvbilcbiAgICAgIDU6IFNCUiAoU3BlY3RyYWwgQmFuZCBSZXBsaWNhdGlvbilcbiAgICAgIDY6IEFBQyBTY2FsYWJsZVxuICAgICBzYW1wbGluZyBmcmVxXG4gICAgICAwOiA5NjAwMCBIelxuICAgICAgMTogODgyMDAgSHpcbiAgICAgIDI6IDY0MDAwIEh6XG4gICAgICAzOiA0ODAwMCBIelxuICAgICAgNDogNDQxMDAgSHpcbiAgICAgIDU6IDMyMDAwIEh6XG4gICAgICA2OiAyNDAwMCBIelxuICAgICAgNzogMjIwNTAgSHpcbiAgICAgIDg6IDE2MDAwIEh6XG4gICAgICA5OiAxMjAwMCBIelxuICAgICAgMTA6IDExMDI1IEh6XG4gICAgICAxMTogODAwMCBIelxuICAgICAgMTI6IDczNTAgSHpcbiAgICAgIDEzOiBSZXNlcnZlZFxuICAgICAgMTQ6IFJlc2VydmVkXG4gICAgICAxNTogZnJlcXVlbmN5IGlzIHdyaXR0ZW4gZXhwbGljdGx5XG4gICAgICBDaGFubmVsIENvbmZpZ3VyYXRpb25zXG4gICAgICBUaGVzZSBhcmUgdGhlIGNoYW5uZWwgY29uZmlndXJhdGlvbnM6XG4gICAgICAwOiBEZWZpbmVkIGluIEFPVCBTcGVjaWZjIENvbmZpZ1xuICAgICAgMTogMSBjaGFubmVsOiBmcm9udC1jZW50ZXJcbiAgICAgIDI6IDIgY2hhbm5lbHM6IGZyb250LWxlZnQsIGZyb250LXJpZ2h0XG4gICAgKi9cbiAgICAvLyBhdWRpb09iamVjdFR5cGUgPSBwcm9maWxlID0+IHByb2ZpbGUsIHRoZSBNUEVHLTQgQXVkaW8gT2JqZWN0IFR5cGUgbWludXMgMVxuICAgIGNvbmZpZ1swXSA9IGFkdHNPYmplY3RUeXBlIDw8IDM7XG4gICAgLy8gc2FtcGxpbmdGcmVxdWVuY3lJbmRleFxuICAgIGNvbmZpZ1swXSB8PSAoYWR0c1NhbXBsaW5nSW5kZXggJiAweDBlKSA+PiAxO1xuICAgIGNvbmZpZ1sxXSB8PSAoYWR0c1NhbXBsaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgIC8vIGNoYW5uZWxDb25maWd1cmF0aW9uXG4gICAgY29uZmlnWzFdIHw9IGFkdHNDaGFubmVsQ29uZmlnIDw8IDM7XG4gICAgaWYgKGFkdHNPYmplY3RUeXBlID09PSA1KSB7XG4gICAgICAvLyBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleFxuICAgICAgY29uZmlnWzFdIHw9IChhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCAmIDB4MGUpID4+IDE7XG4gICAgICBjb25maWdbMl0gPSAoYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgICAgLy8gYWR0c09iamVjdFR5cGUgKGZvcmNlIHRvIDIsIGNocm9tZSBpcyBjaGVja2luZyB0aGF0IG9iamVjdCB0eXBlIGlzIGxlc3MgdGhhbiA1ID8/P1xuICAgICAgLy8gICAgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvbWVkaWEvZm9ybWF0cy9tcDQvYWFjLmNjXG4gICAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xuICAgICAgY29uZmlnWzNdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgc2FtcGxlcmF0ZTogYWR0c1NhbXBsaW5nUmF0ZXNbYWR0c1NhbXBsaW5nSW5kZXhdLFxuICAgICAgY2hhbm5lbENvdW50OiBhZHRzQ2hhbm5lbENvbmZpZyxcbiAgICAgIGNvZGVjOiAnbXA0YS40MC4nICsgYWR0c09iamVjdFR5cGUsXG4gICAgICBtYW5pZmVzdENvZGVjOiBtYW5pZmVzdENvZGVjXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4kMShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhmNikgPT09IDB4ZjA7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SGVhZGVyTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhW29mZnNldCArIDFdICYgMHgwMSA/IDcgOiA5O1xuICB9XG4gIGZ1bmN0aW9uIGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSB8IGRhdGFbb2Zmc2V0ICsgNF0gPDwgMyB8IChkYXRhW29mZnNldCArIDVdICYgMHhlMCkgPj4+IDU7XG4gIH1cbiAgZnVuY3Rpb24gY2FuR2V0RnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCArIDUgPCBkYXRhLmxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBpc0hlYWRlciQxKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIExvb2sgZm9yIEFEVFMgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExMSBYMDBYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMVxuICAgIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgMCBmb3IgQURUU1xuICAgIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICAgIHJldHVybiBvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuJDEoZGF0YSwgb2Zmc2V0KTtcbiAgfVxuICBmdW5jdGlvbiBjYW5QYXJzZSQxKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBjYW5HZXRGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpICYmIGlzSGVhZGVyUGF0dGVybiQxKGRhdGEsIG9mZnNldCkgJiYgZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgPD0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG4gIH1cbiAgZnVuY3Rpb24gcHJvYmUkMShkYXRhLCBvZmZzZXQpIHtcbiAgICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgQURUUyBmcmFtZSBmb2xsb3dzIGxhc3QgQURUUyBmcmFtZVxuICAgIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcbiAgICBpZiAoaXNIZWFkZXIkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAvLyBBRFRTIGhlYWRlciBMZW5ndGhcbiAgICAgIHZhciBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgICAgIGlmIChvZmZzZXQgKyBoZWFkZXJMZW5ndGggPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQURUUyBmcmFtZSBMZW5ndGhcbiAgICAgIHZhciBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgICAgaWYgKGZyYW1lTGVuZ3RoIDw9IGhlYWRlckxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgICByZXR1cm4gbmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCBpc0hlYWRlciQxKGRhdGEsIG5ld09mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBpbml0VHJhY2tDb25maWcodHJhY2ssIG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpIHtcbiAgICBpZiAoIXRyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICAgIHZhciBjb25maWcgPSBnZXRBdWRpb0NvbmZpZyhvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKTtcbiAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgICB0cmFjay5zYW1wbGVyYXRlID0gY29uZmlnLnNhbXBsZXJhdGU7XG4gICAgICB0cmFjay5jaGFubmVsQ291bnQgPSBjb25maWcuY2hhbm5lbENvdW50O1xuICAgICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgICB0cmFjay5tYW5pZmVzdENvZGVjID0gY29uZmlnLm1hbmlmZXN0Q29kZWM7XG4gICAgICBsb2dnZXIubG9nKFwicGFyc2VkIGNvZGVjOlwiICsgdHJhY2suY29kZWMgKyBcIiwgcmF0ZTpcIiArIGNvbmZpZy5zYW1wbGVyYXRlICsgXCIsIGNoYW5uZWxzOlwiICsgY29uZmlnLmNoYW5uZWxDb3VudCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldEZyYW1lRHVyYXRpb24oc2FtcGxlcmF0ZSkge1xuICAgIHJldHVybiAxMDI0ICogOTAwMDAgLyBzYW1wbGVyYXRlO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlRnJhbWVIZWFkZXIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIEFEVFMgaGVhZGVyXG4gICAgdmFyIGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgKyBoZWFkZXJMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIHJldHJpZXZlIGZyYW1lIHNpemVcbiAgICAgIHZhciBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIC0gaGVhZGVyTGVuZ3RoO1xuICAgICAgaWYgKGZyYW1lTGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBsb2dnZXIubG9nKGBBQUMgZnJhbWUsIG9mZnNldC9sZW5ndGgvdG90YWwvcHRzOiR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtmcmFtZUxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9YCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGVhZGVyTGVuZ3RoOiBoZWFkZXJMZW5ndGgsXG4gICAgICAgICAgZnJhbWVMZW5ndGg6IGZyYW1lTGVuZ3RoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFwcGVuZEZyYW1lJDEodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KSB7XG4gICAgdmFyIGZyYW1lRHVyYXRpb24gPSBnZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuICAgIHZhciBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICAgIHZhciBoZWFkZXIgPSBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gICAgdmFyIHVuaXQ7XG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgdmFyIGZyYW1lTGVuZ3RoID0gaGVhZGVyLmZyYW1lTGVuZ3RoLFxuICAgICAgICBoZWFkZXJMZW5ndGggPSBoZWFkZXIuaGVhZGVyTGVuZ3RoO1xuICAgICAgdmFyIF9sZW5ndGggPSBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aDtcbiAgICAgIHZhciBtaXNzaW5nID0gTWF0aC5tYXgoMCwgb2Zmc2V0ICsgX2xlbmd0aCAtIGRhdGEubGVuZ3RoKTtcbiAgICAgIC8vIGxvZ2dlci5sb2coYEFBQyBmcmFtZSAke2ZyYW1lSW5kZXh9LCBwdHM6JHtzdGFtcH0gbGVuZ3RoQG9mZnNldC90b3RhbDogJHtmcmFtZUxlbmd0aH1AJHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH0gbWlzc2luZzogJHttaXNzaW5nfWApO1xuICAgICAgaWYgKG1pc3NpbmcpIHtcbiAgICAgICAgdW5pdCA9IG5ldyBVaW50OEFycmF5KF9sZW5ndGggLSBoZWFkZXJMZW5ndGgpO1xuICAgICAgICB1bml0LnNldChkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgZGF0YS5sZW5ndGgpLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXQgPSBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgX2xlbmd0aCk7XG4gICAgICB9XG4gICAgICB2YXIgX3NhbXBsZSA9IHtcbiAgICAgICAgdW5pdDogdW5pdCxcbiAgICAgICAgcHRzOiBzdGFtcFxuICAgICAgfTtcbiAgICAgIGlmICghbWlzc2luZykge1xuICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goX3NhbXBsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzYW1wbGU6IF9zYW1wbGUsXG4gICAgICAgIGxlbmd0aDogX2xlbmd0aCxcbiAgICAgICAgbWlzc2luZzogbWlzc2luZ1xuICAgICAgfTtcbiAgICB9XG4gICAgLy8gb3ZlcmZsb3cgaW5jb21wbGV0ZSBoZWFkZXJcbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG4gICAgdW5pdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgdW5pdC5zZXQoZGF0YS5zdWJhcnJheShvZmZzZXQsIGRhdGEubGVuZ3RoKSwgMCk7XG4gICAgdmFyIHNhbXBsZSA9IHtcbiAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICBwdHM6IHN0YW1wXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlOiBzYW1wbGUsXG4gICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgIG1pc3Npbmc6IC0xXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgTVBFRyBwYXJzZXIgaGVscGVyXG4gICAqL1xuXG4gIHZhciBjaHJvbWVWZXJzaW9uJDEgPSBudWxsO1xuICB2YXIgQml0cmF0ZXNNYXAgPSBbMzIsIDY0LCA5NiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDI4OCwgMzIwLCAzNTIsIDM4NCwgNDE2LCA0NDgsIDMyLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzg0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE2MCwgMTkyLCAyMjQsIDI1NiwgMzIwLCAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTQ0LCAxNjAsIDE3NiwgMTkyLCAyMjQsIDI1NiwgOCwgMTYsIDI0LCAzMiwgNDAsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwXTtcbiAgdmFyIFNhbXBsaW5nUmF0ZU1hcCA9IFs0NDEwMCwgNDgwMDAsIDMyMDAwLCAyMjA1MCwgMjQwMDAsIDE2MDAwLCAxMTAyNSwgMTIwMDAsIDgwMDBdO1xuICB2YXIgU2FtcGxlc0NvZWZmaWNpZW50cyA9IFtcbiAgLy8gTVBFRyAyLjVcbiAgWzAsXG4gIC8vIFJlc2VydmVkXG4gIDcyLFxuICAvLyBMYXllcjNcbiAgMTQ0LFxuICAvLyBMYXllcjJcbiAgMTIgLy8gTGF5ZXIxXG4gIF0sXG4gIC8vIFJlc2VydmVkXG4gIFswLFxuICAvLyBSZXNlcnZlZFxuICAwLFxuICAvLyBMYXllcjNcbiAgMCxcbiAgLy8gTGF5ZXIyXG4gIDAgLy8gTGF5ZXIxXG4gIF0sXG4gIC8vIE1QRUcgMlxuICBbMCxcbiAgLy8gUmVzZXJ2ZWRcbiAgNzIsXG4gIC8vIExheWVyM1xuICAxNDQsXG4gIC8vIExheWVyMlxuICAxMiAvLyBMYXllcjFcbiAgXSxcbiAgLy8gTVBFRyAxXG4gIFswLFxuICAvLyBSZXNlcnZlZFxuICAxNDQsXG4gIC8vIExheWVyM1xuICAxNDQsXG4gIC8vIExheWVyMlxuICAxMiAvLyBMYXllcjFcbiAgXV07XG4gIHZhciBCeXRlc0luU2xvdCA9IFswLFxuICAvLyBSZXNlcnZlZFxuICAxLFxuICAvLyBMYXllcjNcbiAgMSxcbiAgLy8gTGF5ZXIyXG4gIDQgLy8gTGF5ZXIxXG4gIF07XG4gIGZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCkge1xuICAgIC8vIFVzaW5nIGh0dHA6Ly93d3cuZGF0YXZveWFnZS5jb20vbXBnc2NyaXB0L21wZWdoZHIuaHRtIGFzIGEgcmVmZXJlbmNlXG4gICAgaWYgKG9mZnNldCArIDI0ID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGhlYWRlciA9IHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gICAgaWYgKGhlYWRlciAmJiBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGggPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIHZhciBmcmFtZUR1cmF0aW9uID0gaGVhZGVyLnNhbXBsZXNQZXJGcmFtZSAqIDkwMDAwIC8gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgICB2YXIgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICAgIHZhciBzYW1wbGUgPSB7XG4gICAgICAgIHVuaXQ6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBoZWFkZXIuZnJhbWVMZW5ndGgpLFxuICAgICAgICBwdHM6IHN0YW1wLFxuICAgICAgICBkdHM6IHN0YW1wXG4gICAgICB9O1xuICAgICAgdHJhY2suY29uZmlnID0gW107XG4gICAgICB0cmFjay5jaGFubmVsQ291bnQgPSBoZWFkZXIuY2hhbm5lbENvdW50O1xuICAgICAgdHJhY2suc2FtcGxlcmF0ZSA9IGhlYWRlci5zYW1wbGVSYXRlO1xuICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKHNhbXBsZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzYW1wbGU6IHNhbXBsZSxcbiAgICAgICAgbGVuZ3RoOiBoZWFkZXIuZnJhbWVMZW5ndGgsXG4gICAgICAgIG1pc3Npbmc6IDBcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAgIHZhciBtcGVnVmVyc2lvbiA9IGRhdGFbb2Zmc2V0ICsgMV0gPj4gMyAmIDM7XG4gICAgdmFyIG1wZWdMYXllciA9IGRhdGFbb2Zmc2V0ICsgMV0gPj4gMSAmIDM7XG4gICAgdmFyIGJpdFJhdGVJbmRleCA9IGRhdGFbb2Zmc2V0ICsgMl0gPj4gNCAmIDE1O1xuICAgIHZhciBzYW1wbGVSYXRlSW5kZXggPSBkYXRhW29mZnNldCArIDJdID4+IDIgJiAzO1xuICAgIGlmIChtcGVnVmVyc2lvbiAhPT0gMSAmJiBiaXRSYXRlSW5kZXggIT09IDAgJiYgYml0UmF0ZUluZGV4ICE9PSAxNSAmJiBzYW1wbGVSYXRlSW5kZXggIT09IDMpIHtcbiAgICAgIHZhciBwYWRkaW5nQml0ID0gZGF0YVtvZmZzZXQgKyAyXSA+PiAxICYgMTtcbiAgICAgIHZhciBjaGFubmVsTW9kZSA9IGRhdGFbb2Zmc2V0ICsgM10gPj4gNjtcbiAgICAgIHZhciBjb2x1bW5JbkJpdHJhdGVzID0gbXBlZ1ZlcnNpb24gPT09IDMgPyAzIC0gbXBlZ0xheWVyIDogbXBlZ0xheWVyID09PSAzID8gMyA6IDQ7XG4gICAgICB2YXIgYml0UmF0ZSA9IEJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGJpdFJhdGVJbmRleCAtIDFdICogMTAwMDtcbiAgICAgIHZhciBjb2x1bW5JblNhbXBsZVJhdGVzID0gbXBlZ1ZlcnNpb24gPT09IDMgPyAwIDogbXBlZ1ZlcnNpb24gPT09IDIgPyAxIDogMjtcbiAgICAgIHZhciBzYW1wbGVSYXRlID0gU2FtcGxpbmdSYXRlTWFwW2NvbHVtbkluU2FtcGxlUmF0ZXMgKiAzICsgc2FtcGxlUmF0ZUluZGV4XTtcbiAgICAgIHZhciBjaGFubmVsQ291bnQgPSBjaGFubmVsTW9kZSA9PT0gMyA/IDEgOiAyOyAvLyBJZiBiaXRzIG9mIGNoYW5uZWwgbW9kZSBhcmUgYDExYCB0aGVuIGl0IGlzIGEgc2luZ2xlIGNoYW5uZWwgKE1vbm8pXG4gICAgICB2YXIgc2FtcGxlQ29lZmZpY2llbnQgPSBTYW1wbGVzQ29lZmZpY2llbnRzW21wZWdWZXJzaW9uXVttcGVnTGF5ZXJdO1xuICAgICAgdmFyIGJ5dGVzSW5TbG90ID0gQnl0ZXNJblNsb3RbbXBlZ0xheWVyXTtcbiAgICAgIHZhciBzYW1wbGVzUGVyRnJhbWUgPSBzYW1wbGVDb2VmZmljaWVudCAqIDggKiBieXRlc0luU2xvdDtcbiAgICAgIHZhciBmcmFtZUxlbmd0aCA9IE1hdGguZmxvb3Ioc2FtcGxlQ29lZmZpY2llbnQgKiBiaXRSYXRlIC8gc2FtcGxlUmF0ZSArIHBhZGRpbmdCaXQpICogYnl0ZXNJblNsb3Q7XG4gICAgICBpZiAoY2hyb21lVmVyc2lvbiQxID09PSBudWxsKSB7XG4gICAgICAgIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvaSk7XG4gICAgICAgIGNocm9tZVZlcnNpb24kMSA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgICAgfVxuICAgICAgdmFyIG5lZWRDaHJvbWVGaXggPSAhIWNocm9tZVZlcnNpb24kMSAmJiBjaHJvbWVWZXJzaW9uJDEgPD0gODc7XG4gICAgICBpZiAobmVlZENocm9tZUZpeCAmJiBtcGVnTGF5ZXIgPT09IDIgJiYgYml0UmF0ZSA+PSAyMjQwMDAgJiYgY2hhbm5lbE1vZGUgPT09IDApIHtcbiAgICAgICAgLy8gV29yayBhcm91bmQgYnVnIGluIENocm9taXVtIGJ5IHNldHRpbmcgY2hhbm5lbE1vZGUgdG8gZHVhbC1jaGFubmVsICgwMSkgaW5zdGVhZCBvZiBzdGVyZW8gKDAwKVxuICAgICAgICBkYXRhW29mZnNldCArIDNdID0gZGF0YVtvZmZzZXQgKyAzXSB8IDB4ODA7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzYW1wbGVSYXRlOiBzYW1wbGVSYXRlLFxuICAgICAgICBjaGFubmVsQ291bnQ6IGNoYW5uZWxDb3VudCxcbiAgICAgICAgZnJhbWVMZW5ndGg6IGZyYW1lTGVuZ3RoLFxuICAgICAgICBzYW1wbGVzUGVyRnJhbWU6IHNhbXBsZXNQZXJGcmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGUwKSA9PT0gMHhlMCAmJiAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MDYpICE9PSAweDAwO1xuICB9XG4gIGZ1bmN0aW9uIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcbiAgICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICAgIHJldHVybiBvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgdmFyIGhlYWRlclNpemUgPSA0O1xuICAgIHJldHVybiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSAmJiBoZWFkZXJTaXplIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xuICB9XG4gIGZ1bmN0aW9uIHByb2JlKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBNUEVHIGZyYW1lIGZvbGxvd3MgbGFzdCBNUEVHIGZyYW1lXG4gICAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICAgIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgIC8vIE1QRUcgaGVhZGVyIExlbmd0aFxuICAgICAgdmFyIGhlYWRlckxlbmd0aCA9IDQ7XG4gICAgICAvLyBNUEVHIGZyYW1lIExlbmd0aFxuICAgICAgdmFyIGhlYWRlciA9IHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gICAgICB2YXIgZnJhbWVMZW5ndGggPSBoZWFkZXJMZW5ndGg7XG4gICAgICBpZiAoaGVhZGVyICE9IG51bGwgJiYgaGVhZGVyLmZyYW1lTGVuZ3RoKSB7XG4gICAgICAgIGZyYW1lTGVuZ3RoID0gaGVhZGVyLmZyYW1lTGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xuICAgICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIoZGF0YSwgbmV3T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIEFBQ0RlbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQXVkaW9EZW11eGVyKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoQUFDRGVtdXhlciwgX0Jhc2VBdWRpb0RlbXV4ZXIpO1xuICAgIGZ1bmN0aW9uIEFBQ0RlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZykge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfQmFzZUF1ZGlvRGVtdXhlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICAgIF90aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICAgIF90aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICBfdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBBQUNEZW11eGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICAgIF9CYXNlQXVkaW9EZW11eGVyLnByb3RvdHlwZS5yZXNldEluaXRTZWdtZW50LmNhbGwodGhpcywgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgICAgY29udGFpbmVyOiAnYXVkaW8vYWR0cycsXG4gICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgIGlkOiAyLFxuICAgICAgICBwaWQ6IC0xLFxuICAgICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgICAgc2VnbWVudENvZGVjOiAnYWFjJyxcbiAgICAgICAgc2FtcGxlczogW10sXG4gICAgICAgIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICAgIGRyb3BwZWQ6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gU291cmNlIGZvciBwcm9iZSBpbmZvIC0gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgICA7XG4gICAgQUFDRGVtdXhlci5wcm9iZSA9IGZ1bmN0aW9uIHByb2JlJDIoZGF0YSkge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBBRFRTIHN5bmMgd29yZFxuICAgICAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gICAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIDAgZm9yIEFEVFNcbiAgICAgIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICAgICAgdmFyIGlkM0RhdGEgPSBnZXRJRDNEYXRhKGRhdGEsIDApO1xuICAgICAgdmFyIG9mZnNldCA9IChpZDNEYXRhID09IG51bGwgPyB2b2lkIDAgOiBpZDNEYXRhLmxlbmd0aCkgfHwgMDtcbiAgICAgIGlmIChwcm9iZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICAgIGlmIChwcm9iZSQxKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdBRFRTIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5jYW5QYXJzZSA9IGZ1bmN0aW9uIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGNhblBhcnNlJDEoZGF0YSwgb2Zmc2V0KTtcbiAgICB9O1xuICAgIF9wcm90by5hcHBlbmRGcmFtZSA9IGZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICAgIGluaXRUcmFja0NvbmZpZyh0cmFjaywgdGhpcy5vYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCB0cmFjay5tYW5pZmVzdENvZGVjKTtcbiAgICAgIHZhciBmcmFtZSA9IGFwcGVuZEZyYW1lJDEodHJhY2ssIGRhdGEsIG9mZnNldCwgdGhpcy5iYXNlUFRTLCB0aGlzLmZyYW1lSW5kZXgpO1xuICAgICAgaWYgKGZyYW1lICYmIGZyYW1lLm1pc3NpbmcgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFBQ0RlbXV4ZXI7XG4gIH0oQmFzZUF1ZGlvRGVtdXhlcik7XG5cbiAgdmFyIGVtc2dTY2hlbWVQYXR0ZXJuID0gL1xcL2Vtc2dbLS9dSUQzL2k7XG4gIHZhciBNUDREZW11eGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNUDREZW11eGVyKG9ic2VydmVyLCBjb25maWcpIHtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLnRpbWVPZmZzZXQgPSAwO1xuICAgICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgICB0aGlzLnZpZGVvVHJhY2sgPSB2b2lkIDA7XG4gICAgICB0aGlzLmF1ZGlvVHJhY2sgPSB2b2lkIDA7XG4gICAgICB0aGlzLmlkM1RyYWNrID0gdm9pZCAwO1xuICAgICAgdGhpcy50eHRUcmFjayA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTVA0RGVtdXhlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnJlc2V0VGltZVN0YW1wID0gZnVuY3Rpb24gcmVzZXRUaW1lU3RhbXAoKSB7fTtcbiAgICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICAgIHZhciB2aWRlb1RyYWNrID0gdGhpcy52aWRlb1RyYWNrID0gZHVtbXlUcmFjaygndmlkZW8nLCAxKTtcbiAgICAgIHZhciBhdWRpb1RyYWNrID0gdGhpcy5hdWRpb1RyYWNrID0gZHVtbXlUcmFjaygnYXVkaW8nLCAxKTtcbiAgICAgIHZhciBjYXB0aW9uVHJhY2sgPSB0aGlzLnR4dFRyYWNrID0gZHVtbXlUcmFjaygndGV4dCcsIDEpO1xuICAgICAgdGhpcy5pZDNUcmFjayA9IGR1bW15VHJhY2soJ2lkMycsIDEpO1xuICAgICAgdGhpcy50aW1lT2Zmc2V0ID0gMDtcbiAgICAgIGlmICghKGluaXRTZWdtZW50ICE9IG51bGwgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGluaXREYXRhID0gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCk7XG4gICAgICBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgICAgdmFyIF9pbml0RGF0YSR2aWRlbyA9IGluaXREYXRhLnZpZGVvLFxuICAgICAgICAgIGlkID0gX2luaXREYXRhJHZpZGVvLmlkLFxuICAgICAgICAgIHRpbWVzY2FsZSA9IF9pbml0RGF0YSR2aWRlby50aW1lc2NhbGUsXG4gICAgICAgICAgY29kZWMgPSBfaW5pdERhdGEkdmlkZW8uY29kZWM7XG4gICAgICAgIHZpZGVvVHJhY2suaWQgPSBpZDtcbiAgICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSBjYXB0aW9uVHJhY2sudGltZXNjYWxlID0gdGltZXNjYWxlO1xuICAgICAgICB2aWRlb1RyYWNrLmNvZGVjID0gY29kZWM7XG4gICAgICB9XG4gICAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgICAgdmFyIF9pbml0RGF0YSRhdWRpbyA9IGluaXREYXRhLmF1ZGlvLFxuICAgICAgICAgIF9pZCA9IF9pbml0RGF0YSRhdWRpby5pZCxcbiAgICAgICAgICBfdGltZXNjYWxlID0gX2luaXREYXRhJGF1ZGlvLnRpbWVzY2FsZSxcbiAgICAgICAgICBfY29kZWMgPSBfaW5pdERhdGEkYXVkaW8uY29kZWM7XG4gICAgICAgIGF1ZGlvVHJhY2suaWQgPSBfaWQ7XG4gICAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gX3RpbWVzY2FsZTtcbiAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9IF9jb2RlYztcbiAgICAgIH1cbiAgICAgIGNhcHRpb25UcmFjay5pZCA9IFJlbXV4ZXJUcmFja0lkQ29uZmlnLnRleHQ7XG4gICAgICB2aWRlb1RyYWNrLnNhbXBsZUR1cmF0aW9uID0gMDtcbiAgICAgIHZpZGVvVHJhY2suZHVyYXRpb24gPSBhdWRpb1RyYWNrLmR1cmF0aW9uID0gdHJhY2tEdXJhdGlvbjtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldENvbnRpZ3VpdHkgPSBmdW5jdGlvbiByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIH07XG4gICAgTVA0RGVtdXhlci5wcm9iZSA9IGZ1bmN0aW9uIHByb2JlKGRhdGEpIHtcbiAgICAgIHJldHVybiBoYXNNb29mRGF0YShkYXRhKTtcbiAgICB9O1xuICAgIF9wcm90by5kZW11eCA9IGZ1bmN0aW9uIGRlbXV4KGRhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICAgIHRoaXMudGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gICAgICAvLyBMb2FkIGFsbCBkYXRhIGludG8gdGhlIGF2YyB0cmFjay4gVGhlIENNQUYgcmVtdXhlciB3aWxsIGxvb2sgZm9yIHRoZSBkYXRhIGluIHRoZSBzYW1wbGVzIG9iamVjdDsgdGhlIHJlc3Qgb2YgdGhlIGZpZWxkcyBkbyBub3QgbWF0dGVyXG4gICAgICB2YXIgdmlkZW9TYW1wbGVzID0gZGF0YTtcbiAgICAgIHZhciB2aWRlb1RyYWNrID0gdGhpcy52aWRlb1RyYWNrO1xuICAgICAgdmFyIHRleHRUcmFjayA9IHRoaXMudHh0VHJhY2s7XG4gICAgICBpZiAodGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpIHtcbiAgICAgICAgLy8gU3BsaXQgdGhlIGJ5dGVzdHJlYW0gaW50byB0d28gcmFuZ2VzOiBvbmUgZW5jb21wYXNzaW5nIGFsbCBkYXRhIHVwIHVudGlsIHRoZSBzdGFydCBvZiB0aGUgbGFzdCBtb29mLCBhbmQgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICAvLyBUaGlzIGlzIGRvbmUgdG8gZ3VhcmFudGVlIHRoYXQgd2UncmUgc2VuZGluZyB2YWxpZCBkYXRhIHRvIE1TRSAtIHdoZW4gZGVtdXhpbmcgcHJvZ3Jlc3NpdmVseSwgd2UgaGF2ZSBubyBndWFyYW50ZWVcbiAgICAgICAgLy8gdGhhdCB0aGUgZmV0Y2ggbG9hZGVyIGdpdmVzIHVzIGZsdXNoIG1vb2YrbWRhdCBwYWlycy4gSWYgd2UgcHVzaCBqYWdnZWQgZGF0YSB0byBNU0UsIGl0IHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICAgICAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhKSB7XG4gICAgICAgICAgdmlkZW9TYW1wbGVzID0gYXBwZW5kVWludDhBcnJheSh0aGlzLnJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWdtZW50ZWREYXRhID0gc2VnbWVudFZhbGlkUmFuZ2UodmlkZW9TYW1wbGVzKTtcbiAgICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gc2VnbWVudGVkRGF0YS5yZW1haW5kZXI7XG4gICAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHNlZ21lbnRlZERhdGEudmFsaWQgfHwgbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHZpZGVvU2FtcGxlcztcbiAgICAgIH1cbiAgICAgIHZhciBpZDNUcmFjayA9IHRoaXMuZXh0cmFjdElEM1RyYWNrKHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgICAgdGV4dFRyYWNrLnNhbXBsZXMgPSBwYXJzZVNhbXBsZXModGltZU9mZnNldCwgdmlkZW9UcmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2aWRlb1RyYWNrOiB2aWRlb1RyYWNrLFxuICAgICAgICBhdWRpb1RyYWNrOiB0aGlzLmF1ZGlvVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrOiB0aGlzLnR4dFRyYWNrXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICB2YXIgdGltZU9mZnNldCA9IHRoaXMudGltZU9mZnNldDtcbiAgICAgIHZhciB2aWRlb1RyYWNrID0gdGhpcy52aWRlb1RyYWNrO1xuICAgICAgdmFyIHRleHRUcmFjayA9IHRoaXMudHh0VHJhY2s7XG4gICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSB0aGlzLnJlbWFpbmRlckRhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgICB2YXIgaWQzVHJhY2sgPSB0aGlzLmV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aGlzLnRpbWVPZmZzZXQpO1xuICAgICAgdGV4dFRyYWNrLnNhbXBsZXMgPSBwYXJzZVNhbXBsZXModGltZU9mZnNldCwgdmlkZW9UcmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2aWRlb1RyYWNrOiB2aWRlb1RyYWNrLFxuICAgICAgICBhdWRpb1RyYWNrOiBkdW1teVRyYWNrKCksXG4gICAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrOiBkdW1teVRyYWNrKClcbiAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uZXh0cmFjdElEM1RyYWNrID0gZnVuY3Rpb24gZXh0cmFjdElEM1RyYWNrKHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpIHtcbiAgICAgIHZhciBpZDNUcmFjayA9IHRoaXMuaWQzVHJhY2s7XG4gICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgZW1zZ3MgPSBmaW5kQm94KHZpZGVvVHJhY2suc2FtcGxlcywgWydlbXNnJ10pO1xuICAgICAgICBpZiAoZW1zZ3MpIHtcbiAgICAgICAgICBlbXNncy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgZW1zZ0luZm8gPSBwYXJzZUVtc2coZGF0YSk7XG4gICAgICAgICAgICBpZiAoZW1zZ1NjaGVtZVBhdHRlcm4udGVzdChlbXNnSW5mby5zY2hlbWVJZFVyaSkpIHtcbiAgICAgICAgICAgICAgdmFyIHB0cyA9IGlzRmluaXRlTnVtYmVyKGVtc2dJbmZvLnByZXNlbnRhdGlvblRpbWUpID8gZW1zZ0luZm8ucHJlc2VudGF0aW9uVGltZSAvIGVtc2dJbmZvLnRpbWVTY2FsZSA6IHRpbWVPZmZzZXQgKyBlbXNnSW5mby5wcmVzZW50YXRpb25UaW1lRGVsdGEgLyBlbXNnSW5mby50aW1lU2NhbGU7XG4gICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGVtc2dJbmZvLmV2ZW50RHVyYXRpb24gPT09IDB4ZmZmZmZmZmYgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgOiBlbXNnSW5mby5ldmVudER1cmF0aW9uIC8gZW1zZ0luZm8udGltZVNjYWxlO1xuICAgICAgICAgICAgICAvLyBTYWZhcmkgdGFrZXMgYW55dGhpbmcgPD0gMC4wMDEgc2Vjb25kcyBhbmQgbWFwcyBpdCB0byBJbmZpbml0eVxuICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPD0gMC4wMDEpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGVtc2dJbmZvLnBheWxvYWQ7XG4gICAgICAgICAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0YTogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICBsZW46IHBheWxvYWQuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICBkdHM6IHB0cyxcbiAgICAgICAgICAgICAgICBwdHM6IHB0cyxcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXRhZGF0YVNjaGVtYS5lbXNnLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlkM1RyYWNrO1xuICAgIH07XG4gICAgX3Byb3RvLmRlbXV4U2FtcGxlQWVzID0gZnVuY3Rpb24gZGVtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVGhlIE1QNCBkZW11eGVyIGRvZXMgbm90IHN1cHBvcnQgU0FNUExFLUFFUyBkZWNyeXB0aW9uJykpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge307XG4gICAgcmV0dXJuIE1QNERlbXV4ZXI7XG4gIH0oKTtcblxuICB2YXIgZ2V0QXVkaW9CU0lEID0gZnVuY3Rpb24gZ2V0QXVkaW9CU0lEKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIGNoZWNrIHRoZSBic2lkIHRvIGNvbmZpcm0gYWMtMyB8IGVjLTNcbiAgICB2YXIgYnNpZCA9IDA7XG4gICAgdmFyIG51bUJpdHMgPSA1O1xuICAgIG9mZnNldCArPSBudW1CaXRzO1xuICAgIHZhciB0ZW1wID0gbmV3IFVpbnQzMkFycmF5KDEpOyAvLyB1bnNpZ25lZCAzMiBiaXQgZm9yIHRlbXBvcmFyeSBzdG9yYWdlXG4gICAgdmFyIG1hc2sgPSBuZXcgVWludDMyQXJyYXkoMSk7IC8vIHVuc2lnbmVkIDMyIGJpdCBtYXNrIHZhbHVlXG4gICAgdmFyIF9ieXRlID0gbmV3IFVpbnQ4QXJyYXkoMSk7IC8vIHVuc2lnbmVkIDggYml0IGZvciB0ZW1wb3Jhcnkgc3RvcmFnZVxuICAgIHdoaWxlIChudW1CaXRzID4gMCkge1xuICAgICAgX2J5dGVbMF0gPSBkYXRhW29mZnNldF07XG4gICAgICAvLyByZWFkIHJlbWFpbmluZyBiaXRzLCB1cHRvIDggYml0cyBhdCBhIHRpbWVcbiAgICAgIHZhciBiaXRzID0gTWF0aC5taW4obnVtQml0cywgOCk7XG4gICAgICB2YXIgc2hpZnQgPSA4IC0gYml0cztcbiAgICAgIG1hc2tbMF0gPSAweGZmMDAwMDAwID4+PiAyNCArIHNoaWZ0IDw8IHNoaWZ0O1xuICAgICAgdGVtcFswXSA9IChfYnl0ZVswXSAmIG1hc2tbMF0pID4+IHNoaWZ0O1xuICAgICAgYnNpZCA9ICFic2lkID8gdGVtcFswXSA6IGJzaWQgPDwgYml0cyB8IHRlbXBbMF07XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICAgIG51bUJpdHMgLT0gYml0cztcbiAgICB9XG4gICAgcmV0dXJuIGJzaWQ7XG4gIH07XG5cbiAgdmFyIEFDM0RlbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQXVkaW9EZW11eGVyKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoQUMzRGVtdXhlciwgX0Jhc2VBdWRpb0RlbXV4ZXIpO1xuICAgIGZ1bmN0aW9uIEFDM0RlbXV4ZXIob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF90aGlzID0gX0Jhc2VBdWRpb0RlbXV4ZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgX3RoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQUMzRGVtdXhlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgICBfQmFzZUF1ZGlvRGVtdXhlci5wcm90b3R5cGUucmVzZXRJbml0U2VnbWVudC5jYWxsKHRoaXMsIGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKTtcbiAgICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL2FjLTMnLFxuICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICBpZDogMixcbiAgICAgICAgcGlkOiAtMSxcbiAgICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICAgIHNlZ21lbnRDb2RlYzogJ2FjMycsXG4gICAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgICBtYW5pZmVzdENvZGVjOiBhdWRpb0NvZGVjLFxuICAgICAgICBkdXJhdGlvbjogdHJhY2tEdXJhdGlvbixcbiAgICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgICBkcm9wcGVkOiAwXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmNhblBhcnNlID0gZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgNjQgPCBkYXRhLmxlbmd0aDtcbiAgICB9O1xuICAgIF9wcm90by5hcHBlbmRGcmFtZSA9IGZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICAgIHZhciBmcmFtZUxlbmd0aCA9IF9hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCB0aGlzLmJhc2VQVFMsIHRoaXMuZnJhbWVJbmRleCk7XG4gICAgICBpZiAoZnJhbWVMZW5ndGggIT09IC0xKSB7XG4gICAgICAgIHZhciBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW3RyYWNrLnNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2FtcGxlOiBzYW1wbGUsXG4gICAgICAgICAgbGVuZ3RoOiBmcmFtZUxlbmd0aCxcbiAgICAgICAgICBtaXNzaW5nOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBBQzNEZW11eGVyLnByb2JlID0gZnVuY3Rpb24gcHJvYmUoZGF0YSkge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpZDNEYXRhID0gZ2V0SUQzRGF0YShkYXRhLCAwKTtcbiAgICAgIGlmICghaWQzRGF0YSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvb2sgZm9yIHRoZSBhYy0zIHN5bmMgYnl0ZXNcbiAgICAgIHZhciBvZmZzZXQgPSBpZDNEYXRhLmxlbmd0aDtcbiAgICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4MGIgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg3NyAmJiBnZXRUaW1lU3RhbXAoaWQzRGF0YSkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgLy8gY2hlY2sgdGhlIGJzaWQgdG8gY29uZmlybSBhYy0zXG4gICAgICBnZXRBdWRpb0JTSUQoZGF0YSwgb2Zmc2V0KSA8IDE2KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIEFDM0RlbXV4ZXI7XG4gIH0oQmFzZUF1ZGlvRGVtdXhlcik7XG4gIGZ1bmN0aW9uIF9hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgc3RhcnQsIHB0cywgZnJhbWVJbmRleCkge1xuICAgIGlmIChzdGFydCArIDggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xOyAvLyBub3QgZW5vdWdoIGJ5dGVzIGxlZnRcbiAgICB9XG4gICAgaWYgKGRhdGFbc3RhcnRdICE9PSAweDBiIHx8IGRhdGFbc3RhcnQgKyAxXSAhPT0gMHg3Nykge1xuICAgICAgcmV0dXJuIC0xOyAvLyBpbnZhbGlkIG1hZ2ljXG4gICAgfVxuXG4gICAgLy8gZ2V0IHNhbXBsZSByYXRlXG4gICAgdmFyIHNhbXBsaW5nUmF0ZUNvZGUgPSBkYXRhW3N0YXJ0ICsgNF0gPj4gNjtcbiAgICBpZiAoc2FtcGxpbmdSYXRlQ29kZSA+PSAzKSB7XG4gICAgICByZXR1cm4gLTE7IC8vIGludmFsaWQgc2FtcGxpbmcgcmF0ZVxuICAgIH1cbiAgICB2YXIgc2FtcGxpbmdSYXRlTWFwID0gWzQ4MDAwLCA0NDEwMCwgMzIwMDBdO1xuICAgIHZhciBzYW1wbGVSYXRlID0gc2FtcGxpbmdSYXRlTWFwW3NhbXBsaW5nUmF0ZUNvZGVdO1xuXG4gICAgLy8gZ2V0IGZyYW1lIHNpemVcbiAgICB2YXIgZnJhbWVTaXplQ29kZSA9IGRhdGFbc3RhcnQgKyA0XSAmIDB4M2Y7XG4gICAgdmFyIGZyYW1lU2l6ZU1hcCA9IFs2NCwgNjksIDk2LCA2NCwgNzAsIDk2LCA4MCwgODcsIDEyMCwgODAsIDg4LCAxMjAsIDk2LCAxMDQsIDE0NCwgOTYsIDEwNSwgMTQ0LCAxMTIsIDEyMSwgMTY4LCAxMTIsIDEyMiwgMTY4LCAxMjgsIDEzOSwgMTkyLCAxMjgsIDE0MCwgMTkyLCAxNjAsIDE3NCwgMjQwLCAxNjAsIDE3NSwgMjQwLCAxOTIsIDIwOCwgMjg4LCAxOTIsIDIwOSwgMjg4LCAyMjQsIDI0MywgMzM2LCAyMjQsIDI0NCwgMzM2LCAyNTYsIDI3OCwgMzg0LCAyNTYsIDI3OSwgMzg0LCAzMjAsIDM0OCwgNDgwLCAzMjAsIDM0OSwgNDgwLCAzODQsIDQxNywgNTc2LCAzODQsIDQxOCwgNTc2LCA0NDgsIDQ4NywgNjcyLCA0NDgsIDQ4OCwgNjcyLCA1MTIsIDU1NywgNzY4LCA1MTIsIDU1OCwgNzY4LCA2NDAsIDY5NiwgOTYwLCA2NDAsIDY5NywgOTYwLCA3NjgsIDgzNSwgMTE1MiwgNzY4LCA4MzYsIDExNTIsIDg5NiwgOTc1LCAxMzQ0LCA4OTYsIDk3NiwgMTM0NCwgMTAyNCwgMTExNCwgMTUzNiwgMTAyNCwgMTExNSwgMTUzNiwgMTE1MiwgMTI1MywgMTcyOCwgMTE1MiwgMTI1NCwgMTcyOCwgMTI4MCwgMTM5MywgMTkyMCwgMTI4MCwgMTM5NCwgMTkyMF07XG4gICAgdmFyIGZyYW1lTGVuZ3RoID0gZnJhbWVTaXplTWFwW2ZyYW1lU2l6ZUNvZGUgKiAzICsgc2FtcGxpbmdSYXRlQ29kZV0gKiAyO1xuICAgIGlmIChzdGFydCArIGZyYW1lTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBnZXQgY2hhbm5lbCBjb3VudFxuICAgIHZhciBjaGFubmVsTW9kZSA9IGRhdGFbc3RhcnQgKyA2XSA+PiA1O1xuICAgIHZhciBza2lwQ291bnQgPSAwO1xuICAgIGlmIChjaGFubmVsTW9kZSA9PT0gMikge1xuICAgICAgc2tpcENvdW50ICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaGFubmVsTW9kZSAmIDEgJiYgY2hhbm5lbE1vZGUgIT09IDEpIHtcbiAgICAgICAgc2tpcENvdW50ICs9IDI7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbm5lbE1vZGUgJiA0KSB7XG4gICAgICAgIHNraXBDb3VudCArPSAyO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbGZlb24gPSAoZGF0YVtzdGFydCArIDZdIDw8IDggfCBkYXRhW3N0YXJ0ICsgN10pID4+IDEyIC0gc2tpcENvdW50ICYgMTtcbiAgICB2YXIgY2hhbm5lbHNNYXAgPSBbMiwgMSwgMiwgMywgMywgNCwgNCwgNV07XG4gICAgdmFyIGNoYW5uZWxDb3VudCA9IGNoYW5uZWxzTWFwW2NoYW5uZWxNb2RlXSArIGxmZW9uO1xuXG4gICAgLy8gYnVpbGQgZGFjMyBib3hcbiAgICB2YXIgYnNpZCA9IGRhdGFbc3RhcnQgKyA1XSA+PiAzO1xuICAgIHZhciBic21vZCA9IGRhdGFbc3RhcnQgKyA1XSAmIDc7XG4gICAgdmFyIGNvbmZpZyA9IG5ldyBVaW50OEFycmF5KFtzYW1wbGluZ1JhdGVDb2RlIDw8IDYgfCBic2lkIDw8IDEgfCBic21vZCA+PiAyLCAoYnNtb2QgJiAzKSA8PCA2IHwgY2hhbm5lbE1vZGUgPDwgMyB8IGxmZW9uIDw8IDIgfCBmcmFtZVNpemVDb2RlID4+IDQsIGZyYW1lU2l6ZUNvZGUgPDwgNCAmIDB4ZTBdKTtcbiAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IDE1MzYgLyBzYW1wbGVSYXRlICogOTAwMDA7XG4gICAgdmFyIHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgdmFyIHVuaXQgPSBkYXRhLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGZyYW1lTGVuZ3RoKTtcbiAgICB0cmFjay5jb25maWcgPSBjb25maWc7XG4gICAgdHJhY2suY2hhbm5lbENvdW50ID0gY2hhbm5lbENvdW50O1xuICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBzYW1wbGVSYXRlO1xuICAgIHRyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICB1bml0OiB1bml0LFxuICAgICAgcHRzOiBzdGFtcFxuICAgIH0pO1xuICAgIHJldHVybiBmcmFtZUxlbmd0aDtcbiAgfVxuXG4gIHZhciBCYXNlVmlkZW9QYXJzZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VWaWRlb1BhcnNlcigpIHtcbiAgICAgIHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQmFzZVZpZGVvUGFyc2VyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uY3JlYXRlVmlkZW9TYW1wbGUgPSBmdW5jdGlvbiBjcmVhdGVWaWRlb1NhbXBsZShrZXksIHB0cywgZHRzLCBkZWJ1Zykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIGZyYW1lOiBmYWxzZSxcbiAgICAgICAgcHRzOiBwdHMsXG4gICAgICAgIGR0czogZHRzLFxuICAgICAgICB1bml0czogW10sXG4gICAgICAgIGRlYnVnOiBkZWJ1ZyxcbiAgICAgICAgbGVuZ3RoOiAwXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmdldExhc3ROYWxVbml0ID0gZnVuY3Rpb24gZ2V0TGFzdE5hbFVuaXQoc2FtcGxlcykge1xuICAgICAgdmFyIF9WaWRlb1NhbXBsZTtcbiAgICAgIHZhciBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGU7XG4gICAgICB2YXIgbGFzdFVuaXQ7XG4gICAgICAvLyB0cnkgdG8gZmFsbGJhY2sgdG8gcHJldmlvdXMgc2FtcGxlIGlmIGN1cnJlbnQgb25lIGlzIGVtcHR5XG4gICAgICBpZiAoIVZpZGVvU2FtcGxlIHx8IFZpZGVvU2FtcGxlLnVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBWaWRlb1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmICgoX1ZpZGVvU2FtcGxlID0gVmlkZW9TYW1wbGUpICE9IG51bGwgJiYgX1ZpZGVvU2FtcGxlLnVuaXRzKSB7XG4gICAgICAgIHZhciB1bml0cyA9IFZpZGVvU2FtcGxlLnVuaXRzO1xuICAgICAgICBsYXN0VW5pdCA9IHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RVbml0O1xuICAgIH07XG4gICAgX3Byb3RvLnB1c2hBY2Nlc3NVbml0ID0gZnVuY3Rpb24gcHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHZpZGVvVHJhY2spIHtcbiAgICAgIGlmIChWaWRlb1NhbXBsZS51bml0cy5sZW5ndGggJiYgVmlkZW9TYW1wbGUuZnJhbWUpIHtcbiAgICAgICAgLy8gaWYgc2FtcGxlIGRvZXMgbm90IGhhdmUgUFRTL0RUUywgcGF0Y2ggd2l0aCBsYXN0IHNhbXBsZSBQVFMvRFRTXG4gICAgICAgIGlmIChWaWRlb1NhbXBsZS5wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzO1xuICAgICAgICAgIHZhciBuYlNhbXBsZXMgPSBzYW1wbGVzLmxlbmd0aDtcbiAgICAgICAgICBpZiAobmJTYW1wbGVzKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFNhbXBsZSA9IHNhbXBsZXNbbmJTYW1wbGVzIC0gMV07XG4gICAgICAgICAgICBWaWRlb1NhbXBsZS5wdHMgPSBsYXN0U2FtcGxlLnB0cztcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlLmR0cyA9IGxhc3RTYW1wbGUuZHRzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkcm9wcGluZyBzYW1wbGVzLCBubyB0aW1lc3RhbXAgZm91bmRcbiAgICAgICAgICAgIHZpZGVvVHJhY2suZHJvcHBlZCsrO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aWRlb1RyYWNrLnNhbXBsZXMucHVzaChWaWRlb1NhbXBsZSk7XG4gICAgICB9XG4gICAgICBpZiAoVmlkZW9TYW1wbGUuZGVidWcubGVuZ3RoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coVmlkZW9TYW1wbGUucHRzICsgJy8nICsgVmlkZW9TYW1wbGUuZHRzICsgJzonICsgVmlkZW9TYW1wbGUuZGVidWcpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJhc2VWaWRlb1BhcnNlcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBQYXJzZXIgZm9yIGV4cG9uZW50aWFsIEdvbG9tYiBjb2RlcywgYSB2YXJpYWJsZS1iaXR3aWR0aCBudW1iZXIgZW5jb2Rpbmcgc2NoZW1lIHVzZWQgYnkgaDI2NC5cbiAgICovXG5cbiAgdmFyIEV4cEdvbG9tYiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwR29sb21iKGRhdGEpIHtcbiAgICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLndvcmQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSB2b2lkIDA7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgLy8gdGhlIGN1cnJlbnQgd29yZCBiZWluZyBleGFtaW5lZFxuICAgICAgdGhpcy53b3JkID0gMDsgLy8gOnVpbnRcbiAgICAgIC8vIHRoZSBudW1iZXIgb2YgYml0cyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhlIGN1cnJlbnQgd29yZFxuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gMDsgLy8gOnVpbnRcbiAgICB9XG5cbiAgICAvLyAoKTp2b2lkXG4gICAgdmFyIF9wcm90byA9IEV4cEdvbG9tYi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmxvYWRXb3JkID0gZnVuY3Rpb24gbG9hZFdvcmQoKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHZhciBieXRlc0F2YWlsYWJsZSA9IHRoaXMuYnl0ZXNBdmFpbGFibGU7XG4gICAgICB2YXIgcG9zaXRpb24gPSBkYXRhLmJ5dGVMZW5ndGggLSBieXRlc0F2YWlsYWJsZTtcbiAgICAgIHZhciB3b3JraW5nQnl0ZXMgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgIHZhciBhdmFpbGFibGVCeXRlcyA9IE1hdGgubWluKDQsIGJ5dGVzQXZhaWxhYmxlKTtcbiAgICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgICAgfVxuICAgICAgd29ya2luZ0J5dGVzLnNldChkYXRhLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGF2YWlsYWJsZUJ5dGVzKSk7XG4gICAgICB0aGlzLndvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuICAgICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB0aGlzLmRhdGEgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IGF2YWlsYWJsZUJ5dGVzICogODtcbiAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gYXZhaWxhYmxlQnl0ZXM7XG4gICAgfVxuXG4gICAgLy8gKGNvdW50OmludCk6dm9pZFxuICAgIDtcbiAgICBfcHJvdG8uc2tpcEJpdHMgPSBmdW5jdGlvbiBza2lwQml0cyhjb3VudCkge1xuICAgICAgdmFyIHNraXBCeXRlczsgLy8gOmludFxuICAgICAgY291bnQgPSBNYXRoLm1pbihjb3VudCwgdGhpcy5ieXRlc0F2YWlsYWJsZSAqIDggKyB0aGlzLmJpdHNBdmFpbGFibGUpO1xuICAgICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IGNvdW50KSB7XG4gICAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50IC09IHRoaXMuYml0c0F2YWlsYWJsZTtcbiAgICAgICAgc2tpcEJ5dGVzID0gY291bnQgPj4gMztcbiAgICAgICAgY291bnQgLT0gc2tpcEJ5dGVzIDw8IDM7XG4gICAgICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuICAgICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAoc2l6ZTppbnQpOnVpbnRcbiAgICA7XG4gICAgX3Byb3RvLnJlYWRCaXRzID0gZnVuY3Rpb24gcmVhZEJpdHMoc2l6ZSkge1xuICAgICAgdmFyIGJpdHMgPSBNYXRoLm1pbih0aGlzLmJpdHNBdmFpbGFibGUsIHNpemUpOyAvLyA6dWludFxuICAgICAgdmFyIHZhbHUgPSB0aGlzLndvcmQgPj4+IDMyIC0gYml0czsgLy8gOnVpbnRcbiAgICAgIGlmIChzaXplID4gMzIpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3QgcmVhZCBtb3JlIHRoYW4gMzIgYml0cyBhdCBhIHRpbWUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBiaXRzO1xuICAgICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IDApIHtcbiAgICAgICAgdGhpcy53b3JkIDw8PSBiaXRzO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmJ5dGVzQXZhaWxhYmxlID4gMCkge1xuICAgICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJpdHMgYXZhaWxhYmxlJyk7XG4gICAgICB9XG4gICAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XG4gICAgICBpZiAoYml0cyA+IDAgJiYgdGhpcy5iaXRzQXZhaWxhYmxlKSB7XG4gICAgICAgIHJldHVybiB2YWx1IDw8IGJpdHMgfCB0aGlzLnJlYWRCaXRzKGJpdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gKCk6dWludFxuICAgIDtcbiAgICBfcHJvdG8uc2tpcExaID0gZnVuY3Rpb24gc2tpcExaKCkge1xuICAgICAgdmFyIGxlYWRpbmdaZXJvQ291bnQ7IC8vIDp1aW50XG4gICAgICBmb3IgKGxlYWRpbmdaZXJvQ291bnQgPSAwOyBsZWFkaW5nWmVyb0NvdW50IDwgdGhpcy5iaXRzQXZhaWxhYmxlOyArK2xlYWRpbmdaZXJvQ291bnQpIHtcbiAgICAgICAgaWYgKCh0aGlzLndvcmQgJiAweDgwMDAwMDAwID4+PiBsZWFkaW5nWmVyb0NvdW50KSAhPT0gMCkge1xuICAgICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcbiAgICAgICAgICB0aGlzLndvcmQgPDw9IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHdlIGV4aGF1c3RlZCB3b3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgIHJldHVybiBsZWFkaW5nWmVyb0NvdW50ICsgdGhpcy5za2lwTFooKTtcbiAgICB9XG5cbiAgICAvLyAoKTp2b2lkXG4gICAgO1xuICAgIF9wcm90by5za2lwVUVHID0gZnVuY3Rpb24gc2tpcFVFRygpIHtcbiAgICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICAgIH1cblxuICAgIC8vICgpOnZvaWRcbiAgICA7XG4gICAgX3Byb3RvLnNraXBFRyA9IGZ1bmN0aW9uIHNraXBFRygpIHtcbiAgICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICAgIH1cblxuICAgIC8vICgpOnVpbnRcbiAgICA7XG4gICAgX3Byb3RvLnJlYWRVRUcgPSBmdW5jdGlvbiByZWFkVUVHKCkge1xuICAgICAgdmFyIGNseiA9IHRoaXMuc2tpcExaKCk7IC8vIDp1aW50XG4gICAgICByZXR1cm4gdGhpcy5yZWFkQml0cyhjbHogKyAxKSAtIDE7XG4gICAgfVxuXG4gICAgLy8gKCk6aW50XG4gICAgO1xuICAgIF9wcm90by5yZWFkRUcgPSBmdW5jdGlvbiByZWFkRUcoKSB7XG4gICAgICB2YXIgdmFsdSA9IHRoaXMucmVhZFVFRygpOyAvLyA6aW50XG4gICAgICBpZiAoMHgwMSAmIHZhbHUpIHtcbiAgICAgICAgLy8gdGhlIG51bWJlciBpcyBvZGQgaWYgdGhlIGxvdyBvcmRlciBiaXQgaXMgc2V0XG4gICAgICAgIHJldHVybiAxICsgdmFsdSA+Pj4gMTsgLy8gYWRkIDEgdG8gbWFrZSBpdCBldmVuLCBhbmQgZGl2aWRlIGJ5IDJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xuICAgIC8vIDpCb29sZWFuXG4gICAgO1xuICAgIF9wcm90by5yZWFkQm9vbGVhbiA9IGZ1bmN0aW9uIHJlYWRCb29sZWFuKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMSkgPT09IDE7XG4gICAgfVxuXG4gICAgLy8gKCk6aW50XG4gICAgO1xuICAgIF9wcm90by5yZWFkVUJ5dGUgPSBmdW5jdGlvbiByZWFkVUJ5dGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcbiAgICB9XG5cbiAgICAvLyAoKTppbnRcbiAgICA7XG4gICAgX3Byb3RvLnJlYWRVU2hvcnQgPSBmdW5jdGlvbiByZWFkVVNob3J0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMTYpO1xuICAgIH1cblxuICAgIC8vICgpOmludFxuICAgIDtcbiAgICBfcHJvdG8ucmVhZFVJbnQgPSBmdW5jdGlvbiByZWFkVUludCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDMyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgICAqIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAgICogc2V0IGFuZCBpcyBub3QgcmVsZXZhbnQgdG8gdHJhbnNtdXhpbmcuXG4gICAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICAgKi87XG4gICAgX3Byb3RvLnNraXBTY2FsaW5nTGlzdCA9IGZ1bmN0aW9uIHNraXBTY2FsaW5nTGlzdChjb3VudCkge1xuICAgICAgdmFyIGxhc3RTY2FsZSA9IDg7XG4gICAgICB2YXIgbmV4dFNjYWxlID0gODtcbiAgICAgIHZhciBkZWx0YVNjYWxlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIGlmIChuZXh0U2NhbGUgIT09IDApIHtcbiAgICAgICAgICBkZWx0YVNjYWxlID0gdGhpcy5yZWFkRUcoKTtcbiAgICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFNjYWxlID0gbmV4dFNjYWxlID09PSAwID8gbGFzdFNjYWxlIDogbmV4dFNjYWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGFuZCByZXR1cm4gc29tZSBpbnRlcmVzdGluZyB2aWRlb1xuICAgICAqIHByb3BlcnRpZXMuIEEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBpcyB0aGUgSDI2NCBtZXRhZGF0YSB0aGF0XG4gICAgICogZGVzY3JpYmVzIHRoZSBwcm9wZXJ0aWVzIG9mIHVwY29taW5nIHZpZGVvIGZyYW1lcy5cbiAgICAgKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgICAqIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQsIGluY2x1ZGluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGVcbiAgICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cbiAgICAgKi87XG4gICAgX3Byb3RvLnJlYWRTUFMgPSBmdW5jdGlvbiByZWFkU1BTKCkge1xuICAgICAgdmFyIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSAwO1xuICAgICAgdmFyIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBmcmFtZUNyb3BUb3BPZmZzZXQgPSAwO1xuICAgICAgdmFyIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IDA7XG4gICAgICB2YXIgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlO1xuICAgICAgdmFyIHNjYWxpbmdMaXN0Q291bnQ7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciByZWFkVUJ5dGUgPSB0aGlzLnJlYWRVQnl0ZS5iaW5kKHRoaXMpO1xuICAgICAgdmFyIHJlYWRCaXRzID0gdGhpcy5yZWFkQml0cy5iaW5kKHRoaXMpO1xuICAgICAgdmFyIHJlYWRVRUcgPSB0aGlzLnJlYWRVRUcuYmluZCh0aGlzKTtcbiAgICAgIHZhciByZWFkQm9vbGVhbiA9IHRoaXMucmVhZEJvb2xlYW4uYmluZCh0aGlzKTtcbiAgICAgIHZhciBza2lwQml0cyA9IHRoaXMuc2tpcEJpdHMuYmluZCh0aGlzKTtcbiAgICAgIHZhciBza2lwRUcgPSB0aGlzLnNraXBFRy5iaW5kKHRoaXMpO1xuICAgICAgdmFyIHNraXBVRUcgPSB0aGlzLnNraXBVRUcuYmluZCh0aGlzKTtcbiAgICAgIHZhciBza2lwU2NhbGluZ0xpc3QgPSB0aGlzLnNraXBTY2FsaW5nTGlzdC5iaW5kKHRoaXMpO1xuICAgICAgcmVhZFVCeXRlKCk7XG4gICAgICB2YXIgcHJvZmlsZUlkYyA9IHJlYWRVQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgICAgcmVhZEJpdHMoNSk7IC8vIHByb2ZpbGVDb21wYXQgY29uc3RyYWludF9zZXRbMC00XV9mbGFnLCB1KDUpXG4gICAgICBza2lwQml0cygzKTsgLy8gcmVzZXJ2ZWRfemVyb18zYml0cyB1KDMpLFxuICAgICAgcmVhZFVCeXRlKCk7IC8vIGxldmVsX2lkYyB1KDgpXG4gICAgICBza2lwVUVHKCk7IC8vIHNlcV9wYXJhbWV0ZXJfc2V0X2lkXG4gICAgICAvLyBzb21lIHByb2ZpbGVzIGhhdmUgbW9yZSBvcHRpb25hbCBkYXRhIHdlIGRvbid0IG5lZWRcbiAgICAgIGlmIChwcm9maWxlSWRjID09PSAxMDAgfHwgcHJvZmlsZUlkYyA9PT0gMTEwIHx8IHByb2ZpbGVJZGMgPT09IDEyMiB8fCBwcm9maWxlSWRjID09PSAyNDQgfHwgcHJvZmlsZUlkYyA9PT0gNDQgfHwgcHJvZmlsZUlkYyA9PT0gODMgfHwgcHJvZmlsZUlkYyA9PT0gODYgfHwgcHJvZmlsZUlkYyA9PT0gMTE4IHx8IHByb2ZpbGVJZGMgPT09IDEyOCkge1xuICAgICAgICB2YXIgY2hyb21hRm9ybWF0SWRjID0gcmVhZFVFRygpO1xuICAgICAgICBpZiAoY2hyb21hRm9ybWF0SWRjID09PSAzKSB7XG4gICAgICAgICAgc2tpcEJpdHMoMSk7XG4gICAgICAgIH0gLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcblxuICAgICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9sdW1hX21pbnVzOFxuICAgICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XG4gICAgICAgIHNraXBCaXRzKDEpOyAvLyBxcHByaW1lX3lfemVyb190cmFuc2Zvcm1fYnlwYXNzX2ZsYWdcbiAgICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgICAvLyBzZXFfc2NhbGluZ19tYXRyaXhfcHJlc2VudF9mbGFnXG4gICAgICAgICAgc2NhbGluZ0xpc3RDb3VudCA9IGNocm9tYUZvcm1hdElkYyAhPT0gMyA/IDggOiAxMjtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbGluZ0xpc3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgICAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXG4gICAgICAgICAgICAgIGlmIChpIDwgNikge1xuICAgICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDY0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2tpcFVFRygpOyAvLyBsb2cyX21heF9mcmFtZV9udW1fbWludXM0XG4gICAgICB2YXIgcGljT3JkZXJDbnRUeXBlID0gcmVhZFVFRygpO1xuICAgICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xuICAgICAgICByZWFkVUVHKCk7IC8vIGxvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzNFxuICAgICAgfSBlbHNlIGlmIChwaWNPcmRlckNudFR5cGUgPT09IDEpIHtcbiAgICAgICAgc2tpcEJpdHMoMSk7IC8vIGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnXG4gICAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX3RvcF90b19ib3R0b21fZmllbGRcbiAgICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlID0gcmVhZFVFRygpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlOyBpKyspIHtcbiAgICAgICAgICBza2lwRUcoKTtcbiAgICAgICAgfSAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG4gICAgICB9XG4gICAgICBza2lwVUVHKCk7IC8vIG1heF9udW1fcmVmX2ZyYW1lc1xuICAgICAgc2tpcEJpdHMoMSk7IC8vIGdhcHNfaW5fZnJhbWVfbnVtX3ZhbHVlX2FsbG93ZWRfZmxhZ1xuICAgICAgdmFyIHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgICB2YXIgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICAgIHZhciBmcmFtZU1ic09ubHlGbGFnID0gcmVhZEJpdHMoMSk7XG4gICAgICBpZiAoZnJhbWVNYnNPbmx5RmxhZyA9PT0gMCkge1xuICAgICAgICBza2lwQml0cygxKTtcbiAgICAgIH0gLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuXG4gICAgICBza2lwQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuICAgICAgaWYgKHJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICB9XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIHZ1aV9wYXJhbWV0ZXJzX3ByZXNlbnRfZmxhZ1xuICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICAgIHZhciBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xuICAgICAgICAgIHN3aXRjaCAoYXNwZWN0UmF0aW9JZGMpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTIsIDExXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTAsIDExXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTYsIDExXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNDAsIDMzXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjQsIDExXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjAsIDExXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMzIsIDExXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbODAsIDMzXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE4LCAxMV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNSwgMTFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNjQsIDMzXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2MCwgOTldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNCwgM107XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFszLCAyXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIsIDFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjU1OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFtyZWFkVUJ5dGUoKSA8PCA4IHwgcmVhZFVCeXRlKCksIHJlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBNYXRoLmNlaWwoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2IC0gZnJhbWVDcm9wTGVmdE9mZnNldCAqIDIgLSBmcmFtZUNyb3BSaWdodE9mZnNldCAqIDIpLFxuICAgICAgICBoZWlnaHQ6ICgyIC0gZnJhbWVNYnNPbmx5RmxhZykgKiAocGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSArIDEpICogMTYgLSAoZnJhbWVNYnNPbmx5RmxhZyA/IDIgOiA0KSAqIChmcmFtZUNyb3BUb3BPZmZzZXQgKyBmcmFtZUNyb3BCb3R0b21PZmZzZXQpLFxuICAgICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLnJlYWRTbGljZVR5cGUgPSBmdW5jdGlvbiByZWFkU2xpY2VUeXBlKCkge1xuICAgICAgLy8gc2tpcCBOQUx1IHR5cGVcbiAgICAgIHRoaXMucmVhZFVCeXRlKCk7XG4gICAgICAvLyBkaXNjYXJkIGZpcnN0X21iX2luX3NsaWNlXG4gICAgICB0aGlzLnJlYWRVRUcoKTtcbiAgICAgIC8vIHJldHVybiBzbGljZV90eXBlXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVUVHKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRXhwR29sb21iO1xuICB9KCk7XG5cbiAgdmFyIEF2Y1ZpZGVvUGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVZpZGVvUGFyc2VyKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoQXZjVmlkZW9QYXJzZXIsIF9CYXNlVmlkZW9QYXJzZXIpO1xuICAgIGZ1bmN0aW9uIEF2Y1ZpZGVvUGFyc2VyKCkge1xuICAgICAgcmV0dXJuIF9CYXNlVmlkZW9QYXJzZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQXZjVmlkZW9QYXJzZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5wYXJzZUFWQ1BFUyA9IGZ1bmN0aW9uIHBhcnNlQVZDUEVTKHRyYWNrLCB0ZXh0VHJhY2ssIHBlcywgbGFzdCwgZHVyYXRpb24pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgdW5pdHMgPSB0aGlzLnBhcnNlQVZDTkFMdSh0cmFjaywgcGVzLmRhdGEpO1xuICAgICAgdmFyIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZTtcbiAgICAgIHZhciBwdXNoO1xuICAgICAgdmFyIHNwc2ZvdW5kID0gZmFsc2U7XG4gICAgICAvLyBmcmVlIHBlcy5kYXRhIHRvIHNhdmUgdXAgc29tZSBtZW1vcnlcbiAgICAgIHBlcy5kYXRhID0gbnVsbDtcblxuICAgICAgLy8gaWYgbmV3IE5BTCB1bml0cyBmb3VuZCBhbmQgbGFzdCBzYW1wbGUgc3RpbGwgdGhlcmUsIGxldCdzIHB1c2ggLi4uXG4gICAgICAvLyB0aGlzIGhlbHBzIHBhcnNpbmcgc3RyZWFtcyB3aXRoIG1pc3NpbmcgQVVEIChvbmx5IGRvIHRoaXMgaWYgQVVEIG5ldmVyIGZvdW5kKVxuICAgICAgaWYgKFZpZGVvU2FtcGxlICYmIHVuaXRzLmxlbmd0aCAmJiAhdHJhY2suYXVkRm91bmQpIHtcbiAgICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICB9XG4gICAgICB1bml0cy5mb3JFYWNoKGZ1bmN0aW9uICh1bml0KSB7XG4gICAgICAgIHZhciBfVmlkZW9TYW1wbGUyO1xuICAgICAgICBzd2l0Y2ggKHVuaXQudHlwZSkge1xuICAgICAgICAgIC8vIE5EUlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGlza2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgICAgICAgLy8gb25seSBjaGVjayBzbGljZSB0eXBlIHRvIGRldGVjdCBLRiBpbiBjYXNlIFNQUyBmb3VuZCBpbiBzYW1lIHBhY2tldCAoYW55IGtleWZyYW1lIGlzIHByZWNlZGVkIGJ5IFNQUyAuLi4pXG4gICAgICAgICAgICAgIGlmIChzcHNmb3VuZCAmJiBkYXRhLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXRyaWV2ZSBzbGljZSB0eXBlIGJ5IHBhcnNpbmcgYmVnaW5uaW5nIG9mIE5BTCB1bml0IChmb2xsb3cgSDI2NCBzcGVjLCBzbGljZV9oZWFkZXIgZGVmaW5pdGlvbikgdG8gZGV0ZWN0IGtleWZyYW1lIGVtYmVkZGVkIGluIE5EUlxuICAgICAgICAgICAgICAgIHZhciBzbGljZVR5cGUgPSBuZXcgRXhwR29sb21iKGRhdGEpLnJlYWRTbGljZVR5cGUoKTtcbiAgICAgICAgICAgICAgICAvLyAyIDogSSBzbGljZSwgNCA6IFNJIHNsaWNlLCA3IDogSSBzbGljZSwgOTogU0kgc2xpY2VcbiAgICAgICAgICAgICAgICAvLyBTSSBzbGljZSA6IEEgc2xpY2UgdGhhdCBpcyBjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkgYW5kIHVzaW5nIHF1YW50aXNhdGlvbiBvZiB0aGUgcHJlZGljdGlvbiBzYW1wbGVzLlxuICAgICAgICAgICAgICAgIC8vIEFuIFNJIHNsaWNlIGNhbiBiZSBjb2RlZCBzdWNoIHRoYXQgaXRzIGRlY29kZWQgc2FtcGxlcyBjYW4gYmUgY29uc3RydWN0ZWQgaWRlbnRpY2FsbHkgdG8gYW4gU1Agc2xpY2UuXG4gICAgICAgICAgICAgICAgLy8gSSBzbGljZTogQSBzbGljZSB0aGF0IGlzIG5vdCBhbiBTSSBzbGljZSB0aGF0IGlzIGRlY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5LlxuICAgICAgICAgICAgICAgIC8vIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA3KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDQgfHwgc2xpY2VUeXBlID09PSA3IHx8IHNsaWNlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgaXNrZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX1ZpZGVvU2FtcGxlO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbm9uLWtleWZyYW1lIGRhdGEgYWxyZWFkeSwgdGhhdCBjYW5ub3QgYmVsb25nIHRvIHRoZSBzYW1lIGZyYW1lIGFzIGEga2V5ZnJhbWUsIHNvIGZvcmNlIGEgcHVzaFxuICAgICAgICAgICAgICAgIGlmICgoX1ZpZGVvU2FtcGxlID0gVmlkZW9TYW1wbGUpICE9IG51bGwgJiYgX1ZpZGVvU2FtcGxlLmZyYW1lICYmICFWaWRlb1NhbXBsZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICAgICAgICBWaWRlb1NhbXBsZSA9IF90aGlzLlZpZGVvU2FtcGxlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gX3RoaXMuVmlkZW9TYW1wbGUgPSBfdGhpcy5jcmVhdGVWaWRlb1NhbXBsZSh0cnVlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgVmlkZW9TYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgICBWaWRlb1NhbXBsZS5rZXkgPSBpc2tleTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIElEUlxuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgLy8gaGFuZGxlIFBFUyBub3Qgc3RhcnRpbmcgd2l0aCBBVURcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgZnJhbWUgZGF0YSBhbHJlYWR5LCB0aGF0IGNhbm5vdCBiZWxvbmcgdG8gdGhlIHNhbWUgZnJhbWUsIHNvIGZvcmNlIGEgcHVzaFxuICAgICAgICAgICAgaWYgKChfVmlkZW9TYW1wbGUyID0gVmlkZW9TYW1wbGUpICE9IG51bGwgJiYgX1ZpZGVvU2FtcGxlMi5mcmFtZSAmJiAhVmlkZW9TYW1wbGUua2V5KSB7XG4gICAgICAgICAgICAgIF90aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gX3RoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgICBWaWRlb1NhbXBsZSA9IF90aGlzLlZpZGVvU2FtcGxlID0gX3RoaXMuY3JlYXRlVmlkZW9TYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVmlkZW9TYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIFNFSVxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KHVuaXQuZGF0YSwgMSwgcGVzLnB0cywgdGV4dFRyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgLy8gU1BTXG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgX3RyYWNrJHBpeGVsUmF0aW8sIF90cmFjayRwaXhlbFJhdGlvMjtcbiAgICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICAgIHNwc2ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIHNwcyA9IHVuaXQuZGF0YTtcbiAgICAgICAgICAgICAgdmFyIGV4cEdvbG9tYkRlY29kZXIgPSBuZXcgRXhwR29sb21iKHNwcyk7XG4gICAgICAgICAgICAgIHZhciBjb25maWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcbiAgICAgICAgICAgICAgaWYgKCF0cmFjay5zcHMgfHwgdHJhY2sud2lkdGggIT09IGNvbmZpZy53aWR0aCB8fCB0cmFjay5oZWlnaHQgIT09IGNvbmZpZy5oZWlnaHQgfHwgKChfdHJhY2skcGl4ZWxSYXRpbyA9IHRyYWNrLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfdHJhY2skcGl4ZWxSYXRpb1swXSkgIT09IGNvbmZpZy5waXhlbFJhdGlvWzBdIHx8ICgoX3RyYWNrJHBpeGVsUmF0aW8yID0gdHJhY2sucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmFjayRwaXhlbFJhdGlvMlsxXSkgIT09IGNvbmZpZy5waXhlbFJhdGlvWzFdKSB7XG4gICAgICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICAgICAgdHJhY2suaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcbiAgICAgICAgICAgICAgICB0cmFjay5waXhlbFJhdGlvID0gY29uZmlnLnBpeGVsUmF0aW87XG4gICAgICAgICAgICAgICAgdHJhY2suc3BzID0gW3Nwc107XG4gICAgICAgICAgICAgICAgdHJhY2suZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgY29kZWNhcnJheSA9IHNwcy5zdWJhcnJheSgxLCA0KTtcbiAgICAgICAgICAgICAgICB2YXIgY29kZWNzdHJpbmcgPSAnYXZjMS4nO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgICAgaWYgKGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICBoID0gJzAnICsgaDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvZGVjc3RyaW5nICs9IGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWNzdHJpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gUFBTXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICB0cmFjay5wcHMgPSBbdW5pdC5kYXRhXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIEFVRFxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgdHJhY2suYXVkRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKFZpZGVvU2FtcGxlKSB7XG4gICAgICAgICAgICAgIF90aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBWaWRlb1NhbXBsZSA9IF90aGlzLlZpZGVvU2FtcGxlID0gX3RoaXMuY3JlYXRlVmlkZW9TYW1wbGUoZmFsc2UsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIEZpbGxlciBEYXRhXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgICBWaWRlb1NhbXBsZS5kZWJ1ZyArPSAndW5rbm93biBOQUwgJyArIHVuaXQudHlwZSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChWaWRlb1NhbXBsZSAmJiBwdXNoKSB7XG4gICAgICAgICAgdmFyIF91bml0cyA9IFZpZGVvU2FtcGxlLnVuaXRzO1xuICAgICAgICAgIF91bml0cy5wdXNoKHVuaXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIGlmIGxhc3QgUEVTIHBhY2tldCwgcHVzaCBzYW1wbGVzXG4gICAgICBpZiAobGFzdCAmJiBWaWRlb1NhbXBsZSkge1xuICAgICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgIHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnBhcnNlQVZDTkFMdSA9IGZ1bmN0aW9uIHBhcnNlQVZDTkFMdSh0cmFjaywgYXJyYXkpIHtcbiAgICAgIHZhciBsZW4gPSBhcnJheS5ieXRlTGVuZ3RoO1xuICAgICAgdmFyIHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDA7XG4gICAgICB2YXIgbGFzdFN0YXRlID0gc3RhdGU7XG4gICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgIHZhciB1bml0VHlwZTtcbiAgICAgIHZhciBsYXN0VW5pdFN0YXJ0ID0gLTE7XG4gICAgICB2YXIgbGFzdFVuaXRUeXBlID0gMDtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ1BFUzonICsgSGV4LmhleER1bXAoYXJyYXkpKTtcblxuICAgICAgaWYgKHN0YXRlID09PSAtMSkge1xuICAgICAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XG4gICAgICAgIGxhc3RVbml0U3RhcnQgPSAwO1xuICAgICAgICAvLyBOQUx1IHR5cGUgaXMgdmFsdWUgcmVhZCBmcm9tIG9mZnNldCAwXG4gICAgICAgIGxhc3RVbml0VHlwZSA9IGFycmF5WzBdICYgMHgxZjtcbiAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICBpID0gMTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIHZhbHVlID0gYXJyYXlbaSsrXTtcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uLiBzdGF0ZSAwIGFuZCAxIGFyZSB0aGUgcHJlZG9taW5hbnQgY2FzZS4gbGV0J3MgaGFuZGxlIHRoZW0gb3V0c2lkZSBvZiB0aGUgc3dpdGNoL2Nhc2VcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGVyZSB3ZSBoYXZlIHN0YXRlIGVpdGhlciBlcXVhbCB0byAyIG9yIDNcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgIHN0YXRlID0gMztcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICAgIG92ZXJmbG93ID0gaSAtIHN0YXRlIC0gMTtcbiAgICAgICAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgdW5pdCA9IHtcbiAgICAgICAgICAgICAgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgb3ZlcmZsb3cpLFxuICAgICAgICAgICAgICB0eXBlOiBsYXN0VW5pdFR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbGFzdFVuaXRTdGFydCBpcyB1bmRlZmluZWQgPT4gdGhpcyBpcyB0aGUgZmlyc3Qgc3RhcnQgY29kZSBmb3VuZCBpbiB0aGlzIFBFUyBwYWNrZXRcbiAgICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGlmIHN0YXJ0IGNvZGUgZGVsaW1pdGVyIGlzIG92ZXJsYXBwaW5nIGJldHdlZW4gMiBQRVMgcGFja2V0cyxcbiAgICAgICAgICAgIC8vIGllIGl0IHN0YXJ0ZWQgaW4gbGFzdCBwYWNrZXQgKGxhc3RTdGF0ZSBub3QgemVybylcbiAgICAgICAgICAgIC8vIGFuZCBlbmRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgUEVTIHBhY2tldCAoaSA8PSA0IC0gbGFzdFN0YXRlKVxuICAgICAgICAgICAgdmFyIGxhc3RVbml0ID0gdGhpcy5nZXRMYXN0TmFsVW5pdCh0cmFjay5zYW1wbGVzKTtcbiAgICAgICAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICAgICAgICBpZiAobGFzdFN0YXRlICYmIGkgPD0gNCAtIGxhc3RTdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbGFzdFVuaXQgaGFkIGEgc3RhdGUgZGlmZmVyZW50IGZyb20gemVyb1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VW5pdC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xuICAgICAgICAgICAgICAgICAgbGFzdFVuaXQuZGF0YSA9IGxhc3RVbml0LmRhdGEuc3ViYXJyYXkoMCwgbGFzdFVuaXQuZGF0YS5ieXRlTGVuZ3RoIC0gbGFzdFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gSWYgTkFMIHVuaXRzIGFyZSBub3Qgc3RhcnRpbmcgcmlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBhY2tldCwgcHVzaCBwcmVjZWRpbmcgZGF0YSBpbnRvIHByZXZpb3VzIE5BTCB1bml0LlxuXG4gICAgICAgICAgICAgIGlmIChvdmVyZmxvdyA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaXJzdCBOQUxVIGZvdW5kIHdpdGggb3ZlcmZsb3c6JyArIG92ZXJmbG93KTtcbiAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gYXBwZW5kVWludDhBcnJheShsYXN0VW5pdC5kYXRhLCBhcnJheS5zdWJhcnJheSgwLCBvdmVyZmxvdykpO1xuICAgICAgICAgICAgICAgIGxhc3RVbml0LnN0YXRlID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVhZCB1bml0IHR5cGVcbiAgICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgICAgdW5pdFR5cGUgPSBhcnJheVtpXSAmIDB4MWY7XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdmaW5kIE5BTFUgQCBvZmZzZXQ6JyArIGkgKyAnLHR5cGU6JyArIHVuaXRUeXBlKTtcbiAgICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSBpO1xuICAgICAgICAgICAgbGFzdFVuaXRUeXBlID0gdW5pdFR5cGU7XG4gICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vdCBlbm91Z2ggYnl0ZSB0byByZWFkIHVuaXQgdHlwZS4gbGV0J3MgcmVhZCBpdCBvbiBuZXh0IFBFUyBwYXJzaW5nXG4gICAgICAgICAgICBzdGF0ZSA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDAgJiYgc3RhdGUgPj0gMCkge1xuICAgICAgICB2YXIgX3VuaXQgPSB7XG4gICAgICAgICAgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgbGVuKSxcbiAgICAgICAgICB0eXBlOiBsYXN0VW5pdFR5cGUsXG4gICAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICAgIH07XG4gICAgICAgIHVuaXRzLnB1c2goX3VuaXQpO1xuICAgICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZS9zdGF0ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGggKyAnLycgKyBzdGF0ZSk7XG4gICAgICB9XG4gICAgICAvLyBubyBOQUx1IGZvdW5kXG4gICAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgICB2YXIgX2xhc3RVbml0ID0gdGhpcy5nZXRMYXN0TmFsVW5pdCh0cmFjay5zYW1wbGVzKTtcbiAgICAgICAgaWYgKF9sYXN0VW5pdCkge1xuICAgICAgICAgIF9sYXN0VW5pdC5kYXRhID0gYXBwZW5kVWludDhBcnJheShfbGFzdFVuaXQuZGF0YSwgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmFjay5uYWx1U3RhdGUgPSBzdGF0ZTtcbiAgICAgIHJldHVybiB1bml0cztcbiAgICB9O1xuICAgIHJldHVybiBBdmNWaWRlb1BhcnNlcjtcbiAgfShCYXNlVmlkZW9QYXJzZXIpO1xuXG4gIC8qKlxuICAgKiBTQU1QTEUtQUVTIGRlY3J5cHRlclxuICAgKi9cblxuICB2YXIgU2FtcGxlQWVzRGVjcnlwdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTYW1wbGVBZXNEZWNyeXB0ZXIob2JzZXJ2ZXIsIGNvbmZpZywga2V5RGF0YSkge1xuICAgICAgdGhpcy5rZXlEYXRhID0gdm9pZCAwO1xuICAgICAgdGhpcy5kZWNyeXB0ZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmtleURhdGEgPSBrZXlEYXRhO1xuICAgICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKGNvbmZpZywge1xuICAgICAgICByZW1vdmVQS0NTN1BhZGRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFNhbXBsZUFlc0RlY3J5cHRlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmRlY3J5cHRCdWZmZXIgPSBmdW5jdGlvbiBkZWNyeXB0QnVmZmVyKGVuY3J5cHRlZERhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIHRoaXMua2V5RGF0YS5rZXkuYnVmZmVyLCB0aGlzLmtleURhdGEuaXYuYnVmZmVyKTtcbiAgICB9XG5cbiAgICAvLyBBQUMgLSBlbmNyeXB0IGFsbCBmdWxsIDE2IGJ5dGVzIGJsb2NrcyBzdGFydGluZyBmcm9tIG9mZnNldCAxNlxuICAgIDtcbiAgICBfcHJvdG8uZGVjcnlwdEFhY1NhbXBsZSA9IGZ1bmN0aW9uIGRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGN1clVuaXQgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0O1xuICAgICAgaWYgKGN1clVuaXQubGVuZ3RoIDw9IDE2KSB7XG4gICAgICAgIC8vIE5vIGVuY3J5cHRlZCBwb3J0aW9uIGluIHRoaXMgc2FtcGxlIChmaXJzdCAxNiBieXRlcyBpcyBub3RcbiAgICAgICAgLy8gZW5jcnlwdGVkLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0F1ZGlvVmlkZW8vQ29uY2VwdHVhbC9ITFNfU2FtcGxlX0VuY3J5cHRpb24vRW5jcnlwdGlvbi9FbmNyeXB0aW9uLmh0bWwpLFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IGN1clVuaXQuc3ViYXJyYXkoMTYsIGN1clVuaXQubGVuZ3RoIC0gY3VyVW5pdC5sZW5ndGggJSAxNik7XG4gICAgICB2YXIgZW5jcnlwdGVkQnVmZmVyID0gZW5jcnlwdGVkRGF0YS5idWZmZXIuc2xpY2UoZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0LCBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQgKyBlbmNyeXB0ZWREYXRhLmxlbmd0aCk7XG4gICAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkQnVmZmVyKS50aGVuKGZ1bmN0aW9uIChkZWNyeXB0ZWRCdWZmZXIpIHtcbiAgICAgICAgdmFyIGRlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWRCdWZmZXIpO1xuICAgICAgICBjdXJVbml0LnNldChkZWNyeXB0ZWREYXRhLCAxNik7XG4gICAgICAgIGlmICghX3RoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgICAgX3RoaXMuZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmRlY3J5cHRBYWNTYW1wbGVzID0gZnVuY3Rpb24gZGVjcnlwdEFhY1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICBmb3IgKDs7IHNhbXBsZUluZGV4KyspIHtcbiAgICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQubGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFWQyAtIGVuY3J5cHQgb25lIDE2IGJ5dGVzIGJsb2NrIG91dCBvZiB0ZW4sIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDMyXG4gICAgO1xuICAgIF9wcm90by5nZXRBdmNFbmNyeXB0ZWREYXRhID0gZnVuY3Rpb24gZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSkge1xuICAgICAgdmFyIGVuY3J5cHRlZERhdGFMZW4gPSBNYXRoLmZsb29yKChkZWNvZGVkRGF0YS5sZW5ndGggLSA0OCkgLyAxNjApICogMTYgKyAxNjtcbiAgICAgIHZhciBlbmNyeXB0ZWREYXRhID0gbmV3IEludDhBcnJheShlbmNyeXB0ZWREYXRhTGVuKTtcbiAgICAgIHZhciBvdXRwdXRQb3MgPSAwO1xuICAgICAgZm9yICh2YXIgaW5wdXRQb3MgPSAzMjsgaW5wdXRQb3MgPCBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgaW5wdXRQb3MgKz0gMTYwLCBvdXRwdXRQb3MgKz0gMTYpIHtcbiAgICAgICAgZW5jcnlwdGVkRGF0YS5zZXQoZGVjb2RlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuY3J5cHRlZERhdGE7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0QXZjRGVjcnlwdGVkVW5pdCA9IGZ1bmN0aW9uIGdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpIHtcbiAgICAgIHZhciB1aW50OERlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICAgIHZhciBpbnB1dFBvcyA9IDA7XG4gICAgICBmb3IgKHZhciBvdXRwdXRQb3MgPSAzMjsgb3V0cHV0UG9zIDwgZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IG91dHB1dFBvcyArPSAxNjAsIGlucHV0UG9zICs9IDE2KSB7XG4gICAgICAgIGRlY29kZWREYXRhLnNldCh1aW50OERlY3J5cHRlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY29kZWREYXRhO1xuICAgIH07XG4gICAgX3Byb3RvLmRlY3J5cHRBdmNTYW1wbGUgPSBmdW5jdGlvbiBkZWNyeXB0QXZjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXgsIGNhbGxiYWNrLCBjdXJVbml0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBkZWNvZGVkRGF0YSA9IGRpc2NhcmRFUEIoY3VyVW5pdC5kYXRhKTtcbiAgICAgIHZhciBlbmNyeXB0ZWREYXRhID0gdGhpcy5nZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKTtcbiAgICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhLmJ1ZmZlcikudGhlbihmdW5jdGlvbiAoZGVjcnlwdGVkQnVmZmVyKSB7XG4gICAgICAgIGN1clVuaXQuZGF0YSA9IF90aGlzMi5nZXRBdmNEZWNyeXB0ZWRVbml0KGRlY29kZWREYXRhLCBkZWNyeXB0ZWRCdWZmZXIpO1xuICAgICAgICBpZiAoIV90aGlzMi5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgICBfdGhpczIuZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjcnlwdEF2Y1NhbXBsZXMgPSBmdW5jdGlvbiBkZWNyeXB0QXZjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaykge1xuICAgICAgaWYgKHNhbXBsZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY3J5cHQgc2FtcGxlcyBvZiB0eXBlIFVpbnQ4QXJyYXknKTtcbiAgICAgIH1cbiAgICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKywgdW5pdEluZGV4ID0gMCkge1xuICAgICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyVW5pdHMgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0cztcbiAgICAgICAgZm9yICg7OyB1bml0SW5kZXgrKykge1xuICAgICAgICAgIGlmICh1bml0SW5kZXggPj0gY3VyVW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGN1clVuaXQgPSBjdXJVbml0c1t1bml0SW5kZXhdO1xuICAgICAgICAgIGlmIChjdXJVbml0LmRhdGEubGVuZ3RoIDw9IDQ4IHx8IGN1clVuaXQudHlwZSAhPT0gMSAmJiBjdXJVbml0LnR5cGUgIT09IDUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmRlY3J5cHRBdmNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2ssIGN1clVuaXQpO1xuICAgICAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTYW1wbGVBZXNEZWNyeXB0ZXI7XG4gIH0oKTtcblxuICB2YXIgUEFDS0VUX0xFTkdUSCA9IDE4ODtcbiAgdmFyIFRTRGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVFNEZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgICB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IDA7XG4gICAgICB0aGlzLl9wbXRJZCA9IC0xO1xuICAgICAgdGhpcy5fdmlkZW9UcmFjayA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9pZDNUcmFjayA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX3R4dFRyYWNrID0gdm9pZCAwO1xuICAgICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgICAgdGhpcy52aWRlb1BhcnNlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICAgIHRoaXMudmlkZW9QYXJzZXIgPSBuZXcgQXZjVmlkZW9QYXJzZXIoKTtcbiAgICB9XG4gICAgVFNEZW11eGVyLnByb2JlID0gZnVuY3Rpb24gcHJvYmUoZGF0YSkge1xuICAgICAgdmFyIHN5bmNPZmZzZXQgPSBUU0RlbXV4ZXIuc3luY09mZnNldChkYXRhKTtcbiAgICAgIGlmIChzeW5jT2Zmc2V0ID4gMCkge1xuICAgICAgICBsb2dnZXIud2FybihcIk1QRUcyLVRTIGRldGVjdGVkIGJ1dCBmaXJzdCBzeW5jIHdvcmQgZm91bmQgQCBvZmZzZXQgXCIgKyBzeW5jT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzeW5jT2Zmc2V0ICE9PSAtMTtcbiAgICB9O1xuICAgIFRTRGVtdXhlci5zeW5jT2Zmc2V0ID0gZnVuY3Rpb24gc3luY09mZnNldChkYXRhKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB2YXIgc2NhbndpbmRvdyA9IE1hdGgubWluKFBBQ0tFVF9MRU5HVEggKiA1LCBsZW5ndGggLSBQQUNLRVRfTEVOR1RIKSArIDE7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IHNjYW53aW5kb3cpIHtcbiAgICAgICAgLy8gYSBUUyBpbml0IHNlZ21lbnQgc2hvdWxkIGNvbnRhaW4gYXQgbGVhc3QgMiBUUyBwYWNrZXRzOiBQQVQgYW5kIFBNVCwgZWFjaCBzdGFydGluZyB3aXRoIDB4NDdcbiAgICAgICAgdmFyIGZvdW5kUGF0ID0gZmFsc2U7XG4gICAgICAgIHZhciBwYWNrZXRTdGFydCA9IC0xO1xuICAgICAgICB2YXIgdHNQYWNrZXRzID0gMDtcbiAgICAgICAgZm9yICh2YXIgaiA9IGk7IGogPCBsZW5ndGg7IGogKz0gUEFDS0VUX0xFTkdUSCkge1xuICAgICAgICAgIGlmIChkYXRhW2pdID09PSAweDQ3ICYmIChsZW5ndGggLSBqID09PSBQQUNLRVRfTEVOR1RIIHx8IGRhdGFbaiArIFBBQ0tFVF9MRU5HVEhdID09PSAweDQ3KSkge1xuICAgICAgICAgICAgdHNQYWNrZXRzKys7XG4gICAgICAgICAgICBpZiAocGFja2V0U3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHBhY2tldFN0YXJ0ID0gajtcbiAgICAgICAgICAgICAgLy8gRmlyc3Qgc3luYyB3b3JkIGZvdW5kIGF0IG9mZnNldCwgaW5jcmVhc2Ugc2NhbiBsZW5ndGggKCM1MjUxKVxuICAgICAgICAgICAgICBpZiAocGFja2V0U3RhcnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICBzY2Fud2luZG93ID0gTWF0aC5taW4ocGFja2V0U3RhcnQgKyBQQUNLRVRfTEVOR1RIICogOTksIGRhdGEubGVuZ3RoIC0gUEFDS0VUX0xFTkdUSCkgKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kUGF0KSB7XG4gICAgICAgICAgICAgIGZvdW5kUGF0ID0gcGFyc2VQSUQoZGF0YSwgaikgPT09IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTeW5jIHdvcmQgZm91bmQgYXQgMCB3aXRoIDMgcGFja2V0cywgb3IgZm91bmQgYXQgb2Zmc2V0IGxlYXN0IDIgcGFja2V0cyB1cCB0byBzY2Fud2luZG93ICgjNTUwMSlcbiAgICAgICAgICAgIGlmIChmb3VuZFBhdCAmJiB0c1BhY2tldHMgPiAxICYmIChwYWNrZXRTdGFydCA9PT0gMCAmJiB0c1BhY2tldHMgPiAyIHx8IGogKyBQQUNLRVRfTEVOR1RIID4gc2NhbndpbmRvdykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhY2tldFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHNQYWNrZXRzKSB7XG4gICAgICAgICAgICAvLyBFeGl0IGlmIHN5bmMgd29yZCBmb3VuZCwgYnV0IGRvZXMgbm90IGNvbnRhaW4gY29udGlndW91cyBwYWNrZXRzXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRyYWNrIG1vZGVsIGludGVybmFsIHRvIGRlbXV4ZXIgdXNlZCB0byBkcml2ZSByZW11eGluZyBpbnB1dFxuICAgICAqLztcbiAgICBUU0RlbXV4ZXIuY3JlYXRlVHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVUcmFjayh0eXBlLCBkdXJhdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGFpbmVyOiB0eXBlID09PSAndmlkZW8nIHx8IHR5cGUgPT09ICdhdWRpbycgPyAndmlkZW8vbXAydCcgOiB1bmRlZmluZWQsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGlkOiBSZW11eGVyVHJhY2tJZENvbmZpZ1t0eXBlXSxcbiAgICAgICAgcGlkOiAtMSxcbiAgICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgICAgc2FtcGxlczogW10sXG4gICAgICAgIGRyb3BwZWQ6IDAsXG4gICAgICAgIGR1cmF0aW9uOiB0eXBlID09PSAnYXVkaW8nID8gZHVyYXRpb24gOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5pdCBzZWdtZW50IG9uIHRoZSBkZW11eGVyL3JlbXV4ZXIgaW50ZXJmYWNlLiBOZWVkZWQgZm9yIGRpc2NvbnRpbnVpdGllcy90cmFjay1zd2l0Y2hlcyAob3IgYXQgc3RyZWFtIHN0YXJ0KVxuICAgICAqIFJlc2V0cyBhbGwgaW50ZXJuYWwgdHJhY2sgaW5zdGFuY2VzIG9mIHRoZSBkZW11eGVyLlxuICAgICAqLztcbiAgICB2YXIgX3Byb3RvID0gVFNEZW11eGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICAgIHRoaXMucG10UGFyc2VkID0gZmFsc2U7XG4gICAgICB0aGlzLl9wbXRJZCA9IC0xO1xuICAgICAgdGhpcy5fdmlkZW9UcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndmlkZW8nKTtcbiAgICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soJ2F1ZGlvJywgdHJhY2tEdXJhdGlvbik7XG4gICAgICB0aGlzLl9pZDNUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygnaWQzJyk7XG4gICAgICB0aGlzLl90eHRUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndGV4dCcpO1xuICAgICAgdGhpcy5fYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPSAnYWFjJztcblxuICAgICAgLy8gZmx1c2ggYW55IHBhcnRpYWwgY29udGVudFxuICAgICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IHRyYWNrRHVyYXRpb247XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRUaW1lU3RhbXAgPSBmdW5jdGlvbiByZXNldFRpbWVTdGFtcCgpIHt9O1xuICAgIF9wcm90by5yZXNldENvbnRpZ3VpdHkgPSBmdW5jdGlvbiByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgICB2YXIgX2F1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgICBfdmlkZW9UcmFjayA9IHRoaXMuX3ZpZGVvVHJhY2ssXG4gICAgICAgIF9pZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrO1xuICAgICAgaWYgKF9hdWRpb1RyYWNrKSB7XG4gICAgICAgIF9hdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKF92aWRlb1RyYWNrKSB7XG4gICAgICAgIF92aWRlb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKF9pZDNUcmFjaykge1xuICAgICAgICBfaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVtdXggPSBmdW5jdGlvbiBkZW11eChkYXRhLCB0aW1lT2Zmc2V0LCBpc1NhbXBsZUFlcywgZmx1c2gpIHtcbiAgICAgIGlmIChpc1NhbXBsZUFlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlzU2FtcGxlQWVzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZmx1c2ggPT09IHZvaWQgMCkge1xuICAgICAgICBmbHVzaCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgcGVzO1xuICAgICAgdmFyIHZpZGVvVHJhY2sgPSB0aGlzLl92aWRlb1RyYWNrO1xuICAgICAgdmFyIGF1ZGlvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrO1xuICAgICAgdmFyIGlkM1RyYWNrID0gdGhpcy5faWQzVHJhY2s7XG4gICAgICB2YXIgdGV4dFRyYWNrID0gdGhpcy5fdHh0VHJhY2s7XG4gICAgICB2YXIgdmlkZW9QaWQgPSB2aWRlb1RyYWNrLnBpZDtcbiAgICAgIHZhciB2aWRlb0RhdGEgPSB2aWRlb1RyYWNrLnBlc0RhdGE7XG4gICAgICB2YXIgYXVkaW9QaWQgPSBhdWRpb1RyYWNrLnBpZDtcbiAgICAgIHZhciBpZDNQaWQgPSBpZDNUcmFjay5waWQ7XG4gICAgICB2YXIgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhO1xuICAgICAgdmFyIGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhO1xuICAgICAgdmFyIHVua25vd25QSUQgPSBudWxsO1xuICAgICAgdmFyIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkO1xuICAgICAgdmFyIHBtdElkID0gdGhpcy5fcG10SWQ7XG4gICAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhKSB7XG4gICAgICAgIGRhdGEgPSBhcHBlbmRVaW50OEFycmF5KHRoaXMucmVtYWluZGVyRGF0YSwgZGF0YSk7XG4gICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGxlbiA8IFBBQ0tFVF9MRU5HVEggJiYgIWZsdXNoKSB7XG4gICAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXVkaW9UcmFjazogYXVkaW9UcmFjayxcbiAgICAgICAgICB2aWRlb1RyYWNrOiB2aWRlb1RyYWNrLFxuICAgICAgICAgIGlkM1RyYWNrOiBpZDNUcmFjayxcbiAgICAgICAgICB0ZXh0VHJhY2s6IHRleHRUcmFja1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHN5bmNPZmZzZXQgPSBNYXRoLm1heCgwLCBUU0RlbXV4ZXIuc3luY09mZnNldChkYXRhKSk7XG4gICAgICBsZW4gLT0gKGxlbiAtIHN5bmNPZmZzZXQpICUgUEFDS0VUX0xFTkdUSDtcbiAgICAgIGlmIChsZW4gPCBkYXRhLmJ5dGVMZW5ndGggJiYgIWZsdXNoKSB7XG4gICAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBsZW4sIGRhdGEuYnVmZmVyLmJ5dGVMZW5ndGggLSBsZW4pO1xuICAgICAgfVxuXG4gICAgICAvLyBsb29wIHRocm91Z2ggVFMgcGFja2V0c1xuICAgICAgdmFyIHRzUGFja2V0RXJyb3JzID0gMDtcbiAgICAgIGZvciAodmFyIHN0YXJ0ID0gc3luY09mZnNldDsgc3RhcnQgPCBsZW47IHN0YXJ0ICs9IFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgICAgaWYgKGRhdGFbc3RhcnRdID09PSAweDQ3KSB7XG4gICAgICAgICAgdmFyIHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xuICAgICAgICAgIHZhciBwaWQgPSBwYXJzZVBJRChkYXRhLCBzdGFydCk7XG4gICAgICAgICAgdmFyIGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xuXG4gICAgICAgICAgLy8gaWYgYW4gYWRhcHRpb24gZmllbGQgaXMgcHJlc2VudCwgaXRzIGxlbmd0aCBpcyBzcGVjaWZpZWQgYnkgdGhlIGZpZnRoIGJ5dGUgb2YgdGhlIFRTIHBhY2tldCBoZWFkZXIuXG4gICAgICAgICAgdmFyIG9mZnNldCA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoYXRmID4gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnQgKyA1ICsgZGF0YVtzdGFydCArIDRdO1xuICAgICAgICAgICAgLy8gY29udGludWUgaWYgdGhlcmUgaXMgb25seSBhZGFwdGF0aW9uIGZpZWxkXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydCArIFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChwaWQpIHtcbiAgICAgICAgICAgIGNhc2UgdmlkZW9QaWQ6XG4gICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyh2aWRlb0RhdGEpKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy52aWRlb1BhcnNlci5wYXJzZUFWQ1BFUyh2aWRlb1RyYWNrLCB0ZXh0VHJhY2ssIHBlcywgZmFsc2UsIHRoaXMuX2R1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlkZW9EYXRhID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmlkZW9EYXRhKSB7XG4gICAgICAgICAgICAgICAgdmlkZW9EYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyBQQUNLRVRfTEVOR1RIKSk7XG4gICAgICAgICAgICAgICAgdmlkZW9EYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhdWRpb1BpZDpcbiAgICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FhYyc6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFBQ1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VNUEVHUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FjMyc6XG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFDM1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXVkaW9EYXRhID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYXVkaW9EYXRhKSB7XG4gICAgICAgICAgICAgICAgYXVkaW9EYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyBQQUNLRVRfTEVOR1RIKSk7XG4gICAgICAgICAgICAgICAgYXVkaW9EYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBpZDNQaWQ6XG4gICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZDNEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaWQzRGF0YSkge1xuICAgICAgICAgICAgICAgIGlkM0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgICBpZDNEYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG10SWQgPSB0aGlzLl9wbXRJZCA9IHBhcnNlUEFUKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1BNVCBQSUQ6JyAgKyB0aGlzLl9wbXRJZCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBwbXRJZDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBkYXRhW29mZnNldF0gKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkUElEcyA9IHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdGhpcy50eXBlU3VwcG9ydGVkLCBpc1NhbXBsZUFlcywgdGhpcy5vYnNlcnZlcik7XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSB0cmFjayBpZCBpZiB0cmFjayBQSUQgZm91bmQgd2hpbGUgcGFyc2luZyBQTVRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGF2b2lkIHJlc2V0dGluZyB0aGUgUElEIHRvIC0xIGluIGNhc2VcbiAgICAgICAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpbiBjYXNlIG9mIHRyYW5zaWVudCBtaXNzaW5nIGF1ZGlvIHNhbXBsZXMgZm9yIGV4YW1wbGVcbiAgICAgICAgICAgICAgICAvLyBOT1RFIHRoaXMgaXMgb25seSB0aGUgUElEIG9mIHRoZSB0cmFjayBhcyBmb3VuZCBpbiBUUyxcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgYXJlIG5vdCB1c2luZyB0aGlzIGZvciBNUDQgdHJhY2sgSURzLlxuICAgICAgICAgICAgICAgIHZpZGVvUGlkID0gcGFyc2VkUElEcy52aWRlb1BpZDtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW9QaWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICB2aWRlb1RyYWNrLnBpZCA9IHZpZGVvUGlkO1xuICAgICAgICAgICAgICAgICAgdmlkZW9UcmFjay5zZWdtZW50Q29kZWMgPSBwYXJzZWRQSURzLnNlZ21lbnRWaWRlb0NvZGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdWRpb1BpZCA9IHBhcnNlZFBJRHMuYXVkaW9QaWQ7XG4gICAgICAgICAgICAgICAgaWYgKGF1ZGlvUGlkID4gMCkge1xuICAgICAgICAgICAgICAgICAgYXVkaW9UcmFjay5waWQgPSBhdWRpb1BpZDtcbiAgICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2suc2VnbWVudENvZGVjID0gcGFyc2VkUElEcy5zZWdtZW50QXVkaW9Db2RlYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWQzUGlkID0gcGFyc2VkUElEcy5pZDNQaWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlkM1BpZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGlkM1RyYWNrLnBpZCA9IGlkM1BpZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVua25vd25QSUQgIT09IG51bGwgJiYgIXBtdFBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJNUEVHLVRTIFBNVCBmb3VuZCBhdCBcIiArIHN0YXJ0ICsgXCIgYWZ0ZXIgdW5rbm93biBQSUQgJ1wiICsgdW5rbm93blBJRCArIFwiJy4gQmFja3RyYWNraW5nIHRvIHN5bmMgYnl0ZSBAXCIgKyBzeW5jT2Zmc2V0ICsgXCIgdG8gcGFyc2UgYWxsIFRTIHBhY2tldHMuXCIpO1xuICAgICAgICAgICAgICAgICAgdW5rbm93blBJRCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAvLyB3ZSBzZXQgaXQgdG8gLTE4OCwgdGhlICs9IDE4OCBpbiB0aGUgZm9yIGxvb3Agd2lsbCByZXNldCBzdGFydCB0byAwXG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHN5bmNPZmZzZXQgLSAxODg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAweDExOlxuICAgICAgICAgICAgY2FzZSAweDFmZmY6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdW5rbm93blBJRCA9IHBpZDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRzUGFja2V0RXJyb3JzKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0c1BhY2tldEVycm9ycyA+IDApIHtcbiAgICAgICAgZW1pdFBhcnNpbmdFcnJvcih0aGlzLm9ic2VydmVyLCBuZXcgRXJyb3IoXCJGb3VuZCBcIiArIHRzUGFja2V0RXJyb3JzICsgXCIgVFMgcGFja2V0L3MgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCAweDQ3XCIpKTtcbiAgICAgIH1cbiAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IHZpZGVvRGF0YTtcbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBpZDNEYXRhO1xuICAgICAgdmFyIGRlbXV4UmVzdWx0ID0ge1xuICAgICAgICBhdWRpb1RyYWNrOiBhdWRpb1RyYWNrLFxuICAgICAgICB2aWRlb1RyYWNrOiB2aWRlb1RyYWNrLFxuICAgICAgICBpZDNUcmFjazogaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjazogdGV4dFRyYWNrXG4gICAgICB9O1xuICAgICAgaWYgKGZsdXNoKSB7XG4gICAgICAgIHRoaXMuZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMoZGVtdXhSZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbXV4UmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICB2YXIgcmVtYWluZGVyRGF0YSA9IHRoaXMucmVtYWluZGVyRGF0YTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHJlbWFpbmRlckRhdGEpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5kZW11eChyZW1haW5kZXJEYXRhLCAtMSwgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIHZpZGVvVHJhY2s6IHRoaXMuX3ZpZGVvVHJhY2ssXG4gICAgICAgICAgYXVkaW9UcmFjazogdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2ssXG4gICAgICAgICAgdGV4dFRyYWNrOiB0aGlzLl90eHRUcmFja1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5leHRyYWN0UmVtYWluaW5nU2FtcGxlcyhyZXN1bHQpO1xuICAgICAgaWYgKHRoaXMuc2FtcGxlQWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHQocmVzdWx0LCB0aGlzLnNhbXBsZUFlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzID0gZnVuY3Rpb24gZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMoZGVtdXhSZXN1bHQpIHtcbiAgICAgIHZhciBhdWRpb1RyYWNrID0gZGVtdXhSZXN1bHQuYXVkaW9UcmFjayxcbiAgICAgICAgdmlkZW9UcmFjayA9IGRlbXV4UmVzdWx0LnZpZGVvVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrID0gZGVtdXhSZXN1bHQuaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjayA9IGRlbXV4UmVzdWx0LnRleHRUcmFjaztcbiAgICAgIHZhciB2aWRlb0RhdGEgPSB2aWRlb1RyYWNrLnBlc0RhdGE7XG4gICAgICB2YXIgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhO1xuICAgICAgdmFyIGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhO1xuICAgICAgLy8gdHJ5IHRvIHBhcnNlIGxhc3QgUEVTIHBhY2tldHNcbiAgICAgIHZhciBwZXM7XG4gICAgICBpZiAodmlkZW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyh2aWRlb0RhdGEpKSkge1xuICAgICAgICB0aGlzLnZpZGVvUGFyc2VyLnBhcnNlQVZDUEVTKHZpZGVvVHJhY2ssIHRleHRUcmFjaywgcGVzLCB0cnVlLCB0aGlzLl9kdXJhdGlvbik7XG4gICAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlaXRoZXIgYXZjRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICAgIHZpZGVvVHJhY2sucGVzRGF0YSA9IHZpZGVvRGF0YTtcbiAgICAgIH1cbiAgICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpKSB7XG4gICAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgICAgdGhpcy5wYXJzZUFBQ1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICAgIHRoaXMucGFyc2VNUEVHUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhYzMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLnBhcnNlQUMzUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGF1ZGlvRGF0YSAhPSBudWxsICYmIGF1ZGlvRGF0YS5zaXplKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnbGFzdCBBQUMgUEVTIHBhY2tldCB0cnVuY2F0ZWQsbWlnaHQgb3ZlcmxhcCBiZXR3ZWVuIGZyYWdtZW50cycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZWl0aGVyIGF1ZGlvRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICAgIH1cbiAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgICAgdGhpcy5wYXJzZUlEM1BFUyhpZDNUcmFjaywgcGVzKTtcbiAgICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlaXRoZXIgaWQzRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBpZDNEYXRhO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmRlbXV4U2FtcGxlQWVzID0gZnVuY3Rpb24gZGVtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCkge1xuICAgICAgdmFyIGRlbXV4UmVzdWx0ID0gdGhpcy5kZW11eChkYXRhLCB0aW1lT2Zmc2V0LCB0cnVlLCAhdGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpO1xuICAgICAgdmFyIHNhbXBsZUFlcyA9IHRoaXMuc2FtcGxlQWVzID0gbmV3IFNhbXBsZUFlc0RlY3J5cHRlcih0aGlzLm9ic2VydmVyLCB0aGlzLmNvbmZpZywga2V5RGF0YSk7XG4gICAgICByZXR1cm4gdGhpcy5kZWNyeXB0KGRlbXV4UmVzdWx0LCBzYW1wbGVBZXMpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlY3J5cHQgPSBmdW5jdGlvbiBkZWNyeXB0KGRlbXV4UmVzdWx0LCBzYW1wbGVBZXMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICB2YXIgYXVkaW9UcmFjayA9IGRlbXV4UmVzdWx0LmF1ZGlvVHJhY2ssXG4gICAgICAgICAgdmlkZW9UcmFjayA9IGRlbXV4UmVzdWx0LnZpZGVvVHJhY2s7XG4gICAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMgJiYgYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgICAgc2FtcGxlQWVzLmRlY3J5cHRBYWNTYW1wbGVzKGF1ZGlvVHJhY2suc2FtcGxlcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmlkZW9UcmFjay5zYW1wbGVzKSB7XG4gICAgICAgICAgc2FtcGxlQWVzLmRlY3J5cHRBdmNTYW1wbGVzKHZpZGVvVHJhY2suc2FtcGxlcywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICAgIH07XG4gICAgX3Byb3RvLnBhcnNlQUFDUEVTID0gZnVuY3Rpb24gcGFyc2VBQUNQRVModHJhY2ssIHBlcykge1xuICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBhYWNPdmVyRmxvdyA9IHRoaXMuYWFjT3ZlckZsb3c7XG4gICAgICB2YXIgZGF0YSA9IHBlcy5kYXRhO1xuICAgICAgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgICAgICB2YXIgZnJhbWVNaXNzaW5nQnl0ZXMgPSBhYWNPdmVyRmxvdy5taXNzaW5nO1xuICAgICAgICB2YXIgc2FtcGxlTGVuZ3RoID0gYWFjT3ZlckZsb3cuc2FtcGxlLnVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDOiBhcHBlbmQgb3ZlcmZsb3dpbmcgJHtzYW1wbGVMZW5ndGh9IGJ5dGVzIHRvIGJlZ2lubmluZyBvZiBuZXcgUEVTYCk7XG4gICAgICAgIGlmIChmcmFtZU1pc3NpbmdCeXRlcyA9PT0gLTEpIHtcbiAgICAgICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheShhYWNPdmVyRmxvdy5zYW1wbGUudW5pdCwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZyYW1lT3ZlcmZsb3dCeXRlcyA9IHNhbXBsZUxlbmd0aCAtIGZyYW1lTWlzc2luZ0J5dGVzO1xuICAgICAgICAgIGFhY092ZXJGbG93LnNhbXBsZS51bml0LnNldChkYXRhLnN1YmFycmF5KDAsIGZyYW1lTWlzc2luZ0J5dGVzKSwgZnJhbWVPdmVyZmxvd0J5dGVzKTtcbiAgICAgICAgICB0cmFjay5zYW1wbGVzLnB1c2goYWFjT3ZlckZsb3cuc2FtcGxlKTtcbiAgICAgICAgICBzdGFydE9mZnNldCA9IGFhY092ZXJGbG93Lm1pc3Npbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGxvb2sgZm9yIEFEVFMgaGVhZGVyICgweEZGRngpXG4gICAgICB2YXIgb2Zmc2V0O1xuICAgICAgdmFyIGxlbjtcbiAgICAgIGZvciAob2Zmc2V0ID0gc3RhcnRPZmZzZXQsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgICBpZiAoaXNIZWFkZXIkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIEFEVFMgaGVhZGVyIGRvZXMgbm90IHN0YXJ0IHN0cmFpZ2h0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgUEVTIHBheWxvYWQsIHJhaXNlIGFuIGVycm9yXG4gICAgICBpZiAob2Zmc2V0ICE9PSBzdGFydE9mZnNldCkge1xuICAgICAgICB2YXIgcmVhc29uO1xuICAgICAgICB2YXIgcmVjb3ZlcmFibGUgPSBvZmZzZXQgPCBsZW4gLSAxO1xuICAgICAgICBpZiAocmVjb3ZlcmFibGUpIHtcbiAgICAgICAgICByZWFzb24gPSBcIkFBQyBQRVMgZGlkIG5vdCBzdGFydCB3aXRoIEFEVFMgaGVhZGVyLG9mZnNldDpcIiArIG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWFzb24gPSAnTm8gQURUUyBoZWFkZXIgZm91bmQgaW4gQUFDIFBFUyc7XG4gICAgICAgIH1cbiAgICAgICAgZW1pdFBhcnNpbmdFcnJvcih0aGlzLm9ic2VydmVyLCBuZXcgRXJyb3IocmVhc29uKSwgcmVjb3ZlcmFibGUpO1xuICAgICAgICBpZiAoIXJlY292ZXJhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbml0VHJhY2tDb25maWcodHJhY2ssIHRoaXMub2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgdGhpcy5hdWRpb0NvZGVjKTtcbiAgICAgIHZhciBwdHM7XG4gICAgICBpZiAocGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHB0cyA9IHBlcy5wdHM7XG4gICAgICB9IGVsc2UgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICAgIC8vIGlmIGxhc3QgQUFDIGZyYW1lIGlzIG92ZXJmbG93aW5nLCB3ZSBzaG91bGQgZW5zdXJlIHRpbWVzdGFtcHMgYXJlIGNvbnRpZ3VvdXM6XG4gICAgICAgIC8vIGZpcnN0IHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGZyYW1lRHVyYXRpb25cbiAgICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSBnZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuICAgICAgICBwdHMgPSBhYWNPdmVyRmxvdy5zYW1wbGUucHRzICsgZnJhbWVEdXJhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogQUFDIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHNjYW4gZm9yIGFhYyBzYW1wbGVzXG4gICAgICB2YXIgZnJhbWVJbmRleCA9IDA7XG4gICAgICB2YXIgZnJhbWU7XG4gICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICAgIGZyYW1lID0gYXBwZW5kRnJhbWUkMSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgpO1xuICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICBpZiAoIWZyYW1lLm1pc3NpbmcpIHtcbiAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgICAgZm9yICg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICAgICAgICBpZiAoaXNIZWFkZXIkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFhY092ZXJGbG93ID0gZnJhbWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5wYXJzZU1QRUdQRVMgPSBmdW5jdGlvbiBwYXJzZU1QRUdQRVModHJhY2ssIHBlcykge1xuICAgICAgdmFyIGRhdGEgPSBwZXMuZGF0YTtcbiAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgdmFyIHB0cyA9IHBlcy5wdHM7XG4gICAgICBpZiAocHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBNUEVHIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgdmFyIGZyYW1lID0gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm90aGluZyBmb3VuZCwga2VlcCBsb29raW5nXG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5wYXJzZUFDM1BFUyA9IGZ1bmN0aW9uIHBhcnNlQUMzUEVTKHRyYWNrLCBwZXMpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGRhdGEgPSBwZXMuZGF0YTtcbiAgICAgICAgdmFyIHB0cyA9IHBlcy5wdHM7XG4gICAgICAgIGlmIChwdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogQUMzIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHZhciBmcmFtZUluZGV4ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBwYXJzZWQ7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGggJiYgKHBhcnNlZCA9IF9hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCBwdHMsIGZyYW1lSW5kZXgrKykpID4gMCkge1xuICAgICAgICAgIG9mZnNldCArPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5wYXJzZUlEM1BFUyA9IGZ1bmN0aW9uIHBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpIHtcbiAgICAgIGlmIChwZXMucHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBJRDMgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpZDNTYW1wbGUgPSBfZXh0ZW5kcyh7fSwgcGVzLCB7XG4gICAgICAgIHR5cGU6IHRoaXMuX3ZpZGVvVHJhY2sgPyBNZXRhZGF0YVNjaGVtYS5lbXNnIDogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgIH0pO1xuICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKGlkM1NhbXBsZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVFNEZW11eGVyO1xuICB9KCk7XG4gIGZ1bmN0aW9uIHBhcnNlUElEKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIHBpZCBpcyBhIDEzLWJpdCBmaWVsZCBzdGFydGluZyBhdCB0aGUgbGFzdCBiaXQgb2YgVFNbMV1cbiAgICByZXR1cm4gKChkYXRhW29mZnNldCArIDFdICYgMHgxZikgPDwgOCkgKyBkYXRhW29mZnNldCArIDJdO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlUEFUKGRhdGEsIG9mZnNldCkge1xuICAgIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcbiAgICByZXR1cm4gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgxZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdHlwZVN1cHBvcnRlZCwgaXNTYW1wbGVBZXMsIG9ic2VydmVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGF1ZGlvUGlkOiAtMSxcbiAgICAgIHZpZGVvUGlkOiAtMSxcbiAgICAgIGlkM1BpZDogLTEsXG4gICAgICBzZWdtZW50VmlkZW9Db2RlYzogJ2F2YycsXG4gICAgICBzZWdtZW50QXVkaW9Db2RlYzogJ2FhYydcbiAgICB9O1xuICAgIHZhciBzZWN0aW9uTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAyXTtcbiAgICB2YXIgdGFibGVFbmQgPSBvZmZzZXQgKyAzICsgc2VjdGlvbkxlbmd0aCAtIDQ7XG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSB0YWJsZSBpcywgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvd1xuICAgIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcbiAgICB2YXIgcHJvZ3JhbUluZm9MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxMF0gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyAxMV07XG4gICAgLy8gYWR2YW5jZSB0aGUgb2Zmc2V0IHRvIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgbWFwcGluZyB0YWJsZVxuICAgIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICAgIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgICAgdmFyIHBpZCA9IHBhcnNlUElEKGRhdGEsIG9mZnNldCk7XG4gICAgICB2YXIgZXNJbmZvTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgM10gJiAweDBmKSA8PCA4IHwgZGF0YVtvZmZzZXQgKyA0XTtcbiAgICAgIHN3aXRjaCAoZGF0YVtvZmZzZXRdKSB7XG4gICAgICAgIGNhc2UgMHhjZjpcbiAgICAgICAgICAvLyBTQU1QTEUtQUVTIEFBQ1xuICAgICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICAgIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0oJ0FEVFMgQUFDJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAweDBmOlxuICAgICAgICAgIC8vIElTTy9JRUMgMTM4MTgtNyBBRFRTIEFBQyAoTVBFRy0yIGxvd2VyIGJpdC1yYXRlIGF1ZGlvKVxuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmIChyZXN1bHQuYXVkaW9QaWQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQuYXVkaW9QaWQgPSBwaWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIFBhY2tldGl6ZWQgbWV0YWRhdGEgKElEMylcbiAgICAgICAgY2FzZSAweDE1OlxuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ0lEMyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmIChyZXN1bHQuaWQzUGlkID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmlkM1BpZCA9IHBpZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHhkYjpcbiAgICAgICAgICAvLyBTQU1QTEUtQUVTIEFWQ1xuICAgICAgICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgICAgICAgIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0oJ0guMjY0Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAweDFiOlxuICAgICAgICAgIC8vIElUVS1UIFJlYy4gSC4yNjQgYW5kIElTTy9JRUMgMTQ0OTYtMTAgKGxvd2VyIGJpdC1yYXRlIHZpZGVvKVxuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ0FWQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmIChyZXN1bHQudmlkZW9QaWQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQudmlkZW9QaWQgPSBwaWQ7XG4gICAgICAgICAgICByZXN1bHQuc2VnbWVudFZpZGVvQ29kZWMgPSAnYXZjJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gSVNPL0lFQyAxMTE3Mi0zIChNUEVHLTEgYXVkaW8pXG4gICAgICAgIC8vIG9yIElTTy9JRUMgMTM4MTgtMyAoTVBFRy0yIGhhbHZlZCBzYW1wbGUgcmF0ZSBhdWRpbylcbiAgICAgICAgY2FzZSAweDAzOlxuICAgICAgICBjYXNlIDB4MDQ6XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnTVBFRyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICAgIGlmICghdHlwZVN1cHBvcnRlZC5tcGVnICYmICF0eXBlU3VwcG9ydGVkLm1wMykge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygnTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hdWRpb1BpZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hdWRpb1BpZCA9IHBpZDtcbiAgICAgICAgICAgIHJlc3VsdC5zZWdtZW50QXVkaW9Db2RlYyA9ICdtcDMnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweGMxOlxuICAgICAgICAgIC8vIFNBTVBMRS1BRVMgQUMzXG4gICAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgICAgbG9nRW5jcnlwdGVkU2FtcGxlc0ZvdW5kSW5VbmVuY3J5cHRlZFN0cmVhbSgnQUMtMycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgMHg4MTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXR5cGVTdXBwb3J0ZWQuYWMzKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coJ0FDLTMgYXVkaW8gZm91bmQsIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hdWRpb1BpZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmF1ZGlvUGlkID0gcGlkO1xuICAgICAgICAgICAgICByZXN1bHQuc2VnbWVudEF1ZGlvQ29kZWMgPSAnYWMzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwNjpcbiAgICAgICAgICAvLyBzdHJlYW1fdHlwZSA2IGNhbiBtZWFuIGEgbG90IG9mIGRpZmZlcmVudCB0aGluZ3MgaW4gY2FzZSBvZiBEVkIuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBsb29rIGF0IHRoZSBkZXNjcmlwdG9ycy4gUmlnaHQgbm93LCB3ZSdyZSBvbmx5IGludGVyZXN0ZWRcbiAgICAgICAgICAvLyBpbiBBQy0zIGF1ZGlvLCBzbyB3ZSBkbyB0aGUgZGVzY3JpcHRvciBwYXJzaW5nIG9ubHkgd2hlbiB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgLy8gYW4gYXVkaW8gUElEIHlldC5cbiAgICAgICAgICBpZiAocmVzdWx0LmF1ZGlvUGlkID09PSAtMSAmJiBlc0luZm9MZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VQb3MgPSBvZmZzZXQgKyA1O1xuICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IGVzSW5mb0xlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChyZW1haW5pbmcgPiAyKSB7XG4gICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9ySWQgPSBkYXRhW3BhcnNlUG9zXTtcbiAgICAgICAgICAgICAgc3dpdGNoIChkZXNjcmlwdG9ySWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDB4NmE6XG4gICAgICAgICAgICAgICAgICAvLyBEVkIgRGVzY3JpcHRvciBmb3IgQUMtM1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5hYzMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKCdBQy0zIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlciBmb3Igbm93Jyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmF1ZGlvUGlkID0gcGlkO1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZWdtZW50QXVkaW9Db2RlYyA9ICdhYzMnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvckxlbiA9IGRhdGFbcGFyc2VQb3MgKyAxXSArIDI7XG4gICAgICAgICAgICAgIHBhcnNlUG9zICs9IGRlc2NyaXB0b3JMZW47XG4gICAgICAgICAgICAgIHJlbWFpbmluZyAtPSBkZXNjcmlwdG9yTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweGMyOiAvLyBTQU1QTEUtQUVTIEVDM1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgMHg4NzpcbiAgICAgICAgICBlbWl0UGFyc2luZ0Vycm9yKG9ic2VydmVyLCBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIEVDLTMgaW4gTTJUUyBmb3VuZCcpKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBjYXNlIDB4MjQ6XG4gICAgICAgICAgZW1pdFBhcnNpbmdFcnJvcihvYnNlcnZlciwgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBIRVZDIGluIE0yVFMgZm91bmQnKSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgdGFibGUgZW50cnlcbiAgICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcbiAgICAgIG9mZnNldCArPSBlc0luZm9MZW5ndGggKyA1O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGVtaXRQYXJzaW5nRXJyb3Iob2JzZXJ2ZXIsIGVycm9yLCBsZXZlbFJldHJ5KSB7XG4gICAgbG9nZ2VyLndhcm4oXCJwYXJzaW5nIGVycm9yOiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgbGV2ZWxSZXRyeTogbGV2ZWxSZXRyeSxcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0odHlwZSkge1xuICAgIGxvZ2dlci5sb2codHlwZSArIFwiIHdpdGggQUVTLTEyOC1DQkMgZW5jcnlwdGlvbiBmb3VuZCBpbiB1bmVuY3J5cHRlZCBzdHJlYW1cIik7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VQRVMoc3RyZWFtKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBmcmFnO1xuICAgIHZhciBwZXNMZW47XG4gICAgdmFyIHBlc0hkckxlbjtcbiAgICB2YXIgcGVzUHRzO1xuICAgIHZhciBwZXNEdHM7XG4gICAgdmFyIGRhdGEgPSBzdHJlYW0uZGF0YTtcbiAgICAvLyBzYWZldHkgY2hlY2tcbiAgICBpZiAoIXN0cmVhbSB8fCBzdHJlYW0uc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gd2UgbWlnaHQgbmVlZCB1cCB0byAxOSBieXRlcyB0byByZWFkIFBFUyBoZWFkZXJcbiAgICAvLyBpZiBmaXJzdCBjaHVuayBvZiBkYXRhIGlzIGxlc3MgdGhhbiAxOSBieXRlcywgbGV0J3MgbWVyZ2UgaXQgd2l0aCBmb2xsb3dpbmcgb25lcyB1bnRpbCB3ZSBnZXQgMTkgYnl0ZXNcbiAgICAvLyB1c3VhbGx5IG9ubHkgb25lIG1lcmdlIGlzIG5lZWRlZCAoYW5kIHRoaXMgaXMgcmFyZSAuLi4pXG4gICAgd2hpbGUgKGRhdGFbMF0ubGVuZ3RoIDwgMTkgJiYgZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICBkYXRhWzBdID0gYXBwZW5kVWludDhBcnJheShkYXRhWzBdLCBkYXRhWzFdKTtcbiAgICAgIGRhdGEuc3BsaWNlKDEsIDEpO1xuICAgIH1cbiAgICAvLyByZXRyaWV2ZSBQVFMvRFRTIGZyb20gZmlyc3QgZnJhZ21lbnRcbiAgICBmcmFnID0gZGF0YVswXTtcbiAgICB2YXIgcGVzUHJlZml4ID0gKGZyYWdbMF0gPDwgMTYpICsgKGZyYWdbMV0gPDwgOCkgKyBmcmFnWzJdO1xuICAgIGlmIChwZXNQcmVmaXggPT09IDEpIHtcbiAgICAgIHBlc0xlbiA9IChmcmFnWzRdIDw8IDgpICsgZnJhZ1s1XTtcbiAgICAgIC8vIGlmIFBFUyBwYXJzZWQgbGVuZ3RoIGlzIG5vdCB6ZXJvIGFuZCBncmVhdGVyIHRoYW4gdG90YWwgcmVjZWl2ZWQgbGVuZ3RoLCBzdG9wIHBhcnNpbmcuIFBFUyBtaWdodCBiZSB0cnVuY2F0ZWRcbiAgICAgIC8vIG1pbnVzIDYgOiBQRVMgaGVhZGVyIHNpemVcbiAgICAgIGlmIChwZXNMZW4gJiYgcGVzTGVuID4gc3RyZWFtLnNpemUgLSA2KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHBlc0ZsYWdzID0gZnJhZ1s3XTtcbiAgICAgIGlmIChwZXNGbGFncyAmIDB4YzApIHtcbiAgICAgICAgLyogUEVTIGhlYWRlciBkZXNjcmliZWQgaGVyZSA6IGh0dHA6Ly9kdmQuc291cmNlZm9yZ2UubmV0L2R2ZGluZm8vcGVzLWhkci5odG1sXG4gICAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcbiAgICAgICAgICAgIGFzIEJpdHdpc2Ugb3BlcmF0b3JzIHRyZWF0IHRoZWlyIG9wZXJhbmRzIGFzIGEgc2VxdWVuY2Ugb2YgMzIgYml0cyAqL1xuICAgICAgICBwZXNQdHMgPSAoZnJhZ1s5XSAmIDB4MGUpICogNTM2ODcwOTEyICtcbiAgICAgICAgLy8gMSA8PCAyOVxuICAgICAgICAoZnJhZ1sxMF0gJiAweGZmKSAqIDQxOTQzMDQgK1xuICAgICAgICAvLyAxIDw8IDIyXG4gICAgICAgIChmcmFnWzExXSAmIDB4ZmUpICogMTYzODQgK1xuICAgICAgICAvLyAxIDw8IDE0XG4gICAgICAgIChmcmFnWzEyXSAmIDB4ZmYpICogMTI4ICtcbiAgICAgICAgLy8gMSA8PCA3XG4gICAgICAgIChmcmFnWzEzXSAmIDB4ZmUpIC8gMjtcbiAgICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xuICAgICAgICAgIHBlc0R0cyA9IChmcmFnWzE0XSAmIDB4MGUpICogNTM2ODcwOTEyICtcbiAgICAgICAgICAvLyAxIDw8IDI5XG4gICAgICAgICAgKGZyYWdbMTVdICYgMHhmZikgKiA0MTk0MzA0ICtcbiAgICAgICAgICAvLyAxIDw8IDIyXG4gICAgICAgICAgKGZyYWdbMTZdICYgMHhmZSkgKiAxNjM4NCArXG4gICAgICAgICAgLy8gMSA8PCAxNFxuICAgICAgICAgIChmcmFnWzE3XSAmIDB4ZmYpICogMTI4ICtcbiAgICAgICAgICAvLyAxIDw8IDdcbiAgICAgICAgICAoZnJhZ1sxOF0gJiAweGZlKSAvIDI7XG4gICAgICAgICAgaWYgKHBlc1B0cyAtIHBlc0R0cyA+IDYwICogOTAwMDApIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKE1hdGgucm91bmQoKHBlc1B0cyAtIHBlc0R0cykgLyA5MDAwMCkgKyBcInMgZGVsdGEgYmV0d2VlbiBQVFMgYW5kIERUUywgYWxpZ24gdGhlbVwiKTtcbiAgICAgICAgICAgIHBlc1B0cyA9IHBlc0R0cztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVzRHRzID0gcGVzUHRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZXNIZHJMZW4gPSBmcmFnWzhdO1xuICAgICAgLy8gOSBieXRlcyA6IDYgYnl0ZXMgZm9yIFBFUyBoZWFkZXIgKyAzIGJ5dGVzIGZvciBQRVMgZXh0ZW5zaW9uXG4gICAgICB2YXIgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gcGVzSGRyTGVuICsgOTtcbiAgICAgIGlmIChzdHJlYW0uc2l6ZSA8PSBwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBzdHJlYW0uc2l6ZSAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAvLyByZWFzc2VtYmxlIFBFUyBwYWNrZXRcbiAgICAgIHZhciBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGRhdGFMZW47IGorKykge1xuICAgICAgICBmcmFnID0gZGF0YVtqXTtcbiAgICAgICAgdmFyIGxlbiA9IGZyYWcuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCkge1xuICAgICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQgPiBsZW4pIHtcbiAgICAgICAgICAgIC8vIHRyaW0gZnVsbCBmcmFnIGlmIFBFUyBoZWFkZXIgYmlnZ2VyIHRoYW4gZnJhZ1xuICAgICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0IC09IGxlbjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0cmltIHBhcnRpYWwgZnJhZyBpZiBQRVMgaGVhZGVyIHNtYWxsZXIgdGhhbiBmcmFnXG4gICAgICAgICAgICBmcmFnID0gZnJhZy5zdWJhcnJheShwYXlsb2FkU3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgbGVuIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBlc0RhdGEuc2V0KGZyYWcsIGkpO1xuICAgICAgICBpICs9IGxlbjtcbiAgICAgIH1cbiAgICAgIGlmIChwZXNMZW4pIHtcbiAgICAgICAgLy8gcGF5bG9hZCBzaXplIDogcmVtb3ZlIFBFUyBoZWFkZXIgKyBQRVMgZXh0ZW5zaW9uXG4gICAgICAgIHBlc0xlbiAtPSBwZXNIZHJMZW4gKyAzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGVzRGF0YSxcbiAgICAgICAgcHRzOiBwZXNQdHMsXG4gICAgICAgIGR0czogcGVzRHRzLFxuICAgICAgICBsZW46IHBlc0xlblxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgTVAzRGVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VBdWRpb0RlbXV4ZXIpIHtcbiAgICBfaW5oZXJpdHNMb29zZShNUDNEZW11eGVyLCBfQmFzZUF1ZGlvRGVtdXhlcik7XG4gICAgZnVuY3Rpb24gTVAzRGVtdXhlcigpIHtcbiAgICAgIHJldHVybiBfQmFzZUF1ZGlvRGVtdXhlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBNUDNEZW11eGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVzZXRJbml0U2VnbWVudCA9IGZ1bmN0aW9uIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICAgIF9CYXNlQXVkaW9EZW11eGVyLnByb3RvdHlwZS5yZXNldEluaXRTZWdtZW50LmNhbGwodGhpcywgaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgICAgY29udGFpbmVyOiAnYXVkaW8vbXBlZycsXG4gICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgIGlkOiAyLFxuICAgICAgICBwaWQ6IC0xLFxuICAgICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgICAgc2VnbWVudENvZGVjOiAnbXAzJyxcbiAgICAgICAgc2FtcGxlczogW10sXG4gICAgICAgIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgICBpbnB1dFRpbWVTY2FsZTogOTAwMDAsXG4gICAgICAgIGRyb3BwZWQ6IDBcbiAgICAgIH07XG4gICAgfTtcbiAgICBNUDNEZW11eGVyLnByb2JlID0gZnVuY3Rpb24gcHJvYmUkMShkYXRhKSB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIE1QRUcgc3luYyB3b3JkXG4gICAgICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxuICAgICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcbiAgICAgIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG4gICAgICB2YXIgaWQzRGF0YSA9IGdldElEM0RhdGEoZGF0YSwgMCk7XG4gICAgICB2YXIgb2Zmc2V0ID0gKGlkM0RhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGlkM0RhdGEubGVuZ3RoKSB8fCAwO1xuXG4gICAgICAvLyBDaGVjayBmb3IgYWMtM3xlYy0zIHN5bmMgYnl0ZXMgYW5kIHJldHVybiBmYWxzZSBpZiBwcmVzZW50XG4gICAgICBpZiAoaWQzRGF0YSAmJiBkYXRhW29mZnNldF0gPT09IDB4MGIgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg3NyAmJiBnZXRUaW1lU3RhbXAoaWQzRGF0YSkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgLy8gY2hlY2sgdGhlIGJzaWQgdG8gY29uZmlybSBhYy0zIG9yIGVjLTMgKG5vdCBtcDMpXG4gICAgICBnZXRBdWRpb0JTSUQoZGF0YSwgb2Zmc2V0KSA8PSAxNikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgICBpZiAocHJvYmUoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgIGxvZ2dlci5sb2coJ01QRUcgQXVkaW8gc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLmNhblBhcnNlID0gZnVuY3Rpb24gY2FuUGFyc2UkMShkYXRhLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpO1xuICAgIH07XG4gICAgX3Byb3RvLmFwcGVuZEZyYW1lID0gZnVuY3Rpb24gYXBwZW5kRnJhbWUkMSh0cmFjaywgZGF0YSwgb2Zmc2V0KSB7XG4gICAgICBpZiAodGhpcy5iYXNlUFRTID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0LCB0aGlzLmJhc2VQVFMsIHRoaXMuZnJhbWVJbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gTVAzRGVtdXhlcjtcbiAgfShCYXNlQXVkaW9EZW11eGVyKTtcblxuICAvKipcbiAgICogIEFBQyBoZWxwZXJcbiAgICovXG4gIHZhciBBQUMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFBQygpIHt9XG4gICAgQUFDLmdldFNpbGVudEZyYW1lID0gZnVuY3Rpb24gZ2V0U2lsZW50RnJhbWUoY29kZWMsIGNoYW5uZWxDb3VudCkge1xuICAgICAgc3dpdGNoIChjb2RlYykge1xuICAgICAgICBjYXNlICdtcDRhLjQwLjInOlxuICAgICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMywgMHg4MF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MjEsIDB4MDAsIDB4NDksIDB4OTAsIDB4MDIsIDB4MTksIDB4MDAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCwgMHgwMCwgMHg4MCwgMHgyYywgMHg4MCwgMHgwOCwgMHgwMiwgMHgzOF0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MzhdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBoYW5kbGUgSEUtQUFDIGJlbG93IChtcDRhLjQwLjUgLyBtcDRhLjQwLjI5KVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg0ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDFjLCAweDYsIDB4ZjEsIDB4YzEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1ZV0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg1ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCwgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcmV0dXJuIEFBQztcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBNUDQgQm94XG4gICAqL1xuXG4gIHZhciBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcbiAgdmFyIE1QNCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTVA0KCkge31cbiAgICBNUDQuaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBNUDQudHlwZXMgPSB7XG4gICAgICAgIGF2YzE6IFtdLFxuICAgICAgICAvLyBjb2RpbmduYW1lXG4gICAgICAgIGF2Y0M6IFtdLFxuICAgICAgICBidHJ0OiBbXSxcbiAgICAgICAgZGluZjogW10sXG4gICAgICAgIGRyZWY6IFtdLFxuICAgICAgICBlc2RzOiBbXSxcbiAgICAgICAgZnR5cDogW10sXG4gICAgICAgIGhkbHI6IFtdLFxuICAgICAgICBtZGF0OiBbXSxcbiAgICAgICAgbWRoZDogW10sXG4gICAgICAgIG1kaWE6IFtdLFxuICAgICAgICBtZmhkOiBbXSxcbiAgICAgICAgbWluZjogW10sXG4gICAgICAgIG1vb2Y6IFtdLFxuICAgICAgICBtb292OiBbXSxcbiAgICAgICAgbXA0YTogW10sXG4gICAgICAgICcubXAzJzogW10sXG4gICAgICAgIGRhYzM6IFtdLFxuICAgICAgICAnYWMtMyc6IFtdLFxuICAgICAgICBtdmV4OiBbXSxcbiAgICAgICAgbXZoZDogW10sXG4gICAgICAgIHBhc3A6IFtdLFxuICAgICAgICBzZHRwOiBbXSxcbiAgICAgICAgc3RibDogW10sXG4gICAgICAgIHN0Y286IFtdLFxuICAgICAgICBzdHNjOiBbXSxcbiAgICAgICAgc3RzZDogW10sXG4gICAgICAgIHN0c3o6IFtdLFxuICAgICAgICBzdHRzOiBbXSxcbiAgICAgICAgdGZkdDogW10sXG4gICAgICAgIHRmaGQ6IFtdLFxuICAgICAgICB0cmFmOiBbXSxcbiAgICAgICAgdHJhazogW10sXG4gICAgICAgIHRydW46IFtdLFxuICAgICAgICB0cmV4OiBbXSxcbiAgICAgICAgdGtoZDogW10sXG4gICAgICAgIHZtaGQ6IFtdLFxuICAgICAgICBzbWhkOiBbXVxuICAgICAgfTtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpIGluIE1QNC50eXBlcykge1xuICAgICAgICBpZiAoTVA0LnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgTVA0LnR5cGVzW2ldID0gW2kuY2hhckNvZGVBdCgwKSwgaS5jaGFyQ29kZUF0KDEpLCBpLmNoYXJDb2RlQXQoMiksIGkuY2hhckNvZGVBdCgzKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB2aWRlb0hkbHIgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAgIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsXG4gICAgICAvLyBoYW5kbGVyX3R5cGU6ICd2aWRlJ1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHg1NiwgMHg2OSwgMHg2NCwgMHg2NSwgMHg2ZiwgMHg0OCwgMHg2MSwgMHg2ZSwgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xuICAgICAgXSk7XG4gICAgICB2YXIgYXVkaW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgICAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDczLCAweDZmLCAweDc1LCAweDZlLFxuICAgICAgLy8gaGFuZGxlcl90eXBlOiAnc291bidcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTMsIDB4NmYsIDB4NzUsIDB4NmUsIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcbiAgICAgIF0pO1xuICAgICAgTVA0LkhETFJfVFlQRVMgPSB7XG4gICAgICAgIHZpZGVvOiB2aWRlb0hkbHIsXG4gICAgICAgIGF1ZGlvOiBhdWRpb0hkbHJcbiAgICAgIH07XG4gICAgICB2YXIgZHJlZiA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgICAgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgICAvLyBlbnRyeV9jb3VudFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwYyxcbiAgICAgIC8vIGVudHJ5X3NpemVcbiAgICAgIDB4NzUsIDB4NzIsIDB4NmMsIDB4MjAsXG4gICAgICAvLyAndXJsJyB0eXBlXG4gICAgICAweDAwLFxuICAgICAgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAxIC8vIGVudHJ5X2ZsYWdzXG4gICAgICBdKTtcbiAgICAgIHZhciBzdGNvID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgICAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgICAgIF0pO1xuICAgICAgTVA0LlNUVFMgPSBNUDQuU1RTQyA9IE1QNC5TVENPID0gc3RjbztcbiAgICAgIE1QNC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgICAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBzYW1wbGVfc2l6ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBzYW1wbGVfY291bnRcbiAgICAgIF0pO1xuICAgICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAgIC8vIHZlcnNpb25cbiAgICAgIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgICAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGdyYXBoaWNzbW9kZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBvcGNvbG9yXG4gICAgICBdKTtcbiAgICAgIE1QNC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgICAvLyB2ZXJzaW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsXG4gICAgICAvLyBiYWxhbmNlXG4gICAgICAweDAwLCAweDAwIC8vIHJlc2VydmVkXG4gICAgICBdKTtcbiAgICAgIE1QNC5TVFNEID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgICAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMV0pOyAvLyBlbnRyeV9jb3VudFxuXG4gICAgICB2YXIgbWFqb3JCcmFuZCA9IG5ldyBVaW50OEFycmF5KFsxMDUsIDExNSwgMTExLCAxMDldKTsgLy8gaXNvbVxuICAgICAgdmFyIGF2YzFCcmFuZCA9IG5ldyBVaW50OEFycmF5KFs5NywgMTE4LCA5OSwgNDldKTsgLy8gYXZjMVxuICAgICAgdmFyIG1pbm9yVmVyc2lvbiA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAxXSk7XG4gICAgICBNUDQuRlRZUCA9IE1QNC5ib3goTVA0LnR5cGVzLmZ0eXAsIG1ham9yQnJhbmQsIG1pbm9yVmVyc2lvbiwgbWFqb3JCcmFuZCwgYXZjMUJyYW5kKTtcbiAgICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICAgIH07XG4gICAgTVA0LmJveCA9IGZ1bmN0aW9uIGJveCh0eXBlKSB7XG4gICAgICB2YXIgc2l6ZSA9IDg7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGF5bG9hZCA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHBheWxvYWRbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgdmFyIGkgPSBwYXlsb2FkLmxlbmd0aDtcbiAgICAgIHZhciBsZW4gPSBpO1xuICAgICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBzaXplIHdlIG5lZWQgdG8gYWxsb2NhdGVcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICByZXN1bHRbMF0gPSBzaXplID4+IDI0ICYgMHhmZjtcbiAgICAgIHJlc3VsdFsxXSA9IHNpemUgPj4gMTYgJiAweGZmO1xuICAgICAgcmVzdWx0WzJdID0gc2l6ZSA+PiA4ICYgMHhmZjtcbiAgICAgIHJlc3VsdFszXSA9IHNpemUgJiAweGZmO1xuICAgICAgcmVzdWx0LnNldCh0eXBlLCA0KTtcbiAgICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG4gICAgICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIGNvcHkgcGF5bG9hZFtpXSBhcnJheSBAIG9mZnNldCBzaXplXG4gICAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1QNC5oZGxyID0gZnVuY3Rpb24gaGRscih0eXBlKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICAgIH07XG4gICAgTVA0Lm1kYXQgPSBmdW5jdGlvbiBtZGF0KGRhdGEpIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGF0LCBkYXRhKTtcbiAgICB9O1xuICAgIE1QNC5tZGhkID0gZnVuY3Rpb24gbWRoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgICB2YXIgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICB2YXIgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWRoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgICAvLyB2ZXJzaW9uIDFcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMixcbiAgICAgIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgICAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgICAgdGltZXNjYWxlID4+IDI0ICYgMHhmZiwgdGltZXNjYWxlID4+IDE2ICYgMHhmZiwgdGltZXNjYWxlID4+IDggJiAweGZmLCB0aW1lc2NhbGUgJiAweGZmLFxuICAgICAgLy8gdGltZXNjYWxlXG4gICAgICB1cHBlcldvcmREdXJhdGlvbiA+PiAyNCwgdXBwZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiAyNCwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gJiAweGZmLCAweDU1LCAweGM0LFxuICAgICAgLy8gJ3VuZCcgbGFuZ3VhZ2UgKHVuZGV0ZXJtaW5lZClcbiAgICAgIDB4MDAsIDB4MDBdKSk7XG4gICAgfTtcbiAgICBNUDQubWRpYSA9IGZ1bmN0aW9uIG1kaWEodHJhY2spIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGlhLCBNUDQubWRoZCh0cmFjay50aW1lc2NhbGUsIHRyYWNrLmR1cmF0aW9uKSwgTVA0LmhkbHIodHJhY2sudHlwZSksIE1QNC5taW5mKHRyYWNrKSk7XG4gICAgfTtcbiAgICBNUDQubWZoZCA9IGZ1bmN0aW9uIG1maGQoc2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZmhkLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGZsYWdzXG4gICAgICBzZXF1ZW5jZU51bWJlciA+PiAyNCwgc2VxdWVuY2VOdW1iZXIgPj4gMTYgJiAweGZmLCBzZXF1ZW5jZU51bWJlciA+PiA4ICYgMHhmZiwgc2VxdWVuY2VOdW1iZXIgJiAweGZmIC8vIHNlcXVlbmNlX251bWJlclxuICAgICAgXSkpO1xuICAgIH07XG4gICAgTVA0Lm1pbmYgPSBmdW5jdGlvbiBtaW5mKHRyYWNrKSB7XG4gICAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMuc21oZCwgTVA0LlNNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5taW5mLCBNUDQuYm94KE1QNC50eXBlcy52bWhkLCBNUDQuVk1IRCksIE1QNC5ESU5GLCBNUDQuc3RibCh0cmFjaykpO1xuICAgICAgfVxuICAgIH07XG4gICAgTVA0Lm1vb2YgPSBmdW5jdGlvbiBtb29mKHNuLCBiYXNlTWVkaWFEZWNvZGVUaW1lLCB0cmFjaykge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1vb2YsIE1QNC5tZmhkKHNuKSwgTVA0LnRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpKTtcbiAgICB9O1xuICAgIE1QNC5tb292ID0gZnVuY3Rpb24gbW9vdih0cmFja3MpIHtcbiAgICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aDtcbiAgICAgIHZhciBib3hlcyA9IFtdO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBib3hlc1tpXSA9IE1QNC50cmFrKHRyYWNrc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUsIHRyYWNrc1swXS5kdXJhdGlvbildLmNvbmNhdChib3hlcykuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpKTtcbiAgICB9O1xuICAgIE1QNC5tdmV4ID0gZnVuY3Rpb24gbXZleCh0cmFja3MpIHtcbiAgICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aDtcbiAgICAgIHZhciBib3hlcyA9IFtdO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBib3hlc1tpXSA9IE1QNC50cmV4KHRyYWNrc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm12ZXhdLmNvbmNhdChib3hlcykpO1xuICAgIH07XG4gICAgTVA0Lm12aGQgPSBmdW5jdGlvbiBtdmhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICAgIGR1cmF0aW9uICo9IHRpbWVzY2FsZTtcbiAgICAgIHZhciB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgIHZhciBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgICAgLy8gdmVyc2lvbiAxXG4gICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgICAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAzLFxuICAgICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgIHRpbWVzY2FsZSA+PiAyNCAmIDB4ZmYsIHRpbWVzY2FsZSA+PiAxNiAmIDB4ZmYsIHRpbWVzY2FsZSA+PiA4ICYgMHhmZiwgdGltZXNjYWxlICYgMHhmZixcbiAgICAgIC8vIHRpbWVzY2FsZVxuICAgICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIDEuMCByYXRlXG4gICAgICAweDAxLCAweDAwLFxuICAgICAgLy8gMS4wIHZvbHVtZVxuICAgICAgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHg0MCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiAvLyBuZXh0X3RyYWNrX0lEXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tdmhkLCBieXRlcyk7XG4gICAgfTtcbiAgICBNUDQuc2R0cCA9IGZ1bmN0aW9uIHNkdHAodHJhY2spIHtcbiAgICAgIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KDQgKyBzYW1wbGVzLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBmbGFncztcbiAgICAgIC8vIGxlYXZlIHRoZSBmdWxsIGJveCBoZWFkZXIgKDQgYnl0ZXMpIGFsbCB6ZXJvXG4gICAgICAvLyB3cml0ZSB0aGUgc2FtcGxlIHRhYmxlXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbGFncyA9IHNhbXBsZXNbaV0uZmxhZ3M7XG4gICAgICAgIGJ5dGVzW2kgKyA0XSA9IGZsYWdzLmRlcGVuZHNPbiA8PCA0IHwgZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDIgfCBmbGFncy5oYXNSZWR1bmRhbmN5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnNkdHAsIGJ5dGVzKTtcbiAgICB9O1xuICAgIE1QNC5zdGJsID0gZnVuY3Rpb24gc3RibCh0cmFjaykge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0YmwsIE1QNC5zdHNkKHRyYWNrKSwgTVA0LmJveChNUDQudHlwZXMuc3R0cywgTVA0LlNUVFMpLCBNUDQuYm94KE1QNC50eXBlcy5zdHNjLCBNUDQuU1RTQyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c3osIE1QNC5TVFNaKSwgTVA0LmJveChNUDQudHlwZXMuc3RjbywgTVA0LlNUQ08pKTtcbiAgICB9O1xuICAgIE1QNC5hdmMxID0gZnVuY3Rpb24gYXZjMSh0cmFjaykge1xuICAgICAgdmFyIHNwcyA9IFtdO1xuICAgICAgdmFyIHBwcyA9IFtdO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIHZhciBsZW47XG4gICAgICAvLyBhc3NlbWJsZSB0aGUgU1BTc1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2suc3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGEgPSB0cmFjay5zcHNbaV07XG4gICAgICAgIGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgc3BzLnB1c2gobGVuID4+PiA4ICYgMHhmZik7XG4gICAgICAgIHNwcy5wdXNoKGxlbiAmIDB4ZmYpO1xuXG4gICAgICAgIC8vIFNQU1xuICAgICAgICBzcHMgPSBzcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXNzZW1ibGUgdGhlIFBQU3NcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5wcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YSA9IHRyYWNrLnBwc1tpXTtcbiAgICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICBwcHMucHVzaChsZW4gPj4+IDggJiAweGZmKTtcbiAgICAgICAgcHBzLnB1c2gobGVuICYgMHhmZik7XG4gICAgICAgIHBwcyA9IHBwcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSkpO1xuICAgICAgfVxuICAgICAgdmFyIGF2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5hdmNDLCBuZXcgVWludDhBcnJheShbMHgwMSxcbiAgICAgIC8vIHZlcnNpb25cbiAgICAgIHNwc1szXSxcbiAgICAgIC8vIHByb2ZpbGVcbiAgICAgIHNwc1s0XSxcbiAgICAgIC8vIHByb2ZpbGUgY29tcGF0XG4gICAgICBzcHNbNV0sXG4gICAgICAvLyBsZXZlbFxuICAgICAgMHhmYyB8IDMsXG4gICAgICAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xuICAgICAgMHhlMCB8IHRyYWNrLnNwcy5sZW5ndGggLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgICBdLmNvbmNhdChzcHMpLmNvbmNhdChbdHJhY2sucHBzLmxlbmd0aCAvLyBudW1PZlBpY3R1cmVQYXJhbWV0ZXJTZXRzXG4gICAgICBdKS5jb25jYXQocHBzKSkpOyAvLyBcIlBQU1wiXG4gICAgICB2YXIgd2lkdGggPSB0cmFjay53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSB0cmFjay5oZWlnaHQ7XG4gICAgICB2YXIgaFNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzBdO1xuICAgICAgdmFyIHZTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1sxXTtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5hdmMxLCBuZXcgVWludDhBcnJheShbMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDEsXG4gICAgICAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgICAgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBwcmVfZGVmaW5lZFxuICAgICAgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZixcbiAgICAgIC8vIHdpZHRoXG4gICAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsXG4gICAgICAvLyBoZWlnaHRcbiAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBob3JpenJlc29sdXRpb25cbiAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsXG4gICAgICAvLyB2ZXJ0cmVzb2x1dGlvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLFxuICAgICAgLy8gZnJhbWVfY291bnRcbiAgICAgIDB4MTIsIDB4NjQsIDB4NjEsIDB4NjksIDB4NmMsXG4gICAgICAvLyBkYWlseW1vdGlvbi9obHMuanNcbiAgICAgIDB4NzksIDB4NmQsIDB4NmYsIDB4NzQsIDB4NjksIDB4NmYsIDB4NmUsIDB4MmYsIDB4NjgsIDB4NmMsIDB4NzMsIDB4MmUsIDB4NmEsIDB4NzMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBjb21wcmVzc29ybmFtZVxuICAgICAgMHgwMCwgMHgxOCxcbiAgICAgIC8vIGRlcHRoID0gMjRcbiAgICAgIDB4MTEsIDB4MTFdKSxcbiAgICAgIC8vIHByZV9kZWZpbmVkID0gLTFcbiAgICAgIGF2Y2MsIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDFjLCAweDljLCAweDgwLFxuICAgICAgLy8gYnVmZmVyU2l6ZURCXG4gICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwLFxuICAgICAgLy8gbWF4Qml0cmF0ZVxuICAgICAgMHgwMCwgMHgyZCwgMHhjNiwgMHhjMF0pKSxcbiAgICAgIC8vIGF2Z0JpdHJhdGVcbiAgICAgIE1QNC5ib3goTVA0LnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtoU3BhY2luZyA+PiAyNCxcbiAgICAgIC8vIGhTcGFjaW5nXG4gICAgICBoU3BhY2luZyA+PiAxNiAmIDB4ZmYsIGhTcGFjaW5nID4+IDggJiAweGZmLCBoU3BhY2luZyAmIDB4ZmYsIHZTcGFjaW5nID4+IDI0LFxuICAgICAgLy8gdlNwYWNpbmdcbiAgICAgIHZTcGFjaW5nID4+IDE2ICYgMHhmZiwgdlNwYWNpbmcgPj4gOCAmIDB4ZmYsIHZTcGFjaW5nICYgMHhmZl0pKSk7XG4gICAgfTtcbiAgICBNUDQuZXNkcyA9IGZ1bmN0aW9uIGVzZHModHJhY2spIHtcbiAgICAgIHZhciBjb25maWdsZW4gPSB0cmFjay5jb25maWcubGVuZ3RoO1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgICAgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gZmxhZ3NcblxuICAgICAgMHgwMyxcbiAgICAgIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgMHgxNyArIGNvbmZpZ2xlbixcbiAgICAgIC8vIGxlbmd0aFxuICAgICAgMHgwMCwgMHgwMSxcbiAgICAgIC8vIGVzX2lkXG4gICAgICAweDAwLFxuICAgICAgLy8gc3RyZWFtX3ByaW9yaXR5XG5cbiAgICAgIDB4MDQsXG4gICAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIDB4MGYgKyBjb25maWdsZW4sXG4gICAgICAvLyBsZW5ndGhcbiAgICAgIDB4NDAsXG4gICAgICAvLyBjb2RlYyA6IG1wZWc0X2F1ZGlvXG4gICAgICAweDE1LFxuICAgICAgLy8gc3RyZWFtX3R5cGVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBidWZmZXJfc2l6ZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIG1heEJpdHJhdGVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBhdmdCaXRyYXRlXG5cbiAgICAgIDB4MDUgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICBdLmNvbmNhdChbY29uZmlnbGVuXSkuY29uY2F0KHRyYWNrLmNvbmZpZykuY29uY2F0KFsweDA2LCAweDAxLCAweDAyXSkpOyAvLyBHQVNwZWNpZmljQ29uZmlnKSk7IC8vIGxlbmd0aCArIGF1ZGlvIGNvbmZpZyBkZXNjcmlwdG9yXG4gICAgfTtcbiAgICBNUDQuYXVkaW9TdHNkID0gZnVuY3Rpb24gYXVkaW9TdHNkKHRyYWNrKSB7XG4gICAgICB2YXIgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLFxuICAgICAgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LFxuICAgICAgLy8gY2hhbm5lbGNvdW50XG4gICAgICAweDAwLCAweDEwLFxuICAgICAgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZDJcbiAgICAgIHNhbXBsZXJhdGUgPj4gOCAmIDB4ZmYsIHNhbXBsZXJhdGUgJiAweGZmLFxuICAgICAgLy9cbiAgICAgIDB4MDAsIDB4MDBdKTtcbiAgICB9O1xuICAgIE1QNC5tcDRhID0gZnVuY3Rpb24gbXA0YSh0cmFjaykge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1wNGEsIE1QNC5hdWRpb1N0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5lc2RzLCBNUDQuZXNkcyh0cmFjaykpKTtcbiAgICB9O1xuICAgIE1QNC5tcDMgPSBmdW5jdGlvbiBtcDModHJhY2spIHtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlc1snLm1wMyddLCBNUDQuYXVkaW9TdHNkKHRyYWNrKSk7XG4gICAgfTtcbiAgICBNUDQuYWMzID0gZnVuY3Rpb24gYWMzKHRyYWNrKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXNbJ2FjLTMnXSwgTVA0LmF1ZGlvU3RzZCh0cmFjayksIE1QNC5ib3goTVA0LnR5cGVzLmRhYzMsIHRyYWNrLmNvbmZpZykpO1xuICAgIH07XG4gICAgTVA0LnN0c2QgPSBmdW5jdGlvbiBzdHNkKHRyYWNrKSB7XG4gICAgICBpZiAodHJhY2sudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBpZiAodHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0cmFjay5jb2RlYyA9PT0gJ21wMycpIHtcbiAgICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5tcDModHJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2suc2VnbWVudENvZGVjID09PSAnYWMzJykge1xuICAgICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0LmFjMyh0cmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wNGEodHJhY2spKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0LmF2YzEodHJhY2spKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIE1QNC50a2hkID0gZnVuY3Rpb24gdGtoZCh0cmFjaykge1xuICAgICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgICB2YXIgZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiAqIHRyYWNrLnRpbWVzY2FsZTtcbiAgICAgIHZhciB3aWR0aCA9IHRyYWNrLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICAgIHZhciB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgIHZhciBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50a2hkLCBuZXcgVWludDhBcnJheShbMHgwMSxcbiAgICAgIC8vIHZlcnNpb24gMVxuICAgICAgMHgwMCwgMHgwMCwgMHgwNyxcbiAgICAgIC8vIGZsYWdzXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAyLFxuICAgICAgLy8gY3JlYXRpb25fdGltZVxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMyxcbiAgICAgIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICBpZCA+PiAyNCAmIDB4ZmYsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZixcbiAgICAgIC8vIHRyYWNrX0lEXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIHVwcGVyV29yZER1cmF0aW9uID4+IDI0LCB1cHBlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LCBsb3dlcldvcmREdXJhdGlvbiA+PiAxNiAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uID4+IDggJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGxheWVyXG4gICAgICAweDAwLCAweDAwLFxuICAgICAgLy8gYWx0ZXJuYXRlX2dyb3VwXG4gICAgICAweDAwLCAweDAwLFxuICAgICAgLy8gbm9uLWF1ZGlvIHRyYWNrIHZvbHVtZVxuICAgICAgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgICAgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZiwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIHdpZHRoXG4gICAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsIDB4MDAsIDB4MDAgLy8gaGVpZ2h0XG4gICAgICBdKSk7XG4gICAgfTtcbiAgICBNUDQudHJhZiA9IGZ1bmN0aW9uIHRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICAgIHZhciBzYW1wbGVEZXBlbmRlbmN5VGFibGUgPSBNUDQuc2R0cCh0cmFjayk7XG4gICAgICB2YXIgaWQgPSB0cmFjay5pZDtcbiAgICAgIHZhciB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICB2YXIgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWYsIE1QNC5ib3goTVA0LnR5cGVzLnRmaGQsIG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgICAgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLCAweDAwLCAweDAwLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYgLy8gdHJhY2tfSURcbiAgICAgIF0pKSwgTVA0LmJveChNUDQudHlwZXMudGZkdCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgICAvLyB2ZXJzaW9uIDFcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNiAmIDB4ZmYsIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gOCAmIDB4ZmYsIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDI0LCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4ICYgMHhmZiwgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4ZmZdKSksIE1QNC50cnVuKHRyYWNrLCBzYW1wbGVEZXBlbmRlbmN5VGFibGUubGVuZ3RoICsgMTYgK1xuICAgICAgLy8gdGZoZFxuICAgICAgMjAgK1xuICAgICAgLy8gdGZkdFxuICAgICAgOCArXG4gICAgICAvLyB0cmFmIGhlYWRlclxuICAgICAgMTYgK1xuICAgICAgLy8gbWZoZFxuICAgICAgOCArXG4gICAgICAvLyBtb29mIGhlYWRlclxuICAgICAgOCksXG4gICAgICAvLyBtZGF0IGhlYWRlclxuICAgICAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHRyYWNrIGJveC5cbiAgICAgKiBAcGFyYW0gdHJhY2sgYSB0cmFjayBkZWZpbml0aW9uXG4gICAgICovO1xuICAgIE1QNC50cmFrID0gZnVuY3Rpb24gdHJhayh0cmFjaykge1xuICAgICAgdHJhY2suZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiB8fCAweGZmZmZmZmZmO1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRyYWssIE1QNC50a2hkKHRyYWNrKSwgTVA0Lm1kaWEodHJhY2spKTtcbiAgICB9O1xuICAgIE1QNC50cmV4ID0gZnVuY3Rpb24gdHJleCh0cmFjaykge1xuICAgICAgdmFyIGlkID0gdHJhY2suaWQ7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJleCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgICAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgaWQgPj4gMjQsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZixcbiAgICAgIC8vIHRyYWNrX0lEXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLFxuICAgICAgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIC8vIGRlZmF1bHRfc2FtcGxlX3NpemVcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDEgLy8gZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICAgIF0pKTtcbiAgICB9O1xuICAgIE1QNC50cnVuID0gZnVuY3Rpb24gdHJ1bih0cmFjaywgb2Zmc2V0KSB7XG4gICAgICB2YXIgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW107XG4gICAgICB2YXIgbGVuID0gc2FtcGxlcy5sZW5ndGg7XG4gICAgICB2YXIgYXJyYXlsZW4gPSAxMiArIDE2ICogbGVuO1xuICAgICAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlsZW4pO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgc2FtcGxlO1xuICAgICAgdmFyIGR1cmF0aW9uO1xuICAgICAgdmFyIHNpemU7XG4gICAgICB2YXIgZmxhZ3M7XG4gICAgICB2YXIgY3RzO1xuICAgICAgb2Zmc2V0ICs9IDggKyBhcnJheWxlbjtcbiAgICAgIGFycmF5LnNldChbdHJhY2sudHlwZSA9PT0gJ3ZpZGVvJyA/IDB4MDEgOiAweDAwLFxuICAgICAgLy8gdmVyc2lvbiAxIGZvciB2aWRlbyB3aXRoIHNpZ25lZC1pbnQgc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICAweDAwLCAweDBmLCAweDAxLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIGxlbiA+Pj4gMjQgJiAweGZmLCBsZW4gPj4+IDE2ICYgMHhmZiwgbGVuID4+PiA4ICYgMHhmZiwgbGVuICYgMHhmZixcbiAgICAgIC8vIHNhbXBsZV9jb3VudFxuICAgICAgb2Zmc2V0ID4+PiAyNCAmIDB4ZmYsIG9mZnNldCA+Pj4gMTYgJiAweGZmLCBvZmZzZXQgPj4+IDggJiAweGZmLCBvZmZzZXQgJiAweGZmIC8vIGRhdGFfb2Zmc2V0XG4gICAgICBdLCAwKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgICBkdXJhdGlvbiA9IHNhbXBsZS5kdXJhdGlvbjtcbiAgICAgICAgc2l6ZSA9IHNhbXBsZS5zaXplO1xuICAgICAgICBmbGFncyA9IHNhbXBsZS5mbGFncztcbiAgICAgICAgY3RzID0gc2FtcGxlLmN0cztcbiAgICAgICAgYXJyYXkuc2V0KFtkdXJhdGlvbiA+Pj4gMjQgJiAweGZmLCBkdXJhdGlvbiA+Pj4gMTYgJiAweGZmLCBkdXJhdGlvbiA+Pj4gOCAmIDB4ZmYsIGR1cmF0aW9uICYgMHhmZixcbiAgICAgICAgLy8gc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgIHNpemUgPj4+IDI0ICYgMHhmZiwgc2l6ZSA+Pj4gMTYgJiAweGZmLCBzaXplID4+PiA4ICYgMHhmZiwgc2l6ZSAmIDB4ZmYsXG4gICAgICAgIC8vIHNhbXBsZV9zaXplXG4gICAgICAgIGZsYWdzLmlzTGVhZGluZyA8PCAyIHwgZmxhZ3MuZGVwZW5kc09uLCBmbGFncy5pc0RlcGVuZGVkT24gPDwgNiB8IGZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCB8IGZsYWdzLnBhZGRpbmdWYWx1ZSA8PCAxIHwgZmxhZ3MuaXNOb25TeW5jLCBmbGFncy5kZWdyYWRQcmlvICYgMHhmMCA8PCA4LCBmbGFncy5kZWdyYWRQcmlvICYgMHgwZixcbiAgICAgICAgLy8gc2FtcGxlX2ZsYWdzXG4gICAgICAgIGN0cyA+Pj4gMjQgJiAweGZmLCBjdHMgPj4+IDE2ICYgMHhmZiwgY3RzID4+PiA4ICYgMHhmZiwgY3RzICYgMHhmZiAvLyBzYW1wbGVfY29tcG9zaXRpb25fdGltZV9vZmZzZXRcbiAgICAgICAgXSwgMTIgKyAxNiAqIGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnRydW4sIGFycmF5KTtcbiAgICB9O1xuICAgIE1QNC5pbml0U2VnbWVudCA9IGZ1bmN0aW9uIGluaXRTZWdtZW50KHRyYWNrcykge1xuICAgICAgaWYgKCFNUDQudHlwZXMpIHtcbiAgICAgICAgTVA0LmluaXQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBtb3ZpZSA9IE1QNC5tb292KHRyYWNrcyk7XG4gICAgICB2YXIgcmVzdWx0ID0gYXBwZW5kVWludDhBcnJheShNUDQuRlRZUCwgbW92aWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBNUDQ7XG4gIH0oKTtcbiAgTVA0LnR5cGVzID0gdm9pZCAwO1xuICBNUDQuSERMUl9UWVBFUyA9IHZvaWQgMDtcbiAgTVA0LlNUVFMgPSB2b2lkIDA7XG4gIE1QNC5TVFNDID0gdm9pZCAwO1xuICBNUDQuU1RDTyA9IHZvaWQgMDtcbiAgTVA0LlNUU1ogPSB2b2lkIDA7XG4gIE1QNC5WTUhEID0gdm9pZCAwO1xuICBNUDQuU01IRCA9IHZvaWQgMDtcbiAgTVA0LlNUU0QgPSB2b2lkIDA7XG4gIE1QNC5GVFlQID0gdm9pZCAwO1xuICBNUDQuRElORiA9IHZvaWQgMDtcblxuICB2YXIgTVBFR19UU19DTE9DS19GUkVRX0haID0gOTAwMDA7XG4gIGZ1bmN0aW9uIHRvVGltZXNjYWxlRnJvbUJhc2UoYmFzZVRpbWUsIGRlc3RTY2FsZSwgc3JjQmFzZSwgcm91bmQpIHtcbiAgICBpZiAoc3JjQmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzcmNCYXNlID0gMTtcbiAgICB9XG4gICAgaWYgKHJvdW5kID09PSB2b2lkIDApIHtcbiAgICAgIHJvdW5kID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBiYXNlVGltZSAqIGRlc3RTY2FsZSAqIHNyY0Jhc2U7IC8vIGVxdWl2YWxlbnQgdG8gYCh2YWx1ZSAqIHNjYWxlKSAvICgxIC8gYmFzZSlgXG4gICAgcmV0dXJuIHJvdW5kID8gTWF0aC5yb3VuZChyZXN1bHQpIDogcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIHRvVGltZXNjYWxlRnJvbVNjYWxlKGJhc2VUaW1lLCBkZXN0U2NhbGUsIHNyY1NjYWxlLCByb3VuZCkge1xuICAgIGlmIChzcmNTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzcmNTY2FsZSA9IDE7XG4gICAgfVxuICAgIGlmIChyb3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgICByb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZShiYXNlVGltZSwgZGVzdFNjYWxlLCAxIC8gc3JjU2NhbGUsIHJvdW5kKTtcbiAgfVxuICBmdW5jdGlvbiB0b01zRnJvbU1wZWdUc0Nsb2NrKGJhc2VUaW1lLCByb3VuZCkge1xuICAgIGlmIChyb3VuZCA9PT0gdm9pZCAwKSB7XG4gICAgICByb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZShiYXNlVGltZSwgMTAwMCwgMSAvIE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiwgcm91bmQpO1xuICB9XG4gIGZ1bmN0aW9uIHRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlKGJhc2VUaW1lLCBzcmNTY2FsZSkge1xuICAgIGlmIChzcmNTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzcmNTY2FsZSA9IDE7XG4gICAgfVxuICAgIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCBNUEVHX1RTX0NMT0NLX0ZSRVFfSFosIDEgLyBzcmNTY2FsZSk7XG4gIH1cblxuICB2YXIgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiA9IDEwICogMTAwMDsgLy8gMTAgc2Vjb25kc1xuICB2YXIgQUFDX1NBTVBMRVNfUEVSX0ZSQU1FID0gMTAyNDtcbiAgdmFyIE1QRUdfQVVESU9fU0FNUExFX1BFUl9GUkFNRSA9IDExNTI7XG4gIHZhciBBQzNfU0FNUExFU19QRVJfRlJBTUUgPSAxNTM2O1xuICB2YXIgY2hyb21lVmVyc2lvbiA9IG51bGw7XG4gIHZhciBzYWZhcmlXZWJraXRWZXJzaW9uID0gbnVsbDtcbiAgdmFyIE1QNFJlbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1QNFJlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdmVuZG9yKSB7XG4gICAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDA7XG4gICAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9pbml0UFRTID0gbnVsbDtcbiAgICAgIHRoaXMuX2luaXREVFMgPSBudWxsO1xuICAgICAgdGhpcy5uZXh0QXZjRHRzID0gbnVsbDtcbiAgICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbnVsbDtcbiAgICAgIHRoaXMudmlkZW9TYW1wbGVEdXJhdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgICB0aGlzLnZpZGVvVHJhY2tDb25maWcgPSB2b2lkIDA7XG4gICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICBpZiAoY2hyb21lVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgICBjaHJvbWVWZXJzaW9uID0gcmVzdWx0ID8gcGFyc2VJbnQocmVzdWx0WzFdKSA6IDA7XG4gICAgICB9XG4gICAgICBpZiAoc2FmYXJpV2Via2l0VmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgX3Jlc3VsdCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQrKS9pKTtcbiAgICAgICAgc2FmYXJpV2Via2l0VmVyc2lvbiA9IF9yZXN1bHQgPyBwYXJzZUludChfcmVzdWx0WzFdKSA6IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBNUDRSZW11eGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmNvbmZpZyA9IHRoaXMudmlkZW9UcmFja0NvbmZpZyA9IHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRUaW1lU3RhbXApIHtcbiAgICAgIGxvZ2dlci5sb2coJ1ttcDQtcmVtdXhlcl06IGluaXRQVFMgJiBpbml0RFRTIHJlc2V0Jyk7XG4gICAgICB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IGRlZmF1bHRUaW1lU3RhbXA7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXROZXh0VGltZXN0YW1wID0gZnVuY3Rpb24gcmVzZXROZXh0VGltZXN0YW1wKCkge1xuICAgICAgbG9nZ2VyLmxvZygnW21wNC1yZW11eGVyXTogcmVzZXQgbmV4dCB0aW1lc3RhbXAnKTtcbiAgICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldEluaXRTZWdtZW50ID0gZnVuY3Rpb24gcmVzZXRJbml0U2VnbWVudCgpIHtcbiAgICAgIGxvZ2dlci5sb2coJ1ttcDQtcmVtdXhlcl06IElTR2VuZXJhdGVkIGZsYWcgcmVzZXQnKTtcbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMudmlkZW9UcmFja0NvbmZpZyA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRWaWRlb1N0YXJ0UHRzID0gZnVuY3Rpb24gZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1NhbXBsZXMpIHtcbiAgICAgIHZhciByb2xsb3ZlckRldGVjdGVkID0gZmFsc2U7XG4gICAgICB2YXIgc3RhcnRQVFMgPSB2aWRlb1NhbXBsZXMucmVkdWNlKGZ1bmN0aW9uIChtaW5QVFMsIHNhbXBsZSkge1xuICAgICAgICB2YXIgZGVsdGEgPSBzYW1wbGUucHRzIC0gbWluUFRTO1xuICAgICAgICBpZiAoZGVsdGEgPCAtNDI5NDk2NzI5Nikge1xuICAgICAgICAgIC8vIDJeMzIsIHNlZSBQVFNOb3JtYWxpemUgZm9yIHJlYXNvbmluZywgYnV0IHdlJ3JlIGhpdHRpbmcgYSByb2xsb3ZlciBoZXJlLCBhbmQgd2UgZG9uJ3Qgd2FudCB0aGF0IHRvIGltcGFjdCB0aGUgdGltZU9mZnNldCBjYWxjdWxhdGlvblxuICAgICAgICAgIHJvbGxvdmVyRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBub3JtYWxpemVQdHMobWluUFRTLCBzYW1wbGUucHRzKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gbWluUFRTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzYW1wbGUucHRzO1xuICAgICAgICB9XG4gICAgICB9LCB2aWRlb1NhbXBsZXNbMF0ucHRzKTtcbiAgICAgIGlmIChyb2xsb3ZlckRldGVjdGVkKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnUFRTIHJvbGxvdmVyIGRldGVjdGVkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnRQVFM7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtdXggPSBmdW5jdGlvbiByZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGZsdXNoLCBwbGF5bGlzdFR5cGUpIHtcbiAgICAgIHZhciB2aWRlbztcbiAgICAgIHZhciBhdWRpbztcbiAgICAgIHZhciBpbml0U2VnbWVudDtcbiAgICAgIHZhciB0ZXh0O1xuICAgICAgdmFyIGlkMztcbiAgICAgIHZhciBpbmRlcGVuZGVudDtcbiAgICAgIHZhciBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgICAgdmFyIHZpZGVvVGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG5cbiAgICAgIC8vIElmIHdlJ3JlIHJlbXV4aW5nIGF1ZGlvIGFuZCB2aWRlbyBwcm9ncmVzc2l2ZWx5LCB3YWl0IHVudGlsIHdlJ3ZlIHJlY2VpdmVkIGVub3VnaCBzYW1wbGVzIGZvciBlYWNoIHRyYWNrIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIHN5bmNocm9uaXplIHRoZSBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtcy4gV2Uga25vdyBpZiB0aGUgY3VycmVudCBzZWdtZW50IHdpbGwgaGF2ZSBzYW1wbGVzIGlmIHRoZSBcInBpZFwiXG4gICAgICAvLyBwYXJhbWV0ZXIgaXMgZ3JlYXRlciB0aGFuIC0xLiBUaGUgcGlkIGlzIHNldCB3aGVuIHRoZSBQTVQgaXMgcGFyc2VkLCB3aGljaCBjb250YWlucyB0aGUgdHJhY2tzIGxpc3QuXG4gICAgICAvLyBIb3dldmVyLCBpZiB0aGUgaW5pdFNlZ21lbnQgaGFzIGFscmVhZHkgYmVlbiBnZW5lcmF0ZWQsIG9yIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiBhIHNlZ21lbnQgKGZsdXNoKSxcbiAgICAgIC8vIHRoZW4gd2UgY2FuIHJlbXV4IG9uZSB0cmFjayB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBvdGhlci5cbiAgICAgIHZhciBoYXNBdWRpbyA9IGF1ZGlvVHJhY2sucGlkID4gLTE7XG4gICAgICB2YXIgaGFzVmlkZW8gPSB2aWRlb1RyYWNrLnBpZCA+IC0xO1xuICAgICAgdmFyIGxlbmd0aCA9IHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gICAgICB2YXIgZW5vdWdoQXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCA+IDA7XG4gICAgICB2YXIgZW5vdWdoVmlkZW9TYW1wbGVzID0gZmx1c2ggJiYgbGVuZ3RoID4gMCB8fCBsZW5ndGggPiAxO1xuICAgICAgdmFyIGNhblJlbXV4QXZjID0gKCFoYXNBdWRpbyB8fCBlbm91Z2hBdWRpb1NhbXBsZXMpICYmICghaGFzVmlkZW8gfHwgZW5vdWdoVmlkZW9TYW1wbGVzKSB8fCB0aGlzLklTR2VuZXJhdGVkIHx8IGZsdXNoO1xuICAgICAgaWYgKGNhblJlbXV4QXZjKSB7XG4gICAgICAgIGlmICh0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgICAgdmFyIF92aWRlb1RyYWNrJHBpeGVsUmF0aSwgX2NvbmZpZyRwaXhlbFJhdGlvLCBfdmlkZW9UcmFjayRwaXhlbFJhdGkyLCBfY29uZmlnJHBpeGVsUmF0aW8yO1xuICAgICAgICAgIHZhciBjb25maWcgPSB0aGlzLnZpZGVvVHJhY2tDb25maWc7XG4gICAgICAgICAgaWYgKGNvbmZpZyAmJiAodmlkZW9UcmFjay53aWR0aCAhPT0gY29uZmlnLndpZHRoIHx8IHZpZGVvVHJhY2suaGVpZ2h0ICE9PSBjb25maWcuaGVpZ2h0IHx8ICgoX3ZpZGVvVHJhY2skcGl4ZWxSYXRpID0gdmlkZW9UcmFjay5waXhlbFJhdGlvKSA9PSBudWxsID8gdm9pZCAwIDogX3ZpZGVvVHJhY2skcGl4ZWxSYXRpWzBdKSAhPT0gKChfY29uZmlnJHBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb25maWckcGl4ZWxSYXRpb1swXSkgfHwgKChfdmlkZW9UcmFjayRwaXhlbFJhdGkyID0gdmlkZW9UcmFjay5waXhlbFJhdGlvKSA9PSBudWxsID8gdm9pZCAwIDogX3ZpZGVvVHJhY2skcGl4ZWxSYXRpMlsxXSkgIT09ICgoX2NvbmZpZyRwaXhlbFJhdGlvMiA9IGNvbmZpZy5waXhlbFJhdGlvKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbmZpZyRwaXhlbFJhdGlvMlsxXSkpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNWaWRlb0NvbnRpZ3VvdXMgPSB0aGlzLmlzVmlkZW9Db250aWd1b3VzO1xuICAgICAgICB2YXIgZmlyc3RLZXlGcmFtZUluZGV4ID0gLTE7XG4gICAgICAgIHZhciBmaXJzdEtleUZyYW1lUFRTO1xuICAgICAgICBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgZmlyc3RLZXlGcmFtZUluZGV4ID0gZmluZEtleWZyYW1lSW5kZXgodmlkZW9UcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICBpZiAoIWlzVmlkZW9Db250aWd1b3VzICYmIHRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICAgIGluZGVwZW5kZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChmaXJzdEtleUZyYW1lSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiW21wNC1yZW11eGVyXTogRHJvcHBlZCBcIiArIGZpcnN0S2V5RnJhbWVJbmRleCArIFwiIG91dCBvZiBcIiArIGxlbmd0aCArIFwiIHZpZGVvIHNhbXBsZXMgZHVlIHRvIGEgbWlzc2luZyBrZXlmcmFtZVwiKTtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvVHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcy5zbGljZShmaXJzdEtleUZyYW1lSW5kZXgpO1xuICAgICAgICAgICAgICB2aWRlb1RyYWNrLmRyb3BwZWQgKz0gZmlyc3RLZXlGcmFtZUluZGV4O1xuICAgICAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQgKz0gKHZpZGVvVHJhY2suc2FtcGxlc1swXS5wdHMgLSBzdGFydFBUUykgLyB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICAgICAgICBmaXJzdEtleUZyYW1lUFRTID0gdmlkZW9UaW1lT2Zmc2V0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaXJzdEtleUZyYW1lSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiW21wNC1yZW11eGVyXTogTm8ga2V5ZnJhbWUgZm91bmQgb3V0IG9mIFwiICsgbGVuZ3RoICsgXCIgdmlkZW8gc2FtcGxlc1wiKTtcbiAgICAgICAgICAgICAgaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgICBpZiAoZW5vdWdoQXVkaW9TYW1wbGVzICYmIGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgICAgLy8gdGltZU9mZnNldCBpcyBleHBlY3RlZCB0byBiZSB0aGUgb2Zmc2V0IG9mIHRoZSBmaXJzdCB0aW1lc3RhbXAgb2YgdGhpcyBmcmFnbWVudCAoZmlyc3QgRFRTKVxuICAgICAgICAgICAgLy8gaWYgZmlyc3QgYXVkaW8gRFRTIGlzIG5vdCBhbGlnbmVkIHdpdGggZmlyc3QgdmlkZW8gRFRTIHRoZW4gd2UgbmVlZCB0byB0YWtlIHRoYXQgaW50byBhY2NvdW50XG4gICAgICAgICAgICAvLyB3aGVuIHByb3ZpZGluZyB0aW1lT2Zmc2V0IHRvIHJlbXV4QXVkaW8gLyByZW11eFZpZGVvLiBpZiB3ZSBkb24ndCBkbyB0aGF0LCB0aGVyZSBtaWdodCBiZSBhIHBlcm1hbmVudCAvIHNtYWxsXG4gICAgICAgICAgICAvLyBkcmlmdCBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW1zXG4gICAgICAgICAgICB2YXIgX3N0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvVHJhY2suc2FtcGxlcyk7XG4gICAgICAgICAgICB2YXIgdHNEZWx0YSA9IG5vcm1hbGl6ZVB0cyhhdWRpb1RyYWNrLnNhbXBsZXNbMF0ucHRzLCBfc3RhcnRQVFMpIC0gX3N0YXJ0UFRTO1xuICAgICAgICAgICAgdmFyIGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSA9IHRzRGVsdGEgLyB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICAgICAgYXVkaW9UaW1lT2Zmc2V0ICs9IE1hdGgubWF4KDAsIGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSk7XG4gICAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQgKz0gTWF0aC5tYXgoMCwgLWF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHJlbXV4aW5nIGF1ZGlvIGJlZm9yZSB2aWRlbywgc28gdGhhdCByZW11eFZpZGVvIGNhbiB1c2UgbmV4dEF1ZGlvUHRzLCB3aGljaCBpcyBjYWxjdWxhdGVkIGluIHJlbXV4QXVkaW8uXG4gICAgICAgICAgaWYgKGVub3VnaEF1ZGlvU2FtcGxlcykge1xuICAgICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IGF1ZGlvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICAgIGlmICghYXVkaW9UcmFjay5zYW1wbGVyYXRlKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdbbXA0LXJlbXV4ZXJdOiByZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIGF1ZGlvIGRldGVjdGVkJyk7XG4gICAgICAgICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdWRpbyA9IHRoaXMucmVtdXhBdWRpbyhhdWRpb1RyYWNrLCBhdWRpb1RpbWVPZmZzZXQsIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgaGFzVmlkZW8gfHwgZW5vdWdoVmlkZW9TYW1wbGVzIHx8IHBsYXlsaXN0VHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8gPyB2aWRlb1RpbWVPZmZzZXQgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgICAgICB2YXIgYXVkaW9UcmFja0xlbmd0aCA9IGF1ZGlvID8gYXVkaW8uZW5kUFRTIC0gYXVkaW8uc3RhcnRQVFMgOiAwO1xuICAgICAgICAgICAgICAvLyBpZiBpbml0U2VnbWVudCB3YXMgZ2VuZXJhdGVkIHdpdGhvdXQgdmlkZW8gc2FtcGxlcywgcmVnZW5lcmF0ZSBpdCBhZ2FpblxuICAgICAgICAgICAgICBpZiAoIXZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybignW21wNC1yZW11eGVyXTogcmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyB2aWRlbyBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmlkZW8gPSB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBpc1ZpZGVvQ29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICAgIHZpZGVvID0gdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssIHZpZGVvVGltZU9mZnNldCwgaXNWaWRlb0NvbnRpZ3VvdXMsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgICAgIHZpZGVvLmZpcnN0S2V5RnJhbWUgPSBmaXJzdEtleUZyYW1lSW5kZXg7XG4gICAgICAgICAgICB2aWRlby5pbmRlcGVuZGVudCA9IGZpcnN0S2V5RnJhbWVJbmRleCAhPT0gLTE7XG4gICAgICAgICAgICB2aWRlby5maXJzdEtleUZyYW1lUFRTID0gZmlyc3RLZXlGcmFtZVBUUztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgSUQzIGFuZCB0ZXh0IHRvIHJlbXV4LCBldmVuIGlmIG1vcmUgYXVkaW8vdmlkZW8gc2FtcGxlcyBhcmUgcmVxdWlyZWRcbiAgICAgIGlmICh0aGlzLklTR2VuZXJhdGVkICYmIHRoaXMuX2luaXRQVFMgJiYgdGhpcy5faW5pdERUUykge1xuICAgICAgICBpZiAoaWQzVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZDMgPSBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyhpZDNUcmFjaywgdGltZU9mZnNldCwgdGhpcy5faW5pdFBUUywgdGhpcy5faW5pdERUUyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHRUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRleHQgPSBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyh0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIHRoaXMuX2luaXRQVFMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdWRpbzogYXVkaW8sXG4gICAgICAgIHZpZGVvOiB2aWRlbyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LFxuICAgICAgICBpbmRlcGVuZGVudDogaW5kZXBlbmRlbnQsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGlkMzogaWQzXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlSVMgPSBmdW5jdGlvbiBnZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgICAgdmFyIGF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcztcbiAgICAgIHZhciB2aWRlb1NhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgICB2YXIgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZDtcbiAgICAgIHZhciB0cmFja3MgPSB7fTtcbiAgICAgIHZhciBfaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgICB2YXIgY29tcHV0ZVBUU0RUUyA9ICFfaW5pdFBUUyB8fCBhY2N1cmF0ZVRpbWVPZmZzZXQ7XG4gICAgICB2YXIgY29udGFpbmVyID0gJ2F1ZGlvL21wNCc7XG4gICAgICB2YXIgaW5pdFBUUztcbiAgICAgIHZhciBpbml0RFRTO1xuICAgICAgdmFyIHRpbWVzY2FsZTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBpZiAoYXVkaW9UcmFjay5jb25maWcgJiYgYXVkaW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAvLyBsZXQncyB1c2UgYXVkaW8gc2FtcGxpbmcgcmF0ZSBhcyBNUDQgdGltZSBzY2FsZS5cbiAgICAgICAgLy8gcmF0aW9uYWxlIGlzIHRoYXQgdGhlcmUgaXMgYSBpbnRlZ2VyIG5iIG9mIGF1ZGlvIGZyYW1lcyBwZXIgYXVkaW8gc2FtcGxlICgxMDI0IGZvciBBQUMpXG4gICAgICAgIC8vIHVzaW5nIGF1ZGlvIHNhbXBsaW5nIHJhdGUgaGVyZSBoZWxwcyBoYXZpbmcgYW4gaW50ZWdlciBNUDQgZnJhbWUgZHVyYXRpb25cbiAgICAgICAgLy8gdGhpcyBhdm9pZHMgcG90ZW50aWFsIHJvdW5kaW5nIGlzc3VlIGFuZCBBViBzeW5jIGlzc3VlXG4gICAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gYXVkaW9UcmFjay5zYW1wbGVyYXRlO1xuICAgICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLm1wZWcpIHtcbiAgICAgICAgICAgICAgLy8gQ2hyb21lIGFuZCBTYWZhcmlcbiAgICAgICAgICAgICAgY29udGFpbmVyID0gJ2F1ZGlvL21wZWcnO1xuICAgICAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVTdXBwb3J0ZWQubXAzKSB7XG4gICAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICdtcDMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYWMzJzpcbiAgICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnYWMtMyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgICAgaWQ6ICdhdWRpbycsXG4gICAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgICAgY29kZWM6IGF1ZGlvVHJhY2suY29kZWMsXG4gICAgICAgICAgaW5pdFNlZ21lbnQ6IGF1ZGlvVHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0eXBlU3VwcG9ydGVkLm1wZWcgPyBuZXcgVWludDhBcnJheSgwKSA6IE1QNC5pbml0U2VnbWVudChbYXVkaW9UcmFja10pLFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICBjaGFubmVsQ291bnQ6IGF1ZGlvVHJhY2suY2hhbm5lbENvdW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICAgIHRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgaWYgKCFfaW5pdFBUUyB8fCB0aW1lc2NhbGUgIT09IF9pbml0UFRTLnRpbWVzY2FsZSkge1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIHRoaXMgZGVtdXhpbmcgY29udGV4dC4gZm9yIGF1ZGlvLCBQVFMgPSBEVFNcbiAgICAgICAgICAgIGluaXRQVFMgPSBpbml0RFRTID0gYXVkaW9TYW1wbGVzWzBdLnB0cyAtIE1hdGgucm91bmQodGltZXNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXB1dGVQVFNEVFMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIGxldCdzIHVzZSBpbnB1dCB0aW1lIHNjYWxlIGFzIE1QNCB2aWRlbyB0aW1lc2NhbGVcbiAgICAgICAgLy8gd2UgdXNlIGlucHV0IHRpbWUgc2NhbGUgc3RyYWlnaHQgYXdheSB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMgb24gZnJhbWUgZHVyYXRpb24gLyBjdHMgY29tcHV0YXRpb25cbiAgICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICB0cmFja3MudmlkZW8gPSB7XG4gICAgICAgICAgaWQ6ICdtYWluJyxcbiAgICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICAgIGNvZGVjOiB2aWRlb1RyYWNrLmNvZGVjLFxuICAgICAgICAgIGluaXRTZWdtZW50OiBNUDQuaW5pdFNlZ21lbnQoW3ZpZGVvVHJhY2tdKSxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgd2lkdGg6IHZpZGVvVHJhY2sud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHZpZGVvVHJhY2suaGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICAgIHRpbWVzY2FsZSA9IHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgaWYgKCFfaW5pdFBUUyB8fCB0aW1lc2NhbGUgIT09IF9pbml0UFRTLnRpbWVzY2FsZSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcyk7XG4gICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBNYXRoLnJvdW5kKHRpbWVzY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgaW5pdERUUyA9IE1hdGgubWluKGluaXREVFMsIG5vcm1hbGl6ZVB0cyh2aWRlb1NhbXBsZXNbMF0uZHRzLCBzdGFydFBUUykgLSBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICBpbml0UFRTID0gTWF0aC5taW4oaW5pdFBUUywgc3RhcnRQVFMgLSBzdGFydE9mZnNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXB1dGVQVFNEVFMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWRlb1RyYWNrQ29uZmlnID0ge1xuICAgICAgICAgIHdpZHRoOiB2aWRlb1RyYWNrLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHQsXG4gICAgICAgICAgcGl4ZWxSYXRpbzogdmlkZW9UcmFjay5waXhlbFJhdGlvXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXModHJhY2tzKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5JU0dlbmVyYXRlZCA9IHRydWU7XG4gICAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgICAgdGhpcy5faW5pdFBUUyA9IHtcbiAgICAgICAgICAgIGJhc2VUaW1lOiBpbml0UFRTLFxuICAgICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX2luaXREVFMgPSB7XG4gICAgICAgICAgICBiYXNlVGltZTogaW5pdERUUyxcbiAgICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbml0UFRTID0gdGltZXNjYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhY2tzOiB0cmFja3MsXG4gICAgICAgICAgaW5pdFBUUzogaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnJlbXV4VmlkZW8gPSBmdW5jdGlvbiByZW11eFZpZGVvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBhdWRpb1RyYWNrTGVuZ3RoKSB7XG4gICAgICB2YXIgdGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICB2YXIgaW5wdXRTYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICAgIHZhciBvdXRwdXRTYW1wbGVzID0gW107XG4gICAgICB2YXIgbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcbiAgICAgIHZhciBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICAgIHZhciBuZXh0QXZjRHRzID0gdGhpcy5uZXh0QXZjRHRzO1xuICAgICAgdmFyIG9mZnNldCA9IDg7XG4gICAgICB2YXIgbXA0U2FtcGxlRHVyYXRpb24gPSB0aGlzLnZpZGVvU2FtcGxlRHVyYXRpb247XG4gICAgICB2YXIgZmlyc3REVFM7XG4gICAgICB2YXIgbGFzdERUUztcbiAgICAgIHZhciBtaW5QVFMgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB2YXIgbWF4UFRTID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgdmFyIHNvcnRTYW1wbGVzID0gZmFsc2U7XG5cbiAgICAgIC8vIGlmIHBhcnNlZCBmcmFnbWVudCBpcyBjb250aWd1b3VzIHdpdGggbGFzdCBvbmUsIGxldCdzIHVzZSBsYXN0IERUUyB2YWx1ZSBhcyByZWZlcmVuY2VcbiAgICAgIGlmICghY29udGlndW91cyB8fCBuZXh0QXZjRHRzID09PSBudWxsKSB7XG4gICAgICAgIHZhciBwdHMgPSB0aW1lT2Zmc2V0ICogdGltZVNjYWxlO1xuICAgICAgICB2YXIgY3RzID0gaW5wdXRTYW1wbGVzWzBdLnB0cyAtIG5vcm1hbGl6ZVB0cyhpbnB1dFNhbXBsZXNbMF0uZHRzLCBpbnB1dFNhbXBsZXNbMF0ucHRzKTtcbiAgICAgICAgaWYgKGNocm9tZVZlcnNpb24gJiYgbmV4dEF2Y0R0cyAhPT0gbnVsbCAmJiBNYXRoLmFicyhwdHMgLSBjdHMgLSBuZXh0QXZjRHRzKSA8IDE1MDAwKSB7XG4gICAgICAgICAgLy8gdHJlYXQgYXMgY29udGlnb3VzIHRvIGFkanVzdCBzYW1wbGVzIHRoYXQgd291bGQgb3RoZXJ3aXNlIHByb2R1Y2UgdmlkZW8gYnVmZmVyIGdhcHMgaW4gQ2hyb21lXG4gICAgICAgICAgY29udGlndW91cyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgbm90IGNvbnRpZ3VvdXMsIGxldCdzIHVzZSB0YXJnZXQgdGltZU9mZnNldFxuICAgICAgICAgIG5leHRBdmNEdHMgPSBwdHMgLSBjdHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUFRTIGlzIGNvZGVkIG9uIDMzYml0cywgYW5kIGNhbiBsb29wIGZyb20gLTJeMzIgdG8gMl4zMlxuICAgICAgLy8gUFRTTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuICAgICAgdmFyIGluaXRUaW1lID0gaW5pdFBUUy5iYXNlVGltZSAqIHRpbWVTY2FsZSAvIGluaXRQVFMudGltZXNjYWxlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgICB2YXIgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0VGltZSwgbmV4dEF2Y0R0cyk7XG4gICAgICAgIHNhbXBsZS5kdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLmR0cyAtIGluaXRUaW1lLCBuZXh0QXZjRHRzKTtcbiAgICAgICAgaWYgKHNhbXBsZS5kdHMgPCBpbnB1dFNhbXBsZXNbaSA+IDAgPyBpIC0gMSA6IGldLmR0cykge1xuICAgICAgICAgIHNvcnRTYW1wbGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzb3J0IHZpZGVvIHNhbXBsZXMgYnkgRFRTIHRoZW4gUFRTIHRoZW4gZGVtdXggaWQgb3JkZXJcbiAgICAgIGlmIChzb3J0U2FtcGxlcykge1xuICAgICAgICBpbnB1dFNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHZhciBkZWx0YWR0cyA9IGEuZHRzIC0gYi5kdHM7XG4gICAgICAgICAgdmFyIGRlbHRhcHRzID0gYS5wdHMgLSBiLnB0cztcbiAgICAgICAgICByZXR1cm4gZGVsdGFkdHMgfHwgZGVsdGFwdHM7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgZmlyc3QvbGFzdCBEVFNcbiAgICAgIGZpcnN0RFRTID0gaW5wdXRTYW1wbGVzWzBdLmR0cztcbiAgICAgIGxhc3REVFMgPSBpbnB1dFNhbXBsZXNbaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDFdLmR0cztcblxuICAgICAgLy8gU2FtcGxlIGR1cmF0aW9uIChhcyBleHBlY3RlZCBieSB0cnVuIE1QNCBib3hlcyksIHNob3VsZCBiZSB0aGUgZGVsdGEgYmV0d2VlbiBzYW1wbGUgRFRTXG4gICAgICAvLyBzZXQgdGhpcyBjb25zdGFudCBkdXJhdGlvbiBhcyBiZWluZyB0aGUgYXZnIGRlbHRhIGJldHdlZW4gY29uc2VjdXRpdmUgRFRTLlxuICAgICAgdmFyIGlucHV0RHVyYXRpb24gPSBsYXN0RFRTIC0gZmlyc3REVFM7XG4gICAgICB2YXIgYXZlcmFnZVNhbXBsZUR1cmF0aW9uID0gaW5wdXREdXJhdGlvbiA/IE1hdGgucm91bmQoaW5wdXREdXJhdGlvbiAvIChuYlNhbXBsZXMgLSAxKSkgOiBtcDRTYW1wbGVEdXJhdGlvbiB8fCB0cmFjay5pbnB1dFRpbWVTY2FsZSAvIDMwO1xuXG4gICAgICAvLyBpZiBmcmFnbWVudCBhcmUgY29udGlndW91cywgZGV0ZWN0IGhvbGUvb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHNcbiAgICAgIGlmIChjb250aWd1b3VzKSB7XG4gICAgICAgIC8vIGNoZWNrIHRpbWVzdGFtcCBjb250aW51aXR5IGFjcm9zcyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgKHRoaXMgaXMgdG8gcmVtb3ZlIGludGVyLWZyYWdtZW50IGdhcC9ob2xlKVxuICAgICAgICB2YXIgZGVsdGEgPSBmaXJzdERUUyAtIG5leHRBdmNEdHM7XG4gICAgICAgIHZhciBmb3VuZEhvbGUgPSBkZWx0YSA+IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgdmFyIGZvdW5kT3ZlcmxhcCA9IGRlbHRhIDwgLTE7XG4gICAgICAgIGlmIChmb3VuZEhvbGUgfHwgZm91bmRPdmVybGFwKSB7XG4gICAgICAgICAgaWYgKGZvdW5kSG9sZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJBVkM6IFwiICsgdG9Nc0Zyb21NcGVnVHNDbG9jayhkZWx0YSwgdHJ1ZSkgKyBcIiBtcyAoXCIgKyBkZWx0YSArIFwiZHRzKSBob2xlIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkIGF0IFwiICsgdGltZU9mZnNldC50b0ZpeGVkKDMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJBVkM6IFwiICsgdG9Nc0Zyb21NcGVnVHNDbG9jaygtZGVsdGEsIHRydWUpICsgXCIgbXMgKFwiICsgZGVsdGEgKyBcImR0cykgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWQgYXQgXCIgKyB0aW1lT2Zmc2V0LnRvRml4ZWQoMykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kT3ZlcmxhcCB8fCBuZXh0QXZjRHRzID49IGlucHV0U2FtcGxlc1swXS5wdHMgfHwgY2hyb21lVmVyc2lvbikge1xuICAgICAgICAgICAgZmlyc3REVFMgPSBuZXh0QXZjRHRzO1xuICAgICAgICAgICAgdmFyIGZpcnN0UFRTID0gaW5wdXRTYW1wbGVzWzBdLnB0cyAtIGRlbHRhO1xuICAgICAgICAgICAgaWYgKGZvdW5kSG9sZSkge1xuICAgICAgICAgICAgICBpbnB1dFNhbXBsZXNbMF0uZHRzID0gZmlyc3REVFM7XG4gICAgICAgICAgICAgIGlucHV0U2FtcGxlc1swXS5wdHMgPSBmaXJzdFBUUztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U2FtcGxlc1tfaV0uZHRzID4gZmlyc3RQVFMpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnB1dFNhbXBsZXNbX2ldLmR0cyAtPSBkZWx0YTtcbiAgICAgICAgICAgICAgICBpbnB1dFNhbXBsZXNbX2ldLnB0cyAtPSBkZWx0YTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlZpZGVvOiBJbml0aWFsIFBUUy9EVFMgYWRqdXN0ZWQ6IFwiICsgdG9Nc0Zyb21NcGVnVHNDbG9jayhmaXJzdFBUUywgdHJ1ZSkgKyBcIi9cIiArIHRvTXNGcm9tTXBlZ1RzQ2xvY2soZmlyc3REVFMsIHRydWUpICsgXCIsIGRlbHRhOiBcIiArIHRvTXNGcm9tTXBlZ1RzQ2xvY2soZGVsdGEsIHRydWUpICsgXCIgbXNcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaXJzdERUUyA9IE1hdGgubWF4KDAsIGZpcnN0RFRTKTtcbiAgICAgIHZhciBuYk5hbHUgPSAwO1xuICAgICAgdmFyIG5hbHVMZW4gPSAwO1xuICAgICAgdmFyIGR0c1N0ZXAgPSBmaXJzdERUUztcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5iU2FtcGxlczsgX2kyKyspIHtcbiAgICAgICAgLy8gY29tcHV0ZSB0b3RhbC9hdmMgc2FtcGxlIGxlbmd0aCBhbmQgbmIgb2YgTkFMIHVuaXRzXG4gICAgICAgIHZhciBfc2FtcGxlID0gaW5wdXRTYW1wbGVzW19pMl07XG4gICAgICAgIHZhciB1bml0cyA9IF9zYW1wbGUudW5pdHM7XG4gICAgICAgIHZhciBuYlVuaXRzID0gdW5pdHMubGVuZ3RoO1xuICAgICAgICB2YXIgc2FtcGxlTGVuID0gMDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuYlVuaXRzOyBqKyspIHtcbiAgICAgICAgICBzYW1wbGVMZW4gKz0gdW5pdHNbal0uZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbmFsdUxlbiArPSBzYW1wbGVMZW47XG4gICAgICAgIG5iTmFsdSArPSBuYlVuaXRzO1xuICAgICAgICBfc2FtcGxlLmxlbmd0aCA9IHNhbXBsZUxlbjtcblxuICAgICAgICAvLyBlbnN1cmUgc2FtcGxlIG1vbm90b25pYyBEVFNcbiAgICAgICAgaWYgKF9zYW1wbGUuZHRzIDwgZHRzU3RlcCkge1xuICAgICAgICAgIF9zYW1wbGUuZHRzID0gZHRzU3RlcDtcbiAgICAgICAgICBkdHNTdGVwICs9IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiAvIDQgfCAwIHx8IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHRzU3RlcCA9IF9zYW1wbGUuZHRzO1xuICAgICAgICB9XG4gICAgICAgIG1pblBUUyA9IE1hdGgubWluKF9zYW1wbGUucHRzLCBtaW5QVFMpO1xuICAgICAgICBtYXhQVFMgPSBNYXRoLm1heChfc2FtcGxlLnB0cywgbWF4UFRTKTtcbiAgICAgIH1cbiAgICAgIGxhc3REVFMgPSBpbnB1dFNhbXBsZXNbbmJTYW1wbGVzIC0gMV0uZHRzO1xuXG4gICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbXBkYXQgdHlwZSkgKi9cbiAgICAgIHZhciBtZGF0U2l6ZSA9IG5hbHVMZW4gKyA0ICogbmJOYWx1ICsgODtcbiAgICAgIHZhciBtZGF0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1VWF9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuUkVNVVhfQUxMT0NfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgYnl0ZXM6IG1kYXRTaXplLFxuICAgICAgICAgIHJlYXNvbjogXCJmYWlsIGFsbG9jYXRpbmcgdmlkZW8gbWRhdCBcIiArIG1kYXRTaXplXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhtZGF0LmJ1ZmZlcik7XG4gICAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgICB2YXIgc3RyZXRjaGVkTGFzdEZyYW1lID0gZmFsc2U7XG4gICAgICB2YXIgbWluRHRzRGVsdGEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB2YXIgbWluUHRzRGVsdGEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB2YXIgbWF4RHRzRGVsdGEgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICB2YXIgbWF4UHRzRGVsdGEgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBuYlNhbXBsZXM7IF9pMysrKSB7XG4gICAgICAgIHZhciBfVmlkZW9TYW1wbGUgPSBpbnB1dFNhbXBsZXNbX2kzXTtcbiAgICAgICAgdmFyIFZpZGVvU2FtcGxlVW5pdHMgPSBfVmlkZW9TYW1wbGUudW5pdHM7XG4gICAgICAgIHZhciBtcDRTYW1wbGVMZW5ndGggPSAwO1xuICAgICAgICAvLyBjb252ZXJ0IE5BTFUgYml0c3RyZWFtIHRvIE1QNCBmb3JtYXQgKHByZXBlbmQgTkFMVSB3aXRoIHNpemUgZmllbGQpXG4gICAgICAgIGZvciAodmFyIF9qID0gMCwgX25iVW5pdHMgPSBWaWRlb1NhbXBsZVVuaXRzLmxlbmd0aDsgX2ogPCBfbmJVbml0czsgX2orKykge1xuICAgICAgICAgIHZhciB1bml0ID0gVmlkZW9TYW1wbGVVbml0c1tfal07XG4gICAgICAgICAgdmFyIHVuaXREYXRhID0gdW5pdC5kYXRhO1xuICAgICAgICAgIHZhciB1bml0RGF0YUxlbiA9IHVuaXQuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgdW5pdERhdGFMZW4pO1xuICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgIG1kYXQuc2V0KHVuaXREYXRhLCBvZmZzZXQpO1xuICAgICAgICAgIG9mZnNldCArPSB1bml0RGF0YUxlbjtcbiAgICAgICAgICBtcDRTYW1wbGVMZW5ndGggKz0gNCArIHVuaXREYXRhTGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXhwZWN0ZWQgc2FtcGxlIGR1cmF0aW9uIGlzIHRoZSBEZWNvZGluZyBUaW1lc3RhbXAgZGlmZiBvZiBjb25zZWN1dGl2ZSBzYW1wbGVzXG4gICAgICAgIHZhciBwdHNEZWx0YSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKF9pMyA8IG5iU2FtcGxlcyAtIDEpIHtcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGlucHV0U2FtcGxlc1tfaTMgKyAxXS5kdHMgLSBfVmlkZW9TYW1wbGUuZHRzO1xuICAgICAgICAgIHB0c0RlbHRhID0gaW5wdXRTYW1wbGVzW19pMyArIDFdLnB0cyAtIF9WaWRlb1NhbXBsZS5wdHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgIHZhciBsYXN0RnJhbWVEdXJhdGlvbiA9IF9pMyA+IDAgPyBfVmlkZW9TYW1wbGUuZHRzIC0gaW5wdXRTYW1wbGVzW19pMyAtIDFdLmR0cyA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICBwdHNEZWx0YSA9IF9pMyA+IDAgPyBfVmlkZW9TYW1wbGUucHRzIC0gaW5wdXRTYW1wbGVzW19pMyAtIDFdLnB0cyA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICBpZiAoY29uZmlnLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2sgJiYgdGhpcy5uZXh0QXVkaW9QdHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMsIGEgc2VnbWVudCdzIGF1ZGlvIHRyYWNrIGR1cmF0aW9uIG1heSBleGNlZWQgdGhlIHZpZGVvIHRyYWNrIGR1cmF0aW9uLlxuICAgICAgICAgICAgLy8gU2luY2Ugd2UndmUgYWxyZWFkeSByZW11eGVkIGF1ZGlvLCBhbmQgd2Uga25vdyBob3cgbG9uZyB0aGUgYXVkaW8gdHJhY2sgaXMsIHdlIGxvb2sgdG9cbiAgICAgICAgICAgIC8vIHNlZSBpZiB0aGUgZGVsdGEgdG8gdGhlIG5leHQgc2VnbWVudCBpcyBsb25nZXIgdGhhbiBtYXhCdWZmZXJIb2xlLlxuICAgICAgICAgICAgLy8gSWYgc28sIHBsYXliYWNrIHdvdWxkIHBvdGVudGlhbGx5IGdldCBzdHVjaywgc28gd2UgYXJ0aWZpY2lhbGx5IGluZmxhdGVcbiAgICAgICAgICAgIC8vIHRoZSBkdXJhdGlvbiBvZiB0aGUgbGFzdCBmcmFtZSB0byBtaW5pbWl6ZSBhbnkgcG90ZW50aWFsIGdhcCBiZXR3ZWVuIHNlZ21lbnRzLlxuICAgICAgICAgICAgdmFyIGdhcFRvbGVyYW5jZSA9IE1hdGguZmxvb3IoY29uZmlnLm1heEJ1ZmZlckhvbGUgKiB0aW1lU2NhbGUpO1xuICAgICAgICAgICAgdmFyIGRlbHRhVG9GcmFtZUVuZCA9IChhdWRpb1RyYWNrTGVuZ3RoID8gbWluUFRTICsgYXVkaW9UcmFja0xlbmd0aCAqIHRpbWVTY2FsZSA6IHRoaXMubmV4dEF1ZGlvUHRzKSAtIF9WaWRlb1NhbXBsZS5wdHM7XG4gICAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHN1YnRyYWN0IGxhc3RGcmFtZUR1cmF0aW9uIGZyb20gZGVsdGFUb0ZyYW1lRW5kIHRvIHRyeSB0byBwcmV2ZW50IGFueSB2aWRlb1xuICAgICAgICAgICAgICAvLyBmcmFtZSBvdmVybGFwLiBtYXhCdWZmZXJIb2xlIHNob3VsZCBiZSA+PiBsYXN0RnJhbWVEdXJhdGlvbiBhbnl3YXkuXG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICAgIGlmIChtcDRTYW1wbGVEdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmV0Y2hlZExhc3RGcmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlttcDQtcmVtdXhlcl06IEl0IGlzIGFwcHJveGltYXRlbHkgXCIgKyBkZWx0YVRvRnJhbWVFbmQgLyA5MCArIFwiIG1zIHRvIHRoZSBuZXh0IHNlZ21lbnQ7IHVzaW5nIGR1cmF0aW9uIFwiICsgbXA0U2FtcGxlRHVyYXRpb24gLyA5MCArIFwiIG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbiA9IGxhc3RGcmFtZUR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5yb3VuZChfVmlkZW9TYW1wbGUucHRzIC0gX1ZpZGVvU2FtcGxlLmR0cyk7XG4gICAgICAgIG1pbkR0c0RlbHRhID0gTWF0aC5taW4obWluRHRzRGVsdGEsIG1wNFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgICAgbWF4RHRzRGVsdGEgPSBNYXRoLm1heChtYXhEdHNEZWx0YSwgbXA0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICBtaW5QdHNEZWx0YSA9IE1hdGgubWluKG1pblB0c0RlbHRhLCBwdHNEZWx0YSk7XG4gICAgICAgIG1heFB0c0RlbHRhID0gTWF0aC5tYXgobWF4UHRzRGVsdGEsIHB0c0RlbHRhKTtcbiAgICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG5ldyBNcDRTYW1wbGUoX1ZpZGVvU2FtcGxlLmtleSwgbXA0U2FtcGxlRHVyYXRpb24sIG1wNFNhbXBsZUxlbmd0aCwgY29tcG9zaXRpb25UaW1lT2Zmc2V0KSk7XG4gICAgICB9XG4gICAgICBpZiAob3V0cHV0U2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGNocm9tZVZlcnNpb24pIHtcbiAgICAgICAgICBpZiAoY2hyb21lVmVyc2lvbiA8IDcwKSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgd29ya2Fyb3VuZCwgbWFyayBmaXJzdCBzYW1wbGUgYXMgYmVpbmcgYSBSYW5kb20gQWNjZXNzIFBvaW50IChrZXlmcmFtZSkgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTQxMlxuICAgICAgICAgICAgdmFyIGZsYWdzID0gb3V0cHV0U2FtcGxlc1swXS5mbGFncztcbiAgICAgICAgICAgIGZsYWdzLmRlcGVuZHNPbiA9IDI7XG4gICAgICAgICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzYWZhcmlXZWJraXRWZXJzaW9uKSB7XG4gICAgICAgICAgLy8gRml4IGZvciBcIkNOTiBzcGVjaWFsIHJlcG9ydCwgd2l0aCBDQ1wiIGluIHRlc3Qtc3RyZWFtcyAoU2FmYXJpIGJyb3dzZXIgb25seSlcbiAgICAgICAgICAvLyBJZ25vcmUgRFRTIHdoZW4gZnJhbWUgZHVyYXRpb25zIGFyZSBpcnJlZ3VsYXIuIFNhZmFyaSBNU0UgZG9lcyBub3QgaGFuZGxlIHRoaXMgbGVhZGluZyB0byBnYXBzLlxuICAgICAgICAgIGlmIChtYXhQdHNEZWx0YSAtIG1pblB0c0RlbHRhIDwgbWF4RHRzRGVsdGEgLSBtaW5EdHNEZWx0YSAmJiBhdmVyYWdlU2FtcGxlRHVyYXRpb24gLyBtYXhEdHNEZWx0YSA8IDAuMDI1ICYmIG91dHB1dFNhbXBsZXNbMF0uY3RzID09PSAwKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignRm91bmQgaXJyZWd1bGFyIGdhcHMgaW4gc2FtcGxlIGR1cmF0aW9uLiBVc2luZyBQVFMgaW5zdGVhZCBvZiBEVFMgdG8gZGV0ZXJtaW5lIE1QNCBzYW1wbGUgZHVyYXRpb24uJyk7XG4gICAgICAgICAgICB2YXIgZHRzID0gZmlyc3REVFM7XG4gICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBsZW4gPSBvdXRwdXRTYW1wbGVzLmxlbmd0aDsgX2k0IDwgbGVuOyBfaTQrKykge1xuICAgICAgICAgICAgICB2YXIgbmV4dER0cyA9IGR0cyArIG91dHB1dFNhbXBsZXNbX2k0XS5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgdmFyIF9wdHMgPSBkdHMgKyBvdXRwdXRTYW1wbGVzW19pNF0uY3RzO1xuICAgICAgICAgICAgICBpZiAoX2k0IDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0UHRzID0gbmV4dER0cyArIG91dHB1dFNhbXBsZXNbX2k0ICsgMV0uY3RzO1xuICAgICAgICAgICAgICAgIG91dHB1dFNhbXBsZXNbX2k0XS5kdXJhdGlvbiA9IG5leHRQdHMgLSBfcHRzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dFNhbXBsZXNbX2k0XS5kdXJhdGlvbiA9IF9pNCA/IG91dHB1dFNhbXBsZXNbX2k0IC0gMV0uZHVyYXRpb24gOiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0cHV0U2FtcGxlc1tfaTRdLmN0cyA9IDA7XG4gICAgICAgICAgICAgIGR0cyA9IG5leHREdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBuZXh0IEFWQyBzYW1wbGUgRFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBEVFMgKyBsYXN0IHNhbXBsZSBkdXJhdGlvbiAoaW4gUEVTIHRpbWVzY2FsZSlcbiAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gc3RyZXRjaGVkTGFzdEZyYW1lIHx8ICFtcDRTYW1wbGVEdXJhdGlvbiA/IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiA6IG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgICAgdGhpcy5uZXh0QXZjRHRzID0gbmV4dEF2Y0R0cyA9IGxhc3REVFMgKyBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICAgIHRoaXMudmlkZW9TYW1wbGVEdXJhdGlvbiA9IG1wNFNhbXBsZUR1cmF0aW9uO1xuICAgICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IHRydWU7XG4gICAgICB2YXIgbW9vZiA9IE1QNC5tb29mKHRyYWNrLnNlcXVlbmNlTnVtYmVyKyssIGZpcnN0RFRTLCBfZXh0ZW5kcyh7fSwgdHJhY2ssIHtcbiAgICAgICAgc2FtcGxlczogb3V0cHV0U2FtcGxlc1xuICAgICAgfSkpO1xuICAgICAgdmFyIHR5cGUgPSAndmlkZW8nO1xuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIGRhdGExOiBtb29mLFxuICAgICAgICBkYXRhMjogbWRhdCxcbiAgICAgICAgc3RhcnRQVFM6IG1pblBUUyAvIHRpbWVTY2FsZSxcbiAgICAgICAgZW5kUFRTOiAobWF4UFRTICsgbXA0U2FtcGxlRHVyYXRpb24pIC8gdGltZVNjYWxlLFxuICAgICAgICBzdGFydERUUzogZmlyc3REVFMgLyB0aW1lU2NhbGUsXG4gICAgICAgIGVuZERUUzogbmV4dEF2Y0R0cyAvIHRpbWVTY2FsZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgaGFzQXVkaW86IGZhbHNlLFxuICAgICAgICBoYXNWaWRlbzogdHJ1ZSxcbiAgICAgICAgbmI6IG91dHB1dFNhbXBsZXMubGVuZ3RoLFxuICAgICAgICBkcm9wcGVkOiB0cmFjay5kcm9wcGVkXG4gICAgICB9O1xuICAgICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgICAgdHJhY2suZHJvcHBlZCA9IDA7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRTYW1wbGVzUGVyRnJhbWUgPSBmdW5jdGlvbiBnZXRTYW1wbGVzUGVyRnJhbWUodHJhY2spIHtcbiAgICAgIHN3aXRjaCAodHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgcmV0dXJuIE1QRUdfQVVESU9fU0FNUExFX1BFUl9GUkFNRTtcbiAgICAgICAgY2FzZSAnYWMzJzpcbiAgICAgICAgICByZXR1cm4gQUMzX1NBTVBMRVNfUEVSX0ZSQU1FO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBBQUNfU0FNUExFU19QRVJfRlJBTUU7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtdXhBdWRpbyA9IGZ1bmN0aW9uIHJlbXV4QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgdmlkZW9UaW1lT2Zmc2V0KSB7XG4gICAgICB2YXIgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgIHZhciBtcDR0aW1lU2NhbGUgPSB0cmFjay5zYW1wbGVyYXRlID8gdHJhY2suc2FtcGxlcmF0ZSA6IGlucHV0VGltZVNjYWxlO1xuICAgICAgdmFyIHNjYWxlRmFjdG9yID0gaW5wdXRUaW1lU2NhbGUgLyBtcDR0aW1lU2NhbGU7XG4gICAgICB2YXIgbXA0U2FtcGxlRHVyYXRpb24gPSB0aGlzLmdldFNhbXBsZXNQZXJGcmFtZSh0cmFjayk7XG4gICAgICB2YXIgaW5wdXRTYW1wbGVEdXJhdGlvbiA9IG1wNFNhbXBsZUR1cmF0aW9uICogc2NhbGVGYWN0b3I7XG4gICAgICB2YXIgaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgICB2YXIgcmF3TVBFRyA9IHRyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ21wMycgJiYgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWc7XG4gICAgICB2YXIgb3V0cHV0U2FtcGxlcyA9IFtdO1xuICAgICAgdmFyIGFsaWduZWRXaXRoVmlkZW8gPSB2aWRlb1RpbWVPZmZzZXQgIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgICAgdmFyIG9mZnNldCA9IHJhd01QRUcgPyAwIDogODtcbiAgICAgIHZhciBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cyB8fCAtMTtcblxuICAgICAgLy8gd2luZG93LmF1ZGlvU2FtcGxlcyA/IHdpbmRvdy5hdWRpb1NhbXBsZXMucHVzaChpbnB1dFNhbXBsZXMubWFwKHMgPT4gcy5wdHMpKSA6ICh3aW5kb3cuYXVkaW9TYW1wbGVzID0gW2lucHV0U2FtcGxlcy5tYXAocyA9PiBzLnB0cyldKTtcblxuICAgICAgLy8gZm9yIGF1ZGlvIHNhbXBsZXMsIGFsc28gY29uc2lkZXIgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGFzIGJlaW5nIGNvbnRpZ3VvdXMgKGV2ZW4gaWYgYSBsZXZlbCBzd2l0Y2ggb2NjdXJzKSxcbiAgICAgIC8vIGZvciBzYWtlIG9mIGNsYXJpdHk6XG4gICAgICAvLyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXJlIGZyYWdzIHdpdGhcbiAgICAgIC8vICAtIGxlc3MgdGhhbiAxMDBtcyBnYXBzIGJldHdlZW4gbmV3IHRpbWUgb2Zmc2V0IChpZiBhY2N1cmF0ZSkgYW5kIG5leHQgZXhwZWN0ZWQgUFRTIE9SXG4gICAgICAvLyAgLSBsZXNzIHRoYW4gMjAgYXVkaW8gZnJhbWVzIGRpc3RhbmNlXG4gICAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgICAgLy8gdGhpcyBoZWxwcyBlbnN1cmluZyBhdWRpbyBjb250aW51aXR5XG4gICAgICAvLyBhbmQgdGhpcyBhbHNvIGF2b2lkcyBhdWRpbyBnbGl0Y2hlcy9jdXQgd2hlbiBzd2l0Y2hpbmcgcXVhbGl0eSwgb3IgcmVwb3J0aW5nIHdyb25nIGR1cmF0aW9uIG9uIGZpcnN0IGF1ZGlvIGZyYW1lXG4gICAgICB2YXIgdGltZU9mZnNldE1wZWdUUyA9IHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZTtcbiAgICAgIHZhciBpbml0VGltZSA9IGluaXRQVFMuYmFzZVRpbWUgKiBpbnB1dFRpbWVTY2FsZSAvIGluaXRQVFMudGltZXNjYWxlO1xuICAgICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IGNvbnRpZ3VvdXMgPSBjb250aWd1b3VzIHx8IGlucHV0U2FtcGxlcy5sZW5ndGggJiYgbmV4dEF1ZGlvUHRzID4gMCAmJiAoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmIE1hdGguYWJzKHRpbWVPZmZzZXRNcGVnVFMgLSBuZXh0QXVkaW9QdHMpIDwgOTAwMCB8fCBNYXRoLmFicyhub3JtYWxpemVQdHMoaW5wdXRTYW1wbGVzWzBdLnB0cyAtIGluaXRUaW1lLCB0aW1lT2Zmc2V0TXBlZ1RTKSAtIG5leHRBdWRpb1B0cykgPCAyMCAqIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuXG4gICAgICAvLyBjb21wdXRlIG5vcm1hbGl6ZWQgUFRTXG4gICAgICBpbnB1dFNhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cyAtIGluaXRUaW1lLCB0aW1lT2Zmc2V0TXBlZ1RTKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRBdWRpb1B0cyA8IDApIHtcbiAgICAgICAgLy8gZmlsdGVyIG91dCBzYW1wbGUgd2l0aCBuZWdhdGl2ZSBQVFMgdGhhdCBhcmUgbm90IHBsYXlhYmxlIGFueXdheVxuICAgICAgICAvLyBpZiB3ZSBkb24ndCByZW1vdmUgdGhlc2UgbmVnYXRpdmUgc2FtcGxlcywgdGhleSB3aWxsIHNoaWZ0IGFsbCBhdWRpbyBzYW1wbGVzIGZvcndhcmQuXG4gICAgICAgIC8vIGxlYWRpbmcgdG8gYXVkaW8gb3ZlcmxhcCBiZXR3ZWVuIGN1cnJlbnQgLyBuZXh0IGZyYWdtZW50XG4gICAgICAgIGlucHV0U2FtcGxlcyA9IGlucHV0U2FtcGxlcy5maWx0ZXIoZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgICAgIHJldHVybiBzYW1wbGUucHRzID49IDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGluIGNhc2UgYWxsIHNhbXBsZXMgaGF2ZSBuZWdhdGl2ZSBQVFMsIGFuZCBoYXZlIGJlZW4gZmlsdGVyZWQgb3V0LCByZXR1cm4gbm93XG4gICAgICAgIGlmICghaW5wdXRTYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlkZW9UaW1lT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgLy8gU2V0IHRoZSBzdGFydCB0byAwIHRvIG1hdGNoIHZpZGVvIHNvIHRoYXQgc3RhcnQgZ2FwcyBsYXJnZXIgdGhhbiBpbnB1dFNhbXBsZUR1cmF0aW9uIGFyZSBmaWxsZWQgd2l0aCBzaWxlbmNlXG4gICAgICAgICAgbmV4dEF1ZGlvUHRzID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgIWFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgICAvLyBXaGVuIG5vdCBzZWVraW5nLCBub3QgbGl2ZSwgYW5kIExldmVsRGV0YWlscy5QVFNLbm93biwgdXNlIGZyYWdtZW50IHN0YXJ0IGFzIHByZWRpY3RlZCBuZXh0IGF1ZGlvIFBUU1xuICAgICAgICAgIG5leHRBdWRpb1B0cyA9IE1hdGgubWF4KDAsIHRpbWVPZmZzZXRNcGVnVFMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIGZyYWdzIGFyZSBub3QgY29udGlndW91cyBhbmQgaWYgd2UgY2FudCB0cnVzdCB0aW1lIG9mZnNldCwgbGV0J3MgdXNlIGZpcnN0IHNhbXBsZSBQVFMgYXMgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgICBuZXh0QXVkaW9QdHMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBhdWRpbyB0cmFjayBpcyBtaXNzaW5nIHNhbXBsZXMsIHRoZSBmcmFtZXMgc2VlbSB0byBnZXQgXCJsZWZ0LXNoaWZ0ZWRcIiB3aXRoaW4gdGhlXG4gICAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgICAgLy8gSW4gYW4gZWZmb3J0IHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZywgd2UgaW5qZWN0IGZyYW1lcyBoZXJlIHdoZXJlIHRoZXJlIGFyZSBnYXBzLlxuICAgICAgLy8gV2hlbiBwb3NzaWJsZSwgd2UgaW5qZWN0IGEgc2lsZW50IGZyYW1lOyB3aGVuIHRoYXQncyBub3QgcG9zc2libGUsIHdlIGR1cGxpY2F0ZSB0aGUgbGFzdFxuICAgICAgLy8gZnJhbWUuXG5cbiAgICAgIGlmICh0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgIHZhciBtYXhBdWRpb0ZyYW1lc0RyaWZ0ID0gdGhpcy5jb25maWcubWF4QXVkaW9GcmFtZXNEcmlmdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5leHRQdHMgPSBuZXh0QXVkaW9QdHM7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBGaXJzdCwgbGV0J3Mgc2VlIGhvdyBmYXIgb2ZmIHRoaXMgZnJhbWUgaXMgZnJvbSB3aGVyZSB3ZSBleHBlY3QgaXQgdG8gYmVcbiAgICAgICAgICB2YXIgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgICAgIHZhciBwdHMgPSBzYW1wbGUucHRzO1xuICAgICAgICAgIHZhciBkZWx0YSA9IHB0cyAtIG5leHRQdHM7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gTWF0aC5hYnMoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpO1xuXG4gICAgICAgICAgLy8gV2hlbiByZW11eGluZyB3aXRoIHZpZGVvLCBpZiB3ZSdyZSBvdmVybGFwcGluZyBieSBtb3JlIHRoYW4gYSBkdXJhdGlvbiwgZHJvcCB0aGlzIHNhbXBsZSB0byBzdGF5IGluIHN5bmNcbiAgICAgICAgICBpZiAoZGVsdGEgPD0gLW1heEF1ZGlvRnJhbWVzRHJpZnQgKiBpbnB1dFNhbXBsZUR1cmF0aW9uICYmIGFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiQXVkaW8gZnJhbWUgQCBcIiArIChwdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZCgzKSArIFwicyBvdmVybGFwcyBuZXh0QXVkaW9QdHMgYnkgXCIgKyBNYXRoLnJvdW5kKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKSArIFwiIG1zLlwiKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBuZXh0QXVkaW9QdHMgPSBuZXh0UHRzID0gcHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuXG4gICAgICAgICAgLy8gSW5zZXJ0IG1pc3NpbmcgZnJhbWVzIGlmOlxuICAgICAgICAgIC8vIDE6IFdlJ3JlIG1vcmUgdGhhbiBtYXhBdWRpb0ZyYW1lc0RyaWZ0IGZyYW1lIGF3YXlcbiAgICAgICAgICAvLyAyOiBOb3QgbW9yZSB0aGFuIE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gYXdheVxuICAgICAgICAgIC8vIDM6IGN1cnJlbnRUaW1lIChha2EgbmV4dFB0c05vcm0pIGlzIG5vdCAwXG4gICAgICAgICAgLy8gNDogcmVtdXhpbmcgd2l0aCB2aWRlbyAodmlkZW9UaW1lT2Zmc2V0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgZWxzZSBpZiAoZGVsdGEgPj0gbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiYgZHVyYXRpb24gPCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OICYmIGFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgICAgIHZhciBtaXNzaW5nID0gTWF0aC5yb3VuZChkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgICAgLy8gQWRqdXN0IG5leHRQdHMgc28gdGhhdCBzaWxlbnQgc2FtcGxlcyBhcmUgYWxpZ25lZCB3aXRoIG1lZGlhIHB0cy4gVGhpcyB3aWxsIHByZXZlbnQgbWVkaWEgc2FtcGxlcyBmcm9tXG4gICAgICAgICAgICAvLyBsYXRlciBiZWluZyBzaGlmdGVkIGlmIG5leHRQdHMgaXMgYmFzZWQgb24gdGltZU9mZnNldCBhbmQgZGVsdGEgaXMgbm90IGEgbXVsdGlwbGUgb2YgaW5wdXRTYW1wbGVEdXJhdGlvbi5cbiAgICAgICAgICAgIG5leHRQdHMgPSBwdHMgLSBtaXNzaW5nICogaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIGlmIChuZXh0UHRzIDwgMCkge1xuICAgICAgICAgICAgICBtaXNzaW5nLS07XG4gICAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbmV4dEF1ZGlvUHRzID0gbmV4dFB0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiW21wNC1yZW11eGVyXTogSW5qZWN0aW5nIFwiICsgbWlzc2luZyArIFwiIGF1ZGlvIGZyYW1lIEAgXCIgKyAobmV4dFB0cyAvIGlucHV0VGltZVNjYWxlKS50b0ZpeGVkKDMpICsgXCJzIGR1ZSB0byBcIiArIE1hdGgucm91bmQoMTAwMCAqIGRlbHRhIC8gaW5wdXRUaW1lU2NhbGUpICsgXCIgbXMgZ2FwLlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWlzc2luZzsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBuZXdTdGFtcCA9IE1hdGgubWF4KG5leHRQdHMsIDApO1xuICAgICAgICAgICAgICB2YXIgZmlsbEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICAgIGlmICghZmlsbEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgICAgZmlsbEZyYW1lID0gc2FtcGxlLnVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbnB1dFNhbXBsZXMuc3BsaWNlKGksIDAsIHtcbiAgICAgICAgICAgICAgICB1bml0OiBmaWxsRnJhbWUsXG4gICAgICAgICAgICAgICAgcHRzOiBuZXdTdGFtcFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNhbXBsZS5wdHMgPSBuZXh0UHRzO1xuICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGZpcnN0UFRTID0gbnVsbDtcbiAgICAgIHZhciBsYXN0UFRTID0gbnVsbDtcbiAgICAgIHZhciBtZGF0O1xuICAgICAgdmFyIG1kYXRTaXplID0gMDtcbiAgICAgIHZhciBzYW1wbGVMZW5ndGggPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKHNhbXBsZUxlbmd0aC0tKSB7XG4gICAgICAgIG1kYXRTaXplICs9IGlucHV0U2FtcGxlc1tzYW1wbGVMZW5ndGhdLnVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9qMiA9IDAsIF9uYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoOyBfajIgPCBfbmJTYW1wbGVzOyBfajIrKykge1xuICAgICAgICB2YXIgYXVkaW9TYW1wbGUgPSBpbnB1dFNhbXBsZXNbX2oyXTtcbiAgICAgICAgdmFyIHVuaXQgPSBhdWRpb1NhbXBsZS51bml0O1xuICAgICAgICB2YXIgX3B0czIgPSBhdWRpb1NhbXBsZS5wdHM7XG4gICAgICAgIGlmIChsYXN0UFRTICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHNhbXBsZSwgc2V0IHRoZSBkdXJhdGlvbiBvZiB0aGUgc2FtcGxlIHRvIHRoZSBcInJlYWxcIiBkdXJhdGlvbjsgdGhlIFBUUyBkaWZmIHdpdGhcbiAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgc2FtcGxlXG4gICAgICAgICAgdmFyIHByZXZTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW19qMiAtIDFdO1xuICAgICAgICAgIHByZXZTYW1wbGUuZHVyYXRpb24gPSBNYXRoLnJvdW5kKChfcHRzMiAtIGxhc3RQVFMpIC8gc2NhbGVGYWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb250aWd1b3VzICYmIHRyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ2FhYycpIHtcbiAgICAgICAgICAgIC8vIHNldCBQVFMvRFRTIHRvIGV4cGVjdGVkIFBUUy9EVFNcbiAgICAgICAgICAgIF9wdHMyID0gbmV4dEF1ZGlvUHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2Ygb3VyIGF1ZGlvU2FtcGxlc1xuICAgICAgICAgIGZpcnN0UFRTID0gX3B0czI7XG4gICAgICAgICAgaWYgKG1kYXRTaXplID4gMCkge1xuICAgICAgICAgICAgLyogY29uY2F0ZW5hdGUgdGhlIGF1ZGlvIGRhdGEgYW5kIGNvbnN0cnVjdCB0aGUgbWRhdCBpbiBwbGFjZVxuICAgICAgICAgICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1kYXQgdHlwZSkgKi9cbiAgICAgICAgICAgIG1kYXRTaXplICs9IG9mZnNldDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NVVhfRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLFxuICAgICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgIGJ5dGVzOiBtZGF0U2l6ZSxcbiAgICAgICAgICAgICAgICByZWFzb246IFwiZmFpbCBhbGxvY2F0aW5nIGF1ZGlvIG1kYXQgXCIgKyBtZGF0U2l6ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyYXdNUEVHKSB7XG4gICAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgICAgICAgICAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIGF1ZGlvIHNhbXBsZXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWRhdC5zZXQodW5pdCwgb2Zmc2V0KTtcbiAgICAgICAgdmFyIHVuaXRMZW4gPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICAgIG9mZnNldCArPSB1bml0TGVuO1xuICAgICAgICAvLyBEZWZhdWx0IHRoZSBzYW1wbGUncyBkdXJhdGlvbiB0byB0aGUgY29tcHV0ZWQgbXA0U2FtcGxlRHVyYXRpb24sIHdoaWNoIHdpbGwgZWl0aGVyIGJlIDEwMjQgZm9yIEFBQyBvciAxMTUyIGZvciBNUEVHXG4gICAgICAgIC8vIEluIHRoZSBjYXNlIHRoYXQgd2UgaGF2ZSAxIHNhbXBsZSwgdGhpcyB3aWxsIGJlIHRoZSBkdXJhdGlvbi4gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHNhbXBsZSwgdGhlIGR1cmF0aW9uXG4gICAgICAgIC8vIGJlY29tZXMgdGhlIFBUUyBkaWZmIHdpdGggdGhlIHByZXZpb3VzIHNhbXBsZVxuICAgICAgICBvdXRwdXRTYW1wbGVzLnB1c2gobmV3IE1wNFNhbXBsZSh0cnVlLCBtcDRTYW1wbGVEdXJhdGlvbiwgdW5pdExlbiwgMCkpO1xuICAgICAgICBsYXN0UFRTID0gX3B0czI7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGNvdWxkIGVuZCB1cCB3aXRoIG5vIGF1ZGlvIHNhbXBsZXMgaWYgYWxsIGlucHV0IHNhbXBsZXMgd2VyZSBvdmVybGFwcGluZyB3aXRoIHRoZSBwcmV2aW91c2x5IHJlbXV4ZWQgb25lc1xuICAgICAgdmFyIG5iU2FtcGxlcyA9IG91dHB1dFNhbXBsZXMubGVuZ3RoO1xuICAgICAgaWYgKCFuYlNhbXBsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbmV4dCBhdWRpbyBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBkdXJhdGlvblxuICAgICAgdmFyIGxhc3RTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW291dHB1dFNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IGxhc3RQVFMgKyBzY2FsZUZhY3RvciAqIGxhc3RTYW1wbGUuZHVyYXRpb247XG5cbiAgICAgIC8vIFNldCB0aGUgdHJhY2sgc2FtcGxlcyBmcm9tIGlucHV0U2FtcGxlcyB0byBvdXRwdXRTYW1wbGVzIGJlZm9yZSByZW11eGluZ1xuICAgICAgdmFyIG1vb2YgPSByYXdNUEVHID8gbmV3IFVpbnQ4QXJyYXkoMCkgOiBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdFBUUyAvIHNjYWxlRmFjdG9yLCBfZXh0ZW5kcyh7fSwgdHJhY2ssIHtcbiAgICAgICAgc2FtcGxlczogb3V0cHV0U2FtcGxlc1xuICAgICAgfSkpO1xuXG4gICAgICAvLyBDbGVhciB0aGUgdHJhY2sgc2FtcGxlcy4gVGhpcyBhbHNvIGNsZWFycyB0aGUgc2FtcGxlcyBhcnJheSBpbiB0aGUgZGVtdXhlciwgc2luY2UgdGhlIHJlZmVyZW5jZSBpcyBzaGFyZWRcbiAgICAgIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgICAgIHZhciBzdGFydCA9IGZpcnN0UFRTIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgICB2YXIgZW5kID0gbmV4dEF1ZGlvUHRzIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgICB2YXIgdHlwZSA9ICdhdWRpbyc7XG4gICAgICB2YXIgYXVkaW9EYXRhID0ge1xuICAgICAgICBkYXRhMTogbW9vZixcbiAgICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICAgIHN0YXJ0UFRTOiBzdGFydCxcbiAgICAgICAgZW5kUFRTOiBlbmQsXG4gICAgICAgIHN0YXJ0RFRTOiBzdGFydCxcbiAgICAgICAgZW5kRFRTOiBlbmQsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGhhc0F1ZGlvOiB0cnVlLFxuICAgICAgICBoYXNWaWRlbzogZmFsc2UsXG4gICAgICAgIG5iOiBuYlNhbXBsZXNcbiAgICAgIH07XG4gICAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBhdWRpb0RhdGE7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtdXhFbXB0eUF1ZGlvID0gZnVuY3Rpb24gcmVtdXhFbXB0eUF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCB2aWRlb0RhdGEpIHtcbiAgICAgIHZhciBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgdmFyIG1wNHRpbWVTY2FsZSA9IHRyYWNrLnNhbXBsZXJhdGUgPyB0cmFjay5zYW1wbGVyYXRlIDogaW5wdXRUaW1lU2NhbGU7XG4gICAgICB2YXIgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICAgIHZhciBuZXh0QXVkaW9QdHMgPSB0aGlzLm5leHRBdWRpb1B0cztcbiAgICAgIC8vIHN5bmMgd2l0aCB2aWRlbydzIHRpbWVzdGFtcFxuICAgICAgdmFyIGluaXREVFMgPSB0aGlzLl9pbml0RFRTO1xuICAgICAgdmFyIGluaXQ5MGtIeiA9IGluaXREVFMuYmFzZVRpbWUgKiA5MDAwMCAvIGluaXREVFMudGltZXNjYWxlO1xuICAgICAgdmFyIHN0YXJ0RFRTID0gKG5leHRBdWRpb1B0cyAhPT0gbnVsbCA/IG5leHRBdWRpb1B0cyA6IHZpZGVvRGF0YS5zdGFydERUUyAqIGlucHV0VGltZVNjYWxlKSArIGluaXQ5MGtIejtcbiAgICAgIHZhciBlbmREVFMgPSB2aWRlb0RhdGEuZW5kRFRTICogaW5wdXRUaW1lU2NhbGUgKyBpbml0OTBrSHo7XG4gICAgICAvLyBvbmUgc2FtcGxlJ3MgZHVyYXRpb24gdmFsdWVcbiAgICAgIHZhciBmcmFtZUR1cmF0aW9uID0gc2NhbGVGYWN0b3IgKiBBQUNfU0FNUExFU19QRVJfRlJBTUU7XG4gICAgICAvLyBzYW1wbGVzIGNvdW50IG9mIHRoaXMgc2VnbWVudCdzIGR1cmF0aW9uXG4gICAgICB2YXIgbmJTYW1wbGVzID0gTWF0aC5jZWlsKChlbmREVFMgLSBzdGFydERUUykgLyBmcmFtZUR1cmF0aW9uKTtcbiAgICAgIC8vIHNpbGVudCBmcmFtZVxuICAgICAgdmFyIHNpbGVudEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgICBsb2dnZXIud2FybignW21wNC1yZW11eGVyXTogcmVtdXggZW1wdHkgQXVkaW8nKTtcbiAgICAgIC8vIENhbid0IHJlbXV4IGlmIHdlIGNhbid0IGdlbmVyYXRlIGEgc2lsZW50IGZyYW1lLi4uXG4gICAgICBpZiAoIXNpbGVudEZyYW1lKSB7XG4gICAgICAgIGxvZ2dlci50cmFjZSgnW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIHJlbXV4RW1wdHlBdWRpbyBzaW5jZSB3ZSB3ZXJlIHVuYWJsZSB0byBnZXQgYSBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzYW1wbGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IHN0YXJ0RFRTICsgaSAqIGZyYW1lRHVyYXRpb247XG4gICAgICAgIHNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgdW5pdDogc2lsZW50RnJhbWUsXG4gICAgICAgICAgcHRzOiBzdGFtcCxcbiAgICAgICAgICBkdHM6IHN0YW1wXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdHJhY2suc2FtcGxlcyA9IHNhbXBsZXM7XG4gICAgICByZXR1cm4gdGhpcy5yZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTVA0UmVtdXhlcjtcbiAgfSgpO1xuICBmdW5jdGlvbiBub3JtYWxpemVQdHModmFsdWUsIHJlZmVyZW5jZSkge1xuICAgIHZhciBvZmZzZXQ7XG4gICAgaWYgKHJlZmVyZW5jZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAocmVmZXJlbmNlIDwgdmFsdWUpIHtcbiAgICAgIC8vIC0gMl4zM1xuICAgICAgb2Zmc2V0ID0gLTg1ODk5MzQ1OTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICsgMl4zM1xuICAgICAgb2Zmc2V0ID0gODU4OTkzNDU5MjtcbiAgICB9XG4gICAgLyogUFRTIGlzIDMzYml0IChmcm9tIDAgdG8gMl4zMyAtMSlcbiAgICAgIGlmIGRpZmYgYmV0d2VlbiB2YWx1ZSBhbmQgcmVmZXJlbmNlIGlzIGJpZ2dlciB0aGFuIGhhbGYgb2YgdGhlIGFtcGxpdHVkZSAoMl4zMikgdGhlbiBpdCBtZWFucyB0aGF0XG4gICAgICBQVFMgbG9vcGluZyBvY2N1cmVkLiBmaWxsIHRoZSBnYXAgKi9cbiAgICB3aGlsZSAoTWF0aC5hYnModmFsdWUgLSByZWZlcmVuY2UpID4gNDI5NDk2NzI5Nikge1xuICAgICAgdmFsdWUgKz0gb2Zmc2V0O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZmluZEtleWZyYW1lSW5kZXgoc2FtcGxlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHNhbXBsZXNbaV0ua2V5KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZnVuY3Rpb24gZmx1c2hUZXh0VHJhY2tNZXRhZGF0YUN1ZVNhbXBsZXModHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQVFMsIGluaXREVFMpIHtcbiAgICB2YXIgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgICAgLy8gc2V0dGluZyBpZDMgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFBUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlIC8gaW5pdFBUUy50aW1lc2NhbGUsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICAgIHNhbXBsZS5kdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLmR0cyAtIGluaXREVFMuYmFzZVRpbWUgKiBpbnB1dFRpbWVTY2FsZSAvIGluaXREVFMudGltZXNjYWxlLCB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUpIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgfVxuICAgIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZXM6IHNhbXBsZXNcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZsdXNoVGV4dFRyYWNrVXNlcmRhdGFDdWVTYW1wbGVzKHRyYWNrLCB0aW1lT2Zmc2V0LCBpbml0UFRTKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAgIC8vIHNldHRpbmcgdGV4dCBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0UFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZSwgdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlKSAvIGlucHV0VGltZVNjYWxlO1xuICAgIH1cbiAgICB0cmFjay5zYW1wbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLnB0cyAtIGIucHRzO1xuICAgIH0pO1xuICAgIHZhciBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZXM6IHNhbXBsZXNcbiAgICB9O1xuICB9XG4gIHZhciBNcDRTYW1wbGUgPSBmdW5jdGlvbiBNcDRTYW1wbGUoaXNLZXlmcmFtZSwgZHVyYXRpb24sIHNpemUsIGN0cykge1xuICAgIHRoaXMuc2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuY3RzID0gdm9pZCAwO1xuICAgIHRoaXMuZmxhZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5jdHMgPSBjdHM7XG4gICAgdGhpcy5mbGFncyA9IHtcbiAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgZGVwZW5kc09uOiBpc0tleWZyYW1lID8gMiA6IDEsXG4gICAgICBpc05vblN5bmM6IGlzS2V5ZnJhbWUgPyAwIDogMVxuICAgIH07XG4gIH07XG5cbiAgdmFyIFBhc3NUaHJvdWdoUmVtdXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFzc1Rocm91Z2hSZW11eGVyKCkge1xuICAgICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMDtcbiAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaW5pdERhdGEgPSB2b2lkIDA7XG4gICAgICB0aGlzLmluaXRQVFMgPSBudWxsO1xuICAgICAgdGhpcy5pbml0VHJhY2tzID0gdm9pZCAwO1xuICAgICAgdGhpcy5sYXN0RW5kVGltZSA9IG51bGw7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBQYXNzVGhyb3VnaFJlbXV4ZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHt9O1xuICAgIF9wcm90by5yZXNldFRpbWVTdGFtcCA9IGZ1bmN0aW9uIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UFRTKSB7XG4gICAgICB0aGlzLmluaXRQVFMgPSBkZWZhdWx0SW5pdFBUUztcbiAgICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0TmV4dFRpbWVzdGFtcCA9IGZ1bmN0aW9uIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkZWNyeXB0ZGF0YSkge1xuICAgICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgICB0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQocGF0Y2hFbmN5cHRpb25EYXRhKGluaXRTZWdtZW50LCBkZWNyeXB0ZGF0YSkpO1xuICAgICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlSW5pdFNlZ21lbnQgPSBmdW5jdGlvbiBnZW5lcmF0ZUluaXRTZWdtZW50KGluaXRTZWdtZW50KSB7XG4gICAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMuYXVkaW9Db2RlYyxcbiAgICAgICAgdmlkZW9Db2RlYyA9IHRoaXMudmlkZW9Db2RlYztcbiAgICAgIGlmICghKGluaXRTZWdtZW50ICE9IG51bGwgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkpIHtcbiAgICAgICAgdGhpcy5pbml0VHJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmluaXREYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhID0gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCk7XG5cbiAgICAgIC8vIEdldCBjb2RlYyBmcm9tIGluaXRTZWdtZW50IG9yIGZhbGxiYWNrIHRvIGRlZmF1bHRcbiAgICAgIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgICBhdWRpb0NvZGVjID0gZ2V0UGFyc2VkVHJhY2tDb2RlYyhpbml0RGF0YS5hdWRpbywgRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgICB2aWRlb0NvZGVjID0gZ2V0UGFyc2VkVHJhY2tDb2RlYyhpbml0RGF0YS52aWRlbywgRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKTtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFja3MgPSB7fTtcbiAgICAgIGlmIChpbml0RGF0YS5hdWRpbyAmJiBpbml0RGF0YS52aWRlbykge1xuICAgICAgICB0cmFja3MuYXVkaW92aWRlbyA9IHtcbiAgICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICAgIGNvZGVjOiBhdWRpb0NvZGVjICsgJywnICsgdmlkZW9Db2RlYyxcbiAgICAgICAgICBpbml0U2VnbWVudDogaW5pdFNlZ21lbnQsXG4gICAgICAgICAgaWQ6ICdtYWluJ1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgICAgY29udGFpbmVyOiAnYXVkaW8vbXA0JyxcbiAgICAgICAgICBjb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgICAgICBpbml0U2VnbWVudDogaW5pdFNlZ21lbnQsXG4gICAgICAgICAgaWQ6ICdhdWRpbydcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICAgIGNvbnRhaW5lcjogJ3ZpZGVvL21wNCcsXG4gICAgICAgICAgY29kZWM6IHZpZGVvQ29kZWMsXG4gICAgICAgICAgaW5pdFNlZ21lbnQ6IGluaXRTZWdtZW50LFxuICAgICAgICAgIGlkOiAnbWFpbidcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdbcGFzc3Rocm91Z2gtcmVtdXhlci50c106IGluaXRTZWdtZW50IGRvZXMgbm90IGNvbnRhaW4gbW9vdiBvciB0cmFrIGJveGVzLicpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbml0VHJhY2tzID0gdHJhY2tzO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbXV4ID0gZnVuY3Rpb24gcmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICB2YXIgX2luaXREYXRhLCBfaW5pdERhdGEyO1xuICAgICAgdmFyIGluaXRQVFMgPSB0aGlzLmluaXRQVFMsXG4gICAgICAgIGxhc3RFbmRUaW1lID0gdGhpcy5sYXN0RW5kVGltZTtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGF1ZGlvOiB1bmRlZmluZWQsXG4gICAgICAgIHZpZGVvOiB1bmRlZmluZWQsXG4gICAgICAgIHRleHQ6IHRleHRUcmFjayxcbiAgICAgICAgaWQzOiBpZDNUcmFjayxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZW4ndCB5ZXQgc2V0IGEgbGFzdEVuZERUUywgb3IgaXQgd2FzIHJlc2V0LCBzZXQgaXQgdG8gdGhlIHByb3ZpZGVkIHRpbWVPZmZzZXQuIFdlIHdhbnQgdG8gdXNlIHRoZVxuICAgICAgLy8gbGFzdEVuZERUUyBvdmVyIHRpbWVPZmZzZXQgd2hlbmV2ZXIgcG9zc2libGU7IGR1cmluZyBwcm9ncmVzc2l2ZSBwbGF5YmFjaywgdGhlIG1lZGlhIHNvdXJjZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAgIC8vIHRoZSBtZWRpYSBkdXJhdGlvbiAod2hpY2ggaXMgd2hhdCB0aW1lT2Zmc2V0IGlzIHByb3ZpZGVkIGFzKSBiZWZvcmUgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBuZXh0IGNodW5rLlxuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihsYXN0RW5kVGltZSkpIHtcbiAgICAgICAgbGFzdEVuZFRpbWUgPSB0aGlzLmxhc3RFbmRUaW1lID0gdGltZU9mZnNldCB8fCAwO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgYmluYXJ5IHNlZ21lbnQgZGF0YSBpcyBhZGRlZCB0byB0aGUgdmlkZW9UcmFjayBpbiB0aGUgbXA0ZGVtdXhlci4gV2UgZG9uJ3QgY2hlY2sgdG8gc2VlIGlmIHRoZSBkYXRhIGlzIG9ubHlcbiAgICAgIC8vIGF1ZGlvIG9yIHZpZGVvIChvciBib3RoKTsgYWRkaW5nIGl0IHRvIHZpZGVvIHdhcyBhbiBhcmJpdHJhcnkgY2hvaWNlLlxuICAgICAgdmFyIGRhdGEgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgICBpZiAoIShkYXRhICE9IG51bGwgJiYgZGF0YS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5pdFNlZ21lbnQgPSB7XG4gICAgICAgIGluaXRQVFM6IHVuZGVmaW5lZCxcbiAgICAgICAgdGltZXNjYWxlOiAxXG4gICAgICB9O1xuICAgICAgdmFyIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICAgIGlmICghKChfaW5pdERhdGEgPSBpbml0RGF0YSkgIT0gbnVsbCAmJiBfaW5pdERhdGEubGVuZ3RoKSkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQoZGF0YSk7XG4gICAgICAgIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICAgIH1cbiAgICAgIGlmICghKChfaW5pdERhdGEyID0gaW5pdERhdGEpICE9IG51bGwgJiYgX2luaXREYXRhMi5sZW5ndGgpKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHJlbXV4IGlmIHRoZSBpbml0U2VnbWVudCBjb3VsZCBub3QgYmUgZ2VuZXJhdGVkXG4gICAgICAgIGxvZ2dlci53YXJuKCdbcGFzc3Rocm91Z2gtcmVtdXhlci50c106IEZhaWxlZCB0byBnZW5lcmF0ZSBpbml0U2VnbWVudC4nKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVtaXRJbml0U2VnbWVudCkge1xuICAgICAgICBpbml0U2VnbWVudC50cmFja3MgPSB0aGlzLmluaXRUcmFja3M7XG4gICAgICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgZHVyYXRpb24gPSBnZXREdXJhdGlvbihkYXRhLCBpbml0RGF0YSk7XG4gICAgICB2YXIgc3RhcnREVFMgPSBnZXRTdGFydERUUyhpbml0RGF0YSwgZGF0YSk7XG4gICAgICB2YXIgZGVjb2RlVGltZSA9IHN0YXJ0RFRTID09PSBudWxsID8gdGltZU9mZnNldCA6IHN0YXJ0RFRTO1xuICAgICAgaWYgKGlzSW52YWxpZEluaXRQdHMoaW5pdFBUUywgZGVjb2RlVGltZSwgdGltZU9mZnNldCwgZHVyYXRpb24pIHx8IGluaXRTZWdtZW50LnRpbWVzY2FsZSAhPT0gaW5pdFBUUy50aW1lc2NhbGUgJiYgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICAgIGluaXRTZWdtZW50LmluaXRQVFMgPSBkZWNvZGVUaW1lIC0gdGltZU9mZnNldDtcbiAgICAgICAgaWYgKGluaXRQVFMgJiYgaW5pdFBUUy50aW1lc2NhbGUgPT09IDEpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihcIkFkanVzdGluZyBpbml0UFRTIGJ5IFwiICsgKGluaXRTZWdtZW50LmluaXRQVFMgLSBpbml0UFRTLmJhc2VUaW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0UFRTID0gaW5pdFBUUyA9IHtcbiAgICAgICAgICBiYXNlVGltZTogaW5pdFNlZ21lbnQuaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGU6IDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBzdGFydFRpbWUgPSBhdWRpb1RyYWNrID8gZGVjb2RlVGltZSAtIGluaXRQVFMuYmFzZVRpbWUgLyBpbml0UFRTLnRpbWVzY2FsZSA6IGxhc3RFbmRUaW1lO1xuICAgICAgdmFyIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICAgIG9mZnNldFN0YXJ0RFRTKGluaXREYXRhLCBkYXRhLCBpbml0UFRTLmJhc2VUaW1lIC8gaW5pdFBUUy50aW1lc2NhbGUpO1xuICAgICAgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgICAgICB0aGlzLmxhc3RFbmRUaW1lID0gZW5kVGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdEdXJhdGlvbiBwYXJzZWQgZnJvbSBtcDQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gICAgICAgIHRoaXMucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzQXVkaW8gPSAhIWluaXREYXRhLmF1ZGlvO1xuICAgICAgdmFyIGhhc1ZpZGVvID0gISFpbml0RGF0YS52aWRlbztcbiAgICAgIHZhciB0eXBlID0gJyc7XG4gICAgICBpZiAoaGFzQXVkaW8pIHtcbiAgICAgICAgdHlwZSArPSAnYXVkaW8nO1xuICAgICAgfVxuICAgICAgaWYgKGhhc1ZpZGVvKSB7XG4gICAgICAgIHR5cGUgKz0gJ3ZpZGVvJztcbiAgICAgIH1cbiAgICAgIHZhciB0cmFjayA9IHtcbiAgICAgICAgZGF0YTE6IGRhdGEsXG4gICAgICAgIHN0YXJ0UFRTOiBzdGFydFRpbWUsXG4gICAgICAgIHN0YXJ0RFRTOiBzdGFydFRpbWUsXG4gICAgICAgIGVuZFBUUzogZW5kVGltZSxcbiAgICAgICAgZW5kRFRTOiBlbmRUaW1lLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBoYXNBdWRpbzogaGFzQXVkaW8sXG4gICAgICAgIGhhc1ZpZGVvOiBoYXNWaWRlbyxcbiAgICAgICAgbmI6IDEsXG4gICAgICAgIGRyb3BwZWQ6IDBcbiAgICAgIH07XG4gICAgICByZXN1bHQuYXVkaW8gPSB0cmFjay50eXBlID09PSAnYXVkaW8nID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgICByZXN1bHQudmlkZW8gPSB0cmFjay50eXBlICE9PSAnYXVkaW8nID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgICByZXN1bHQuaW5pdFNlZ21lbnQgPSBpbml0U2VnbWVudDtcbiAgICAgIHJlc3VsdC5pZDMgPSBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyhpZDNUcmFjaywgdGltZU9mZnNldCwgaW5pdFBUUywgaW5pdFBUUyk7XG4gICAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC50ZXh0ID0gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXModGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBpbml0UFRTKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gUGFzc1Rocm91Z2hSZW11eGVyO1xuICB9KCk7XG4gIGZ1bmN0aW9uIGlzSW52YWxpZEluaXRQdHMoaW5pdFBUUywgc3RhcnREVFMsIHRpbWVPZmZzZXQsIGR1cmF0aW9uKSB7XG4gICAgaWYgKGluaXRQVFMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBJbml0UFRTIGlzIGludmFsaWQgd2hlbiBkaXN0YW5jZSBmcm9tIHByb2dyYW0gd291bGQgYmUgbW9yZSB0aGFuIHNlZ21lbnQgZHVyYXRpb24gb3IgYSBtaW5pbXVtIG9mIG9uZSBzZWNvbmRcbiAgICB2YXIgbWluRHVyYXRpb24gPSBNYXRoLm1heChkdXJhdGlvbiwgMSk7XG4gICAgdmFyIHN0YXJ0VGltZSA9IHN0YXJ0RFRTIC0gaW5pdFBUUy5iYXNlVGltZSAvIGluaXRQVFMudGltZXNjYWxlO1xuICAgIHJldHVybiBNYXRoLmFicyhzdGFydFRpbWUgLSB0aW1lT2Zmc2V0KSA+IG1pbkR1cmF0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGdldFBhcnNlZFRyYWNrQ29kZWModHJhY2ssIHR5cGUpIHtcbiAgICB2YXIgcGFyc2VkQ29kZWMgPSB0cmFjayA9PSBudWxsID8gdm9pZCAwIDogdHJhY2suY29kZWM7XG4gICAgaWYgKHBhcnNlZENvZGVjICYmIHBhcnNlZENvZGVjLmxlbmd0aCA+IDQpIHtcbiAgICAgIHJldHVybiBwYXJzZWRDb2RlYztcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTykge1xuICAgICAgaWYgKHBhcnNlZENvZGVjID09PSAnZWMtMycgfHwgcGFyc2VkQ29kZWMgPT09ICdhYy0zJyB8fCBwYXJzZWRDb2RlYyA9PT0gJ2FsYWMnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWRDb2RlYztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWRDb2RlYyA9PT0gJ2ZMYUMnIHx8IHBhcnNlZENvZGVjID09PSAnT3B1cycpIHtcbiAgICAgICAgLy8gT3B0aW5nIG5vdCB0byBnZXQgYHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZWAgZnJvbSBwbGF5ZXIgY29uZmlnIGZvciBpc1N1cHBvcnRlZCgpIGNoZWNrIGZvciBzaW1wbGljaXR5XG4gICAgICAgIHZhciBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGdldENvZGVjQ29tcGF0aWJsZU5hbWUocGFyc2VkQ29kZWMsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gJ21wNGEuNDAuNSc7XG4gICAgICBsb2dnZXIuaW5mbyhcIlBhcnNlZCBhdWRpbyBjb2RlYyBcXFwiXCIgKyBwYXJzZWRDb2RlYyArIFwiXFxcIiBvciBhdWRpbyBvYmplY3QgdHlwZSBub3QgaGFuZGxlZC4gVXNpbmcgXFxcIlwiICsgcmVzdWx0ICsgXCJcXFwiXCIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUHJvdmlkZSBkZWZhdWx0cyBiYXNlZCBvbiBjb2RlYyB0eXBlXG4gICAgLy8gVGhpcyBhbGxvd3MgZm9yIHNvbWUgcGxheWJhY2sgb2Ygc29tZSBmbXA0IHBsYXlsaXN0cyB3aXRob3V0IENPREVDUyBkZWZpbmVkIGluIG1hbmlmZXN0XG4gICAgbG9nZ2VyLndhcm4oXCJVbmhhbmRsZWQgdmlkZW8gY29kZWMgXFxcIlwiICsgcGFyc2VkQ29kZWMgKyBcIlxcXCJcIik7XG4gICAgaWYgKHBhcnNlZENvZGVjID09PSAnaHZjMScgfHwgcGFyc2VkQ29kZWMgPT09ICdoZXYxJykge1xuICAgICAgcmV0dXJuICdodmMxLjEuNi5MMTIwLjkwJztcbiAgICB9XG4gICAgaWYgKHBhcnNlZENvZGVjID09PSAnYXYwMScpIHtcbiAgICAgIHJldHVybiAnYXYwMS4wLjA0TS4wOCc7XG4gICAgfVxuICAgIHJldHVybiAnYXZjMS40MmUwMWUnO1xuICB9XG5cbiAgdmFyIG5vdztcbiAgLy8gcGVyZm9ybWFuY2Uubm93KCkgbm90IGF2YWlsYWJsZSBvbiBXZWJXb3JrZXIsIGF0IGxlYXN0IG9uIFNhZmFyaSBEZXNrdG9wXG4gIHRyeSB7XG4gICAgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3cuYmluZChzZWxmLnBlcmZvcm1hbmNlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdVbmFibGUgdG8gdXNlIFBlcmZvcm1hbmNlIEFQSSBvbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgbm93ID0gb3B0aW9uYWxTZWxmID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25hbFNlbGYuRGF0ZS5ub3c7XG4gIH1cbiAgdmFyIG11eENvbmZpZyA9IFt7XG4gICAgZGVtdXg6IE1QNERlbXV4ZXIsXG4gICAgcmVtdXg6IFBhc3NUaHJvdWdoUmVtdXhlclxuICB9LCB7XG4gICAgZGVtdXg6IFRTRGVtdXhlcixcbiAgICByZW11eDogTVA0UmVtdXhlclxuICB9LCB7XG4gICAgZGVtdXg6IEFBQ0RlbXV4ZXIsXG4gICAgcmVtdXg6IE1QNFJlbXV4ZXJcbiAgfSwge1xuICAgIGRlbXV4OiBNUDNEZW11eGVyLFxuICAgIHJlbXV4OiBNUDRSZW11eGVyXG4gIH1dO1xuICB7XG4gICAgbXV4Q29uZmlnLnNwbGljZSgyLCAwLCB7XG4gICAgICBkZW11eDogQUMzRGVtdXhlcixcbiAgICAgIHJlbXV4OiBNUDRSZW11eGVyXG4gICAgfSk7XG4gIH1cbiAgdmFyIFRyYW5zbXV4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zbXV4ZXIob2JzZXJ2ZXIsIHR5cGVTdXBwb3J0ZWQsIGNvbmZpZywgdmVuZG9yLCBpZCkge1xuICAgICAgdGhpcy5hc3luYyA9IGZhbHNlO1xuICAgICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgICAgdGhpcy52ZW5kb3IgPSB2b2lkIDA7XG4gICAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgICAgdGhpcy5kZW11eGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5yZW11eGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5kZWNyeXB0ZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLnByb2JlID0gdm9pZCAwO1xuICAgICAgdGhpcy5kZWNyeXB0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICB0aGlzLnRyYW5zbXV4Q29uZmlnID0gdm9pZCAwO1xuICAgICAgdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgIHRoaXMudmVuZG9yID0gdmVuZG9yO1xuICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gVHJhbnNtdXhlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIGNvbmZpZ3VyZSh0cmFuc211eENvbmZpZykge1xuICAgICAgdGhpcy50cmFuc211eENvbmZpZyA9IHRyYW5zbXV4Q29uZmlnO1xuICAgICAgaWYgKHRoaXMuZGVjcnlwdGVyKSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdGVyLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucHVzaCA9IGZ1bmN0aW9uIHB1c2goZGF0YSwgZGVjcnlwdGRhdGEsIGNodW5rTWV0YSwgc3RhdGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgICBzdGF0cy5leGVjdXRlU3RhcnQgPSBub3coKTtcbiAgICAgIHZhciB1aW50RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgdmFyIGN1cnJlbnRUcmFuc211eFN0YXRlID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSxcbiAgICAgICAgdHJhbnNtdXhDb25maWcgPSB0aGlzLnRyYW5zbXV4Q29uZmlnO1xuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUgPSBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIHZhciBfcmVmID0gc3RhdGUgfHwgY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICAgIGNvbnRpZ3VvdXMgPSBfcmVmLmNvbnRpZ3VvdXMsXG4gICAgICAgIGRpc2NvbnRpbnVpdHkgPSBfcmVmLmRpc2NvbnRpbnVpdHksXG4gICAgICAgIHRyYWNrU3dpdGNoID0gX3JlZi50cmFja1N3aXRjaCxcbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gX3JlZi5hY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICAgIHRpbWVPZmZzZXQgPSBfcmVmLnRpbWVPZmZzZXQsXG4gICAgICAgIGluaXRTZWdtZW50Q2hhbmdlID0gX3JlZi5pbml0U2VnbWVudENoYW5nZTtcbiAgICAgIHZhciBhdWRpb0NvZGVjID0gdHJhbnNtdXhDb25maWcuYXVkaW9Db2RlYyxcbiAgICAgICAgdmlkZW9Db2RlYyA9IHRyYW5zbXV4Q29uZmlnLnZpZGVvQ29kZWMsXG4gICAgICAgIGRlZmF1bHRJbml0UHRzID0gdHJhbnNtdXhDb25maWcuZGVmYXVsdEluaXRQdHMsXG4gICAgICAgIGR1cmF0aW9uID0gdHJhbnNtdXhDb25maWcuZHVyYXRpb24sXG4gICAgICAgIGluaXRTZWdtZW50RGF0YSA9IHRyYW5zbXV4Q29uZmlnLmluaXRTZWdtZW50RGF0YTtcbiAgICAgIHZhciBrZXlEYXRhID0gZ2V0RW5jcnlwdGlvblR5cGUodWludERhdGEsIGRlY3J5cHRkYXRhKTtcbiAgICAgIGlmIChrZXlEYXRhICYmIGtleURhdGEubWV0aG9kID09PSAnQUVTLTEyOCcpIHtcbiAgICAgICAgdmFyIGRlY3J5cHRlciA9IHRoaXMuZ2V0RGVjcnlwdGVyKCk7XG4gICAgICAgIC8vIFNvZnR3YXJlIGRlY3J5cHRpb24gaXMgc3luY2hyb25vdXM7IHdlYkNyeXB0byBpcyBub3RcbiAgICAgICAgaWYgKGRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICAgIC8vIFNvZnR3YXJlIGRlY3J5cHRpb24gaXMgcHJvZ3Jlc3NpdmUuIFByb2dyZXNzaXZlIGRlY3J5cHRpb24gbWF5IG5vdCByZXR1cm4gYSByZXN1bHQgb24gZWFjaCBjYWxsLiBBbnkgY2FjaGVkXG4gICAgICAgICAgLy8gZGF0YSBpcyBoYW5kbGVkIGluIHRoZSBmbHVzaCgpIGNhbGxcbiAgICAgICAgICB2YXIgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5zb2Z0d2FyZURlY3J5cHQodWludERhdGEsIGtleURhdGEua2V5LmJ1ZmZlciwga2V5RGF0YS5pdi5idWZmZXIpO1xuICAgICAgICAgIC8vIEZvciBMb3ctTGF0ZW5jeSBITFMgUGFydHMsIGRlY3J5cHQgaW4gcGxhY2UsIHNpbmNlIHBhcnQgcGFyc2luZyBpcyBleHBlY3RlZCBvbiBwdXNoIHByb2dyZXNzXG4gICAgICAgICAgdmFyIGxvYWRpbmdQYXJ0cyA9IGNodW5rTWV0YS5wYXJ0ID4gLTE7XG4gICAgICAgICAgaWYgKGxvYWRpbmdQYXJ0cykge1xuICAgICAgICAgICAgZGVjcnlwdGVkRGF0YSA9IGRlY3J5cHRlci5mbHVzaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eVJlc3VsdChjaHVua01ldGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1aW50RGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZERhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBkZWNyeXB0ZXIud2ViQ3J5cHRvRGVjcnlwdCh1aW50RGF0YSwga2V5RGF0YS5rZXkuYnVmZmVyLCBrZXlEYXRhLml2LmJ1ZmZlcikudGhlbihmdW5jdGlvbiAoZGVjcnlwdGVkRGF0YSkge1xuICAgICAgICAgICAgLy8gQ2FsbGluZyBwdXNoIGhlcmUgaXMgaW1wb3J0YW50OyBpZiBmbHVzaCgpIGlzIGNhbGxlZCB3aGlsZSB0aGlzIGlzIHN0aWxsIHJlc29sdmluZywgdGhpcyBlbnN1cmVzIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBkZWNyeXB0ZWQgZGF0YSBoYXMgYmVlbiB0cmFuc211eGVkXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMucHVzaChkZWNyeXB0ZWREYXRhLCBudWxsLCBjaHVua01ldGEpO1xuICAgICAgICAgICAgX3RoaXMuZGVjcnlwdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0aW9uUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHJlc2V0TXV4ZXJzID0gdGhpcy5uZWVkc1Byb2JpbmcoZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gpO1xuICAgICAgaWYgKHJlc2V0TXV4ZXJzKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMuY29uZmlndXJlVHJhbnNtdXhlcih1aW50RGF0YSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFwiW3RyYW5zbXV4ZXJdIFwiICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpc2NvbnRpbnVpdHkgfHwgdHJhY2tTd2l0Y2ggfHwgaW5pdFNlZ21lbnRDaGFuZ2UgfHwgcmVzZXRNdXhlcnMpIHtcbiAgICAgICAgdGhpcy5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZHVyYXRpb24sIGRlY3J5cHRkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNjb250aW51aXR5IHx8IGluaXRTZWdtZW50Q2hhbmdlIHx8IHJlc2V0TXV4ZXJzKSB7XG4gICAgICAgIHRoaXMucmVzZXRJbml0aWFsVGltZXN0YW1wKGRlZmF1bHRJbml0UHRzKTtcbiAgICAgIH1cbiAgICAgIGlmICghY29udGlndW91cykge1xuICAgICAgICB0aGlzLnJlc2V0Q29udGlndWl0eSgpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudHJhbnNtdXgodWludERhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKTtcbiAgICAgIHZhciBjdXJyZW50U3RhdGUgPSB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlO1xuICAgICAgY3VycmVudFN0YXRlLmNvbnRpZ3VvdXMgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlLmRpc2NvbnRpbnVpdHkgPSBmYWxzZTtcbiAgICAgIGN1cnJlbnRTdGF0ZS50cmFja1N3aXRjaCA9IGZhbHNlO1xuICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBEdWUgdG8gZGF0YSBjYWNoaW5nLCBmbHVzaCBjYWxscyBjYW4gcHJvZHVjZSBtb3JlIHRoYW4gb25lIFRyYW5zbXV4ZXJSZXN1bHQgKGhlbmNlIHRoZSBBcnJheSB0eXBlKVxuICAgIDtcbiAgICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaChjaHVua01ldGEpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHN0YXRzID0gY2h1bmtNZXRhLnRyYW5zbXV4aW5nO1xuICAgICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG4gICAgICB2YXIgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXIsXG4gICAgICAgIGN1cnJlbnRUcmFuc211eFN0YXRlID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSxcbiAgICAgICAgZGVjcnlwdGlvblByb21pc2UgPSB0aGlzLmRlY3J5cHRpb25Qcm9taXNlO1xuICAgICAgaWYgKGRlY3J5cHRpb25Qcm9taXNlKSB7XG4gICAgICAgIC8vIFVwb24gcmVzb2x1dGlvbiwgdGhlIGRlY3J5cHRpb24gcHJvbWlzZSBjYWxscyBwdXNoKCkgYW5kIHJldHVybnMgaXRzIFRyYW5zbXV4ZXJSZXN1bHQgdXAgdGhlIHN0YWNrLiBUaGVyZWZvcmVcbiAgICAgICAgLy8gb25seSBmbHVzaGluZyBpcyByZXF1aXJlZCBmb3IgYXN5bmMgZGVjcnlwdGlvblxuICAgICAgICByZXR1cm4gZGVjcnlwdGlvblByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5mbHVzaChjaHVua01ldGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFuc211eFJlc3VsdHMgPSBbXTtcbiAgICAgIHZhciB0aW1lT2Zmc2V0ID0gY3VycmVudFRyYW5zbXV4U3RhdGUudGltZU9mZnNldDtcbiAgICAgIGlmIChkZWNyeXB0ZXIpIHtcbiAgICAgICAgLy8gVGhlIGRlY3J5cHRlciBtYXkgaGF2ZSBkYXRhIGNhY2hlZCwgd2hpY2ggbmVlZHMgdG8gYmUgZGVtdXhlZC4gSW4gdGhpcyBjYXNlIHdlJ2xsIGhhdmUgdHdvIFRyYW5zbXV4UmVzdWx0c1xuICAgICAgICAvLyBUaGlzIGhhcHBlbnMgaW4gdGhlIGNhc2UgdGhhdCB3ZSByZWNlaXZlIG9ubHkgMSBwdXNoIGNhbGwgZm9yIGEgc2VnbWVudCAoZWl0aGVyIGZvciBub24tcHJvZ3Jlc3NpdmUgZG93bmxvYWRzLFxuICAgICAgICAvLyBvciBmb3IgcHJvZ3Jlc3NpdmUgZG93bmxvYWRzIHdpdGggc21hbGwgc2VnbWVudHMpXG4gICAgICAgIHZhciBkZWNyeXB0ZWREYXRhID0gZGVjcnlwdGVyLmZsdXNoKCk7XG4gICAgICAgIGlmIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgICAgLy8gUHVzaCBhbHdheXMgcmV0dXJucyBhIFRyYW5zbXV4ZXJSZXN1bHQgaWYgZGVjcnlwdGRhdGEgaXMgbnVsbFxuICAgICAgICAgIHRyYW5zbXV4UmVzdWx0cy5wdXNoKHRoaXMucHVzaChkZWNyeXB0ZWREYXRhLCBudWxsLCBjaHVua01ldGEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXIsXG4gICAgICAgIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG4gICAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgICAgLy8gSWYgcHJvYmluZyBmYWlsZWQsIHRoZW4gSGxzLmpzIGhhcyBiZWVuIGdpdmVuIGNvbnRlbnQgaXRzIG5vdCBhYmxlIHRvIGhhbmRsZVxuICAgICAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgICAgIHJldHVybiBbZW1wdHlSZXN1bHQoY2h1bmtNZXRhKV07XG4gICAgICB9XG4gICAgICB2YXIgZGVtdXhSZXN1bHRPclByb21pc2UgPSBkZW11eGVyLmZsdXNoKHRpbWVPZmZzZXQpO1xuICAgICAgaWYgKGlzUHJvbWlzZShkZW11eFJlc3VsdE9yUHJvbWlzZSkpIHtcbiAgICAgICAgLy8gRGVjcnlwdCBmaW5hbCBTQU1QTEUtQUVTIHNhbXBsZXNcbiAgICAgICAgcmV0dXJuIGRlbXV4UmVzdWx0T3JQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRlbXV4UmVzdWx0KSB7XG4gICAgICAgICAgX3RoaXMyLmZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdCwgY2h1bmtNZXRhKTtcbiAgICAgICAgICByZXR1cm4gdHJhbnNtdXhSZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0T3JQcm9taXNlLCBjaHVua01ldGEpO1xuICAgICAgcmV0dXJuIHRyYW5zbXV4UmVzdWx0cztcbiAgICB9O1xuICAgIF9wcm90by5mbHVzaFJlbXV4ID0gZnVuY3Rpb24gZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0LCBjaHVua01ldGEpIHtcbiAgICAgIHZhciBhdWRpb1RyYWNrID0gZGVtdXhSZXN1bHQuYXVkaW9UcmFjayxcbiAgICAgICAgdmlkZW9UcmFjayA9IGRlbXV4UmVzdWx0LnZpZGVvVHJhY2ssXG4gICAgICAgIGlkM1RyYWNrID0gZGVtdXhSZXN1bHQuaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjayA9IGRlbXV4UmVzdWx0LnRleHRUcmFjaztcbiAgICAgIHZhciBfdGhpcyRjdXJyZW50VHJhbnNtdXggPSB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlLFxuICAgICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBfdGhpcyRjdXJyZW50VHJhbnNtdXguYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgICB0aW1lT2Zmc2V0ID0gX3RoaXMkY3VycmVudFRyYW5zbXV4LnRpbWVPZmZzZXQ7XG4gICAgICBsb2dnZXIubG9nKFwiW3RyYW5zbXV4ZXIudHNdOiBGbHVzaGVkIGZyYWdtZW50IFwiICsgY2h1bmtNZXRhLnNuICsgKGNodW5rTWV0YS5wYXJ0ID4gLTEgPyAnIHA6ICcgKyBjaHVua01ldGEucGFydCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgY2h1bmtNZXRhLmxldmVsKTtcbiAgICAgIHZhciByZW11eFJlc3VsdCA9IHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHRydWUsIHRoaXMuaWQpO1xuICAgICAgdHJhbnNtdXhSZXN1bHRzLnB1c2goe1xuICAgICAgICByZW11eFJlc3VsdDogcmVtdXhSZXN1bHQsXG4gICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgICB9KTtcbiAgICAgIGNodW5rTWV0YS50cmFuc211eGluZy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVzZXRJbml0aWFsVGltZXN0YW1wID0gZnVuY3Rpb24gcmVzZXRJbml0aWFsVGltZXN0YW1wKGRlZmF1bHRJbml0UHRzKSB7XG4gICAgICB2YXIgZGVtdXhlciA9IHRoaXMuZGVtdXhlcixcbiAgICAgICAgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcbiAgICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZW11eGVyLnJlc2V0VGltZVN0YW1wKGRlZmF1bHRJbml0UHRzKTtcbiAgICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0Q29udGlndWl0eSA9IGZ1bmN0aW9uIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyLFxuICAgICAgICByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuICAgICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlbXV4ZXIucmVzZXRDb250aWd1aXR5KCk7XG4gICAgICByZW11eGVyLnJlc2V0TmV4dFRpbWVzdGFtcCgpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0SW5pdFNlZ21lbnQgPSBmdW5jdGlvbiByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbiwgZGVjcnlwdGRhdGEpIHtcbiAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyLFxuICAgICAgICByZW11eGVyID0gdGhpcy5yZW11eGVyO1xuICAgICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlbXV4ZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgICAgcmVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZGVjcnlwdGRhdGEpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgICB0aGlzLmRlbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRlbXV4ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZW11eGVyKSB7XG4gICAgICAgIHRoaXMucmVtdXhlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucmVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50cmFuc211eCA9IGZ1bmN0aW9uIHRyYW5zbXV4KGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKGtleURhdGEgJiYga2V5RGF0YS5tZXRob2QgPT09ICdTQU1QTEUtQUVTJykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLnRyYW5zbXV4U2FtcGxlQWVzKGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNtdXhVbmVuY3J5cHRlZChkYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLnRyYW5zbXV4VW5lbmNyeXB0ZWQgPSBmdW5jdGlvbiB0cmFuc211eFVuZW5jcnlwdGVkKGRhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgICB2YXIgX2RlbXV4ID0gdGhpcy5kZW11eGVyLmRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIGZhbHNlLCAhdGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpLFxuICAgICAgICBhdWRpb1RyYWNrID0gX2RlbXV4LmF1ZGlvVHJhY2ssXG4gICAgICAgIHZpZGVvVHJhY2sgPSBfZGVtdXgudmlkZW9UcmFjayxcbiAgICAgICAgaWQzVHJhY2sgPSBfZGVtdXguaWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjayA9IF9kZW11eC50ZXh0VHJhY2s7XG4gICAgICB2YXIgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIucmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBmYWxzZSwgdGhpcy5pZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW11eFJlc3VsdDogcmVtdXhSZXN1bHQsXG4gICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLnRyYW5zbXV4U2FtcGxlQWVzID0gZnVuY3Rpb24gdHJhbnNtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLmRlbXV4ZXIuZGVtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQpLnRoZW4oZnVuY3Rpb24gKGRlbXV4UmVzdWx0KSB7XG4gICAgICAgIHZhciByZW11eFJlc3VsdCA9IF90aGlzMy5yZW11eGVyLnJlbXV4KGRlbXV4UmVzdWx0LmF1ZGlvVHJhY2ssIGRlbXV4UmVzdWx0LnZpZGVvVHJhY2ssIGRlbXV4UmVzdWx0LmlkM1RyYWNrLCBkZW11eFJlc3VsdC50ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgZmFsc2UsIF90aGlzMy5pZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVtdXhSZXN1bHQ6IHJlbXV4UmVzdWx0LFxuICAgICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5jb25maWd1cmVUcmFuc211eGVyID0gZnVuY3Rpb24gY29uZmlndXJlVHJhbnNtdXhlcihkYXRhKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcixcbiAgICAgICAgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZCxcbiAgICAgICAgdmVuZG9yID0gdGhpcy52ZW5kb3I7XG4gICAgICAvLyBwcm9iZSBmb3IgY29udGVudCB0eXBlXG4gICAgICB2YXIgbXV4O1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG11eENvbmZpZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgX211eENvbmZpZyRpJGRlbXV4O1xuICAgICAgICBpZiAoKF9tdXhDb25maWckaSRkZW11eCA9IG11eENvbmZpZ1tpXS5kZW11eCkgIT0gbnVsbCAmJiBfbXV4Q29uZmlnJGkkZGVtdXgucHJvYmUoZGF0YSkpIHtcbiAgICAgICAgICBtdXggPSBtdXhDb25maWdbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbXV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGRlbXV4ZXIgYnkgcHJvYmluZyBmcmFnbWVudCBkYXRhJyk7XG4gICAgICB9XG4gICAgICAvLyBzbyBsZXQncyBjaGVjayB0aGF0IGN1cnJlbnQgcmVtdXhlciBhbmQgZGVtdXhlciBhcmUgc3RpbGwgdmFsaWRcbiAgICAgIHZhciBkZW11eGVyID0gdGhpcy5kZW11eGVyO1xuICAgICAgdmFyIHJlbXV4ZXIgPSB0aGlzLnJlbXV4ZXI7XG4gICAgICB2YXIgUmVtdXhlciA9IG11eC5yZW11eDtcbiAgICAgIHZhciBEZW11eGVyID0gbXV4LmRlbXV4O1xuICAgICAgaWYgKCFyZW11eGVyIHx8ICEocmVtdXhlciBpbnN0YW5jZW9mIFJlbXV4ZXIpKSB7XG4gICAgICAgIHRoaXMucmVtdXhlciA9IG5ldyBSZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQsIHZlbmRvcik7XG4gICAgICB9XG4gICAgICBpZiAoIWRlbXV4ZXIgfHwgIShkZW11eGVyIGluc3RhbmNlb2YgRGVtdXhlcikpIHtcbiAgICAgICAgdGhpcy5kZW11eGVyID0gbmV3IERlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCk7XG4gICAgICAgIHRoaXMucHJvYmUgPSBEZW11eGVyLnByb2JlO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm5lZWRzUHJvYmluZyA9IGZ1bmN0aW9uIG5lZWRzUHJvYmluZyhkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCkge1xuICAgICAgLy8gaW4gY2FzZSBvZiBjb250aW51aXR5IGNoYW5nZSwgb3IgdHJhY2sgc3dpdGNoXG4gICAgICAvLyB3ZSBtaWdodCBzd2l0Y2ggZnJvbSBjb250ZW50IHR5cGUgKEFBQyBjb250YWluZXIgdG8gVFMgY29udGFpbmVyLCBvciBUUyB0byBmbXA0IGZvciBleGFtcGxlKVxuICAgICAgcmV0dXJuICF0aGlzLmRlbXV4ZXIgfHwgIXRoaXMucmVtdXhlciB8fCBkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoO1xuICAgIH07XG4gICAgX3Byb3RvLmdldERlY3J5cHRlciA9IGZ1bmN0aW9uIGdldERlY3J5cHRlcigpIHtcbiAgICAgIHZhciBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlcjtcbiAgICAgIGlmICghZGVjcnlwdGVyKSB7XG4gICAgICAgIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcih0aGlzLmNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVjcnlwdGVyO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zbXV4ZXI7XG4gIH0oKTtcbiAgZnVuY3Rpb24gZ2V0RW5jcnlwdGlvblR5cGUoZGF0YSwgZGVjcnlwdERhdGEpIHtcbiAgICB2YXIgZW5jcnlwdGlvblR5cGUgPSBudWxsO1xuICAgIGlmIChkYXRhLmJ5dGVMZW5ndGggPiAwICYmIChkZWNyeXB0RGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGVjcnlwdERhdGEua2V5KSAhPSBudWxsICYmIGRlY3J5cHREYXRhLml2ICE9PSBudWxsICYmIGRlY3J5cHREYXRhLm1ldGhvZCAhPSBudWxsKSB7XG4gICAgICBlbmNyeXB0aW9uVHlwZSA9IGRlY3J5cHREYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZW5jcnlwdGlvblR5cGU7XG4gIH1cbiAgdmFyIGVtcHR5UmVzdWx0ID0gZnVuY3Rpb24gZW1wdHlSZXN1bHQoY2h1bmtNZXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbXV4UmVzdWx0OiB7fSxcbiAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb24gaXNQcm9taXNlKHApIHtcbiAgICByZXR1cm4gJ3RoZW4nIGluIHAgJiYgcC50aGVuIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gIH1cbiAgdmFyIFRyYW5zbXV4Q29uZmlnID0gZnVuY3Rpb24gVHJhbnNtdXhDb25maWcoYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgaW5pdFNlZ21lbnREYXRhLCBkdXJhdGlvbiwgZGVmYXVsdEluaXRQdHMpIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFNlZ21lbnREYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0SW5pdFB0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5pbml0U2VnbWVudERhdGEgPSBpbml0U2VnbWVudERhdGE7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuZGVmYXVsdEluaXRQdHMgPSBkZWZhdWx0SW5pdFB0cyB8fCBudWxsO1xuICB9O1xuICB2YXIgVHJhbnNtdXhTdGF0ZSA9IGZ1bmN0aW9uIFRyYW5zbXV4U3RhdGUoZGlzY29udGludWl0eSwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0cmFja1N3aXRjaCwgdGltZU9mZnNldCwgaW5pdFNlZ21lbnRDaGFuZ2UpIHtcbiAgICB0aGlzLmRpc2NvbnRpbnVpdHkgPSB2b2lkIDA7XG4gICAgdGhpcy5jb250aWd1b3VzID0gdm9pZCAwO1xuICAgIHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0ID0gdm9pZCAwO1xuICAgIHRoaXMudHJhY2tTd2l0Y2ggPSB2b2lkIDA7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFNlZ21lbnRDaGFuZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy5kaXNjb250aW51aXR5ID0gZGlzY29udGludWl0eTtcbiAgICB0aGlzLmNvbnRpZ3VvdXMgPSBjb250aWd1b3VzO1xuICAgIHRoaXMuYWNjdXJhdGVUaW1lT2Zmc2V0ID0gYWNjdXJhdGVUaW1lT2Zmc2V0O1xuICAgIHRoaXMudHJhY2tTd2l0Y2ggPSB0cmFja1N3aXRjaDtcbiAgICB0aGlzLnRpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIHRoaXMuaW5pdFNlZ21lbnRDaGFuZ2UgPSBpbml0U2VnbWVudENoYW5nZTtcbiAgfTtcblxuICB2YXIgZXZlbnRlbWl0dGVyMyA9IHtleHBvcnRzOiB7fX07XG5cbiAgKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuICBcdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gIFx0ICAsIHByZWZpeCA9ICd+JztcblxuICBcdC8qKlxuICBcdCAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gIFx0ICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gIFx0ICpcbiAgXHQgKiBAY29uc3RydWN0b3JcbiAgXHQgKiBAcHJpdmF0ZVxuICBcdCAqL1xuICBcdGZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbiAgXHQvL1xuICBcdC8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4gIFx0Ly8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4gIFx0Ly8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbiAgXHQvLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3RcbiAgXHQvLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbiAgXHQvL1xuICBcdGlmIChPYmplY3QuY3JlYXRlKSB7XG4gIFx0ICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBcdCAgLy9cbiAgXHQgIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIFx0ICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICBcdCAgLy9cbiAgXHQgIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0LyoqXG4gIFx0ICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gIFx0ICpcbiAgXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gIFx0ICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAgXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICBcdCAqIEBjb25zdHJ1Y3RvclxuICBcdCAqIEBwcml2YXRlXG4gIFx0ICovXG4gIFx0ZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgXHQgIHRoaXMuZm4gPSBmbjtcbiAgXHQgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIFx0ICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xuICBcdH1cblxuICBcdC8qKlxuICBcdCAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICBcdCAqXG4gIFx0ICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAgXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gIFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICBcdCAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gIFx0ICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gIFx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAgXHQgKiBAcHJpdmF0ZVxuICBcdCAqL1xuICBcdGZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBcdCAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICBcdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIFx0ICB9XG5cbiAgXHQgIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICBcdCAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgXHQgIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIFx0ICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBcdCAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIFx0ICByZXR1cm4gZW1pdHRlcjtcbiAgXHR9XG5cbiAgXHQvKipcbiAgXHQgKiBDbGVhciBldmVudCBieSBuYW1lLlxuICBcdCAqXG4gIFx0ICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAgXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICBcdCAqIEBwcml2YXRlXG4gIFx0ICovXG4gIFx0ZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgXHQgIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIFx0ICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbiAgXHR9XG5cbiAgXHQvKipcbiAgXHQgKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gIFx0ICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICBcdCAqXG4gIFx0ICogQGNvbnN0cnVjdG9yXG4gIFx0ICogQHB1YmxpY1xuICBcdCAqL1xuICBcdGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgXHQgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgXHQgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgXHR9XG5cbiAgXHQvKipcbiAgXHQgKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICBcdCAqIGxpc3RlbmVycy5cbiAgXHQgKlxuICBcdCAqIEByZXR1cm5zIHtBcnJheX1cbiAgXHQgKiBAcHVibGljXG4gIFx0ICovXG4gIFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgXHQgIHZhciBuYW1lcyA9IFtdXG4gIFx0ICAgICwgZXZlbnRzXG4gIFx0ICAgICwgbmFtZTtcblxuICBcdCAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgXHQgIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICBcdCAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIFx0ICB9XG5cbiAgXHQgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFx0ICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgXHQgIH1cblxuICBcdCAgcmV0dXJuIG5hbWVzO1xuICBcdH07XG5cbiAgXHQvKipcbiAgXHQgKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICBcdCAqXG4gIFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICBcdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICBcdCAqIEBwdWJsaWNcbiAgXHQgKi9cbiAgXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICBcdCAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgXHQgICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIFx0ICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIFx0ICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIFx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgXHQgICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgXHQgIH1cblxuICBcdCAgcmV0dXJuIGVlO1xuICBcdH07XG5cbiAgXHQvKipcbiAgXHQgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gIFx0ICpcbiAgXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gIFx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gIFx0ICogQHB1YmxpY1xuICBcdCAqL1xuICBcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgXHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gIFx0ICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgXHQgIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgXHQgIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICBcdCAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG4gIFx0fTtcblxuICBcdC8qKlxuICBcdCAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICBcdCAqXG4gIFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICBcdCAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAgXHQgKiBAcHVibGljXG4gIFx0ICovXG4gIFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIFx0ICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBcdCAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIFx0ICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgXHQgICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gIFx0ICAgICwgYXJnc1xuICBcdCAgICAsIGk7XG5cbiAgXHQgIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgXHQgICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgXHQgICAgc3dpdGNoIChsZW4pIHtcbiAgXHQgICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gIFx0ICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgXHQgICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgXHQgICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gIFx0ICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgXHQgICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgXHQgICAgfVxuXG4gIFx0ICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gIFx0ICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gIFx0ICAgIH1cblxuICBcdCAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICBcdCAgfSBlbHNlIHtcbiAgXHQgICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgXHQgICAgICAsIGo7XG5cbiAgXHQgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gIFx0ICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgXHQgICAgICBzd2l0Y2ggKGxlbikge1xuICBcdCAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICBcdCAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgXHQgICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICBcdCAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICBcdCAgICAgICAgZGVmYXVsdDpcbiAgXHQgICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICBcdCAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICBcdCAgICAgICAgICB9XG5cbiAgXHQgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgXHQgICAgICB9XG4gIFx0ICAgIH1cbiAgXHQgIH1cblxuICBcdCAgcmV0dXJuIHRydWU7XG4gIFx0fTtcblxuICBcdC8qKlxuICBcdCAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICBcdCAqXG4gIFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICBcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgXHQgKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAgXHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gIFx0ICogQHB1YmxpY1xuICBcdCAqL1xuICBcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgXHQgIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbiAgXHR9O1xuXG4gIFx0LyoqXG4gIFx0ICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gIFx0ICpcbiAgXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gIFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICBcdCAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICBcdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAgXHQgKiBAcHVibGljXG4gIFx0ICovXG4gIFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgXHQgIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xuICBcdH07XG5cbiAgXHQvKipcbiAgXHQgKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICBcdCAqXG4gIFx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICBcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICBcdCAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gIFx0ICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAgXHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gIFx0ICogQHB1YmxpY1xuICBcdCAqL1xuICBcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgXHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIFx0ICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgXHQgIGlmICghZm4pIHtcbiAgXHQgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICBcdCAgICByZXR1cm4gdGhpcztcbiAgXHQgIH1cblxuICBcdCAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIFx0ICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gIFx0ICAgIGlmIChcbiAgXHQgICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gIFx0ICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICBcdCAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgXHQgICAgKSB7XG4gIFx0ICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICBcdCAgICB9XG4gIFx0ICB9IGVsc2Uge1xuICBcdCAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICBcdCAgICAgIGlmIChcbiAgXHQgICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgXHQgICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgXHQgICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICBcdCAgICAgICkge1xuICBcdCAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgXHQgICAgICB9XG4gIFx0ICAgIH1cblxuICBcdCAgICAvL1xuICBcdCAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gIFx0ICAgIC8vXG4gIFx0ICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gIFx0ICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICBcdCAgfVxuXG4gIFx0ICByZXR1cm4gdGhpcztcbiAgXHR9O1xuXG4gIFx0LyoqXG4gIFx0ICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gIFx0ICpcbiAgXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAgXHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gIFx0ICogQHB1YmxpY1xuICBcdCAqL1xuICBcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIFx0ICB2YXIgZXZ0O1xuXG4gIFx0ICBpZiAoZXZlbnQpIHtcbiAgXHQgICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgXHQgICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIFx0ICB9IGVsc2Uge1xuICBcdCAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIFx0ICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgXHQgIH1cblxuICBcdCAgcmV0dXJuIHRoaXM7XG4gIFx0fTtcblxuICBcdC8vXG4gIFx0Ly8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbiAgXHQvL1xuICBcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbiAgXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuICBcdC8vXG4gIFx0Ly8gRXhwb3NlIHRoZSBwcmVmaXguXG4gIFx0Ly9cbiAgXHRFdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbiAgXHQvL1xuICBcdC8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4gIFx0Ly9cbiAgXHRFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4gIFx0Ly9cbiAgXHQvLyBFeHBvc2UgdGhlIG1vZHVsZS5cbiAgXHQvL1xuICBcdHtcbiAgXHQgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuICBcdH0gXG4gIH0gKGV2ZW50ZW1pdHRlcjMpKTtcblxuICB2YXIgZXZlbnRlbWl0dGVyM0V4cG9ydHMgPSBldmVudGVtaXR0ZXIzLmV4cG9ydHM7XG4gIHZhciBFdmVudEVtaXR0ZXIgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZXZlbnRlbWl0dGVyM0V4cG9ydHMpO1xuXG4gIGlmICh0eXBlb2YgX19JTl9XT1JLRVJfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgX19JTl9XT1JLRVJfXykge1xuICAgIHN0YXJ0V29ya2VyKHNlbGYpO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0V29ya2VyKHNlbGYpIHtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdmFyIGZvcndhcmRNZXNzYWdlID0gZnVuY3Rpb24gZm9yd2FyZE1lc3NhZ2UoZXYsIGRhdGEpIHtcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBldmVudDogZXYsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBmb3J3YXJkIGV2ZW50cyB0byBtYWluIHRocmVhZFxuICAgIG9ic2VydmVyLm9uKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIG9ic2VydmVyLm9uKEV2ZW50cy5FUlJPUiwgZm9yd2FyZE1lc3NhZ2UpO1xuXG4gICAgLy8gZm9yd2FyZCBsb2dnZXIgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG4gICAgdmFyIGZvcndhcmRXb3JrZXJMb2dzID0gZnVuY3Rpb24gZm9yd2FyZFdvcmtlckxvZ3MoKSB7XG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChsb2dGbikge1xuICAgICAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMobWVzc2FnZSkge1xuICAgICAgICAgIGZvcndhcmRNZXNzYWdlKCd3b3JrZXJMb2cnLCB7XG4gICAgICAgICAgICBsb2dUeXBlOiBsb2dGbixcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyW2xvZ0ZuXSA9IGZ1bmM7XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgbG9nRm4gaW4gbG9nZ2VyKSB7XG4gICAgICAgIF9sb29wKGxvZ0ZuKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIGRhdGEgPSBldi5kYXRhO1xuICAgICAgc3dpdGNoIChkYXRhLmNtZCkge1xuICAgICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gSlNPTi5wYXJzZShkYXRhLmNvbmZpZyk7XG4gICAgICAgICAgICBzZWxmLnRyYW5zbXV4ZXIgPSBuZXcgVHJhbnNtdXhlcihvYnNlcnZlciwgZGF0YS50eXBlU3VwcG9ydGVkLCBjb25maWcsICcnLCBkYXRhLmlkKTtcbiAgICAgICAgICAgIGVuYWJsZUxvZ3MoY29uZmlnLmRlYnVnLCBkYXRhLmlkKTtcbiAgICAgICAgICAgIGZvcndhcmRXb3JrZXJMb2dzKCk7XG4gICAgICAgICAgICBmb3J3YXJkTWVzc2FnZSgnaW5pdCcsIG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdjb25maWd1cmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNlbGYudHJhbnNtdXhlci5jb25maWd1cmUoZGF0YS5jb25maWcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdkZW11eCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRyYW5zbXV4UmVzdWx0ID0gc2VsZi50cmFuc211eGVyLnB1c2goZGF0YS5kYXRhLCBkYXRhLmRlY3J5cHRkYXRhLCBkYXRhLmNodW5rTWV0YSwgZGF0YS5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKHRyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICAgICAgICBzZWxmLnRyYW5zbXV4ZXIuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICB0cmFuc211eFJlc3VsdC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgZGF0YSk7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGZvcndhcmRNZXNzYWdlKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgICAgICAgICBjaHVua01ldGE6IGRhdGEuY2h1bmtNZXRhLFxuICAgICAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgZXJyOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJ0cmFuc211eGVyLXdvcmtlciBwdXNoIGVycm9yXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLnRyYW5zbXV4ZXIuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZW1pdFRyYW5zbXV4Q29tcGxldGUoc2VsZiwgdHJhbnNtdXhSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdmbHVzaCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGlkID0gZGF0YS5jaHVua01ldGE7XG4gICAgICAgICAgICB2YXIgX3RyYW5zbXV4UmVzdWx0ID0gc2VsZi50cmFuc211eGVyLmZsdXNoKGlkKTtcbiAgICAgICAgICAgIHZhciBhc3luY0ZsdXNoID0gaXNQcm9taXNlKF90cmFuc211eFJlc3VsdCk7XG4gICAgICAgICAgICBpZiAoYXN5bmNGbHVzaCB8fCBzZWxmLnRyYW5zbXV4ZXIuYXN5bmMpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc1Byb21pc2UoX3RyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIF90cmFuc211eFJlc3VsdCA9IFByb21pc2UucmVzb2x2ZShfdHJhbnNtdXhSZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90cmFuc211eFJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRmx1c2hSZXN1bHQoc2VsZiwgcmVzdWx0cywgaWQpO1xuICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBmb3J3YXJkTWVzc2FnZShFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgY2h1bmtNZXRhOiBkYXRhLmNodW5rTWV0YSxcbiAgICAgICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgIGVycjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICByZWFzb246IFwidHJhbnNtdXhlci13b3JrZXIgZmx1c2ggZXJyb3JcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhhbmRsZUZsdXNoUmVzdWx0KHNlbGYsIF90cmFuc211eFJlc3VsdCwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGVtaXRUcmFuc211eENvbXBsZXRlKHNlbGYsIHRyYW5zbXV4UmVzdWx0KSB7XG4gICAgaWYgKGlzRW1wdHlSZXN1bHQodHJhbnNtdXhSZXN1bHQucmVtdXhSZXN1bHQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0cmFuc2ZlcmFibGUgPSBbXTtcbiAgICB2YXIgX3RyYW5zbXV4UmVzdWx0JHJlbXV4ID0gdHJhbnNtdXhSZXN1bHQucmVtdXhSZXN1bHQsXG4gICAgICBhdWRpbyA9IF90cmFuc211eFJlc3VsdCRyZW11eC5hdWRpbyxcbiAgICAgIHZpZGVvID0gX3RyYW5zbXV4UmVzdWx0JHJlbXV4LnZpZGVvO1xuICAgIGlmIChhdWRpbykge1xuICAgICAgYWRkVG9UcmFuc2ZlcmFibGUodHJhbnNmZXJhYmxlLCBhdWRpbyk7XG4gICAgfVxuICAgIGlmICh2aWRlbykge1xuICAgICAgYWRkVG9UcmFuc2ZlcmFibGUodHJhbnNmZXJhYmxlLCB2aWRlbyk7XG4gICAgfVxuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgZXZlbnQ6ICd0cmFuc211eENvbXBsZXRlJyxcbiAgICAgIGRhdGE6IHRyYW5zbXV4UmVzdWx0XG4gICAgfSwgdHJhbnNmZXJhYmxlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIENvbnZlcnRzIGRhdGEgdG8gYSB0cmFuc2ZlcmFibGUgb2JqZWN0IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTEvMTIvVHJhbnNmZXJhYmxlLU9iamVjdHMtTGlnaHRuaW5nLUZhc3QpXG4gIC8vIGluIG9yZGVyIHRvIG1pbmltaXplIG1lc3NhZ2UgcGFzc2luZyBvdmVyaGVhZFxuICBmdW5jdGlvbiBhZGRUb1RyYW5zZmVyYWJsZSh0cmFuc2ZlcmFibGUsIHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLmRhdGExKSB7XG4gICAgICB0cmFuc2ZlcmFibGUucHVzaCh0cmFjay5kYXRhMS5idWZmZXIpO1xuICAgIH1cbiAgICBpZiAodHJhY2suZGF0YTIpIHtcbiAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKHRyYWNrLmRhdGEyLmJ1ZmZlcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUZsdXNoUmVzdWx0KHNlbGYsIHJlc3VsdHMsIGNodW5rTWV0YSkge1xuICAgIHZhciBwYXJzZWQgPSByZXN1bHRzLnJlZHVjZShmdW5jdGlvbiAocGFyc2VkLCByZXN1bHQpIHtcbiAgICAgIHJldHVybiBlbWl0VHJhbnNtdXhDb21wbGV0ZShzZWxmLCByZXN1bHQpIHx8IHBhcnNlZDtcbiAgICB9LCBmYWxzZSk7XG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIC8vIEVtaXQgYXQgbGVhc3Qgb25lIFwidHJhbnNtdXhDb21wbGV0ZVwiIG1lc3NhZ2UgZXZlbiBpZiBtZWRpYSBpcyBub3QgZm91bmQgdG8gdXBkYXRlIHN0cmVhbS1jb250cm9sbGVyIHN0YXRlIHRvIFBBUlNJTkdcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBldmVudDogJ3RyYW5zbXV4Q29tcGxldGUnLFxuICAgICAgICBkYXRhOiByZXN1bHRzWzBdXG4gICAgICB9KTtcbiAgICB9XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICBldmVudDogJ2ZsdXNoJyxcbiAgICAgIGRhdGE6IGNodW5rTWV0YVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGlzRW1wdHlSZXN1bHQocmVtdXhSZXN1bHQpIHtcbiAgICByZXR1cm4gIXJlbXV4UmVzdWx0LmF1ZGlvICYmICFyZW11eFJlc3VsdC52aWRlbyAmJiAhcmVtdXhSZXN1bHQudGV4dCAmJiAhcmVtdXhSZXN1bHQuaWQzICYmICFyZW11eFJlc3VsdC5pbml0U2VnbWVudDtcbiAgfVxuXG4gIC8vIGVuc3VyZSB0aGUgd29ya2VyIGVuZHMgdXAgaW4gdGhlIGJ1bmRsZVxuICAvLyBJZiB0aGUgd29ya2VyIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgdGhpcyBnZXRzIGFsaWFzZWQgdG8gZW1wdHkuanNcbiAgZnVuY3Rpb24gaGFzVU1EV29ya2VyKCkge1xuICAgIHJldHVybiB0eXBlb2YgX19ITFNfV09SS0VSX0JVTkRMRV9fID09PSAnZnVuY3Rpb24nO1xuICB9XG4gIGZ1bmN0aW9uIGluamVjdFdvcmtlcigpIHtcbiAgICB2YXIgYmxvYiA9IG5ldyBzZWxmLkJsb2IoW1widmFyIGV4cG9ydHM9e307dmFyIG1vZHVsZT17ZXhwb3J0czpleHBvcnRzfTtmdW5jdGlvbiBkZWZpbmUoZil7ZigpfTtkZWZpbmUuYW1kPXRydWU7KFwiICsgX19ITFNfV09SS0VSX0JVTkRMRV9fLnRvU3RyaW5nKCkgKyBcIikodHJ1ZSk7XCJdLCB7XG4gICAgICB0eXBlOiAndGV4dC9qYXZhc2NyaXB0J1xuICAgIH0pO1xuICAgIHZhciBvYmplY3RVUkwgPSBzZWxmLlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgdmFyIHdvcmtlciA9IG5ldyBzZWxmLldvcmtlcihvYmplY3RVUkwpO1xuICAgIHJldHVybiB7XG4gICAgICB3b3JrZXI6IHdvcmtlcixcbiAgICAgIG9iamVjdFVSTDogb2JqZWN0VVJMXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBsb2FkV29ya2VyKHBhdGgpIHtcbiAgICB2YXIgc2NyaXB0VVJMID0gbmV3IHNlbGYuVVJMKHBhdGgsIHNlbGYubG9jYXRpb24uaHJlZikuaHJlZjtcbiAgICB2YXIgd29ya2VyID0gbmV3IHNlbGYuV29ya2VyKHNjcmlwdFVSTCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdvcmtlcjogd29ya2VyLFxuICAgICAgc2NyaXB0VVJMOiBzY3JpcHRVUkxcbiAgICB9O1xuICB9XG5cbiAgdmFyIFRyYW5zbXV4ZXJJbnRlcmZhY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zbXV4ZXJJbnRlcmZhY2UoaGxzLCBpZCwgb25UcmFuc211eENvbXBsZXRlLCBvbkZsdXNoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICAgIHRoaXMucGFydCA9IG51bGw7XG4gICAgICB0aGlzLnVzZVdvcmtlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLm9ud21zZyA9IHZvaWQgMDtcbiAgICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgICB0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMub25GbHVzaCA9IHZvaWQgMDtcbiAgICAgIHZhciBjb25maWcgPSBobHMuY29uZmlnO1xuICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICB0aGlzLnVzZVdvcmtlciA9ICEhY29uZmlnLmVuYWJsZVdvcmtlcjtcbiAgICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlID0gb25UcmFuc211eENvbXBsZXRlO1xuICAgICAgdGhpcy5vbkZsdXNoID0gb25GbHVzaDtcbiAgICAgIHZhciBmb3J3YXJkTWVzc2FnZSA9IGZ1bmN0aW9uIGZvcndhcmRNZXNzYWdlKGV2LCBkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICBkYXRhLmZyYWcgPSBfdGhpcy5mcmFnO1xuICAgICAgICBkYXRhLmlkID0gX3RoaXMuaWQ7XG4gICAgICAgIGlmIChldiA9PT0gRXZlbnRzLkVSUk9SKSB7XG4gICAgICAgICAgX3RoaXMuZXJyb3IgPSBkYXRhLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmhscy50cmlnZ2VyKGV2LCBkYXRhKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGZvcndhcmQgZXZlbnRzIHRvIG1haW4gdGhyZWFkXG4gICAgICB0aGlzLm9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgdGhpcy5vYnNlcnZlci5vbihFdmVudHMuRlJBR19ERUNSWVBURUQsIGZvcndhcmRNZXNzYWdlKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIub24oRXZlbnRzLkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgICB2YXIgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZShjb25maWcucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSB8fCB7XG4gICAgICAgIGlzVHlwZVN1cHBvcnRlZDogZnVuY3Rpb24gaXNUeXBlU3VwcG9ydGVkKCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBtMnRzVHlwZVN1cHBvcnRlZCA9IHtcbiAgICAgICAgbXBlZzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJyksXG4gICAgICAgIG1wMzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cIm1wM1wiJyksXG4gICAgICAgIGFjMzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cImFjLTNcIicpIFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLnVzZVdvcmtlciAmJiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgY2FuQ3JlYXRlV29ya2VyID0gY29uZmlnLndvcmtlclBhdGggfHwgaGFzVU1EV29ya2VyKCk7XG4gICAgICAgIGlmIChjYW5DcmVhdGVXb3JrZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy53b3JrZXJQYXRoKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJsb2FkaW5nIFdlYiBXb3JrZXIgXCIgKyBjb25maWcud29ya2VyUGF0aCArIFwiIGZvciBcXFwiXCIgKyBpZCArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gbG9hZFdvcmtlcihjb25maWcud29ya2VyUGF0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiaW5qZWN0aW5nIFdlYiBXb3JrZXIgZm9yIFxcXCJcIiArIGlkICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICB0aGlzLndvcmtlckNvbnRleHQgPSBpbmplY3RXb3JrZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub253bXNnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5vbldvcmtlck1lc3NhZ2UoZXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB3b3JrZXIgPSB0aGlzLndvcmtlckNvbnRleHQud29ya2VyO1xuICAgICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG4gICAgICAgICAgICB3b3JrZXIub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZXZlbnQubWVzc2FnZSArIFwiICAoXCIgKyBldmVudC5maWxlbmFtZSArIFwiOlwiICsgZXZlbnQubGluZW5vICsgXCIpXCIpO1xuICAgICAgICAgICAgICBjb25maWcuZW5hYmxlV29ya2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiRXJyb3IgaW4gXFxcIlwiICsgaWQgKyBcIlxcXCIgV2ViIFdvcmtlciwgZmFsbGJhY2sgdG8gaW5saW5lXCIpO1xuICAgICAgICAgICAgICBfdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT04sXG4gICAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGV2ZW50OiAnZGVtdXhlcldvcmtlcicsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGNtZDogJ2luaXQnLFxuICAgICAgICAgICAgICB0eXBlU3VwcG9ydGVkOiBtMnRzVHlwZVN1cHBvcnRlZCxcbiAgICAgICAgICAgICAgdmVuZG9yOiAnJyxcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICBjb25maWc6IEpTT04uc3RyaW5naWZ5KGNvbmZpZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJFcnJvciBzZXR0aW5nIHVwIFxcXCJcIiArIGlkICsgXCJcXFwiIFdlYiBXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZVwiLCBlcnIpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFdvcmtlcigpO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgVHJhbnNtdXhlcih0aGlzLm9ic2VydmVyLCBtMnRzVHlwZVN1cHBvcnRlZCwgY29uZmlnLCAnJywgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNtdXhlciA9IG5ldyBUcmFuc211eGVyKHRoaXMub2JzZXJ2ZXIsIG0ydHNUeXBlU3VwcG9ydGVkLCBjb25maWcsICcnLCBpZCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBUcmFuc211eGVySW50ZXJmYWNlLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVzZXRXb3JrZXIgPSBmdW5jdGlvbiByZXNldFdvcmtlcigpIHtcbiAgICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzJHdvcmtlckNvbnRleHQgPSB0aGlzLndvcmtlckNvbnRleHQsXG4gICAgICAgICAgd29ya2VyID0gX3RoaXMkd29ya2VyQ29udGV4dC53b3JrZXIsXG4gICAgICAgICAgb2JqZWN0VVJMID0gX3RoaXMkd29ya2VyQ29udGV4dC5vYmplY3RVUkw7XG4gICAgICAgIGlmIChvYmplY3RVUkwpIHtcbiAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgdHJhbnNtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyk7XG4gICAgICAgIHdvcmtlci5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICB0aGlzLndvcmtlckNvbnRleHQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgICB0aGlzLnJlc2V0V29ya2VyKCk7XG4gICAgICAgIHRoaXMub253bXNnID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXI7XG4gICAgICAgIGlmICh0cmFuc211eGVyKSB7XG4gICAgICAgICAgdHJhbnNtdXhlci5kZXN0cm95KCk7XG4gICAgICAgICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlcjtcbiAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5wdXNoID0gZnVuY3Rpb24gcHVzaChkYXRhLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGZyYWcsIHBhcnQsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICAgIHZhciBfZnJhZyRpbml0U2VnbWVudCxcbiAgICAgICAgX2xhc3RGcmFnJGluaXRTZWdtZW50LFxuICAgICAgICBfdGhpczIgPSB0aGlzO1xuICAgICAgY2h1bmtNZXRhLnRyYW5zbXV4aW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHZhciB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyO1xuICAgICAgdmFyIHRpbWVPZmZzZXQgPSBwYXJ0ID8gcGFydC5zdGFydCA6IGZyYWcuc3RhcnQ7XG4gICAgICAvLyBUT0RPOiBwdXNoIFwiY2xlYXItbGVhZFwiIGRlY3J5cHQgZGF0YSBmb3IgdW5lbmNyeXB0ZWQgZnJhZ21lbnRzIGluIHN0cmVhbXMgd2l0aCBlbmNyeXB0ZWQgb25lc1xuICAgICAgdmFyIGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICAgIHZhciBsYXN0RnJhZyA9IHRoaXMuZnJhZztcbiAgICAgIHZhciBkaXNjb250aW51aXR5ID0gIShsYXN0RnJhZyAmJiBmcmFnLmNjID09PSBsYXN0RnJhZy5jYyk7XG4gICAgICB2YXIgdHJhY2tTd2l0Y2ggPSAhKGxhc3RGcmFnICYmIGNodW5rTWV0YS5sZXZlbCA9PT0gbGFzdEZyYWcubGV2ZWwpO1xuICAgICAgdmFyIHNuRGlmZiA9IGxhc3RGcmFnID8gY2h1bmtNZXRhLnNuIC0gbGFzdEZyYWcuc24gOiAtMTtcbiAgICAgIHZhciBwYXJ0RGlmZiA9IHRoaXMucGFydCA/IGNodW5rTWV0YS5wYXJ0IC0gdGhpcy5wYXJ0LmluZGV4IDogLTE7XG4gICAgICB2YXIgcHJvZ3Jlc3NpdmUgPSBzbkRpZmYgPT09IDAgJiYgY2h1bmtNZXRhLmlkID4gMSAmJiBjaHVua01ldGEuaWQgPT09IChsYXN0RnJhZyA9PSBudWxsID8gdm9pZCAwIDogbGFzdEZyYWcuc3RhdHMuY2h1bmtDb3VudCk7XG4gICAgICB2YXIgY29udGlndW91cyA9ICF0cmFja1N3aXRjaCAmJiAoc25EaWZmID09PSAxIHx8IHNuRGlmZiA9PT0gMCAmJiAocGFydERpZmYgPT09IDEgfHwgcHJvZ3Jlc3NpdmUgJiYgcGFydERpZmYgPD0gMCkpO1xuICAgICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBpZiAodHJhY2tTd2l0Y2ggfHwgc25EaWZmIHx8IGZyYWcuc3RhdHMucGFyc2luZy5zdGFydCA9PT0gMCkge1xuICAgICAgICBmcmFnLnN0YXRzLnBhcnNpbmcuc3RhcnQgPSBub3c7XG4gICAgICB9XG4gICAgICBpZiAocGFydCAmJiAocGFydERpZmYgfHwgIWNvbnRpZ3VvdXMpKSB7XG4gICAgICAgIHBhcnQuc3RhdHMucGFyc2luZy5zdGFydCA9IG5vdztcbiAgICAgIH1cbiAgICAgIHZhciBpbml0U2VnbWVudENoYW5nZSA9ICEobGFzdEZyYWcgJiYgKChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZyRpbml0U2VnbWVudC51cmwpID09PSAoKF9sYXN0RnJhZyRpbml0U2VnbWVudCA9IGxhc3RGcmFnLmluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2xhc3RGcmFnJGluaXRTZWdtZW50LnVybCkpO1xuICAgICAgdmFyIHN0YXRlID0gbmV3IFRyYW5zbXV4U3RhdGUoZGlzY29udGludWl0eSwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0cmFja1N3aXRjaCwgdGltZU9mZnNldCwgaW5pdFNlZ21lbnRDaGFuZ2UpO1xuICAgICAgaWYgKCFjb250aWd1b3VzIHx8IGRpc2NvbnRpbnVpdHkgfHwgaW5pdFNlZ21lbnRDaGFuZ2UpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIlt0cmFuc211eGVyLWludGVyZmFjZSwgXCIgKyBmcmFnLnR5cGUgKyBcIl06IFN0YXJ0aW5nIG5ldyB0cmFuc211eCBzZXNzaW9uIGZvciBzbjogXCIgKyBjaHVua01ldGEuc24gKyBcIiBwOiBcIiArIGNodW5rTWV0YS5wYXJ0ICsgXCIgbGV2ZWw6IFwiICsgY2h1bmtNZXRhLmxldmVsICsgXCIgaWQ6IFwiICsgY2h1bmtNZXRhLmlkICsgXCJcXG4gICAgICAgIGRpc2NvbnRpbnVpdHk6IFwiICsgZGlzY29udGludWl0eSArIFwiXFxuICAgICAgICB0cmFja1N3aXRjaDogXCIgKyB0cmFja1N3aXRjaCArIFwiXFxuICAgICAgICBjb250aWd1b3VzOiBcIiArIGNvbnRpZ3VvdXMgKyBcIlxcbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiBcIiArIGFjY3VyYXRlVGltZU9mZnNldCArIFwiXFxuICAgICAgICB0aW1lT2Zmc2V0OiBcIiArIHRpbWVPZmZzZXQgKyBcIlxcbiAgICAgICAgaW5pdFNlZ21lbnRDaGFuZ2U6IFwiICsgaW5pdFNlZ21lbnRDaGFuZ2UpO1xuICAgICAgICB2YXIgY29uZmlnID0gbmV3IFRyYW5zbXV4Q29uZmlnKGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGluaXRTZWdtZW50RGF0YSwgZHVyYXRpb24sIGRlZmF1bHRJbml0UFRTKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmVUcmFuc211eGVyKGNvbmZpZyk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYWcgPSBmcmFnO1xuICAgICAgdGhpcy5wYXJ0ID0gcGFydDtcblxuICAgICAgLy8gRnJhZ3Mgd2l0aCBzbiBvZiAnaW5pdFNlZ21lbnQnIGFyZSBub3QgdHJhbnNtdXhlZFxuICAgICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgICAvLyBwb3N0IGZyYWdtZW50IHBheWxvYWQgYXMgdHJhbnNmZXJhYmxlIG9iamVjdHMgZm9yIEFycmF5QnVmZmVyIChubyBjb3B5KVxuICAgICAgICB0aGlzLndvcmtlckNvbnRleHQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBjbWQ6ICdkZW11eCcsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBkZWNyeXB0ZGF0YTogZGVjcnlwdGRhdGEsXG4gICAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICAgIH0sIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IFtkYXRhXSA6IFtdKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgICB2YXIgX3RyYW5zbXV4UmVzdWx0ID0gdHJhbnNtdXhlci5wdXNoKGRhdGEsIGRlY3J5cHRkYXRhLCBjaHVua01ldGEsIHN0YXRlKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShfdHJhbnNtdXhSZXN1bHQpKSB7XG4gICAgICAgICAgdHJhbnNtdXhlci5hc3luYyA9IHRydWU7XG4gICAgICAgICAgX3RyYW5zbXV4UmVzdWx0LnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIF90aGlzMi5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEpO1xuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMyLnRyYW5zbXV4ZXJFcnJvcihlcnJvciwgY2h1bmtNZXRhLCAndHJhbnNtdXhlci1pbnRlcmZhY2UgcHVzaCBlcnJvcicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYW5zbXV4ZXIuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUoX3RyYW5zbXV4UmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goY2h1bmtNZXRhKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB2YXIgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0Lndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgY21kOiAnZmx1c2gnLFxuICAgICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICAgIHZhciBfdHJhbnNtdXhSZXN1bHQyID0gdHJhbnNtdXhlci5mbHVzaChjaHVua01ldGEpO1xuICAgICAgICB2YXIgYXN5bmNGbHVzaCA9IGlzUHJvbWlzZShfdHJhbnNtdXhSZXN1bHQyKTtcbiAgICAgICAgaWYgKGFzeW5jRmx1c2ggfHwgdHJhbnNtdXhlci5hc3luYykge1xuICAgICAgICAgIGlmICghaXNQcm9taXNlKF90cmFuc211eFJlc3VsdDIpKSB7XG4gICAgICAgICAgICBfdHJhbnNtdXhSZXN1bHQyID0gUHJvbWlzZS5yZXNvbHZlKF90cmFuc211eFJlc3VsdDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdHJhbnNtdXhSZXN1bHQyLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIF90aGlzMy5oYW5kbGVGbHVzaFJlc3VsdChkYXRhLCBjaHVua01ldGEpO1xuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMzLnRyYW5zbXV4ZXJFcnJvcihlcnJvciwgY2h1bmtNZXRhLCAndHJhbnNtdXhlci1pbnRlcmZhY2UgZmx1c2ggZXJyb3InKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUZsdXNoUmVzdWx0KF90cmFuc211eFJlc3VsdDIsIGNodW5rTWV0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50cmFuc211eGVyRXJyb3IgPSBmdW5jdGlvbiB0cmFuc211eGVyRXJyb3IoZXJyb3IsIGNodW5rTWV0YSwgcmVhc29uKSB7XG4gICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhLFxuICAgICAgICBmcmFnOiB0aGlzLmZyYWcgfHwgdW5kZWZpbmVkLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgZXJyOiBlcnJvcixcbiAgICAgICAgcmVhc29uOiByZWFzb25cbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmhhbmRsZUZsdXNoUmVzdWx0ID0gZnVuY3Rpb24gaGFuZGxlRmx1c2hSZXN1bHQocmVzdWx0cywgY2h1bmtNZXRhKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIF90aGlzNC5oYW5kbGVUcmFuc211eENvbXBsZXRlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub25GbHVzaChjaHVua01ldGEpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uV29ya2VyTWVzc2FnZSA9IGZ1bmN0aW9uIG9uV29ya2VyTWVzc2FnZShldmVudCkge1xuICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgaWYgKCEoZGF0YSAhPSBudWxsICYmIGRhdGEuZXZlbnQpKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwid29ya2VyIG1lc3NhZ2UgcmVjZWl2ZWQgd2l0aCBubyBcIiArIChkYXRhID8gJ2V2ZW50IG5hbWUnIDogJ2RhdGEnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChkYXRhLmV2ZW50KSB7XG4gICAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyR3b3JrZXJDb250ZXh0MjtcbiAgICAgICAgICAgIHZhciBvYmplY3RVUkwgPSAoX3RoaXMkd29ya2VyQ29udGV4dDIgPSB0aGlzLndvcmtlckNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR3b3JrZXJDb250ZXh0Mi5vYmplY3RVUkw7XG4gICAgICAgICAgICBpZiAob2JqZWN0VVJMKSB7XG4gICAgICAgICAgICAgIC8vIHJldm9rZSB0aGUgT2JqZWN0IFVSTCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSB0cmFuc211eGVyIHdvcmtlciwgc28gYXMgbm90IHRvIGxlYWsgaXRcbiAgICAgICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVSTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RyYW5zbXV4Q29tcGxldGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShkYXRhLmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdmbHVzaCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5vbkZsdXNoKGRhdGEuZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFzcyBsb2dzIGZyb20gdGhlIHdvcmtlciB0aHJlYWQgdG8gdGhlIG1haW4gbG9nZ2VyXG4gICAgICAgIGNhc2UgJ3dvcmtlckxvZyc6XG4gICAgICAgICAgaWYgKGxvZ2dlcltkYXRhLmRhdGEubG9nVHlwZV0pIHtcbiAgICAgICAgICAgIGxvZ2dlcltkYXRhLmRhdGEubG9nVHlwZV0oZGF0YS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwge307XG4gICAgICAgICAgICBkYXRhLmRhdGEuZnJhZyA9IHRoaXMuZnJhZztcbiAgICAgICAgICAgIGRhdGEuZGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihkYXRhLmV2ZW50LCBkYXRhLmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNvbmZpZ3VyZVRyYW5zbXV4ZXIgPSBmdW5jdGlvbiBjb25maWd1cmVUcmFuc211eGVyKGNvbmZpZykge1xuICAgICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXI7XG4gICAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGNtZDogJ2NvbmZpZ3VyZScsXG4gICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgICAgdHJhbnNtdXhlci5jb25maWd1cmUoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5oYW5kbGVUcmFuc211eENvbXBsZXRlID0gZnVuY3Rpb24gaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5jaHVua01ldGEudHJhbnNtdXhpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlKHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNtdXhlckludGVyZmFjZTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIHN1YnRpdGxlT3B0aW9uc0lkZW50aWNhbCh0cmFja0xpc3QxLCB0cmFja0xpc3QyKSB7XG4gICAgaWYgKHRyYWNrTGlzdDEubGVuZ3RoICE9PSB0cmFja0xpc3QyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGlzdDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghbWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsKHRyYWNrTGlzdDFbaV0uYXR0cnMsIHRyYWNrTGlzdDJbaV0uYXR0cnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gbWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsKGF0dHJzMSwgYXR0cnMyLCBjdXN0b21BdHRyaWJ1dGVzKSB7XG4gICAgLy8gTWVkaWEgb3B0aW9ucyB3aXRoIHRoZSBzYW1lIHJlbmRpdGlvbiBJRCBtdXN0IGJlIGJpdCBpZGVudGljYWxcbiAgICB2YXIgc3RhYmxlUmVuZGl0aW9uSWQgPSBhdHRyczFbJ1NUQUJMRS1SRU5ESVRJT04tSUQnXTtcbiAgICBpZiAoc3RhYmxlUmVuZGl0aW9uSWQgJiYgIWN1c3RvbUF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybiBzdGFibGVSZW5kaXRpb25JZCA9PT0gYXR0cnMyWydTVEFCTEUtUkVORElUSU9OLUlEJ107XG4gICAgfVxuICAgIC8vIFdoZW4gcmVuZGl0aW9uIElEIGlzIG5vdCBwcmVzZW50LCBjb21wYXJlIGF0dHJpYnV0ZXNcbiAgICByZXR1cm4gIShjdXN0b21BdHRyaWJ1dGVzIHx8IFsnTEFOR1VBR0UnLCAnTkFNRScsICdDSEFSQUNURVJJU1RJQ1MnLCAnQVVUT1NFTEVDVCcsICdERUZBVUxUJywgJ0ZPUkNFRCcsICdBU1NPQy1MQU5HVUFHRSddKS5zb21lKGZ1bmN0aW9uIChzdWJ0aXRsZUF0dHJpYnV0ZSkge1xuICAgICAgcmV0dXJuIGF0dHJzMVtzdWJ0aXRsZUF0dHJpYnV0ZV0gIT09IGF0dHJzMltzdWJ0aXRsZUF0dHJpYnV0ZV07XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc3VidGl0bGVUcmFja01hdGNoZXNUZXh0VHJhY2soc3VidGl0bGVUcmFjaywgdGV4dFRyYWNrKSB7XG4gICAgcmV0dXJuIHRleHRUcmFjay5sYWJlbC50b0xvd2VyQ2FzZSgpID09PSBzdWJ0aXRsZVRyYWNrLm5hbWUudG9Mb3dlckNhc2UoKSAmJiAoIXRleHRUcmFjay5sYW5ndWFnZSB8fCB0ZXh0VHJhY2subGFuZ3VhZ2UudG9Mb3dlckNhc2UoKSA9PT0gKHN1YnRpdGxlVHJhY2subGFuZyB8fCAnJykudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICB2YXIgVElDS19JTlRFUlZBTCQyID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuICB2YXIgQXVkaW9TdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICBfaW5oZXJpdHNMb29zZShBdWRpb1N0cmVhbUNvbnRyb2xsZXIsIF9CYXNlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgZnVuY3Rpb24gQXVkaW9TdHJlYW1Db250cm9sbGVyKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF90aGlzID0gX0Jhc2VTdHJlYW1Db250cm9sbGVyLmNhbGwodGhpcywgaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciwgJ1thdWRpby1zdHJlYW0tY29udHJvbGxlcl0nLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTykgfHwgdGhpcztcbiAgICAgIF90aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICAgIF90aGlzLnZpZGVvVHJhY2tDQyA9IC0xO1xuICAgICAgX3RoaXMud2FpdGluZ1ZpZGVvQ0MgPSAtMTtcbiAgICAgIF90aGlzLmJ1ZmZlcmVkVHJhY2sgPSBudWxsO1xuICAgICAgX3RoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgICAgX3RoaXMudHJhY2tJZCA9IC0xO1xuICAgICAgX3RoaXMud2FpdGluZ0RhdGEgPSBudWxsO1xuICAgICAgX3RoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgICAgX3RoaXMuZmx1c2hpbmcgPSBmYWxzZTtcbiAgICAgIF90aGlzLmJ1ZmZlckZsdXNoZWQgPSBmYWxzZTtcbiAgICAgIF90aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IG51bGw7XG4gICAgICBfdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IEF1ZGlvU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLm9uSGFuZGxlckRlc3Ryb3lpbmcgPSBmdW5jdGlvbiBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbkhhbmRsZXJEZXN0cm95aW5nLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IG51bGw7XG4gICAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5fcmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tTX1VQREFURUQsIHRoaXMub25BdWRpb1RyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tTX1VQREFURUQsIHRoaXMub25BdWRpb1RyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBJTklUX1BUU19GT1VORCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdmlkZW8gdHJhY2sgcGFyc2VkIGluIHRoZSBzdHJlYW0tY29udHJvbGxlciBoYXMgYSBuZXcgUFRTIHZhbHVlXG4gICAgO1xuICAgIF9wcm90by5vbkluaXRQdHNGb3VuZCA9IGZ1bmN0aW9uIG9uSW5pdFB0c0ZvdW5kKGV2ZW50LCBfcmVmKSB7XG4gICAgICB2YXIgZnJhZyA9IF9yZWYuZnJhZyxcbiAgICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgICBpbml0UFRTID0gX3JlZi5pbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGUgPSBfcmVmLnRpbWVzY2FsZTtcbiAgICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIG5ldyBJTklUIFBUU1xuICAgICAgLy8gQ2FuIGNoYW5nZSBkdWUgbGV2ZWwgc3dpdGNoXG4gICAgICBpZiAoaWQgPT09ICdtYWluJykge1xuICAgICAgICB2YXIgY2MgPSBmcmFnLmNjO1xuICAgICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSB7XG4gICAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMsXG4gICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2coXCJJbml0UFRTIGZvciBjYzogXCIgKyBjYyArIFwiIGZvdW5kIGZyb20gbWFpbjogXCIgKyBpbml0UFRTKTtcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrQ0MgPSBjYztcbiAgICAgICAgLy8gSWYgd2UgYXJlIHdhaXRpbmcsIHRpY2sgaW1tZWRpYXRlbHkgdG8gdW5ibG9jayBhdWRpbyBmcmFnbWVudCB0cmFuc211eGluZ1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19JTklUX1BUUykge1xuICAgICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICAgIGlmICghdGhpcy5sZXZlbHMpIHtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCQyKTtcbiAgICAgIGlmIChsYXN0Q3VycmVudFRpbWUgPiAwICYmIHN0YXJ0UG9zaXRpb24gPT09IC0xKSB7XG4gICAgICAgIHRoaXMubG9nKFwiT3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAXCIgKyBsYXN0Q3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSBsYXN0Q3VycmVudFRpbWU7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgX3Byb3RvLmRvVGljayA9IGZ1bmN0aW9uIGRvVGljaygpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlIFN0YXRlLklETEU6XG4gICAgICAgICAgdGhpcy5kb1RpY2tJZGxlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19UUkFDSzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2xldmVscyR0cmFja0lkO1xuICAgICAgICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgICAgICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuICAgICAgICAgICAgdmFyIGRldGFpbHMgPSBsZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IChfbGV2ZWxzJHRyYWNrSWQgPSBsZXZlbHNbdHJhY2tJZF0pID09IG51bGwgPyB2b2lkIDAgOiBfbGV2ZWxzJHRyYWNrSWQuZGV0YWlscztcbiAgICAgICAgICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19JTklUX1BUUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICAgICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPSBudWxsICYmIF90aGlzJG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICAgICAgdmFyIF9sZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgICAgICAgICBfdHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcbiAgICAgICAgICAgICAgdGhpcy5sb2coJ1JldHJ5RGF0ZSByZWFjaGVkLCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlJyk7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQoKF9sZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbHNbX3RyYWNrSWRdKSB8fCBudWxsKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19JTklUX1BUUzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIHRoZSBXQUlUSU5HX0lOSVRfUFRTIHN0YXRlIGlmIHRoZSB3YWl0aW5nIGZyYWcgQ0MgZG9lc24ndCBtYXRjaCBhbnkgaW5pdFBUU1xuICAgICAgICAgICAgdmFyIHdhaXRpbmdEYXRhID0gdGhpcy53YWl0aW5nRGF0YTtcbiAgICAgICAgICAgIGlmICh3YWl0aW5nRGF0YSkge1xuICAgICAgICAgICAgICB2YXIgZnJhZyA9IHdhaXRpbmdEYXRhLmZyYWcsXG4gICAgICAgICAgICAgICAgcGFydCA9IHdhaXRpbmdEYXRhLnBhcnQsXG4gICAgICAgICAgICAgICAgY2FjaGUgPSB3YWl0aW5nRGF0YS5jYWNoZSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IHdhaXRpbmdEYXRhLmNvbXBsZXRlO1xuICAgICAgICAgICAgICBpZiAodGhpcy5pbml0UFRTW2ZyYWcuY2NdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLndhaXRpbmdWaWRlb0NDID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGNhY2hlLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZpZGVvVHJhY2tDQyAhPT0gdGhpcy53YWl0aW5nVmlkZW9DQykge1xuICAgICAgICAgICAgICAgIC8vIERyb3Agd2FpdGluZyBmcmFnbWVudCBpZiB2aWRlb1RyYWNrQ0MgaGFzIGNoYW5nZWQgc2luY2Ugd2FpdGluZ0ZyYWdtZW50IHdhcyBzZXQgYW5kIGluaXRQVFMgd2FzIG5vdCBmb3VuZFxuICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiV2FpdGluZyBmcmFnbWVudCBjYyAoXCIgKyBmcmFnLmNjICsgXCIpIGNhbmNlbGxlZCBiZWNhdXNlIHZpZGVvIGlzIGF0IGNjIFwiICsgdGhpcy52aWRlb1RyYWNrQ0MpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJXYWl0aW5nRnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEcm9wIHdhaXRpbmcgZnJhZ21lbnQgaWYgYW4gZWFybGllciBmcmFnbWVudCBpcyBuZWVkZWRcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIsIHBvcywgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgICAgICAgICAgICAgdmFyIHdhaXRpbmdGcmFnbWVudEF0UG9zaXRpb24gPSBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoYnVmZmVySW5mby5lbmQsIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWcpO1xuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nRnJhZ21lbnRBdFBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJXYWl0aW5nIGZyYWdtZW50IGNjIChcIiArIGZyYWcuY2MgKyBcIikgQCBcIiArIGZyYWcuc3RhcnQgKyBcIiBjYW5jZWxsZWQgYmVjYXVzZSBhbm90aGVyIGZyYWdtZW50IGF0IFwiICsgYnVmZmVySW5mby5lbmQgKyBcIiBpcyBuZWVkZWRcIik7XG4gICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyV2FpdGluZ0ZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9uVGlja0VuZCgpO1xuICAgIH07XG4gICAgX3Byb3RvLmNsZWFyV2FpdGluZ0ZyYWdtZW50ID0gZnVuY3Rpb24gY2xlYXJXYWl0aW5nRnJhZ21lbnQoKSB7XG4gICAgICB2YXIgd2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhO1xuICAgICAgaWYgKHdhaXRpbmdEYXRhKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KHdhaXRpbmdEYXRhLmZyYWcpO1xuICAgICAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy53YWl0aW5nVmlkZW9DQyA9IC0xO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5yZXNldExvYWRpbmdTdGF0ZSA9IGZ1bmN0aW9uIHJlc2V0TG9hZGluZ1N0YXRlKCkge1xuICAgICAgdGhpcy5jbGVhcldhaXRpbmdGcmFnbWVudCgpO1xuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5yZXNldExvYWRpbmdTdGF0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uVGlja0VuZCA9IGZ1bmN0aW9uIG9uVGlja0VuZCgpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAoIShtZWRpYSAhPSBudWxsICYmIG1lZGlhLnJlYWR5U3RhdGUpKSB7XG4gICAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBtZWRpYSBvciBpZiB0aGUgbWVkaWEgaGFzbid0IGJ1ZmZlcmVkIGFueXRoaW5nIHlldCAocmVhZHlTdGF0ZSAwKVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIH07XG4gICAgX3Byb3RvLmRvVGlja0lkbGUgPSBmdW5jdGlvbiBkb1RpY2tJZGxlKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICB0cmFja0lkID0gdGhpcy50cmFja0lkO1xuICAgICAgdmFyIGNvbmZpZyA9IGhscy5jb25maWc7XG5cbiAgICAgIC8vIDEuIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcbiAgICAgIC8vICAgIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggbm90IGVuYWJsZWRcbiAgICAgIC8vIDIuIGlmIHRyYWNrcyBvciB0cmFjayBub3QgbG9hZGVkIGFuZCBzZWxlY3RlZFxuICAgICAgLy8gdGhlbiBleGl0IGxvb3BcbiAgICAgIC8vID0+IGlmIG1lZGlhIG5vdCBhdHRhY2hlZCBidXQgc3RhcnQgZnJhZyBwcmVmZXRjaCBpcyBlbmFibGVkIGFuZCBzdGFydCBmcmFnIG5vdCByZXF1ZXN0ZWQgeWV0LCB3ZSB3aWxsIG5vdCBleGl0IGxvb3BcbiAgICAgIGlmICghbWVkaWEgJiYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpIHx8ICEobGV2ZWxzICE9IG51bGwgJiYgbGV2ZWxzW3RyYWNrSWRdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGV2ZWxJbmZvID0gbGV2ZWxzW3RyYWNrSWRdO1xuICAgICAgdmFyIHRyYWNrRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgICAgaWYgKCF0cmFja0RldGFpbHMgfHwgdHJhY2tEZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsSW5mbyB8fCB0aGlzLndhaXRGb3JDZG5UdW5lSW4odHJhY2tEZXRhaWxzKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGJ1ZmZlcmFibGUgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgICBpZiAodGhpcy5idWZmZXJGbHVzaGVkICYmIGJ1ZmZlcmFibGUpIHtcbiAgICAgICAgdGhpcy5idWZmZXJGbHVzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKGJ1ZmZlcmFibGUsIEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTywgUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pO1xuICAgICAgfVxuICAgICAgdmFyIGJ1ZmZlckluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pO1xuICAgICAgaWYgKGJ1ZmZlckluZm8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGJ1ZmZlcmVkVHJhY2sgPSB0aGlzLmJ1ZmZlcmVkVHJhY2ssXG4gICAgICAgIHN3aXRjaGluZ1RyYWNrID0gdGhpcy5zd2l0Y2hpbmdUcmFjaztcbiAgICAgIGlmICghc3dpdGNoaW5nVHJhY2sgJiYgdGhpcy5fc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgdHJhY2tEZXRhaWxzKSkge1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0VPUywge1xuICAgICAgICAgIHR5cGU6ICdhdWRpbydcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG1haW5CdWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMudmlkZW9CdWZmZXIgPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICB2YXIgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG4gICAgICB2YXIgbWF4QnVmTGVuID0gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobWFpbkJ1ZmZlckluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IG1haW5CdWZmZXJJbmZvLmxlbik7XG4gICAgICB2YXIgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cztcbiAgICAgIHZhciBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgIHZhciB0YXJnZXRCdWZmZXJUaW1lID0gdGhpcy5mbHVzaGluZyA/IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCkgOiBidWZmZXJJbmZvLmVuZDtcbiAgICAgIGlmIChzd2l0Y2hpbmdUcmFjayAmJiBtZWRpYSkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICAgICAgLy8gU1RBQkxFXG4gICAgICAgIGlmIChidWZmZXJlZFRyYWNrICYmICFtZWRpYUF0dHJpYnV0ZXNJZGVudGljYWwoc3dpdGNoaW5nVHJhY2suYXR0cnMsIGJ1ZmZlcmVkVHJhY2suYXR0cnMpKSB7XG4gICAgICAgICAgdGFyZ2V0QnVmZmVyVGltZSA9IHBvcztcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBjdXJyZW50VGltZSAocG9zKSBpcyBsZXNzIHRoYW4gYWx0IGF1ZGlvIHBsYXlsaXN0IHN0YXJ0IHRpbWUsIGl0IG1lYW5zIHRoYXQgYWx0IGF1ZGlvIGlzIGFoZWFkIG9mIGN1cnJlbnRUaW1lXG4gICAgICAgIGlmICh0cmFja0RldGFpbHMuUFRTS25vd24gJiYgcG9zIDwgc3RhcnQpIHtcbiAgICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0IG9yIGlmIGF1ZGlvIGJ1ZmZlciB1cGZyb250LCBsZXQncyBzZWVrIHRvIHN0YXJ0XG4gICAgICAgICAgaWYgKGJ1ZmZlckluZm8uZW5kID4gc3RhcnQgfHwgYnVmZmVySW5mby5uZXh0U3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdBbHQgYXVkaW8gdHJhY2sgYWhlYWQgb2YgbWFpbiB0cmFjaywgc2VlayB0byBzdGFydCBvZiBhbHQgYXVkaW8gdHJhY2snKTtcbiAgICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnQgKyAwLjA1O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiBidWZmZXIgbGVuZ3RoIGlzIGxlc3MgdGhhbiBtYXhCdWZMZW4sIG9yIG5lYXIgdGhlIGVuZCwgZmluZCBhIGZyYWdtZW50IHRvIGxvYWRcbiAgICAgIGlmIChidWZmZXJMZW4gPj0gbWF4QnVmTGVuICYmICFzd2l0Y2hpbmdUcmFjayAmJiB0YXJnZXRCdWZmZXJUaW1lIDwgZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5zdGFydCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZnJhZyA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50KHRhcmdldEJ1ZmZlclRpbWUsIHRyYWNrRGV0YWlscyk7XG4gICAgICB2YXIgYXRHYXAgPSBmYWxzZTtcbiAgICAgIC8vIEF2b2lkIGxvb3AgbG9hZGluZyBieSB1c2luZyBuZXh0TG9hZFBvc2l0aW9uIHNldCBmb3IgYmFja3RyYWNraW5nIGFuZCBza2lwcGluZyBjb25zZWN1dGl2ZSBHQVAgdGFnc1xuICAgICAgaWYgKGZyYWcgJiYgdGhpcy5pc0xvb3BMb2FkaW5nKGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpKSB7XG4gICAgICAgIGF0R2FwID0gISFmcmFnLmdhcDtcbiAgICAgICAgZnJhZyA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50TG9vcExvYWRpbmcoZnJhZywgdHJhY2tEZXRhaWxzLCBidWZmZXJJbmZvLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOLCBtYXhCdWZMZW4pO1xuICAgICAgfVxuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQnVmZmVyIGF1ZGlvIHVwIHRvIG9uZSB0YXJnZXQgZHVyYXRpb24gYWhlYWQgb2YgbWFpbiBidWZmZXJcbiAgICAgIHZhciBhdEJ1ZmZlclN5bmNMaW1pdCA9IG1haW5CdWZmZXJJbmZvICYmIGZyYWcuc3RhcnQgPiBtYWluQnVmZmVySW5mby5lbmQgKyB0cmFja0RldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICBpZiAoYXRCdWZmZXJTeW5jTGltaXQgfHxcbiAgICAgIC8vIE9yIHdhaXQgZm9yIG1haW4gYnVmZmVyIGFmdGVyIGJ1ZmZpbmcgc29tZSBhdWRpb1xuICAgICAgIShtYWluQnVmZmVySW5mbyAhPSBudWxsICYmIG1haW5CdWZmZXJJbmZvLmxlbikgJiYgYnVmZmVySW5mby5sZW4pIHtcbiAgICAgICAgLy8gQ2hlY2sgZnJhZ21lbnQtdHJhY2tlciBmb3IgbWFpbiBmcmFnbWVudHMgc2luY2UgR0FQIHNlZ21lbnRzIGRvIG5vdCBzaG93IHVwIGluIGJ1ZmZlckluZm9cbiAgICAgICAgdmFyIG1haW5GcmFnID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcoZnJhZy5zdGFydCwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgIGlmIChtYWluRnJhZyA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBCcmlkZ2UgZ2FwcyBpbiBtYWluIGJ1ZmZlclxuICAgICAgICBhdEdhcCB8fCAoYXRHYXAgPSAhIW1haW5GcmFnLmdhcCB8fCAhIWF0QnVmZmVyU3luY0xpbWl0ICYmIG1haW5CdWZmZXJJbmZvLmxlbiA9PT0gMCk7XG4gICAgICAgIGlmIChhdEJ1ZmZlclN5bmNMaW1pdCAmJiAhYXRHYXAgfHwgYXRHYXAgJiYgYnVmZmVySW5mby5uZXh0U3RhcnQgJiYgYnVmZmVySW5mby5uZXh0U3RhcnQgPCBtYWluRnJhZy5lbmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZEZyYWdtZW50KGZyYWcsIGxldmVsSW5mbywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TWF4QnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gZ2V0TWF4QnVmZmVyTGVuZ3RoKG1haW5CdWZmZXJMZW5ndGgpIHtcbiAgICAgIHZhciBtYXhDb25maWdCdWZmZXIgPSBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmdldE1heEJ1ZmZlckxlbmd0aC5jYWxsKHRoaXMpO1xuICAgICAgaWYgKCFtYWluQnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBtYXhDb25maWdCdWZmZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWF4Q29uZmlnQnVmZmVyLCBtYWluQnVmZmVyTGVuZ3RoKSwgdGhpcy5jb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdGhpcy5mbHVzaGluZyA9IGZhbHNlO1xuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vbk1lZGlhRGV0YWNoaW5nLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25BdWRpb1RyYWNrc1VwZGF0ZWQgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tzVXBkYXRlZChldmVudCwgX3JlZjIpIHtcbiAgICAgIHZhciBhdWRpb1RyYWNrcyA9IF9yZWYyLmF1ZGlvVHJhY2tzO1xuICAgICAgLy8gUmVzZXQgdHJhbnhtdXhlciBpcyBlc3NlbnRpYWwgZm9yIGxhcmdlIGNvbnRleHQgc3dpdGNoZXMgKENvbnRlbnQgU3RlZXJpbmcpXG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgdGhpcy5sZXZlbHMgPSBhdWRpb1RyYWNrcy5tYXAoZnVuY3Rpb24gKG1lZGlhUGxheWxpc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMZXZlbChtZWRpYVBsYXlsaXN0KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLm9uQXVkaW9UcmFja1N3aXRjaGluZyA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgICAgdmFyIGFsdEF1ZGlvID0gISFkYXRhLnVybDtcbiAgICAgIHRoaXMudHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgaWYgKGZyYWdDdXJyZW50KSB7XG4gICAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MoZnJhZ0N1cnJlbnQuc3RhcnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgLy8gZGVzdHJveSB1c2VsZXNzIHRyYW5zbXV4ZXIgd2hlbiBzd2l0Y2hpbmcgYXVkaW8gdG8gbWFpblxuICAgICAgaWYgKCFhbHRBdWRpbykge1xuICAgICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3dpdGNoaW5nIHRvIGF1ZGlvIHRyYWNrLCBzdGFydCB0aW1lciBpZiBub3QgYWxyZWFkeSBzdGFydGVkXG4gICAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCQyKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2hvdWxkIHdlIHN3aXRjaCB0cmFja3MgP1xuICAgICAgaWYgKGFsdEF1ZGlvKSB7XG4gICAgICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBkYXRhO1xuICAgICAgICAvLyBtYWluIGF1ZGlvIHRyYWNrIGFyZSBoYW5kbGVkIGJ5IHN0cmVhbS1jb250cm9sbGVyLCBqdXN0IGRvIHNvbWV0aGluZyBpZiBzd2l0Y2hpbmcgdG8gYWx0IGF1ZGlvIHRyYWNrXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLmZsdXNoQXVkaW9JZk5lZWRlZChkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBkYXRhO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICAgIH1cbiAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IHRoaXMuZmx1c2hpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMubGV2ZWxzID0gdGhpcy5tYWluRGV0YWlscyA9IHRoaXMud2FpdGluZ0RhdGEgPSB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMudHJhY2tJZCA9IHRoaXMudmlkZW9UcmFja0NDID0gdGhpcy53YWl0aW5nVmlkZW9DQyA9IC0xO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTGV2ZWxMb2FkZWQgPSBmdW5jdGlvbiBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLm1haW5EZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgaWYgKHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEpO1xuICAgICAgICB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25BdWRpb1RyYWNrTG9hZGVkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgX3RyYWNrJGRldGFpbHM7XG4gICAgICBpZiAodGhpcy5tYWluRGV0YWlscyA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHMsXG4gICAgICAgIHRyYWNrSWQgPSBkYXRhLmlkO1xuICAgICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgICAgdGhpcy53YXJuKFwiQXVkaW8gdHJhY2tzIHdlcmUgcmVzZXQgd2hpbGUgbG9hZGluZyBsZXZlbCBcIiArIHRyYWNrSWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZyhcIkF1ZGlvIHRyYWNrIFwiICsgdHJhY2tJZCArIFwiIGxvYWRlZCBbXCIgKyBuZXdEZXRhaWxzLnN0YXJ0U04gKyBcIixcIiArIG5ld0RldGFpbHMuZW5kU04gKyBcIl1cIiArIChuZXdEZXRhaWxzLmxhc3RQYXJ0U24gPyBcIltwYXJ0LVwiICsgbmV3RGV0YWlscy5sYXN0UGFydFNuICsgXCItXCIgKyBuZXdEZXRhaWxzLmxhc3RQYXJ0SW5kZXggKyBcIl1cIiA6ICcnKSArIFwiLGR1cmF0aW9uOlwiICsgbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uKTtcbiAgICAgIHZhciB0cmFjayA9IGxldmVsc1t0cmFja0lkXTtcbiAgICAgIHZhciBzbGlkaW5nID0gMDtcbiAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgfHwgKF90cmFjayRkZXRhaWxzID0gdHJhY2suZGV0YWlscykgIT0gbnVsbCAmJiBfdHJhY2skZGV0YWlscy5saXZlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tMaXZlVXBkYXRlKG5ld0RldGFpbHMpO1xuICAgICAgICB2YXIgbWFpbkRldGFpbHMgPSB0aGlzLm1haW5EZXRhaWxzO1xuICAgICAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCB8fCAhbWFpbkRldGFpbHMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0cmFjay5kZXRhaWxzICYmIG5ld0RldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lICYmIG1haW5EZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBvdXIgYXVkaW8gcmVuZGl0aW9uIGlzIGFsaWduZWQgd2l0aCB0aGUgXCJtYWluXCIgcmVuZGl0aW9uLCB1c2luZ1xuICAgICAgICAgIC8vIHBkdCBhcyBvdXIgcmVmZXJlbmNlIHRpbWVzLlxuICAgICAgICAgIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKG5ld0RldGFpbHMsIG1haW5EZXRhaWxzKTtcbiAgICAgICAgICBzbGlkaW5nID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF90aGlzJGxldmVsTGFzdExvYWRlZDtcbiAgICAgICAgICBzbGlkaW5nID0gdGhpcy5hbGlnblBsYXlsaXN0cyhuZXdEZXRhaWxzLCB0cmFjay5kZXRhaWxzLCAoX3RoaXMkbGV2ZWxMYXN0TG9hZGVkID0gdGhpcy5sZXZlbExhc3RMb2FkZWQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRsZXZlbExhc3RMb2FkZWQuZGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyYWNrLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSB0cmFjaztcblxuICAgICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiB3ZSBhcmUgYWxpZ25lZCB3aXRoIHRoZSBtYWluIHBsYXlsaXN0XG4gICAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkICYmICh0aGlzLm1haW5EZXRhaWxzIHx8ICFuZXdEZXRhaWxzLmxpdmUpKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhcnRQb3NpdGlvbih0aGlzLm1haW5EZXRhaWxzIHx8IG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgICAgfVxuICAgICAgLy8gb25seSBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgdHJhY2sgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX1RSQUNLICYmICF0aGlzLndhaXRGb3JDZG5UdW5lSW4obmV3RGV0YWlscykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKSB7XG4gICAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQ7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgcGFydCA9IGRhdGEucGFydCxcbiAgICAgICAgcGF5bG9hZCA9IGRhdGEucGF5bG9hZDtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgdHJhY2tJZCA9IHRoaXMudHJhY2tJZCxcbiAgICAgICAgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgICBpZiAoIWxldmVscykge1xuICAgICAgICB0aGlzLndhcm4oXCJBdWRpbyB0cmFja3Mgd2VyZSByZXNldCB3aGlsZSBmcmFnbWVudCBsb2FkIHdhcyBpbiBwcm9ncmVzcy4gRnJhZ21lbnQgXCIgKyBmcmFnLnNuICsgXCIgb2YgbGV2ZWwgXCIgKyBmcmFnLmxldmVsICsgXCIgd2lsbCBub3QgYmUgYnVmZmVyZWRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFjayA9IGxldmVsc1t0cmFja0lkXTtcbiAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgdGhpcy53YXJuKCdBdWRpbyB0cmFjayBpcyB1bmRlZmluZWQgb24gZnJhZ21lbnQgbG9hZCBwcm9ncmVzcycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGV0YWlscyA9IHRyYWNrLmRldGFpbHM7XG4gICAgICBpZiAoIWRldGFpbHMpIHtcbiAgICAgICAgdGhpcy53YXJuKCdBdWRpbyB0cmFjayBkZXRhaWxzIHVuZGVmaW5lZCBvbiBmcmFnbWVudCBsb2FkIHByb2dyZXNzJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlVW5idWZmZXJlZEZyYWdzKGZyYWcuc3RhcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYXVkaW9Db2RlYyA9IGNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCB0cmFjay5hdWRpb0NvZGVjIHx8ICdtcDRhLjQwLjInO1xuICAgICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXI7XG4gICAgICBpZiAoIXRyYW5zbXV4ZXIpIHtcbiAgICAgICAgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciA9IG5ldyBUcmFuc211eGVySW50ZXJmYWNlKHRoaXMuaGxzLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTywgdGhpcy5faGFuZGxlVHJhbnNtdXhDb21wbGV0ZS5iaW5kKHRoaXMpLCB0aGlzLl9oYW5kbGVUcmFuc211eGVyRmx1c2guYmluZCh0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdmlkZW8gaW5pdFBUU1xuICAgICAgLy8gSWYgbm90IHdlIG5lZWQgdG8gd2FpdCBmb3IgaXRcbiAgICAgIHZhciBpbml0UFRTID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuICAgICAgdmFyIGluaXRTZWdtZW50RGF0YSA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZyRpbml0U2VnbWVudC5kYXRhO1xuICAgICAgaWYgKGluaXRQVFMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0aGlzLmxvZyhgVHJhbnNtdXhpbmcgJHtzbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sdHJhY2sgJHt0cmFja0lkfWApO1xuICAgICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICAgICAgdmFyIGFjY3VyYXRlVGltZU9mZnNldCA9IGZhbHNlOyAvLyBkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XG4gICAgICAgIHZhciBwYXJ0SW5kZXggPSBwYXJ0ID8gcGFydC5pbmRleCA6IC0xO1xuICAgICAgICB2YXIgcGFydGlhbCA9IHBhcnRJbmRleCAhPT0gLTE7XG4gICAgICAgIHZhciBjaHVua01ldGEgPSBuZXcgQ2h1bmtNZXRhZGF0YShmcmFnLmxldmVsLCBmcmFnLnNuLCBmcmFnLnN0YXRzLmNodW5rQ291bnQsIHBheWxvYWQuYnl0ZUxlbmd0aCwgcGFydEluZGV4LCBwYXJ0aWFsKTtcbiAgICAgICAgdHJhbnNtdXhlci5wdXNoKHBheWxvYWQsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgJycsIGZyYWcsIHBhcnQsIGRldGFpbHMudG90YWxkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEsIGluaXRQVFMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2coXCJVbmtub3duIHZpZGVvIFBUUyBmb3IgY2MgXCIgKyBmcmFnLmNjICsgXCIsIHdhaXRpbmcgZm9yIHZpZGVvIFBUUyBiZWZvcmUgZGVtdXhpbmcgYXVkaW8gZnJhZyBcIiArIGZyYWcuc24gKyBcIiBvZiBbXCIgKyBkZXRhaWxzLnN0YXJ0U04gKyBcIiAsXCIgKyBkZXRhaWxzLmVuZFNOICsgXCJdLHRyYWNrIFwiICsgdHJhY2tJZCk7XG4gICAgICAgIHZhciBfdGhpcyR3YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhIHx8IHtcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgY2FjaGU6IG5ldyBDaHVua0NhY2hlKCksXG4gICAgICAgICAgICBjb21wbGV0ZTogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhY2hlID0gX3RoaXMkd2FpdGluZ0RhdGEuY2FjaGU7XG4gICAgICAgIGNhY2hlLnB1c2gobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCkpO1xuICAgICAgICB0aGlzLndhaXRpbmdWaWRlb0NDID0gdGhpcy52aWRlb1RyYWNrQ0M7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRGF0YSkge1xuICAgICAgaWYgKHRoaXMud2FpdGluZ0RhdGEpIHtcbiAgICAgICAgdGhpcy53YWl0aW5nRGF0YS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlLmNhbGwodGhpcywgZnJhZ0xvYWRlZERhdGEpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uQnVmZmVyUmVzZXQgPSBmdW5jdGlvbiBvbkJ1ZmZlclJlc2V0KCAvKiBldmVudDogRXZlbnRzLkJVRkZFUl9SRVNFVCAqL1xuICAgICkge1xuICAgICAgLy8gcmVzZXQgcmVmZXJlbmNlIHRvIHNvdXJjZWJ1ZmZlcnNcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5vbkJ1ZmZlckNyZWF0ZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBhdWRpb1RyYWNrID0gZGF0YS50cmFja3MuYXVkaW87XG4gICAgICBpZiAoYXVkaW9UcmFjaykge1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gYXVkaW9UcmFjay5idWZmZXIgfHwgbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnRyYWNrcy52aWRlbykge1xuICAgICAgICB0aGlzLnZpZGVvQnVmZmVyID0gZGF0YS50cmFja3MudmlkZW8uYnVmZmVyIHx8IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnQnVmZmVyZWQgPSBmdW5jdGlvbiBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQ7XG4gICAgICBpZiAoZnJhZy50eXBlICE9PSBQbGF5bGlzdExldmVsVHlwZS5BVURJTykge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlcmFibGUgPSB0aGlzLnZpZGVvQnVmZmVyIHx8IHRoaXMubWVkaWE7XG4gICAgICAgICAgaWYgKGJ1ZmZlcmFibGUpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXJlZFRpbWVSYW5nZXMgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoYnVmZmVyYWJsZSk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyZWRUaW1lUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgIC8vIElmIGEgbGV2ZWwgc3dpdGNoIHdhcyByZXF1ZXN0ZWQgd2hpbGUgYSBmcmFnbWVudCB3YXMgYnVmZmVyaW5nLCBpdCB3aWxsIGVtaXQgdGhlIEZSQUdfQlVGRkVSRUQgZXZlbnQgdXBvbiBjb21wbGV0aW9uXG4gICAgICAgIC8vIEF2b2lkIHNldHRpbmcgc3RhdGUgYmFjayB0byBJRExFIG9yIGNvbmNsdWRpbmcgdGhlIGF1ZGlvIHN3aXRjaDsgb3RoZXJ3aXNlLCB0aGUgc3dpdGNoZWQtdG8gdHJhY2sgd2lsbCBub3QgYnVmZmVyXG4gICAgICAgIHRoaXMud2FybihcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIChwYXJ0ID8gJyBwOiAnICsgcGFydC5pbmRleCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogXCIgKyB0aGlzLnN0YXRlICsgXCIsIGF1ZGlvU3dpdGNoOiBcIiArICh0aGlzLnN3aXRjaGluZ1RyYWNrID8gdGhpcy5zd2l0Y2hpbmdUcmFjay5uYW1lIDogJ2ZhbHNlJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICAgIHZhciB0cmFjayA9IHRoaXMuc3dpdGNoaW5nVHJhY2s7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IHRyYWNrO1xuICAgICAgICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCBfb2JqZWN0U3ByZWFkMih7fSwgdHJhY2spKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBwYXJ0KTtcbiAgICB9O1xuICAgIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF9kYXRhJGNvbnRleHQ7XG4gICAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfR0FQOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgICAgdGhpcy5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoUGxheWxpc3RMZXZlbFR5cGUuQVVESU8sIGRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgICAgLy8gaW4gY2FzZSBvZiBub24gZmF0YWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0cmFjaywgaWYgbm90IHJldHJ5aW5nIHRvIGxvYWQgdHJhY2ssIHN3aXRjaCBiYWNrIHRvIElETEVcbiAgICAgICAgICBpZiAoIWRhdGEubGV2ZWxSZXRyeSAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX1RSQUNLICYmICgoX2RhdGEkY29udGV4dCA9IGRhdGEuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGNvbnRleHQudHlwZSkgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgICAgaWYgKCFkYXRhLnBhcmVudCB8fCBkYXRhLnBhcmVudCAhPT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUikge1xuICAgICAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5yZWR1Y2VMZW5ndGhBbmRGbHVzaEJ1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJlZFRyYWNrID0gbnVsbDtcbiAgICAgICAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZmx1c2hNYWluQnVmZmVyLmNhbGwodGhpcywgMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCAnYXVkaW8nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTjpcbiAgICAgICAgICB0aGlzLnJlY292ZXJXb3JrZXJFcnJvcihkYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkJ1ZmZlckZsdXNoaW5nID0gZnVuY3Rpb24gb25CdWZmZXJGbHVzaGluZyhldmVudCwgX3JlZjMpIHtcbiAgICAgIHZhciB0eXBlID0gX3JlZjMudHlwZTtcbiAgICAgIGlmICh0eXBlICE9PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICAgICAgdGhpcy5mbHVzaGluZyA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJGbHVzaGVkID0gZnVuY3Rpb24gb25CdWZmZXJGbHVzaGVkKGV2ZW50LCBfcmVmNCkge1xuICAgICAgdmFyIHR5cGUgPSBfcmVmNC50eXBlO1xuICAgICAgaWYgKHR5cGUgIT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTykge1xuICAgICAgICB0aGlzLmZsdXNoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIgfHwgdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhQnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQobWVkaWFCdWZmZXIsIHR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKTtcbiAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLl9oYW5kbGVUcmFuc211eENvbXBsZXRlID0gZnVuY3Rpb24gX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQpIHtcbiAgICAgIHZhciBfaWQzJHNhbXBsZXM7XG4gICAgICB2YXIgaWQgPSAnYXVkaW8nO1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgdmFyIHJlbXV4UmVzdWx0ID0gdHJhbnNtdXhSZXN1bHQucmVtdXhSZXN1bHQsXG4gICAgICAgIGNodW5rTWV0YSA9IHRyYW5zbXV4UmVzdWx0LmNodW5rTWV0YTtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRoaXMucmVzZXRXaGVuTWlzc2luZ0NvbnRleHQoY2h1bmtNZXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICAgIHBhcnQgPSBjb250ZXh0LnBhcnQsXG4gICAgICAgIGxldmVsID0gY29udGV4dC5sZXZlbDtcbiAgICAgIHZhciBkZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAgIHZhciBhdWRpbyA9IHJlbXV4UmVzdWx0LmF1ZGlvLFxuICAgICAgICB0ZXh0ID0gcmVtdXhSZXN1bHQudGV4dCxcbiAgICAgICAgaWQzID0gcmVtdXhSZXN1bHQuaWQzLFxuICAgICAgICBpbml0U2VnbWVudCA9IHJlbXV4UmVzdWx0LmluaXRTZWdtZW50O1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCBmcmFnbWVudCBoYXMgYmVlbiBhYm9ydGVkLiBXZSBjaGVjayB0aGlzIGJ5IGZpcnN0IHNlZWluZyBpZiB3ZSdyZSBzdGlsbCBwbGF5aW5nIHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAgLy8gSWYgd2UgYXJlLCBzdWJzZXF1ZW50bHkgY2hlY2sgaWYgdGhlIGN1cnJlbnRseSBsb2FkaW5nIGZyYWdtZW50IChmcmFnQ3VycmVudCkgaGFzIGNoYW5nZWQuXG4gICAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykgfHwgIWRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTSU5HO1xuICAgICAgaWYgKHRoaXMuc3dpdGNoaW5nVHJhY2sgJiYgYXVkaW8pIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZUF1ZGlvU3dpdGNoKHRoaXMuc3dpdGNoaW5nVHJhY2spO1xuICAgICAgfVxuICAgICAgaWYgKGluaXRTZWdtZW50ICE9IG51bGwgJiYgaW5pdFNlZ21lbnQudHJhY2tzKSB7XG4gICAgICAgIHZhciBtYXBGcmFnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQgfHwgZnJhZztcbiAgICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQobGV2ZWwsIGluaXRTZWdtZW50LnRyYWNrcywgbWFwRnJhZ21lbnQsIGNodW5rTWV0YSk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCB7XG4gICAgICAgICAgZnJhZzogbWFwRnJhZ21lbnQsXG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHRyYWNrczogaW5pdFNlZ21lbnQudHJhY2tzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBPbmx5IGZsdXNoIGF1ZGlvIGZyb20gb2xkIGF1ZGlvIHRyYWNrcyB3aGVuIFBUUyBpcyBrbm93biBvbiBuZXcgYXVkaW8gdHJhY2tcbiAgICAgIH1cbiAgICAgIGlmIChhdWRpbykge1xuICAgICAgICB2YXIgc3RhcnRQVFMgPSBhdWRpby5zdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMgPSBhdWRpby5lbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMgPSBhdWRpby5zdGFydERUUyxcbiAgICAgICAgICBlbmREVFMgPSBhdWRpby5lbmREVFM7XG4gICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0ge1xuICAgICAgICAgICAgc3RhcnRQVFM6IHN0YXJ0UFRTLFxuICAgICAgICAgICAgZW5kUFRTOiBlbmRQVFMsXG4gICAgICAgICAgICBzdGFydERUUzogc3RhcnREVFMsXG4gICAgICAgICAgICBlbmREVFM6IGVuZERUU1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyhFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8sIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpO1xuICAgICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShhdWRpbywgZnJhZywgcGFydCwgY2h1bmtNZXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChpZDMgIT0gbnVsbCAmJiAoX2lkMyRzYW1wbGVzID0gaWQzLnNhbXBsZXMpICE9IG51bGwgJiYgX2lkMyRzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgZW1pdHRlZElEMyA9IF9leHRlbmRzKHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzXG4gICAgICAgIH0sIGlkMyk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIGVtaXR0ZWRUZXh0ID0gX2V4dGVuZHMoe1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIGRldGFpbHM6IGRldGFpbHNcbiAgICAgICAgfSwgdGV4dCk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGVtaXR0ZWRUZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5fYnVmZmVySW5pdFNlZ21lbnQgPSBmdW5jdGlvbiBfYnVmZmVySW5pdFNlZ21lbnQoY3VycmVudExldmVsLCB0cmFja3MsIGZyYWcsIGNodW5rTWV0YSkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gZGVsZXRlIGFueSB2aWRlbyB0cmFjayBmb3VuZCBvbiBhdWRpbyB0cmFuc211eGVyXG4gICAgICBpZiAodHJhY2tzLnZpZGVvKSB7XG4gICAgICAgIGRlbGV0ZSB0cmFja3MudmlkZW87XG4gICAgICB9XG5cbiAgICAgIC8vIGluY2x1ZGUgbGV2ZWxDb2RlYyBpbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzXG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyYWNrLmlkID0gJ2F1ZGlvJztcbiAgICAgIHZhciB2YXJpYW50QXVkaW9Db2RlY3MgPSBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjpcIiArIHRyYWNrLmNvbnRhaW5lciArIFwiLCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bXCIgKyB2YXJpYW50QXVkaW9Db2RlY3MgKyBcIi9cIiArIHRyYWNrLmNvZGVjICsgXCJdXCIpO1xuICAgICAgLy8gU291cmNlQnVmZmVyIHdpbGwgdXNlIHRyYWNrLmxldmVsQ29kZWMgaWYgZGVmaW5lZFxuICAgICAgaWYgKHZhcmlhbnRBdWRpb0NvZGVjcyAmJiB2YXJpYW50QXVkaW9Db2RlY3Muc3BsaXQoJywnKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdHJhY2subGV2ZWxDb2RlYyA9IHZhcmlhbnRBdWRpb0NvZGVjcztcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7XG4gICAgICB2YXIgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgIGlmIChpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgY2h1bmtNZXRhOiBjaHVua01ldGEsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgZGF0YTogaW5pdFNlZ21lbnRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVORElORywgc2VnbWVudCk7XG4gICAgICB9XG4gICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgICB9O1xuICAgIF9wcm90by5sb2FkRnJhZ21lbnQgPSBmdW5jdGlvbiBsb2FkRnJhZ21lbnQoZnJhZywgdHJhY2ssIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkIG9yIGlmIGluIGF1ZGlvIHN3aXRjaFxuICAgICAgdmFyIGZyYWdTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG5cbiAgICAgIC8vIHdlIGZvcmNlIGEgZnJhZyBsb2FkaW5nIGluIGF1ZGlvIHN3aXRjaCBhcyBmcmFnbWVudCB0cmFja2VyIG1pZ2h0IG5vdCBoYXZlIGV2aWN0ZWQgcHJldmlvdXMgZnJhZ3MgaW4gY2FzZSBvZiBxdWljayBhdWRpbyBzd2l0Y2hcbiAgICAgIGlmICh0aGlzLnN3aXRjaGluZ1RyYWNrIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XG4gICAgICAgIHZhciBfdHJhY2skZGV0YWlsczI7XG4gICAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgICAgdGhpcy5fbG9hZEluaXRTZWdtZW50KGZyYWcsIHRyYWNrKTtcbiAgICAgICAgfSBlbHNlIGlmICgoX3RyYWNrJGRldGFpbHMyID0gdHJhY2suZGV0YWlscykgIT0gbnVsbCAmJiBfdHJhY2skZGV0YWlsczIubGl2ZSAmJiAhdGhpcy5pbml0UFRTW2ZyYWcuY2NdKSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJXYWl0aW5nIGZvciB2aWRlbyBQVFMgaW4gY29udGludWl0eSBjb3VudGVyIFwiICsgZnJhZy5jYyArIFwiIG9mIGxpdmUgc3RyZWFtIGJlZm9yZSBsb2FkaW5nIGF1ZGlvIGZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIG9mIGxldmVsIFwiICsgdGhpcy50cmFja0lkKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19JTklUX1BUUztcbiAgICAgICAgICB2YXIgbWFpbkRldGFpbHMgPSB0aGlzLm1haW5EZXRhaWxzO1xuICAgICAgICAgIGlmIChtYWluRGV0YWlscyAmJiBtYWluRGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQgIT09IHRyYWNrLmRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0KSB7XG4gICAgICAgICAgICBhbGlnbk1lZGlhUGxheWxpc3RCeVBEVCh0cmFjay5kZXRhaWxzLCBtYWluRGV0YWlscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmxvYWRGcmFnbWVudC5jYWxsKHRoaXMsIGZyYWcsIHRyYWNrLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbGVhclRyYWNrZXJJZk5lZWRlZChmcmFnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5mbHVzaEF1ZGlvSWZOZWVkZWQgPSBmdW5jdGlvbiBmbHVzaEF1ZGlvSWZOZWVkZWQoc3dpdGNoaW5nVHJhY2spIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIGJ1ZmZlcmVkVHJhY2sgPSB0aGlzLmJ1ZmZlcmVkVHJhY2s7XG4gICAgICB2YXIgYnVmZmVyZWRBdHRyaWJ1dGVzID0gYnVmZmVyZWRUcmFjayA9PSBudWxsID8gdm9pZCAwIDogYnVmZmVyZWRUcmFjay5hdHRycztcbiAgICAgIHZhciBzd2l0Y2hBdHRyaWJ1dGVzID0gc3dpdGNoaW5nVHJhY2suYXR0cnM7XG4gICAgICBpZiAobWVkaWEgJiYgYnVmZmVyZWRBdHRyaWJ1dGVzICYmIChidWZmZXJlZEF0dHJpYnV0ZXMuQ0hBTk5FTFMgIT09IHN3aXRjaEF0dHJpYnV0ZXMuQ0hBTk5FTFMgfHwgYnVmZmVyZWRUcmFjay5uYW1lICE9PSBzd2l0Y2hpbmdUcmFjay5uYW1lIHx8IGJ1ZmZlcmVkVHJhY2subGFuZyAhPT0gc3dpdGNoaW5nVHJhY2subGFuZykpIHtcbiAgICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGZsdXNoaW5nIGFsbCBhdWRpbycpO1xuICAgICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmZsdXNoTWFpbkJ1ZmZlci5jYWxsKHRoaXMsIDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgJ2F1ZGlvJyk7XG4gICAgICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY29tcGxldGVBdWRpb1N3aXRjaCA9IGZ1bmN0aW9uIGNvbXBsZXRlQXVkaW9Td2l0Y2goc3dpdGNoaW5nVHJhY2spIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIHRoaXMuZmx1c2hBdWRpb0lmTmVlZGVkKHN3aXRjaGluZ1RyYWNrKTtcbiAgICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IHN3aXRjaGluZ1RyYWNrO1xuICAgICAgdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGw7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIF9vYmplY3RTcHJlYWQyKHt9LCBzd2l0Y2hpbmdUcmFjaykpO1xuICAgIH07XG4gICAgcmV0dXJuIEF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbiAgfShCYXNlU3RyZWFtQ29udHJvbGxlcik7XG5cbiAgdmFyIEF1ZGlvVHJhY2tDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVBsYXlsaXN0Q29udHJvbGwpIHtcbiAgICBfaW5oZXJpdHNMb29zZShBdWRpb1RyYWNrQ29udHJvbGxlciwgX0Jhc2VQbGF5bGlzdENvbnRyb2xsKTtcbiAgICBmdW5jdGlvbiBBdWRpb1RyYWNrQ29udHJvbGxlcihobHMpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF90aGlzID0gX0Jhc2VQbGF5bGlzdENvbnRyb2xsLmNhbGwodGhpcywgaGxzLCAnW2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXJdJykgfHwgdGhpcztcbiAgICAgIF90aGlzLnRyYWNrcyA9IFtdO1xuICAgICAgX3RoaXMuZ3JvdXBJZHMgPSBudWxsO1xuICAgICAgX3RoaXMudHJhY2tzSW5Hcm91cCA9IFtdO1xuICAgICAgX3RoaXMudHJhY2tJZCA9IC0xO1xuICAgICAgX3RoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICAgIF90aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gICAgICBfdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQXVkaW9UcmFja0NvbnRyb2xsZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgdGhpcy50cmFja3MubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMudHJhY2tzSW5Hcm91cC5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICAgIHRoaXMuZ3JvdXBJZHMgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMudHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcyB8fCBbXTtcbiAgICB9O1xuICAgIF9wcm90by5vbkF1ZGlvVHJhY2tMb2FkZWQgPSBmdW5jdGlvbiBvbkF1ZGlvVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBpZCA9IGRhdGEuaWQsXG4gICAgICAgIGdyb3VwSWQgPSBkYXRhLmdyb3VwSWQsXG4gICAgICAgIGRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICB2YXIgdHJhY2tJbkFjdGl2ZUdyb3VwID0gdGhpcy50cmFja3NJbkdyb3VwW2lkXTtcbiAgICAgIGlmICghdHJhY2tJbkFjdGl2ZUdyb3VwIHx8IHRyYWNrSW5BY3RpdmVHcm91cC5ncm91cElkICE9PSBncm91cElkKSB7XG4gICAgICAgIHRoaXMud2FybihcIkF1ZGlvIHRyYWNrIHdpdGggaWQ6XCIgKyBpZCArIFwiIGFuZCBncm91cDpcIiArIGdyb3VwSWQgKyBcIiBub3QgZm91bmQgaW4gYWN0aXZlIGdyb3VwIFwiICsgKHRyYWNrSW5BY3RpdmVHcm91cCA9PSBudWxsID8gdm9pZCAwIDogdHJhY2tJbkFjdGl2ZUdyb3VwLmdyb3VwSWQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGN1ckRldGFpbHMgPSB0cmFja0luQWN0aXZlR3JvdXAuZGV0YWlscztcbiAgICAgIHRyYWNrSW5BY3RpdmVHcm91cC5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgdGhpcy5sb2coXCJBdWRpbyB0cmFjayBcIiArIGlkICsgXCIgXFxcIlwiICsgdHJhY2tJbkFjdGl2ZUdyb3VwLm5hbWUgKyBcIlxcXCIgbGFuZzpcIiArIHRyYWNrSW5BY3RpdmVHcm91cC5sYW5nICsgXCIgZ3JvdXA6XCIgKyBncm91cElkICsgXCIgbG9hZGVkIFtcIiArIGRldGFpbHMuc3RhcnRTTiArIFwiLVwiICsgZGV0YWlscy5lbmRTTiArIFwiXVwiKTtcbiAgICAgIGlmIChpZCA9PT0gdGhpcy50cmFja0lkKSB7XG4gICAgICAgIHRoaXMucGxheWxpc3RMb2FkZWQoaWQsIGRhdGEsIGN1ckRldGFpbHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uTGV2ZWxMb2FkaW5nID0gZnVuY3Rpb24gb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbFN3aXRjaGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3dpdGNoTGV2ZWwgPSBmdW5jdGlvbiBzd2l0Y2hMZXZlbChsZXZlbEluZGV4KSB7XG4gICAgICB2YXIgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgICAgaWYgKCFsZXZlbEluZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGF1ZGlvR3JvdXBzID0gbGV2ZWxJbmZvLmF1ZGlvR3JvdXBzIHx8IG51bGw7XG4gICAgICB2YXIgY3VycmVudEdyb3VwcyA9IHRoaXMuZ3JvdXBJZHM7XG4gICAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgICBpZiAoIWF1ZGlvR3JvdXBzIHx8IChjdXJyZW50R3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50R3JvdXBzLmxlbmd0aCkgIT09IChhdWRpb0dyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9Hcm91cHMubGVuZ3RoKSB8fCBhdWRpb0dyb3VwcyAhPSBudWxsICYmIGF1ZGlvR3JvdXBzLnNvbWUoZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyZW50R3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50R3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkpID09PSAtMTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBJZHMgPSBhdWRpb0dyb3VwcztcbiAgICAgICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICAgICAgdmFyIGF1ZGlvVHJhY2tzID0gdGhpcy50cmFja3MuZmlsdGVyKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgIHJldHVybiAhYXVkaW9Hcm91cHMgfHwgYXVkaW9Hcm91cHMuaW5kZXhPZih0cmFjay5ncm91cElkKSAhPT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gRGlzYWJsZSBzZWxlY3REZWZhdWx0VHJhY2sgaWYgdGhlcmUgYXJlIG5vIGRlZmF1bHQgdHJhY2tzXG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrICYmICFhdWRpb1RyYWNrcy5zb21lKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrLmRlZmF1bHQ7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHRyYWNrLmlkIHNob3VsZCBtYXRjaCBobHMuYXVkaW9UcmFja3MgaW5kZXhcbiAgICAgICAgICBhdWRpb1RyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaywgaSkge1xuICAgICAgICAgICAgdHJhY2suaWQgPSBpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCFjdXJyZW50VHJhY2sgJiYgIXRoaXMudHJhY2tzSW5Hcm91cC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBEbyBub3QgZGlzcGF0Y2ggQVVESU9fVFJBQ0tTX1VQREFURUQgd2hlbiB0aGVyZSB3ZXJlIGFuZCBhcmUgbm8gdHJhY2tzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IGF1ZGlvVHJhY2tzO1xuXG4gICAgICAgIC8vIEZpbmQgcHJlZmVycmVkIHRyYWNrXG4gICAgICAgIHZhciBhdWRpb1ByZWZlcmVuY2UgPSB0aGlzLmhscy5jb25maWcuYXVkaW9QcmVmZXJlbmNlO1xuICAgICAgICBpZiAoIWN1cnJlbnRUcmFjayAmJiBhdWRpb1ByZWZlcmVuY2UpIHtcbiAgICAgICAgICB2YXIgZ3JvdXBJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihhdWRpb1ByZWZlcmVuY2UsIGF1ZGlvVHJhY2tzLCBhdWRpb01hdGNoUHJlZGljYXRlKTtcbiAgICAgICAgICBpZiAoZ3JvdXBJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBjdXJyZW50VHJhY2sgPSBhdWRpb1RyYWNrc1tncm91cEluZGV4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFsbEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKGF1ZGlvUHJlZmVyZW5jZSwgdGhpcy50cmFja3MpO1xuICAgICAgICAgICAgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NbYWxsSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdCBpbml0aWFsIHRyYWNrXG4gICAgICAgIHZhciB0cmFja0lkID0gdGhpcy5maW5kVHJhY2tJZChjdXJyZW50VHJhY2spO1xuICAgICAgICBpZiAodHJhY2tJZCA9PT0gLTEgJiYgY3VycmVudFRyYWNrKSB7XG4gICAgICAgICAgdHJhY2tJZCA9IHRoaXMuZmluZFRyYWNrSWQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaXNwYXRjaCBldmVudHMgYW5kIGxvYWQgdHJhY2sgaWYgbmVlZGVkXG4gICAgICAgIHZhciBhdWRpb1RyYWNrc1VwZGF0ZWQgPSB7XG4gICAgICAgICAgYXVkaW9UcmFja3M6IGF1ZGlvVHJhY2tzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nKFwiVXBkYXRpbmcgYXVkaW8gdHJhY2tzLCBcIiArIGF1ZGlvVHJhY2tzLmxlbmd0aCArIFwiIHRyYWNrKHMpIGZvdW5kIGluIGdyb3VwKHMpOiBcIiArIChhdWRpb0dyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9Hcm91cHMuam9pbignLCcpKSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLU19VUERBVEVELCBhdWRpb1RyYWNrc1VwZGF0ZWQpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRUcmFja0lkID0gdGhpcy50cmFja0lkO1xuICAgICAgICBpZiAodHJhY2tJZCAhPT0gLTEgJiYgc2VsZWN0ZWRUcmFja0lkID09PSAtMSkge1xuICAgICAgICAgIHRoaXMuc2V0QXVkaW9UcmFjayh0cmFja0lkKTtcbiAgICAgICAgfSBlbHNlIGlmIChhdWRpb1RyYWNrcy5sZW5ndGggJiYgc2VsZWN0ZWRUcmFja0lkID09PSAtMSkge1xuICAgICAgICAgIHZhciBfdGhpcyRncm91cElkcztcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJObyBhdWRpbyB0cmFjayBzZWxlY3RlZCBmb3IgY3VycmVudCBhdWRpbyBncm91cC1JRChzKTogXCIgKyAoKF90aGlzJGdyb3VwSWRzID0gdGhpcy5ncm91cElkcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGdyb3VwSWRzLmpvaW4oJywnKSkgKyBcIiB0cmFjayBjb3VudDogXCIgKyBhdWRpb1RyYWNrcy5sZW5ndGgpO1xuICAgICAgICAgIHRoaXMud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnNob3VsZFJlbG9hZFBsYXlsaXN0KGN1cnJlbnRUcmFjaykpIHtcbiAgICAgICAgLy8gUmV0cnkgcGxheWxpc3QgbG9hZGluZyBpZiBubyBwbGF5bGlzdCBpcyBvciBoYXMgYmVlbiBsb2FkZWQgeWV0XG4gICAgICAgIHRoaXMuc2V0QXVkaW9UcmFjayh0aGlzLnRyYWNrSWQpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5mYXRhbCB8fCAhZGF0YS5jb250ZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBkYXRhLmNvbnRleHQuaWQgPT09IHRoaXMudHJhY2tJZCAmJiAoIXRoaXMuZ3JvdXBJZHMgfHwgdGhpcy5ncm91cElkcy5pbmRleE9mKGRhdGEuY29udGV4dC5ncm91cElkKSAhPT0gLTEpKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IC0xO1xuICAgICAgICB0aGlzLmNoZWNrUmV0cnkoZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc2V0QXVkaW9PcHRpb24gPSBmdW5jdGlvbiBzZXRBdWRpb09wdGlvbihhdWRpb09wdGlvbikge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLmNvbmZpZy5hdWRpb1ByZWZlcmVuY2UgPSBhdWRpb09wdGlvbjtcbiAgICAgIGlmIChhdWRpb09wdGlvbikge1xuICAgICAgICB2YXIgYWxsQXVkaW9UcmFja3MgPSB0aGlzLmFsbEF1ZGlvVHJhY2tzO1xuICAgICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgICBpZiAoYWxsQXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gRmlyc3Qgc2VlIGlmIGN1cnJlbnQgb3B0aW9uIG1hdGNoZXMgKG5vIHN3aXRjaCBvcClcbiAgICAgICAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgICAgICAgaWYgKGN1cnJlbnRUcmFjayAmJiBtYXRjaGVzT3B0aW9uKGF1ZGlvT3B0aW9uLCBjdXJyZW50VHJhY2ssIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFRyYWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBGaW5kIG9wdGlvbiBpbiBhdmFpbGFibGUgdHJhY2tzICh0cmFja3NJbkdyb3VwKVxuICAgICAgICAgIHZhciBncm91cEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKGF1ZGlvT3B0aW9uLCB0aGlzLnRyYWNrc0luR3JvdXAsIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpO1xuICAgICAgICAgIGlmIChncm91cEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHZhciB0cmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFtncm91cEluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXVkaW9UcmFjayhncm91cEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRUcmFjaykge1xuICAgICAgICAgICAgLy8gRmluZCBvcHRpb24gaW4gbmVhcmVzdCBsZXZlbCBhdWRpbyBncm91cFxuICAgICAgICAgICAgdmFyIHNlYXJjaEluZGV4ID0gaGxzLmxvYWRMZXZlbDtcbiAgICAgICAgICAgIGlmIChzZWFyY2hJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgc2VhcmNoSW5kZXggPSBobHMuZmlyc3RBdXRvTGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3dpdGNoSW5kZXggPSBmaW5kQ2xvc2VzdExldmVsV2l0aEF1ZGlvR3JvdXAoYXVkaW9PcHRpb24sIGhscy5sZXZlbHMsIGFsbEF1ZGlvVHJhY2tzLCBzZWFyY2hJbmRleCwgYXVkaW9NYXRjaFByZWRpY2F0ZSk7XG4gICAgICAgICAgICBpZiAoc3dpdGNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgIC8vIGNvdWxkIG5vdCBmaW5kIG1hdGNoaW5nIHZhcmlhbnRcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmQgc3dpdGNoIGxldmVsIHRvIGFjaGVpdmUgdGhlIGF1ZGlvIGdyb3VwIHN3aXRjaFxuICAgICAgICAgICAgaGxzLm5leHRMb2FkTGV2ZWwgPSBzd2l0Y2hJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF1ZGlvT3B0aW9uLmNoYW5uZWxzIHx8IGF1ZGlvT3B0aW9uLmF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICAgIC8vIENvdWxkIG5vdCBmaW5kIGEgbWF0Y2ggd2l0aCBjb2RlYyAvIGNoYW5uZWxzIHByZWRpY2F0ZVxuICAgICAgICAgICAgLy8gRmluZCBhIG1hdGNoIHdpdGhvdXQgY2hhbm5lbHMgb3IgY29kZWNcbiAgICAgICAgICAgIHZhciB3aXRob3V0Q29kZWNBbmRDaGFubmVsc01hdGNoID0gZmluZE1hdGNoaW5nT3B0aW9uKGF1ZGlvT3B0aW9uLCBhbGxBdWRpb1RyYWNrcyk7XG4gICAgICAgICAgICBpZiAod2l0aG91dENvZGVjQW5kQ2hhbm5lbHNNYXRjaCA+IC0xKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhbGxBdWRpb1RyYWNrc1t3aXRob3V0Q29kZWNBbmRDaGFubmVsc01hdGNoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLnNldEF1ZGlvVHJhY2sgPSBmdW5jdGlvbiBzZXRBdWRpb1RyYWNrKG5ld0lkKSB7XG4gICAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuXG4gICAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICAgIGlmIChuZXdJZCA8IDAgfHwgbmV3SWQgPj0gdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLndhcm4oXCJJbnZhbGlkIGF1ZGlvIHRyYWNrIGlkOiBcIiArIG5ld0lkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciBsYXN0VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tuZXdJZF07XG4gICAgICB2YXIgdHJhY2tMb2FkZWQgPSB0cmFjay5kZXRhaWxzICYmICF0cmFjay5kZXRhaWxzLmxpdmU7XG4gICAgICBpZiAobmV3SWQgPT09IHRoaXMudHJhY2tJZCAmJiB0cmFjayA9PT0gbGFzdFRyYWNrICYmIHRyYWNrTG9hZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKFwiU3dpdGNoaW5nIHRvIGF1ZGlvLXRyYWNrIFwiICsgbmV3SWQgKyBcIiBcXFwiXCIgKyB0cmFjay5uYW1lICsgXCJcXFwiIGxhbmc6XCIgKyB0cmFjay5sYW5nICsgXCIgZ3JvdXA6XCIgKyB0cmFjay5ncm91cElkICsgXCIgY2hhbm5lbHM6XCIgKyB0cmFjay5jaGFubmVscyk7XG4gICAgICB0aGlzLnRyYWNrSWQgPSBuZXdJZDtcbiAgICAgIHRoaXMuY3VycmVudFRyYWNrID0gdHJhY2s7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIF9vYmplY3RTcHJlYWQyKHt9LCB0cmFjaykpO1xuICAgICAgLy8gRG8gbm90IHJlbG9hZCB0cmFjayB1bmxlc3MgbGl2ZVxuICAgICAgaWYgKHRyYWNrTG9hZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBobHNVcmxQYXJhbWV0ZXJzID0gdGhpcy5zd2l0Y2hQYXJhbXModHJhY2sudXJsLCBsYXN0VHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RUcmFjay5kZXRhaWxzLCB0cmFjay5kZXRhaWxzKTtcbiAgICAgIHRoaXMubG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpO1xuICAgIH07XG4gICAgX3Byb3RvLmZpbmRUcmFja0lkID0gZnVuY3Rpb24gZmluZFRyYWNrSWQoY3VycmVudFRyYWNrKSB7XG4gICAgICB2YXIgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF1ZGlvVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0cmFjayA9IGF1ZGlvVHJhY2tzW2ldO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgJiYgIXRyYWNrLmRlZmF1bHQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnRUcmFjayB8fCBtYXRjaGVzT3B0aW9uKGN1cnJlbnRUcmFjaywgdHJhY2ssIGF1ZGlvTWF0Y2hQcmVkaWNhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgICAgdmFyIG5hbWUgPSBjdXJyZW50VHJhY2submFtZSxcbiAgICAgICAgICBsYW5nID0gY3VycmVudFRyYWNrLmxhbmcsXG4gICAgICAgICAgYXNzb2NMYW5nID0gY3VycmVudFRyYWNrLmFzc29jTGFuZyxcbiAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3MgPSBjdXJyZW50VHJhY2suY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICAgIGF1ZGlvQ29kZWMgPSBjdXJyZW50VHJhY2suYXVkaW9Db2RlYyxcbiAgICAgICAgICBjaGFubmVscyA9IGN1cnJlbnRUcmFjay5jaGFubmVscztcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGF1ZGlvVHJhY2tzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHZhciBfdHJhY2sgPSBhdWRpb1RyYWNrc1tfaV07XG4gICAgICAgICAgaWYgKG1hdGNoZXNPcHRpb24oe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGxhbmc6IGxhbmcsXG4gICAgICAgICAgICBhc3NvY0xhbmc6IGFzc29jTGFuZyxcbiAgICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICAgICAgYXVkaW9Db2RlYzogYXVkaW9Db2RlYyxcbiAgICAgICAgICAgIGNoYW5uZWxzOiBjaGFubmVsc1xuICAgICAgICAgIH0sIF90cmFjaywgYXVkaW9NYXRjaFByZWRpY2F0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBfaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYXVkaW9UcmFja3MubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBfdHJhY2syID0gYXVkaW9UcmFja3NbX2kyXTtcbiAgICAgICAgICBpZiAobWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsKGN1cnJlbnRUcmFjay5hdHRycywgX3RyYWNrMi5hdHRycywgWydMQU5HVUFHRScsICdBU1NPQy1MQU5HVUFHRScsICdDSEFSQUNURVJJU1RJQ1MnXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBfaTI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGF1ZGlvVHJhY2tzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICB2YXIgX3RyYWNrMyA9IGF1ZGlvVHJhY2tzW19pM107XG4gICAgICAgICAgaWYgKG1lZGlhQXR0cmlidXRlc0lkZW50aWNhbChjdXJyZW50VHJhY2suYXR0cnMsIF90cmFjazMuYXR0cnMsIFsnTEFOR1VBR0UnXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBfaTM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgIHZhciBhdWRpb1RyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgICBpZiAodGhpcy5zaG91bGRMb2FkUGxheWxpc3QoYXVkaW9UcmFjaykgJiYgYXVkaW9UcmFjaykge1xuICAgICAgICBfQmFzZVBsYXlsaXN0Q29udHJvbGwucHJvdG90eXBlLmxvYWRQbGF5bGlzdC5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgaWQgPSBhdWRpb1RyYWNrLmlkO1xuICAgICAgICB2YXIgZ3JvdXBJZCA9IGF1ZGlvVHJhY2suZ3JvdXBJZDtcbiAgICAgICAgdmFyIHVybCA9IGF1ZGlvVHJhY2sudXJsO1xuICAgICAgICBpZiAoaGxzVXJsUGFyYW1ldGVycykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cmwgPSBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJsKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy53YXJuKFwiQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIHdpdGggSExTIERlbGl2ZXJ5IERpcmVjdGl2ZXM6IFwiICsgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0cmFjayBub3QgcmV0cmlldmVkIHlldCwgb3IgbGl2ZSBwbGF5bGlzdCB3ZSBuZWVkIHRvIChyZSlsb2FkIGl0XG4gICAgICAgIHRoaXMubG9nKFwibG9hZGluZyBhdWRpby10cmFjayBwbGF5bGlzdCBcIiArIGlkICsgXCIgXFxcIlwiICsgYXVkaW9UcmFjay5uYW1lICsgXCJcXFwiIGxhbmc6XCIgKyBhdWRpb1RyYWNrLmxhbmcgKyBcIiBncm91cDpcIiArIGdyb3VwSWQpO1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfTE9BRElORywge1xuICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX2NyZWF0ZUNsYXNzKEF1ZGlvVHJhY2tDb250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcImFsbEF1ZGlvVHJhY2tzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhdWRpb1RyYWNrc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImF1ZGlvVHJhY2tcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFja0lkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0lkKSB7XG4gICAgICAgIC8vIElmIGF1ZGlvIHRyYWNrIGlzIHNlbGVjdGVkIGZyb20gQVBJIHRoZW4gZG9uJ3QgY2hvb3NlIGZyb20gdGhlIG1hbmlmZXN0IGRlZmF1bHQgdHJhY2tcbiAgICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrKG5ld0lkKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICB9KEJhc2VQbGF5bGlzdENvbnRyb2xsZXIpO1xuXG4gIHZhciBUSUNLX0lOVEVSVkFMJDEgPSA1MDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG5cbiAgdmFyIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VTdHJlYW1Db250cm9sbGVyKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBfQmFzZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSB7XG4gICAgICB2YXIgX3RoaXM7XG4gICAgICBfdGhpcyA9IF9CYXNlU3RyZWFtQ29udHJvbGxlci5jYWxsKHRoaXMsIGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIsICdbc3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXJdJywgUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5jdXJyZW50VHJhY2tJZCA9IC0xO1xuICAgICAgX3RoaXMudHJhY2tzQnVmZmVyZWQgPSBbXTtcbiAgICAgIF90aGlzLm1haW5EZXRhaWxzID0gbnVsbDtcbiAgICAgIF90aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWluZyA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3lpbmcuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHRoaXMub25TdWJ0aXRsZVRyYWNrU3dpdGNoLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB0aGlzLm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHRoaXMub25TdWJ0aXRsZVRyYWNrU3dpdGNoLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHRoaXMub25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3RhcnRMb2FkID0gZnVuY3Rpb24gc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHtcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbChUSUNLX0lOVEVSVkFMJDEpO1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkID0gW107XG4gICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFEZXRhY2hpbmcuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5vbkxldmVsTG9hZGVkID0gZnVuY3Rpb24gb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy5tYWluRGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICB9O1xuICAgIF9wcm90by5vblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCA9IGZ1bmN0aW9uIG9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgc3VjY2VzcyA9IGRhdGEuc3VjY2VzcztcbiAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBidWZmZXJlZCA9IHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF07XG4gICAgICBpZiAoIWJ1ZmZlcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlL3VwZGF0ZSBhIGJ1ZmZlcmVkIGFycmF5IG1hdGNoaW5nIHRoZSBpbnRlcmZhY2UgdXNlZCBieSBCdWZmZXJIZWxwZXIuYnVmZmVyZWRJbmZvXG4gICAgICAvLyBzbyB3ZSBjYW4gcmUtdXNlIHRoZSBsb2dpYyB1c2VkIHRvIGRldGVjdCBob3cgbXVjaCBoYXMgYmVlbiBidWZmZXJlZFxuICAgICAgdmFyIHRpbWVSYW5nZTtcbiAgICAgIHZhciBmcmFnU3RhcnQgPSBmcmFnLnN0YXJ0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZnJhZ1N0YXJ0ID49IGJ1ZmZlcmVkW2ldLnN0YXJ0ICYmIGZyYWdTdGFydCA8PSBidWZmZXJlZFtpXS5lbmQpIHtcbiAgICAgICAgICB0aW1lUmFuZ2UgPSBidWZmZXJlZFtpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGZyYWdFbmQgPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICAgIGlmICh0aW1lUmFuZ2UpIHtcbiAgICAgICAgdGltZVJhbmdlLmVuZCA9IGZyYWdFbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lUmFuZ2UgPSB7XG4gICAgICAgICAgc3RhcnQ6IGZyYWdTdGFydCxcbiAgICAgICAgICBlbmQ6IGZyYWdFbmRcbiAgICAgICAgfTtcbiAgICAgICAgYnVmZmVyZWQucHVzaCh0aW1lUmFuZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKGZyYWcpO1xuICAgICAgdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBudWxsKTtcbiAgICB9O1xuICAgIF9wcm90by5vbkJ1ZmZlckZsdXNoaW5nID0gZnVuY3Rpb24gb25CdWZmZXJGbHVzaGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gZGF0YS5zdGFydE9mZnNldCxcbiAgICAgICAgZW5kT2Zmc2V0ID0gZGF0YS5lbmRPZmZzZXQ7XG4gICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDAgJiYgZW5kT2Zmc2V0ICE9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgdmFyIGVuZE9mZnNldFN1YnRpdGxlcyA9IGVuZE9mZnNldCAtIDE7XG4gICAgICAgIGlmIChlbmRPZmZzZXRTdWJ0aXRsZXMgPD0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLmVuZE9mZnNldFN1YnRpdGxlcyA9IE1hdGgubWF4KDAsIGVuZE9mZnNldFN1YnRpdGxlcyk7XG4gICAgICAgIHRoaXMudHJhY2tzQnVmZmVyZWQuZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5lbmQgPD0gZW5kT2Zmc2V0U3VidGl0bGVzKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcmVkLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChidWZmZXJlZFtpXS5zdGFydCA8IGVuZE9mZnNldFN1YnRpdGxlcykge1xuICAgICAgICAgICAgICBidWZmZXJlZFtpXS5zdGFydCA9IGVuZE9mZnNldFN1YnRpdGxlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldFN1YnRpdGxlcywgUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uRnJhZ0J1ZmZlcmVkID0gZnVuY3Rpb24gb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBkYXRhLmZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICAgIGlmICgoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPSBudWxsICYmIF90aGlzJG1lZGlhLmJ1ZmZlcmVkLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgc29tZXRoaW5nIGdvZXMgd3JvbmcsIHByb2NlZWQgdG8gbmV4dCBmcmFnLCBpZiB3ZSB3ZXJlIHByb2Nlc3Npbmcgb25lLlxuICAgIDtcbiAgICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgaWYgKChmcmFnID09IG51bGwgPyB2b2lkIDAgOiBmcmFnLnR5cGUpID09PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSkge1xuICAgICAgICBpZiAoZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuRlJBR19HQVApIHtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5mcmFnQnVmZmVyZWQoZnJhZywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICB0aGlzLmZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR290IGFsbCBuZXcgc3VidGl0bGUgbGV2ZWxzLlxuICAgIDtcbiAgICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZChldmVudCwgX3JlZikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgc3VidGl0bGVUcmFja3MgPSBfcmVmLnN1YnRpdGxlVHJhY2tzO1xuICAgICAgaWYgKHRoaXMubGV2ZWxzICYmIHN1YnRpdGxlT3B0aW9uc0lkZW50aWNhbCh0aGlzLmxldmVscywgc3VidGl0bGVUcmFja3MpKSB7XG4gICAgICAgIHRoaXMubGV2ZWxzID0gc3VidGl0bGVUcmFja3MubWFwKGZ1bmN0aW9uIChtZWRpYVBsYXlsaXN0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMZXZlbChtZWRpYVBsYXlsaXN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhY2tzQnVmZmVyZWQgPSBbXTtcbiAgICAgIHRoaXMubGV2ZWxzID0gc3VidGl0bGVUcmFja3MubWFwKGZ1bmN0aW9uIChtZWRpYVBsYXlsaXN0KSB7XG4gICAgICAgIHZhciBsZXZlbCA9IG5ldyBMZXZlbChtZWRpYVBsYXlsaXN0KTtcbiAgICAgICAgX3RoaXMyLnRyYWNrc0J1ZmZlcmVkW2xldmVsLmlkXSA9IFtdO1xuICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2UoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSk7XG4gICAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5vblN1YnRpdGxlVHJhY2tTd2l0Y2ggPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tTd2l0Y2goZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfdGhpcyRsZXZlbHM7XG4gICAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gZGF0YS5pZDtcbiAgICAgIGlmICghKChfdGhpcyRsZXZlbHMgPSB0aGlzLmxldmVscykgIT0gbnVsbCAmJiBfdGhpcyRsZXZlbHMubGVuZ3RoKSB8fCB0aGlzLmN1cnJlbnRUcmFja0lkID09PSAtMSkge1xuICAgICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0cmFjayBoYXMgdGhlIG5lY2Vzc2FyeSBkZXRhaWxzIHRvIGxvYWQgZnJhZ21lbnRzXG4gICAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy5sZXZlbHNbdGhpcy5jdXJyZW50VHJhY2tJZF07XG4gICAgICBpZiAoY3VycmVudFRyYWNrICE9IG51bGwgJiYgY3VycmVudFRyYWNrLmRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXJUaW1lUmFuZ2VzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCQxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHb3QgYSBuZXcgc2V0IG9mIHN1YnRpdGxlIGZyYWdtZW50cy5cbiAgICA7XG4gICAgX3Byb3RvLm9uU3VidGl0bGVUcmFja0xvYWRlZCA9IGZ1bmN0aW9uIG9uU3VidGl0bGVUcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF90cmFjayRkZXRhaWxzO1xuICAgICAgdmFyIGN1cnJlbnRUcmFja0lkID0gdGhpcy5jdXJyZW50VHJhY2tJZCxcbiAgICAgICAgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgICB2YXIgbmV3RGV0YWlscyA9IGRhdGEuZGV0YWlscyxcbiAgICAgICAgdHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgICBpZiAoIWxldmVscykge1xuICAgICAgICB0aGlzLndhcm4oXCJTdWJ0aXRsZSB0cmFja3Mgd2VyZSByZXNldCB3aGlsZSBsb2FkaW5nIGxldmVsIFwiICsgdHJhY2tJZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFjayA9IGxldmVsc1t0cmFja0lkXTtcbiAgICAgIGlmICh0cmFja0lkID49IGxldmVscy5sZW5ndGggfHwgIXRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKFwiU3VidGl0bGUgdHJhY2sgXCIgKyB0cmFja0lkICsgXCIgbG9hZGVkIFtcIiArIG5ld0RldGFpbHMuc3RhcnRTTiArIFwiLFwiICsgbmV3RGV0YWlscy5lbmRTTiArIFwiXVwiICsgKG5ld0RldGFpbHMubGFzdFBhcnRTbiA/IFwiW3BhcnQtXCIgKyBuZXdEZXRhaWxzLmxhc3RQYXJ0U24gKyBcIi1cIiArIG5ld0RldGFpbHMubGFzdFBhcnRJbmRleCArIFwiXVwiIDogJycpICsgXCIsZHVyYXRpb246XCIgKyBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24pO1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXJUaW1lUmFuZ2VzO1xuICAgICAgdmFyIHNsaWRpbmcgPSAwO1xuICAgICAgaWYgKG5ld0RldGFpbHMubGl2ZSB8fCAoX3RyYWNrJGRldGFpbHMgPSB0cmFjay5kZXRhaWxzKSAhPSBudWxsICYmIF90cmFjayRkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgdmFyIG1haW5EZXRhaWxzID0gdGhpcy5tYWluRGV0YWlscztcbiAgICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgfHwgIW1haW5EZXRhaWxzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQgPSBtYWluRGV0YWlscy5mcmFnbWVudHNbMF07XG4gICAgICAgIGlmICghdHJhY2suZGV0YWlscykge1xuICAgICAgICAgIGlmIChuZXdEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSAmJiBtYWluRGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICAgIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKG5ld0RldGFpbHMsIG1haW5EZXRhaWxzKTtcbiAgICAgICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudCkge1xuICAgICAgICAgICAgLy8gbGluZSB1cCBsaXZlIHBsYXlsaXN0IHdpdGggbWFpbiBzbyB0aGF0IGZyYWdtZW50cyBpbiByYW5nZSBhcmUgbG9hZGVkXG4gICAgICAgICAgICBzbGlkaW5nID0gbWFpblNsaWRpbmdTdGFydEZyYWdtZW50LnN0YXJ0O1xuICAgICAgICAgICAgYWRkU2xpZGluZyhuZXdEZXRhaWxzLCBzbGlkaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF90aGlzJGxldmVsTGFzdExvYWRlZDtcbiAgICAgICAgICBzbGlkaW5nID0gdGhpcy5hbGlnblBsYXlsaXN0cyhuZXdEZXRhaWxzLCB0cmFjay5kZXRhaWxzLCAoX3RoaXMkbGV2ZWxMYXN0TG9hZGVkID0gdGhpcy5sZXZlbExhc3RMb2FkZWQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRsZXZlbExhc3RMb2FkZWQuZGV0YWlscyk7XG4gICAgICAgICAgaWYgKHNsaWRpbmcgPT09IDAgJiYgbWFpblNsaWRpbmdTdGFydEZyYWdtZW50KSB7XG4gICAgICAgICAgICAvLyByZWFsaWduIHdpdGggbWFpbiB3aGVuIHRoZXJlIGlzIG5vIG92ZXJsYXAgd2l0aCBsYXN0IHJlZnJlc2hcbiAgICAgICAgICAgIHNsaWRpbmcgPSBtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQuc3RhcnQ7XG4gICAgICAgICAgICBhZGRTbGlkaW5nKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJhY2suZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IHRyYWNrO1xuICAgICAgaWYgKHRyYWNrSWQgIT09IGN1cnJlbnRUcmFja0lkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgKHRoaXMubWFpbkRldGFpbHMgfHwgIW5ld0RldGFpbHMubGl2ZSkpIHtcbiAgICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKHRoaXMubWFpbkRldGFpbHMgfHwgbmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICAgIHRoaXMudGljaygpO1xuXG4gICAgICAvLyBJZiBwbGF5bGlzdCBpcyBtaXNhbGlnbmVkIGJlY2F1c2Ugb2YgYmFkIFBEVCBvciBkcmlmdCwgZGVsZXRlIGRldGFpbHMgdG8gcmVzeW5jIHdpdGggbWFpbiBvbiByZWxvYWRcbiAgICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgJiYgIXRoaXMuZnJhZ0N1cnJlbnQgJiYgdGhpcy5tZWRpYSAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICAgIHZhciBmb3VuZEZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhudWxsLCBuZXdEZXRhaWxzLmZyYWdtZW50cywgdGhpcy5tZWRpYS5jdXJyZW50VGltZSwgMCk7XG4gICAgICAgIGlmICghZm91bmRGcmFnKSB7XG4gICAgICAgICAgdGhpcy53YXJuKCdTdWJ0aXRsZSBwbGF5bGlzdCBub3QgYWxpZ25lZCB3aXRoIHBsYXliYWNrJyk7XG4gICAgICAgICAgdHJhY2suZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRGF0YSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgZnJhZyA9IGZyYWdMb2FkZWREYXRhLmZyYWcsXG4gICAgICAgIHBheWxvYWQgPSBmcmFnTG9hZGVkRGF0YS5wYXlsb2FkO1xuICAgICAgdmFyIGRlY3J5cHREYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXG4gICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICE9IG51bGwgJiYgZGVjcnlwdERhdGEua2V5ICYmIGRlY3J5cHREYXRhLml2ICYmIGRlY3J5cHREYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgLy8gZGVjcnlwdCB0aGUgc3VidGl0bGVzXG4gICAgICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGRlY3J5cHREYXRhLmtleS5idWZmZXIsIGRlY3J5cHREYXRhLml2LmJ1ZmZlcikuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgcmVhc29uOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgIGZyYWc6IGZyYWdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICB2YXIgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IGRlY3J5cHRlZERhdGEsXG4gICAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgICB0c3RhcnQ6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgdGRlY3J5cHQ6IGVuZFRpbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIF90aGlzMy53YXJuKGVyci5uYW1lICsgXCI6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgIF90aGlzMy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmRvVGljayA9IGZ1bmN0aW9uIGRvVGljaygpIHtcbiAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLklETEUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUcmFja0lkID0gdGhpcy5jdXJyZW50VHJhY2tJZCxcbiAgICAgICAgICBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICAgICAgdmFyIHRyYWNrID0gbGV2ZWxzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbHNbY3VycmVudFRyYWNrSWRdO1xuICAgICAgICBpZiAoIXRyYWNrIHx8ICFsZXZlbHMubGVuZ3RoIHx8ICF0cmFjay5kZXRhaWxzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGJ1ZmZlcmVkSW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm8odGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXSB8fCBbXSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICAgICAgdmFyIHRhcmdldEJ1ZmZlclRpbWUgPSBidWZmZXJlZEluZm8uZW5kLFxuICAgICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlcmVkSW5mby5sZW47XG4gICAgICAgIHZhciBtYWluQnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgICAgdmFyIHRyYWNrRGV0YWlscyA9IHRyYWNrLmRldGFpbHM7XG4gICAgICAgIHZhciBtYXhCdWZMZW4gPSB0aGlzLmdldE1heEJ1ZmZlckxlbmd0aChtYWluQnVmZmVySW5mbyA9PSBudWxsID8gdm9pZCAwIDogbWFpbkJ1ZmZlckluZm8ubGVuKSArIHRyYWNrRGV0YWlscy5sZXZlbFRhcmdldER1cmF0aW9uO1xuICAgICAgICBpZiAoYnVmZmVyTGVuID4gbWF4QnVmTGVuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcmFnbWVudHMgPSB0cmFja0RldGFpbHMuZnJhZ21lbnRzO1xuICAgICAgICB2YXIgZnJhZ0xlbiA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBlbmQgPSB0cmFja0RldGFpbHMuZWRnZTtcbiAgICAgICAgdmFyIGZvdW5kRnJhZyA9IG51bGw7XG4gICAgICAgIHZhciBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICAgICAgaWYgKHRhcmdldEJ1ZmZlclRpbWUgPCBlbmQpIHtcbiAgICAgICAgICB2YXIgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgICAgICAgdmFyIGxvb2t1cFRvbGVyYW5jZSA9IHRhcmdldEJ1ZmZlclRpbWUgPiBlbmQgLSB0b2xlcmFuY2UgPyAwIDogdG9sZXJhbmNlO1xuICAgICAgICAgIGZvdW5kRnJhZyA9IGZpbmRGcmFnbWVudEJ5UFRTKGZyYWdQcmV2aW91cywgZnJhZ21lbnRzLCBNYXRoLm1heChmcmFnbWVudHNbMF0uc3RhcnQsIHRhcmdldEJ1ZmZlclRpbWUpLCBsb29rdXBUb2xlcmFuY2UpO1xuICAgICAgICAgIGlmICghZm91bmRGcmFnICYmIGZyYWdQcmV2aW91cyAmJiBmcmFnUHJldmlvdXMuc3RhcnQgPCBmcmFnbWVudHNbMF0uc3RhcnQpIHtcbiAgICAgICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm91bmRGcmFnID0gZnJhZ21lbnRzW2ZyYWdMZW4gLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvdW5kRnJhZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZEZyYWcgPSB0aGlzLm1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQoZm91bmRGcmFnKTtcbiAgICAgICAgaWYgKGZvdW5kRnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICAgIC8vIExvYWQgZWFybGllciBmcmFnbWVudCBpbiBzYW1lIGRpc2NvbnRpbnVpdHkgdG8gbWFrZSB1cCBmb3IgbWlzYWxpZ25lZCBwbGF5bGlzdHMgYW5kIGN1ZXMgdGhhdCBleHRlbmQgYmV5b25kIGVuZCBvZiBzZWdtZW50XG4gICAgICAgICAgdmFyIGN1clNOSWR4ID0gZm91bmRGcmFnLnNuIC0gdHJhY2tEZXRhaWxzLnN0YXJ0U047XG4gICAgICAgICAgdmFyIHByZXZGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4IC0gMV07XG4gICAgICAgICAgaWYgKHByZXZGcmFnICYmIHByZXZGcmFnLmNjID09PSBmb3VuZEZyYWcuY2MgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUocHJldkZyYWcpID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQpIHtcbiAgICAgICAgICAgIGZvdW5kRnJhZyA9IHByZXZGcmFnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZm91bmRGcmFnKSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEKSB7XG4gICAgICAgICAgLy8gb25seSBsb2FkIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWRcbiAgICAgICAgICB0aGlzLmxvYWRGcmFnbWVudChmb3VuZEZyYWcsIHRyYWNrLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdldE1heEJ1ZmZlckxlbmd0aCA9IGZ1bmN0aW9uIGdldE1heEJ1ZmZlckxlbmd0aChtYWluQnVmZmVyTGVuZ3RoKSB7XG4gICAgICB2YXIgbWF4Q29uZmlnQnVmZmVyID0gX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5nZXRNYXhCdWZmZXJMZW5ndGguY2FsbCh0aGlzKTtcbiAgICAgIGlmICghbWFpbkJ1ZmZlckxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbWF4Q29uZmlnQnVmZmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgubWF4KG1heENvbmZpZ0J1ZmZlciwgbWFpbkJ1ZmZlckxlbmd0aCk7XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZEZyYWdtZW50ID0gZnVuY3Rpb24gbG9hZEZyYWdtZW50KGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuX2xvYWRJbml0U2VnbWVudChmcmFnLCBsZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUubG9hZEZyYWdtZW50LmNhbGwodGhpcywgZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgX2NyZWF0ZUNsYXNzKFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciwgW3tcbiAgICAgIGtleTogXCJtZWRpYUJ1ZmZlclRpbWVSYW5nZXNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcmFibGVJbnN0YW5jZSh0aGlzLnRyYWNrc0J1ZmZlcmVkW3RoaXMuY3VycmVudFRyYWNrSWRdIHx8IFtdKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjtcbiAgfShCYXNlU3RyZWFtQ29udHJvbGxlcik7XG4gIHZhciBCdWZmZXJhYmxlSW5zdGFuY2UgPSBmdW5jdGlvbiBCdWZmZXJhYmxlSW5zdGFuY2UodGltZXJhbmdlcykge1xuICAgIHRoaXMuYnVmZmVyZWQgPSB2b2lkIDA7XG4gICAgdmFyIGdldFJhbmdlID0gZnVuY3Rpb24gZ2V0UmFuZ2UobmFtZSwgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgaW5kZXggPSBpbmRleCA+Pj4gMDtcbiAgICAgIGlmIChpbmRleCA+IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIkZhaWxlZCB0byBleGVjdXRlICdcIiArIG5hbWUgKyBcIicgb24gJ1RpbWVSYW5nZXMnOiBUaGUgaW5kZXggcHJvdmlkZWQgKFwiICsgaW5kZXggKyBcIikgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIGJvdW5kIChcIiArIGxlbmd0aCArIFwiKVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aW1lcmFuZ2VzW2luZGV4XVtuYW1lXTtcbiAgICB9O1xuICAgIHRoaXMuYnVmZmVyZWQgPSB7XG4gICAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGltZXJhbmdlcy5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgZW5kOiBmdW5jdGlvbiBlbmQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdldFJhbmdlKCdlbmQnLCBpbmRleCwgdGltZXJhbmdlcy5sZW5ndGgpO1xuICAgICAgfSxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChpbmRleCkge1xuICAgICAgICByZXR1cm4gZ2V0UmFuZ2UoJ3N0YXJ0JywgaW5kZXgsIHRpbWVyYW5nZXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VQbGF5bGlzdENvbnRyb2xsKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoU3VidGl0bGVUcmFja0NvbnRyb2xsZXIsIF9CYXNlUGxheWxpc3RDb250cm9sbCk7XG4gICAgZnVuY3Rpb24gU3VidGl0bGVUcmFja0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgICB2YXIgX3RoaXM7XG4gICAgICBfdGhpcyA9IF9CYXNlUGxheWxpc3RDb250cm9sbC5jYWxsKHRoaXMsIGhscywgJ1tzdWJ0aXRsZS10cmFjay1jb250cm9sbGVyXScpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICBfdGhpcy50cmFja3MgPSBbXTtcbiAgICAgIF90aGlzLmdyb3VwSWRzID0gbnVsbDtcbiAgICAgIF90aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICAgIF90aGlzLnRyYWNrSWQgPSAtMTtcbiAgICAgIF90aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgICBfdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICAgICAgX3RoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gLTE7XG4gICAgICBfdGhpcy5hc3luY1BvbGxUcmFja0NoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnBvbGxUcmFja0NoYW5nZSgwKTtcbiAgICAgIH07XG4gICAgICBfdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nID0gZmFsc2U7XG4gICAgICBfdGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCA9IC0xO1xuICAgICAgX3RoaXMuX3N1YnRpdGxlRGlzcGxheSA9IHRydWU7XG4gICAgICBfdGhpcy5vblRleHRUcmFja3NDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV90aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgICAgICBzZWxmLmNsZWFySW50ZXJ2YWwoX3RoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1lZGlhIGlzIHVuZGVmaW5lZCB3aGVuIHN3aXRjaGluZyBzdHJlYW1zIHZpYSBsb2FkU291cmNlKClcbiAgICAgICAgaWYgKCFfdGhpcy5tZWRpYSB8fCAhX3RoaXMuaGxzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHRUcmFjayA9IG51bGw7XG4gICAgICAgIHZhciB0cmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyhfdGhpcy5tZWRpYS50ZXh0VHJhY2tzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodHJhY2tzW2ldLm1vZGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgYnJlYWsgaW4gY2FzZSB0aGVyZSBpcyBhIGZvbGxvd2luZyB0cmFjayB3aXRoIHNob3dpbmcuXG4gICAgICAgICAgICB0ZXh0VHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgICAgfSBlbHNlIGlmICh0cmFja3NbaV0ubW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgICAgICB0ZXh0VHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIGludGVybmFsIHRyYWNrIGluZGV4IGZvciBUZXh0VHJhY2tcbiAgICAgICAgdmFyIHRyYWNrSWQgPSBfdGhpcy5maW5kVHJhY2tGb3JUZXh0VHJhY2sodGV4dFRyYWNrKTtcbiAgICAgICAgaWYgKF90aGlzLnN1YnRpdGxlVHJhY2sgIT09IHRyYWNrSWQpIHtcbiAgICAgICAgICBfdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKHRyYWNrSWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX3RoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMudHJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICAgIHRoaXMub25UZXh0VHJhY2tzQ2hhbmdlZCA9IHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UgPSBudWxsO1xuICAgICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gTGlzdGVuIGZvciBzdWJ0aXRsZSB0cmFjayBjaGFuZ2UsIHRoZW4gZXh0cmFjdCB0aGUgY3VycmVudCB0cmFjayBJRC5cbiAgICA7XG4gICAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID4gLTEpIHtcbiAgICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrID0gdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2s7XG4gICAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gLTE7XG4gICAgICB9XG4gICAgICB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSAhKHRoaXMubWVkaWEudGV4dFRyYWNrcyAmJiAnb25jaGFuZ2UnIGluIHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgICBpZiAodGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nKSB7XG4gICAgICAgIHRoaXMucG9sbFRyYWNrQ2hhbmdlKDUwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1lZGlhLnRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5hc3luY1BvbGxUcmFja0NoYW5nZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucG9sbFRyYWNrQ2hhbmdlID0gZnVuY3Rpb24gcG9sbFRyYWNrQ2hhbmdlKHRpbWVvdXQpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKTtcbiAgICAgIHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwgPSBzZWxmLnNldEludGVydmFsKHRoaXMub25UZXh0VHJhY2tzQ2hhbmdlZCwgdGltZW91dCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuc3VidGl0bGVQb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgaWYgKCF0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgICAgdGhpcy5tZWRpYS50ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHJhY2tJZCA+IC0xKSB7XG4gICAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gdGhpcy50cmFja0lkO1xuICAgICAgfVxuICAgICAgdmFyIHRleHRUcmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuICAgICAgLy8gQ2xlYXIgbG9hZGVkIGN1ZXMgb24gbWVkaWEgZGV0YWNobWVudCBmcm9tIHRyYWNrc1xuICAgICAgdGV4dFRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICBjbGVhckN1cnJlbnRDdWVzKHRyYWNrKTtcbiAgICAgIH0pO1xuICAgICAgLy8gRGlzYWJsZSBhbGwgc3VidGl0bGUgdHJhY2tzIGJlZm9yZSBkZXRhY2htZW50IHNvIHdoZW4gcmVhdHRhY2hlZCBvbmx5IHRyYWNrcyBpbiB0aGF0IGNvbnRlbnQgYXJlIGVuYWJsZWQuXG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSAtMTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgICAgdGhpcy5ncm91cElkcyA9IG51bGw7XG4gICAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZpcmVkIHdoZW5ldmVyIGEgbmV3IG1hbmlmZXN0IGlzIGxvYWRlZC5cbiAgICA7XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RQYXJzZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3M7XG4gICAgfTtcbiAgICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrTG9hZGVkID0gZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgaWQgPSBkYXRhLmlkLFxuICAgICAgICBncm91cElkID0gZGF0YS5ncm91cElkLFxuICAgICAgICBkZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgdmFyIHRyYWNrSW5BY3RpdmVHcm91cCA9IHRoaXMudHJhY2tzSW5Hcm91cFtpZF07XG4gICAgICBpZiAoIXRyYWNrSW5BY3RpdmVHcm91cCB8fCB0cmFja0luQWN0aXZlR3JvdXAuZ3JvdXBJZCAhPT0gZ3JvdXBJZCkge1xuICAgICAgICB0aGlzLndhcm4oXCJTdWJ0aXRsZSB0cmFjayB3aXRoIGlkOlwiICsgaWQgKyBcIiBhbmQgZ3JvdXA6XCIgKyBncm91cElkICsgXCIgbm90IGZvdW5kIGluIGFjdGl2ZSBncm91cCBcIiArICh0cmFja0luQWN0aXZlR3JvdXAgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrSW5BY3RpdmVHcm91cC5ncm91cElkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJEZXRhaWxzID0gdHJhY2tJbkFjdGl2ZUdyb3VwLmRldGFpbHM7XG4gICAgICB0cmFja0luQWN0aXZlR3JvdXAuZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgIHRoaXMubG9nKFwiU3VidGl0bGUgdHJhY2sgXCIgKyBpZCArIFwiIFxcXCJcIiArIHRyYWNrSW5BY3RpdmVHcm91cC5uYW1lICsgXCJcXFwiIGxhbmc6XCIgKyB0cmFja0luQWN0aXZlR3JvdXAubGFuZyArIFwiIGdyb3VwOlwiICsgZ3JvdXBJZCArIFwiIGxvYWRlZCBbXCIgKyBkZXRhaWxzLnN0YXJ0U04gKyBcIi1cIiArIGRldGFpbHMuZW5kU04gKyBcIl1cIik7XG4gICAgICBpZiAoaWQgPT09IHRoaXMudHJhY2tJZCkge1xuICAgICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGlkLCBkYXRhLCBjdXJEZXRhaWxzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkxldmVsTG9hZGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEubGV2ZWwpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTGV2ZWxTd2l0Y2hpbmcgPSBmdW5jdGlvbiBvbkxldmVsU3dpdGNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEubGV2ZWwpO1xuICAgIH07XG4gICAgX3Byb3RvLnN3aXRjaExldmVsID0gZnVuY3Rpb24gc3dpdGNoTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgICAgdmFyIGxldmVsSW5mbyA9IHRoaXMuaGxzLmxldmVsc1tsZXZlbEluZGV4XTtcbiAgICAgIGlmICghbGV2ZWxJbmZvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdWJ0aXRsZUdyb3VwcyA9IGxldmVsSW5mby5zdWJ0aXRsZUdyb3VwcyB8fCBudWxsO1xuICAgICAgdmFyIGN1cnJlbnRHcm91cHMgPSB0aGlzLmdyb3VwSWRzO1xuICAgICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgICAgaWYgKCFzdWJ0aXRsZUdyb3VwcyB8fCAoY3VycmVudEdyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudEdyb3Vwcy5sZW5ndGgpICE9PSAoc3VidGl0bGVHcm91cHMgPT0gbnVsbCA/IHZvaWQgMCA6IHN1YnRpdGxlR3JvdXBzLmxlbmd0aCkgfHwgc3VidGl0bGVHcm91cHMgIT0gbnVsbCAmJiBzdWJ0aXRsZUdyb3Vwcy5zb21lKGZ1bmN0aW9uIChncm91cElkKSB7XG4gICAgICAgIHJldHVybiAoY3VycmVudEdyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudEdyb3Vwcy5pbmRleE9mKGdyb3VwSWQpKSA9PT0gLTE7XG4gICAgICB9KSkge1xuICAgICAgICB0aGlzLmdyb3VwSWRzID0gc3VidGl0bGVHcm91cHM7XG4gICAgICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgICAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgICAgIHZhciBzdWJ0aXRsZVRyYWNrcyA9IHRoaXMudHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICByZXR1cm4gIXN1YnRpdGxlR3JvdXBzIHx8IHN1YnRpdGxlR3JvdXBzLmluZGV4T2YodHJhY2suZ3JvdXBJZCkgIT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1YnRpdGxlVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIERpc2FibGUgc2VsZWN0RGVmYXVsdFRyYWNrIGlmIHRoZXJlIGFyZSBubyBkZWZhdWx0IHRyYWNrc1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdERlZmF1bHRUcmFjayAmJiAhc3VidGl0bGVUcmFja3Muc29tZShmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjay5kZWZhdWx0O1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB0cmFjay5pZCBzaG91bGQgbWF0Y2ggaGxzLmF1ZGlvVHJhY2tzIGluZGV4XG4gICAgICAgICAgc3VidGl0bGVUcmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2ssIGkpIHtcbiAgICAgICAgICAgIHRyYWNrLmlkID0gaTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghY3VycmVudFRyYWNrICYmICF0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gRG8gbm90IGRpc3BhdGNoIFNVQlRJVExFX1RSQUNLU19VUERBVEVEIHdoZW4gdGhlcmUgd2VyZSBhbmQgYXJlIG5vIHRyYWNrc1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBzdWJ0aXRsZVRyYWNrcztcblxuICAgICAgICAvLyBGaW5kIHByZWZlcnJlZCB0cmFja1xuICAgICAgICB2YXIgc3VidGl0bGVQcmVmZXJlbmNlID0gdGhpcy5obHMuY29uZmlnLnN1YnRpdGxlUHJlZmVyZW5jZTtcbiAgICAgICAgaWYgKCFjdXJyZW50VHJhY2sgJiYgc3VidGl0bGVQcmVmZXJlbmNlKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgZ3JvdXBJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihzdWJ0aXRsZVByZWZlcmVuY2UsIHN1YnRpdGxlVHJhY2tzKTtcbiAgICAgICAgICBpZiAoZ3JvdXBJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBjdXJyZW50VHJhY2sgPSBzdWJ0aXRsZVRyYWNrc1tncm91cEluZGV4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFsbEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKHN1YnRpdGxlUHJlZmVyZW5jZSwgdGhpcy50cmFja3MpO1xuICAgICAgICAgICAgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NbYWxsSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdCBpbml0aWFsIHRyYWNrXG4gICAgICAgIHZhciB0cmFja0lkID0gdGhpcy5maW5kVHJhY2tJZChjdXJyZW50VHJhY2spO1xuICAgICAgICBpZiAodHJhY2tJZCA9PT0gLTEgJiYgY3VycmVudFRyYWNrKSB7XG4gICAgICAgICAgdHJhY2tJZCA9IHRoaXMuZmluZFRyYWNrSWQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaXNwYXRjaCBldmVudHMgYW5kIGxvYWQgdHJhY2sgaWYgbmVlZGVkXG4gICAgICAgIHZhciBzdWJ0aXRsZVRyYWNrc1VwZGF0ZWQgPSB7XG4gICAgICAgICAgc3VidGl0bGVUcmFja3M6IHN1YnRpdGxlVHJhY2tzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nKFwiVXBkYXRpbmcgc3VidGl0bGUgdHJhY2tzLCBcIiArIHN1YnRpdGxlVHJhY2tzLmxlbmd0aCArIFwiIHRyYWNrKHMpIGZvdW5kIGluIFxcXCJcIiArIChzdWJ0aXRsZUdyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogc3VidGl0bGVHcm91cHMuam9pbignLCcpKSArIFwiXFxcIiBncm91cC1pZFwiKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHN1YnRpdGxlVHJhY2tzVXBkYXRlZCk7XG4gICAgICAgIGlmICh0cmFja0lkICE9PSAtMSAmJiB0aGlzLnRyYWNrSWQgPT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKHRyYWNrSWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2hvdWxkUmVsb2FkUGxheWxpc3QoY3VycmVudFRyYWNrKSkge1xuICAgICAgICAvLyBSZXRyeSBwbGF5bGlzdCBsb2FkaW5nIGlmIG5vIHBsYXlsaXN0IGlzIG9yIGhhcyBiZWVuIGxvYWRlZCB5ZXRcbiAgICAgICAgdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKHRoaXMudHJhY2tJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZmluZFRyYWNrSWQgPSBmdW5jdGlvbiBmaW5kVHJhY2tJZChjdXJyZW50VHJhY2spIHtcbiAgICAgIHZhciB0cmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgICB2YXIgc2VsZWN0RGVmYXVsdCA9IHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgICBpZiAoc2VsZWN0RGVmYXVsdCAmJiAhdHJhY2suZGVmYXVsdCB8fCAhc2VsZWN0RGVmYXVsdCAmJiAhY3VycmVudFRyYWNrKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJyZW50VHJhY2sgfHwgbWF0Y2hlc09wdGlvbih0cmFjaywgY3VycmVudFRyYWNrKSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0cmFja3MubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF90cmFjayA9IHRyYWNrc1tfaV07XG4gICAgICAgICAgaWYgKG1lZGlhQXR0cmlidXRlc0lkZW50aWNhbChjdXJyZW50VHJhY2suYXR0cnMsIF90cmFjay5hdHRycywgWydMQU5HVUFHRScsICdBU1NPQy1MQU5HVUFHRScsICdDSEFSQUNURVJJU1RJQ1MnXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBfaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdHJhY2tzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgX3RyYWNrMiA9IHRyYWNrc1tfaTJdO1xuICAgICAgICAgIGlmIChtZWRpYUF0dHJpYnV0ZXNJZGVudGljYWwoY3VycmVudFRyYWNrLmF0dHJzLCBfdHJhY2syLmF0dHJzLCBbJ0xBTkdVQUdFJ10pKSB7XG4gICAgICAgICAgICByZXR1cm4gX2kyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgX3Byb3RvLmZpbmRUcmFja0ZvclRleHRUcmFjayA9IGZ1bmN0aW9uIGZpbmRUcmFja0ZvclRleHRUcmFjayh0ZXh0VHJhY2spIHtcbiAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgdmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgICAgaWYgKHN1YnRpdGxlVHJhY2tNYXRjaGVzVGV4dFRyYWNrKHRyYWNrLCB0ZXh0VHJhY2spKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgICAgaWYgKGRhdGEuZmF0YWwgfHwgIWRhdGEuY29udGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5jb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiYgZGF0YS5jb250ZXh0LmlkID09PSB0aGlzLnRyYWNrSWQgJiYgKCF0aGlzLmdyb3VwSWRzIHx8IHRoaXMuZ3JvdXBJZHMuaW5kZXhPZihkYXRhLmNvbnRleHQuZ3JvdXBJZCkgIT09IC0xKSkge1xuICAgICAgICB0aGlzLmNoZWNrUmV0cnkoZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc2V0U3VidGl0bGVPcHRpb24gPSBmdW5jdGlvbiBzZXRTdWJ0aXRsZU9wdGlvbihzdWJ0aXRsZU9wdGlvbikge1xuICAgICAgdGhpcy5obHMuY29uZmlnLnN1YnRpdGxlUHJlZmVyZW5jZSA9IHN1YnRpdGxlT3B0aW9uO1xuICAgICAgaWYgKHN1YnRpdGxlT3B0aW9uKSB7XG4gICAgICAgIHZhciBhbGxTdWJ0aXRsZVRyYWNrcyA9IHRoaXMuYWxsU3VidGl0bGVUcmFja3M7XG4gICAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICAgIGlmIChhbGxTdWJ0aXRsZVRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBGaXJzdCBzZWUgaWYgY3VycmVudCBvcHRpb24gbWF0Y2hlcyAobm8gc3dpdGNoIG9wKVxuICAgICAgICAgIHZhciBjdXJyZW50VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICAgICAgICBpZiAoY3VycmVudFRyYWNrICYmIG1hdGNoZXNPcHRpb24oc3VidGl0bGVPcHRpb24sIGN1cnJlbnRUcmFjaykpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50VHJhY2s7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEZpbmQgb3B0aW9uIGluIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgICB2YXIgZ3JvdXBJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihzdWJ0aXRsZU9wdGlvbiwgdGhpcy50cmFja3NJbkdyb3VwKTtcbiAgICAgICAgICBpZiAoZ3JvdXBJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc0luR3JvdXBbZ3JvdXBJbmRleF07XG4gICAgICAgICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2soZ3JvdXBJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgbm90IHRoZSBpbml0aWFsIHNlbGVjdGlvbiByZXR1cm4gbnVsbFxuICAgICAgICAgICAgLy8gb3B0aW9uIHNob3VsZCBoYXZlIG1hdGNoZWQgb25lIGluIGFjdGl2ZSBncm91cFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIG9wdGlvbiBpbiBhbGwgdHJhY2tzIGZvciBpbml0aWFsIHNlbGVjdGlvblxuICAgICAgICAgICAgdmFyIGFsbEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKHN1YnRpdGxlT3B0aW9uLCBhbGxTdWJ0aXRsZVRyYWNrcyk7XG4gICAgICAgICAgICBpZiAoYWxsSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICByZXR1cm4gYWxsU3VidGl0bGVUcmFja3NbYWxsSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUubG9hZFBsYXlsaXN0LmNhbGwodGhpcyk7XG4gICAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgICBpZiAodGhpcy5zaG91bGRMb2FkUGxheWxpc3QoY3VycmVudFRyYWNrKSAmJiBjdXJyZW50VHJhY2spIHtcbiAgICAgICAgdmFyIGlkID0gY3VycmVudFRyYWNrLmlkO1xuICAgICAgICB2YXIgZ3JvdXBJZCA9IGN1cnJlbnRUcmFjay5ncm91cElkO1xuICAgICAgICB2YXIgdXJsID0gY3VycmVudFRyYWNrLnVybDtcbiAgICAgICAgaWYgKGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdXJsID0gaGxzVXJsUGFyYW1ldGVycy5hZGREaXJlY3RpdmVzKHVybCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMud2FybihcIkNvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCB3aXRoIEhMUyBEZWxpdmVyeSBEaXJlY3RpdmVzOiBcIiArIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2coXCJMb2FkaW5nIHN1YnRpdGxlIHBsYXlsaXN0IGZvciBpZCBcIiArIGlkKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BRElORywge1xuICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBvbGQgc3VidGl0bGVUcmFjayBhbmQgc2V0cyBjdXJyZW50IG1vZGUgb24gdGhlIG5leHQgc3VidGl0bGVUcmFjay5cbiAgICAgKiBUaGlzIG9wZXJhdGVzIG9uIHRoZSBET00gdGV4dFRyYWNrcy5cbiAgICAgKiBBIHZhbHVlIG9mIC0xIHdpbGwgZGlzYWJsZSBhbGwgc3VidGl0bGUgdHJhY2tzLlxuICAgICAqLztcbiAgICBfcHJvdG8udG9nZ2xlVHJhY2tNb2RlcyA9IGZ1bmN0aW9uIHRvZ2dsZVRyYWNrTW9kZXMoKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgaWYgKCFtZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdGV4dFRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKG1lZGlhLnRleHRUcmFja3MpO1xuICAgICAgdmFyIGN1cnJlbnRUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgICAgdmFyIG5leHRUcmFjaztcbiAgICAgIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgICAgbmV4dFRyYWNrID0gdGV4dFRyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRleHRUcmFjaykge1xuICAgICAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrTWF0Y2hlc1RleHRUcmFjayhjdXJyZW50VHJhY2ssIHRleHRUcmFjayk7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICBpZiAoIW5leHRUcmFjaykge1xuICAgICAgICAgIHRoaXMud2FybihcIlVuYWJsZSB0byBmaW5kIHN1YnRpdGxlIFRleHRUcmFjayB3aXRoIG5hbWUgXFxcIlwiICsgY3VycmVudFRyYWNrLm5hbWUgKyBcIlxcXCIgYW5kIGxhbmd1YWdlIFxcXCJcIiArIGN1cnJlbnRUcmFjay5sYW5nICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBbXS5zbGljZS5jYWxsKHRleHRUcmFja3MpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIGlmICh0cmFjay5tb2RlICE9PSAnZGlzYWJsZWQnICYmIHRyYWNrICE9PSBuZXh0VHJhY2spIHtcbiAgICAgICAgICB0cmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAobmV4dFRyYWNrKSB7XG4gICAgICAgIHZhciBtb2RlID0gdGhpcy5zdWJ0aXRsZURpc3BsYXkgPyAnc2hvd2luZycgOiAnaGlkZGVuJztcbiAgICAgICAgaWYgKG5leHRUcmFjay5tb2RlICE9PSBtb2RlKSB7XG4gICAgICAgICAgbmV4dFRyYWNrLm1vZGUgPSBtb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yIHZhbGlkYXRpbmcgdGhlIHN1YnRpdGxlIGluZGV4IGFuZCBwZXJpb2RpY2FsbHkgcmVsb2FkaW5nIGlmIGxpdmUuXG4gICAgICogRGlzcGF0Y2hlcyB0aGUgU1VCVElUTEVfVFJBQ0tfU1dJVENIIGV2ZW50LCB3aGljaCBpbnN0cnVjdHMgdGhlIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyIHRvIGxvYWQgdGhlIHNlbGVjdGVkIHRyYWNrLlxuICAgICAqLztcbiAgICBfcHJvdG8uc2V0U3VidGl0bGVUcmFjayA9IGZ1bmN0aW9uIHNldFN1YnRpdGxlVHJhY2sobmV3SWQpIHtcbiAgICAgIHZhciB0cmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG5cbiAgICAgIC8vIHNldHRpbmcgdGhpcy5zdWJ0aXRsZVRyYWNrIHdpbGwgdHJpZ2dlciBpbnRlcm5hbCBsb2dpY1xuICAgICAgLy8gaWYgbWVkaWEgaGFzIG5vdCBiZWVuIGF0dGFjaGVkIHlldCwgaXQgd2lsbCBmYWlsXG4gICAgICAvLyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBkZWZhdWx0IHRyYWNrIGlkXG4gICAgICAvLyBhbmQgd2UnbGwgc2V0IHN1YnRpdGxlVHJhY2sgd2hlbiBvbk1lZGlhQXR0YWNoZWQgaXMgdHJpZ2dlcmVkXG4gICAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSBuZXdJZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBleGl0IGlmIHRyYWNrIGlkIGFzIGFscmVhZHkgc2V0IG9yIGludmFsaWRcbiAgICAgIGlmIChuZXdJZCA8IC0xIHx8IG5ld0lkID49IHRyYWNrcy5sZW5ndGggfHwgIWlzRmluaXRlTnVtYmVyKG5ld0lkKSkge1xuICAgICAgICB0aGlzLndhcm4oXCJJbnZhbGlkIHN1YnRpdGxlIHRyYWNrIGlkOiBcIiArIG5ld0lkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciBsYXN0VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tuZXdJZF0gfHwgbnVsbDtcbiAgICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgICAgdGhpcy5jdXJyZW50VHJhY2sgPSB0cmFjaztcbiAgICAgIHRoaXMudG9nZ2xlVHJhY2tNb2RlcygpO1xuICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICAvLyBzd2l0Y2ggdG8gLTFcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB7XG4gICAgICAgICAgaWQ6IG5ld0lkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdHJhY2tMb2FkZWQgPSAhIXRyYWNrLmRldGFpbHMgJiYgIXRyYWNrLmRldGFpbHMubGl2ZTtcbiAgICAgIGlmIChuZXdJZCA9PT0gdGhpcy50cmFja0lkICYmIHRyYWNrID09PSBsYXN0VHJhY2sgJiYgdHJhY2tMb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2coXCJTd2l0Y2hpbmcgdG8gc3VidGl0bGUtdHJhY2sgXCIgKyBuZXdJZCArICh0cmFjayA/IFwiIFxcXCJcIiArIHRyYWNrLm5hbWUgKyBcIlxcXCIgbGFuZzpcIiArIHRyYWNrLmxhbmcgKyBcIiBncm91cDpcIiArIHRyYWNrLmdyb3VwSWQgOiAnJykpO1xuICAgICAgdmFyIGlkID0gdHJhY2suaWQsXG4gICAgICAgIF90cmFjayRncm91cElkID0gdHJhY2suZ3JvdXBJZCxcbiAgICAgICAgZ3JvdXBJZCA9IF90cmFjayRncm91cElkID09PSB2b2lkIDAgPyAnJyA6IF90cmFjayRncm91cElkLFxuICAgICAgICBuYW1lID0gdHJhY2submFtZSxcbiAgICAgICAgdHlwZSA9IHRyYWNrLnR5cGUsXG4gICAgICAgIHVybCA9IHRyYWNrLnVybDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHVybDogdXJsXG4gICAgICB9KTtcbiAgICAgIHZhciBobHNVcmxQYXJhbWV0ZXJzID0gdGhpcy5zd2l0Y2hQYXJhbXModHJhY2sudXJsLCBsYXN0VHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RUcmFjay5kZXRhaWxzLCB0cmFjay5kZXRhaWxzKTtcbiAgICAgIHRoaXMubG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpO1xuICAgIH07XG4gICAgX2NyZWF0ZUNsYXNzKFN1YnRpdGxlVHJhY2tDb250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcInN1YnRpdGxlRGlzcGxheVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJ0aXRsZURpc3BsYXk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc3VidGl0bGVEaXNwbGF5ID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrSWQgPiAtMSkge1xuICAgICAgICAgIHRoaXMudG9nZ2xlVHJhY2tNb2RlcygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFsbFN1YnRpdGxlVHJhY2tzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICAgICAgfVxuXG4gICAgICAvKiogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0ICoqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdWJ0aXRsZVRyYWNrc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgICB9XG5cbiAgICAgIC8qKiBnZXQvc2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoYmFzZWQgb24gaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpICoqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdWJ0aXRsZVRyYWNrXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tJZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdJZCkge1xuICAgICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2sobmV3SWQpO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gU3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gIH0oQmFzZVBsYXlsaXN0Q29udHJvbGxlcik7XG5cbiAgdmFyIEJ1ZmZlck9wZXJhdGlvblF1ZXVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCdWZmZXJPcGVyYXRpb25RdWV1ZShzb3VyY2VCdWZmZXJSZWZlcmVuY2UpIHtcbiAgICAgIHRoaXMuYnVmZmVycyA9IHZvaWQgMDtcbiAgICAgIHRoaXMucXVldWVzID0ge1xuICAgICAgICB2aWRlbzogW10sXG4gICAgICAgIGF1ZGlvOiBbXSxcbiAgICAgICAgYXVkaW92aWRlbzogW11cbiAgICAgIH07XG4gICAgICB0aGlzLmJ1ZmZlcnMgPSBzb3VyY2VCdWZmZXJSZWZlcmVuY2U7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBCdWZmZXJPcGVyYXRpb25RdWV1ZS5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChvcGVyYXRpb24sIHR5cGUsIHBlbmRpbmcpIHtcbiAgICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgICAgcXVldWUucHVzaChvcGVyYXRpb24pO1xuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhcGVuZGluZykge1xuICAgICAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmluc2VydEFib3J0ID0gZnVuY3Rpb24gaW5zZXJ0QWJvcnQob3BlcmF0aW9uLCB0eXBlKSB7XG4gICAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlc1t0eXBlXTtcbiAgICAgIHF1ZXVlLnVuc2hpZnQob3BlcmF0aW9uKTtcbiAgICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgfTtcbiAgICBfcHJvdG8uYXBwZW5kQmxvY2tlciA9IGZ1bmN0aW9uIGFwcGVuZEJsb2NrZXIodHlwZSkge1xuICAgICAgdmFyIGV4ZWN1dGU7XG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIGV4ZWN1dGUgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3BlcmF0aW9uID0ge1xuICAgICAgICBleGVjdXRlOiBleGVjdXRlLFxuICAgICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KCkge30sXG4gICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7fSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcigpIHt9XG4gICAgICB9O1xuICAgICAgdGhpcy5hcHBlbmQob3BlcmF0aW9uLCB0eXBlKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gICAgX3Byb3RvLmV4ZWN1dGVOZXh0ID0gZnVuY3Rpb24gZXhlY3V0ZU5leHQodHlwZSkge1xuICAgICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZXNbdHlwZV07XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBvcGVyYXRpb24gPSBxdWV1ZVswXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBPcGVyYXRpb25zIGFyZSBleHBlY3RlZCB0byByZXN1bHQgaW4gYW4gJ3VwZGF0ZWVuZCcgZXZlbnQgYmVpbmcgZmlyZWQuIElmIG5vdCwgdGhlIHF1ZXVlIHdpbGwgbG9jay4gT3BlcmF0aW9uc1xuICAgICAgICAgIC8vIHdoaWNoIGRvIG5vdCBlbmQgd2l0aCB0aGlzIGV2ZW50IG11c3QgY2FsbCBfb25TQlVwZGF0ZUVuZCBtYW51YWxseVxuICAgICAgICAgIG9wZXJhdGlvbi5leGVjdXRlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXCJbYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZV06IEV4Y2VwdGlvbiBleGVjdXRpbmcgXFxcIlwiICsgdHlwZSArIFwiXFxcIiBTb3VyY2VCdWZmZXIgb3BlcmF0aW9uOiBcIiArIGVycm9yKTtcbiAgICAgICAgICBvcGVyYXRpb24ub25FcnJvcihlcnJvcik7XG5cbiAgICAgICAgICAvLyBPbmx5IHNoaWZ0IHRoZSBjdXJyZW50IG9wZXJhdGlvbiBvZmYsIG90aGVyd2lzZSB0aGUgdXBkYXRlZW5kIGhhbmRsZXIgd2lsbCBkbyB0aGlzIGZvciB1c1xuICAgICAgICAgIHZhciBzYiA9IHRoaXMuYnVmZmVyc1t0eXBlXTtcbiAgICAgICAgICBpZiAoIShzYiAhPSBudWxsICYmIHNiLnVwZGF0aW5nKSkge1xuICAgICAgICAgICAgdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnNoaWZ0QW5kRXhlY3V0ZU5leHQgPSBmdW5jdGlvbiBzaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpIHtcbiAgICAgIHRoaXMucXVldWVzW3R5cGVdLnNoaWZ0KCk7XG4gICAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH07XG4gICAgX3Byb3RvLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50KHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXVlc1t0eXBlXVswXTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJPcGVyYXRpb25RdWV1ZTtcbiAgfSgpO1xuXG4gIHZhciBWSURFT19DT0RFQ19QUk9GSUxFX1JFUExBQ0UgPSAvKGF2Y1sxMjM0XXxodmMxfGhldjF8ZHZoWzFlXXx2cDA5fGF2MDEpKD86XFwuW14uLF0rKSsvO1xuICB2YXIgQnVmZmVyQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnVmZmVyQ29udHJvbGxlcihobHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAvLyBUaGUgbGV2ZWwgZGV0YWlscyB1c2VkIHRvIGRldGVybWluZSBkdXJhdGlvbiwgdGFyZ2V0LWR1cmF0aW9uIGFuZCBsaXZlXG4gICAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgICAgLy8gY2FjaGUgdGhlIHNlbGYgZ2VuZXJhdGVkIG9iamVjdCB1cmwgdG8gZGV0ZWN0IGhpamFjayBvZiB2aWRlbyB0YWdcbiAgICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgICAvLyBBIHF1ZXVlIG9mIGJ1ZmZlciBvcGVyYXRpb25zIHdoaWNoIHJlcXVpcmUgdGhlIFNvdXJjZUJ1ZmZlciB0byBub3QgYmUgdXBkYXRpbmcgdXBvbiBleGVjdXRpb25cbiAgICAgIHRoaXMub3BlcmF0aW9uUXVldWUgPSB2b2lkIDA7XG4gICAgICAvLyBSZWZlcmVuY2VzIHRvIGV2ZW50IGxpc3RlbmVycyBmb3IgZWFjaCBTb3VyY2VCdWZmZXIsIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVmZXJlbmNlZCBmb3IgZXZlbnQgcmVtb3ZhbFxuICAgICAgdGhpcy5saXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICAgIC8vIFRoZSBudW1iZXIgb2YgQlVGRkVSX0NPREVDIGV2ZW50cyByZWNlaXZlZCBiZWZvcmUgYW55IHNvdXJjZUJ1ZmZlcnMgYXJlIGNyZWF0ZWRcbiAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IDA7XG4gICAgICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIEJVRkZFUl9DT0RFQyBldmVudHMgcmVjZWl2ZWRcbiAgICAgIHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSAwO1xuICAgICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGF0dGFjaGVkIG1lZGlhIGVsZW1lbnRcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGFjdGl2ZSBtZWRpYSBzb3VyY2VcbiAgICAgIHRoaXMubWVkaWFTb3VyY2UgPSBudWxsO1xuICAgICAgLy8gTGFzdCBNUDMgYXVkaW8gY2h1bmsgYXBwZW5kZWRcbiAgICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgICAgIHRoaXMuYXBwZW5kU291cmNlID0gdm9pZCAwO1xuICAgICAgLy8gY291bnRlcnNcbiAgICAgIHRoaXMuYXBwZW5kRXJyb3JzID0ge1xuICAgICAgICBhdWRpbzogMCxcbiAgICAgICAgdmlkZW86IDAsXG4gICAgICAgIGF1ZGlvdmlkZW86IDBcbiAgICAgIH07XG4gICAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMubG9nID0gdm9pZCAwO1xuICAgICAgdGhpcy53YXJuID0gdm9pZCAwO1xuICAgICAgdGhpcy5lcnJvciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX29uRW5kU3RyZWFtaW5nID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghX3RoaXMuaGxzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmhscy5wYXVzZUJ1ZmZlcmluZygpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX29uU3RhcnRTdHJlYW1pbmcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFfdGhpcy5obHMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuaGxzLnJlc3VtZUJ1ZmZlcmluZygpO1xuICAgICAgfTtcbiAgICAgIC8vIEtlZXAgYXMgYXJyb3cgZnVuY3Rpb25zIHNvIHRoYXQgd2UgY2FuIGRpcmVjdGx5IHJlZmVyZW5jZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgYXMgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB0aGlzLl9vbk1lZGlhU291cmNlT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1lZGlhID0gX3RoaXMubWVkaWEsXG4gICAgICAgICAgbWVkaWFTb3VyY2UgPSBfdGhpcy5tZWRpYVNvdXJjZTtcbiAgICAgICAgX3RoaXMubG9nKCdNZWRpYSBzb3VyY2Ugb3BlbmVkJyk7XG4gICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCBfdGhpcy5fb25NZWRpYUVtcHRpZWQpO1xuICAgICAgICAgIF90aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XG4gICAgICAgICAgX3RoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB7XG4gICAgICAgICAgICBtZWRpYTogbWVkaWEsXG4gICAgICAgICAgICBtZWRpYVNvdXJjZTogbWVkaWFTb3VyY2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgICAgICAvLyBvbmNlIHJlY2VpdmVkLCBkb24ndCBsaXN0ZW4gYW55bW9yZSB0byBzb3VyY2VvcGVuIGV2ZW50XG4gICAgICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIF90aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5sb2coJ01lZGlhIHNvdXJjZSBjbG9zZWQnKTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmxvZygnTWVkaWEgc291cmNlIGVuZGVkJyk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fb25NZWRpYUVtcHRpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZWRpYVNyYyA9IF90aGlzLm1lZGlhU3JjLFxuICAgICAgICAgIF9vYmplY3RVcmwgPSBfdGhpcy5fb2JqZWN0VXJsO1xuICAgICAgICBpZiAobWVkaWFTcmMgIT09IF9vYmplY3RVcmwpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJNZWRpYSBlbGVtZW50IHNyYyB3YXMgc2V0IHdoaWxlIGF0dGFjaGluZyBNZWRpYVNvdXJjZSAoXCIgKyBfb2JqZWN0VXJsICsgXCIgPiBcIiArIG1lZGlhU3JjICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgICB2YXIgbG9nUHJlZml4ID0gJ1tidWZmZXItY29udHJvbGxlcl0nO1xuICAgICAgdGhpcy5hcHBlbmRTb3VyY2UgPSBpc01hbmFnZWRNZWRpYVNvdXJjZShnZXRNZWRpYVNvdXJjZShobHMuY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkpO1xuICAgICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBsb2dQcmVmaXgpO1xuICAgICAgdGhpcy53YXJuID0gbG9nZ2VyLndhcm4uYmluZChsb2dnZXIsIGxvZ1ByZWZpeCk7XG4gICAgICB0aGlzLmVycm9yID0gbG9nZ2VyLmVycm9yLmJpbmQobG9nZ2VyLCBsb2dQcmVmaXgpO1xuICAgICAgdGhpcy5faW5pdFNvdXJjZUJ1ZmZlcigpO1xuICAgICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQnVmZmVyQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmhhc1NvdXJjZVR5cGVzID0gZnVuY3Rpb24gaGFzU291cmNlVHlwZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aCA+IDAgfHwgT2JqZWN0LmtleXModGhpcy5wZW5kaW5nVHJhY2tzKS5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgPSBudWxsO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5obHMgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHRoaXMub25CdWZmZXJBcHBlbmRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0VPUywgdGhpcy5vbkJ1ZmZlckVvcywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkZSQUdfUEFSU0VELCB0aGlzLm9uRnJhZ1BhcnNlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkZSQUdfQ0hBTkdFRCwgdGhpcy5vbkZyYWdDaGFuZ2VkLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0FQUEVORElORywgdGhpcy5vbkJ1ZmZlckFwcGVuZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9FT1MsIHRoaXMub25CdWZmZXJFb3MsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUkFHX1BBUlNFRCwgdGhpcy5vbkZyYWdQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19DSEFOR0VELCB0aGlzLm9uRnJhZ0NoYW5nZWQsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLl9pbml0U291cmNlQnVmZmVyID0gZnVuY3Rpb24gX2luaXRTb3VyY2VCdWZmZXIoKSB7XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgICAgdGhpcy5vcGVyYXRpb25RdWV1ZSA9IG5ldyBCdWZmZXJPcGVyYXRpb25RdWV1ZSh0aGlzLnNvdXJjZUJ1ZmZlcik7XG4gICAgICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICAgICAgYXVkaW86IFtdLFxuICAgICAgICB2aWRlbzogW10sXG4gICAgICAgIGF1ZGlvdmlkZW86IFtdXG4gICAgICB9O1xuICAgICAgdGhpcy5hcHBlbmRFcnJvcnMgPSB7XG4gICAgICAgIGF1ZGlvOiAwLFxuICAgICAgICB2aWRlbzogMCxcbiAgICAgICAgYXVkaW92aWRlbzogMFxuICAgICAgfTtcbiAgICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gdGhpcy5fYnVmZmVyQ29kZWNFdmVudHNUb3RhbCA9IDA7XG4gICAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RQYXJzZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgICAvLyBpbiBjYXNlIG9mIGFsdCBhdWRpbyAyIEJVRkZFUl9DT0RFQ1MgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkLCBvbmUgcGVyIHN0cmVhbSBjb250cm9sbGVyXG4gICAgICAvLyBzb3VyY2VidWZmZXJzIHdpbGwgYmUgY3JlYXRlZCBhbGwgYXQgb25jZSB3aGVuIHRoZSBleHBlY3RlZCBuYiBvZiB0cmFja3Mgd2lsbCBiZSByZWFjaGVkXG4gICAgICAvLyBpbiBjYXNlIGFsdCBhdWRpbyBpcyBub3QgdXNlZCwgb25seSBvbmUgQlVGRkVSX0NPREVDIGV2ZW50IHdpbGwgYmUgZmlyZWQgZnJvbSBtYWluIHN0cmVhbSBjb250cm9sbGVyXG4gICAgICAvLyBpdCB3aWxsIGNvbnRhaW4gdGhlIGV4cGVjdGVkIG5iIG9mIHNvdXJjZSBidWZmZXJzLCBubyBuZWVkIHRvIGNvbXB1dGUgaXRcbiAgICAgIHZhciBjb2RlY0V2ZW50cyA9IDI7XG4gICAgICBpZiAoZGF0YS5hdWRpbyAmJiAhZGF0YS52aWRlbyB8fCAhZGF0YS5hbHRBdWRpbyB8fCAhdHJ1ZSkge1xuICAgICAgICBjb2RlY0V2ZW50cyA9IDE7XG4gICAgICB9XG4gICAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gY29kZWNFdmVudHM7XG4gICAgICB0aGlzLmxvZyh0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgKyBcIiBidWZmZXJDb2RlYyBldmVudChzKSBleHBlY3RlZFwiKTtcbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhQXR0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgICB2YXIgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSh0aGlzLmFwcGVuZFNvdXJjZSk7XG4gICAgICBpZiAobWVkaWEgJiYgTWVkaWFTb3VyY2UpIHtcbiAgICAgICAgdmFyIF9tcyRjb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIG1zID0gdGhpcy5tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpO1xuICAgICAgICB0aGlzLmxvZyhcImNyZWF0ZWQgbWVkaWEgc291cmNlOiBcIiArICgoX21zJGNvbnN0cnVjdG9yID0gbXMuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfbXMkY29uc3RydWN0b3IubmFtZSkpO1xuICAgICAgICAvLyBNZWRpYVNvdXJjZSBsaXN0ZW5lcnMgYXJlIGFycm93IGZ1bmN0aW9ucyB3aXRoIGEgbGV4aWNhbCBzY29wZSwgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIGJvdW5kXG4gICAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKTtcbiAgICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UpO1xuICAgICAgICBpZiAodGhpcy5hcHBlbmRTb3VyY2UpIHtcbiAgICAgICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzdGFydHN0cmVhbWluZycsIHRoaXMuX29uU3RhcnRTdHJlYW1pbmcpO1xuICAgICAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZHN0cmVhbWluZycsIHRoaXMuX29uRW5kU3RyZWFtaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhY2hlIHRoZSBsb2NhbGx5IGdlbmVyYXRlZCBvYmplY3QgdXJsXG4gICAgICAgIHZhciBvYmplY3RVcmwgPSB0aGlzLl9vYmplY3RVcmwgPSBzZWxmLlVSTC5jcmVhdGVPYmplY3RVUkwobXMpO1xuICAgICAgICAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kU291cmNlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICAvLyBNYW5hZ2VkTWVkaWFTb3VyY2Ugd2lsbCBub3Qgb3BlbiB3aXRob3V0IGRpc2FibGVSZW1vdGVQbGF5YmFjayBzZXQgdG8gZmFsc2Ugb3Igc291cmNlIGFsdGVybmF0aXZlc1xuICAgICAgICAgICAgdmFyIE1NUyA9IHNlbGYuTWFuYWdlZE1lZGlhU291cmNlO1xuICAgICAgICAgICAgbWVkaWEuZGlzYWJsZVJlbW90ZVBsYXliYWNrID0gbWVkaWEuZGlzYWJsZVJlbW90ZVBsYXliYWNrIHx8IE1NUyAmJiBtcyBpbnN0YW5jZW9mIE1NUztcbiAgICAgICAgICAgIHJlbW92ZVNvdXJjZUNoaWxkcmVuKG1lZGlhKTtcbiAgICAgICAgICAgIGFkZFNvdXJjZShtZWRpYSwgb2JqZWN0VXJsKTtcbiAgICAgICAgICAgIG1lZGlhLmxvYWQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbWVkaWEuc3JjID0gb2JqZWN0VXJsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZWRpYS5zcmMgPSBvYmplY3RVcmw7XG4gICAgICAgIH1cbiAgICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW1wdGllZCcsIHRoaXMuX29uTWVkaWFFbXB0aWVkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhRGV0YWNoaW5nID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGluZygpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZSxcbiAgICAgICAgX29iamVjdFVybCA9IHRoaXMuX29iamVjdFVybDtcbiAgICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgICB0aGlzLmxvZygnbWVkaWEgc291cmNlIGRldGFjaGluZycpO1xuICAgICAgICBpZiAobWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGVuZE9mU3RyZWFtIGNvdWxkIHRyaWdnZXIgZXhjZXB0aW9uIGlmIGFueSBzb3VyY2VidWZmZXIgaXMgaW4gdXBkYXRpbmcgc3RhdGVcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IGNoZWNraW5nIHNvdXJjZWJ1ZmZlciBzdGF0ZSBoZXJlLFxuICAgICAgICAgICAgLy8gYXMgd2UgYXJlIGFueXdheSBkZXRhY2hpbmcgdGhlIE1lZGlhU291cmNlXG4gICAgICAgICAgICAvLyBsZXQncyBqdXN0IGF2b2lkIHRoaXMgZXhjZXB0aW9uIHRvIHByb3BhZ2F0ZVxuICAgICAgICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMud2FybihcIm9uTWVkaWFEZXRhY2hpbmc6IFwiICsgZXJyLm1lc3NhZ2UgKyBcIiB3aGlsZSBjYWxsaW5nIGVuZE9mU3RyZWFtXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhbiB1cCB0aGUgU291cmNlQnVmZmVycyBieSBpbnZva2luZyBvbkJ1ZmZlclJlc2V0XG4gICAgICAgIHRoaXMub25CdWZmZXJSZXNldCgpO1xuICAgICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xuICAgICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCk7XG4gICAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKTtcbiAgICAgICAgaWYgKHRoaXMuYXBwZW5kU291cmNlKSB7XG4gICAgICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RhcnRzdHJlYW1pbmcnLCB0aGlzLl9vblN0YXJ0U3RyZWFtaW5nKTtcbiAgICAgICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRzdHJlYW1pbmcnLCB0aGlzLl9vbkVuZFN0cmVhbWluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRhY2ggcHJvcGVybHkgdGhlIE1lZGlhU291cmNlIGZyb20gdGhlIEhUTUxNZWRpYUVsZW1lbnQgYXNcbiAgICAgICAgLy8gc3VnZ2VzdGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvbWVkaWEtc291cmNlL2lzc3Vlcy81My5cbiAgICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW1wdGllZCcsIHRoaXMuX29uTWVkaWFFbXB0aWVkKTtcbiAgICAgICAgICBpZiAoX29iamVjdFVybCkge1xuICAgICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKF9vYmplY3RVcmwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNsZWFuIHVwIHZpZGVvIHRhZyBzcmMgb25seSBpZiBpdCdzIG91ciBvd24gdXJsLiBzb21lIGV4dGVybmFsIGxpYnJhcmllcyBtaWdodFxuICAgICAgICAgIC8vIGhpamFjayB0aGUgdmlkZW8gdGFnIGFuZCBjaGFuZ2UgaXRzICdzcmMnIHdpdGhvdXQgZGVzdHJveWluZyB0aGUgSGxzIGluc3RhbmNlIGZpcnN0XG4gICAgICAgICAgaWYgKHRoaXMubWVkaWFTcmMgPT09IF9vYmplY3RVcmwpIHtcbiAgICAgICAgICAgIG1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlU291cmNlQ2hpbGRyZW4obWVkaWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVkaWEubG9hZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oJ21lZGlhfHNvdXJjZS5zcmMgd2FzIGNoYW5nZWQgYnkgYSB0aGlyZCBwYXJ0eSAtIHNraXAgY2xlYW51cCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lZGlhU291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICAgIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWw7XG4gICAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLnRyYWNrcyA9IHt9O1xuICAgICAgfVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUVESUFfREVUQUNIRUQsIHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJSZXNldCA9IGZ1bmN0aW9uIG9uQnVmZmVyUmVzZXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIF90aGlzMi5yZXNldEJ1ZmZlcih0eXBlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faW5pdFNvdXJjZUJ1ZmZlcigpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0QnVmZmVyID0gZnVuY3Rpb24gcmVzZXRCdWZmZXIodHlwZSkge1xuICAgICAgdmFyIHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWFTb3VyY2U7XG4gICAgICAgICAgdGhpcy5yZW1vdmVCdWZmZXJMaXN0ZW5lcnModHlwZSk7XG4gICAgICAgICAgLy8gU3luY2hyb25vdXNseSByZW1vdmUgdGhlIFNCIGZyb20gdGhlIG1hcCBiZWZvcmUgdGhlIG5leHQgY2FsbCBpbiBvcmRlciB0byBwcmV2ZW50IGFuIGFzeW5jIGZ1bmN0aW9uIGZyb21cbiAgICAgICAgICAvLyBhY2Nlc3NpbmcgaXRcbiAgICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoKF90aGlzJG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYVNvdXJjZS5zb3VyY2VCdWZmZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVNvdXJjZS5yZW1vdmVTb3VyY2VCdWZmZXIoc2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMud2FybihcIm9uQnVmZmVyUmVzZXQgXCIgKyB0eXBlLCBlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uQnVmZmVyQ29kZWNzID0gZnVuY3Rpb24gb25CdWZmZXJDb2RlY3MoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIHNvdXJjZUJ1ZmZlckNvdW50ID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aDtcbiAgICAgIHZhciB0cmFja05hbWVzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICB0cmFja05hbWVzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrTmFtZSkge1xuICAgICAgICBpZiAoc291cmNlQnVmZmVyQ291bnQpIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiBTb3VyY2VCdWZmZXIgY29kZWMgbmVlZHMgdG8gY2hhbmdlXG4gICAgICAgICAgdmFyIHRyYWNrID0gX3RoaXMzLnRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICAgIGlmICh0cmFjayAmJiB0eXBlb2YgdHJhY2suYnVmZmVyLmNoYW5nZVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBfdHJhY2tDb2RlYztcbiAgICAgICAgICAgIHZhciBfZGF0YSR0cmFja05hbWUgPSBkYXRhW3RyYWNrTmFtZV0sXG4gICAgICAgICAgICAgIGlkID0gX2RhdGEkdHJhY2tOYW1lLmlkLFxuICAgICAgICAgICAgICBjb2RlYyA9IF9kYXRhJHRyYWNrTmFtZS5jb2RlYyxcbiAgICAgICAgICAgICAgbGV2ZWxDb2RlYyA9IF9kYXRhJHRyYWNrTmFtZS5sZXZlbENvZGVjLFxuICAgICAgICAgICAgICBjb250YWluZXIgPSBfZGF0YSR0cmFja05hbWUuY29udGFpbmVyLFxuICAgICAgICAgICAgICBtZXRhZGF0YSA9IF9kYXRhJHRyYWNrTmFtZS5tZXRhZGF0YTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Q29kZWNGdWxsID0gcGlja01vc3RDb21wbGV0ZUNvZGVjTmFtZSh0cmFjay5jb2RlYywgdHJhY2subGV2ZWxDb2RlYyk7XG4gICAgICAgICAgICB2YXIgY3VycmVudENvZGVjID0gY3VycmVudENvZGVjRnVsbCA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudENvZGVjRnVsbC5yZXBsYWNlKFZJREVPX0NPREVDX1BST0ZJTEVfUkVQTEFDRSwgJyQxJyk7XG4gICAgICAgICAgICB2YXIgdHJhY2tDb2RlYyA9IHBpY2tNb3N0Q29tcGxldGVDb2RlY05hbWUoY29kZWMsIGxldmVsQ29kZWMpO1xuICAgICAgICAgICAgdmFyIG5leHRDb2RlYyA9IChfdHJhY2tDb2RlYyA9IHRyYWNrQ29kZWMpID09IG51bGwgPyB2b2lkIDAgOiBfdHJhY2tDb2RlYy5yZXBsYWNlKFZJREVPX0NPREVDX1BST0ZJTEVfUkVQTEFDRSwgJyQxJyk7XG4gICAgICAgICAgICBpZiAodHJhY2tDb2RlYyAmJiBjdXJyZW50Q29kZWMgIT09IG5leHRDb2RlYykge1xuICAgICAgICAgICAgICBpZiAodHJhY2tOYW1lLnNsaWNlKDAsIDUpID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tDb2RlYyA9IGdldENvZGVjQ29tcGF0aWJsZU5hbWUodHJhY2tDb2RlYywgX3RoaXMzLmFwcGVuZFNvdXJjZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG1pbWVUeXBlID0gY29udGFpbmVyICsgXCI7Y29kZWNzPVwiICsgdHJhY2tDb2RlYztcbiAgICAgICAgICAgICAgX3RoaXMzLmFwcGVuZENoYW5nZVR5cGUodHJhY2tOYW1lLCBtaW1lVHlwZSk7XG4gICAgICAgICAgICAgIF90aGlzMy5sb2coXCJzd2l0Y2hpbmcgY29kZWMgXCIgKyBjdXJyZW50Q29kZWNGdWxsICsgXCIgdG8gXCIgKyB0cmFja0NvZGVjKTtcbiAgICAgICAgICAgICAgX3RoaXMzLnRyYWNrc1t0cmFja05hbWVdID0ge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcjogdHJhY2suYnVmZmVyLFxuICAgICAgICAgICAgICAgIGNvZGVjOiBjb2RlYyxcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBsZXZlbENvZGVjOiBsZXZlbENvZGVjLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgc291cmNlIGJ1ZmZlcihzKSBub3QgY3JlYXRlZCB5ZXQsIGFwcGVuZGVkIGJ1ZmZlciB0cmFja3MgaW4gdGhpcy5wZW5kaW5nVHJhY2tzXG4gICAgICAgICAgX3RoaXMzLnBlbmRpbmdUcmFja3NbdHJhY2tOYW1lXSA9IGRhdGFbdHJhY2tOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGlmIHNvdXJjZWJ1ZmZlcnMgYWxyZWFkeSBjcmVhdGVkLCBkbyBub3RoaW5nIC4uLlxuICAgICAgaWYgKHNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gTWF0aC5tYXgodGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkIC0gMSwgMCk7XG4gICAgICBpZiAodGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkICE9PSBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkKSB7XG4gICAgICAgIHRoaXMubG9nKGJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgKyBcIiBidWZmZXJDb2RlYyBldmVudChzKSBleHBlY3RlZCBcIiArIHRyYWNrTmFtZXMuam9pbignLCcpKTtcbiAgICAgICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1lZGlhU291cmNlICYmIHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uYXBwZW5kQ2hhbmdlVHlwZSA9IGZ1bmN0aW9uIGFwcGVuZENoYW5nZVR5cGUodHlwZSwgbWltZVR5cGUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZTtcbiAgICAgIHZhciBvcGVyYXRpb24gPSB7XG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgICAgICAgdmFyIHNiID0gX3RoaXM0LnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgIF90aGlzNC5sb2coXCJjaGFuZ2luZyBcIiArIHR5cGUgKyBcIiBzb3VyY2VCdWZmZXIgdHlwZSB0byBcIiArIG1pbWVUeXBlKTtcbiAgICAgICAgICAgIHNiLmNoYW5nZVR5cGUobWltZVR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgICB9LFxuICAgICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KCkge30sXG4gICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7fSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgICAgIF90aGlzNC53YXJuKFwiRmFpbGVkIHRvIGNoYW5nZSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXIgdHlwZVwiLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQob3BlcmF0aW9uLCB0eXBlLCAhIXRoaXMucGVuZGluZ1RyYWNrc1t0eXBlXSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJBcHBlbmRpbmcgPSBmdW5jdGlvbiBvbkJ1ZmZlckFwcGVuZGluZyhldmVudCwgZXZlbnREYXRhKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlLFxuICAgICAgICB0cmFja3MgPSB0aGlzLnRyYWNrcztcbiAgICAgIHZhciBkYXRhID0gZXZlbnREYXRhLmRhdGEsXG4gICAgICAgIHR5cGUgPSBldmVudERhdGEudHlwZSxcbiAgICAgICAgZnJhZyA9IGV2ZW50RGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZXZlbnREYXRhLnBhcnQsXG4gICAgICAgIGNodW5rTWV0YSA9IGV2ZW50RGF0YS5jaHVua01ldGE7XG4gICAgICB2YXIgY2h1bmtTdGF0cyA9IGNodW5rTWV0YS5idWZmZXJpbmdbdHlwZV07XG4gICAgICB2YXIgYnVmZmVyQXBwZW5kaW5nU3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY2h1bmtTdGF0cy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgICAgdmFyIGZyYWdCdWZmZXJpbmcgPSBmcmFnLnN0YXRzLmJ1ZmZlcmluZztcbiAgICAgIHZhciBwYXJ0QnVmZmVyaW5nID0gcGFydCA/IHBhcnQuc3RhdHMuYnVmZmVyaW5nIDogbnVsbDtcbiAgICAgIGlmIChmcmFnQnVmZmVyaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICAgIGZyYWdCdWZmZXJpbmcuc3RhcnQgPSBidWZmZXJBcHBlbmRpbmdTdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0QnVmZmVyaW5nICYmIHBhcnRCdWZmZXJpbmcuc3RhcnQgPT09IDApIHtcbiAgICAgICAgcGFydEJ1ZmZlcmluZy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBPbmx5IHVwZGF0ZSB0aW1lc3RhbXBPZmZzZXQgd2hlbiBhdWRpby9tcGVnIGZyYWdtZW50IG9yIHBhcnQgaXMgbm90IGNvbnRpZ3VvdXMgd2l0aCBwcmV2aW91c2x5IGFwcGVuZGVkXG4gICAgICAvLyBBZGp1c3RpbmcgYFNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXRgIChkZXNpcmVkIHBvaW50IGluIHRoZSB0aW1lbGluZSB3aGVyZSB0aGUgbmV4dCBmcmFtZXMgc2hvdWxkIGJlIGFwcGVuZGVkKVxuICAgICAgLy8gaW4gQ2hyb21lIGJyb3dzZXIgd2hlbiB3ZSBkZXRlY3QgTVBFRyBhdWRpbyBjb250YWluZXIgYW5kIHRpbWUgZGVsdGEgYmV0d2VlbiBsZXZlbCBQVFMgYW5kIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YFxuICAgICAgLy8gaXMgZ3JlYXRlciB0aGFuIDEwMG1zICh0aGlzIGlzIGVub3VnaCB0byBoYW5kbGUgc2VlayBmb3IgVk9EIG9yIGxldmVsIGNoYW5nZSBmb3IgTElWRSB2aWRlb3MpLlxuICAgICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zMzIjaXNzdWVjb21tZW50LTI1Nzk4NjQ4NlxuICAgICAgdmFyIGF1ZGlvVHJhY2sgPSB0cmFja3MuYXVkaW87XG4gICAgICB2YXIgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nICYmIChhdWRpb1RyYWNrID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb1RyYWNrLmNvbnRhaW5lcikgPT09ICdhdWRpby9tcGVnJykge1xuICAgICAgICBjaGVja1RpbWVzdGFtcE9mZnNldCA9ICF0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayB8fCBjaHVua01ldGEuaWQgPT09IDEgfHwgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsuc24gIT09IGNodW5rTWV0YS5zbjtcbiAgICAgICAgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgPSBjaHVua01ldGE7XG4gICAgICB9XG4gICAgICB2YXIgZnJhZ1N0YXJ0ID0gZnJhZy5zdGFydDtcbiAgICAgIHZhciBvcGVyYXRpb24gPSB7XG4gICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgICAgICAgY2h1bmtTdGF0cy5leGVjdXRlU3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGlmIChjaGVja1RpbWVzdGFtcE9mZnNldCkge1xuICAgICAgICAgICAgdmFyIHNiID0gX3RoaXM1LnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgICAgIGlmIChzYikge1xuICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBmcmFnU3RhcnQgLSBzYi50aW1lc3RhbXBPZmZzZXQ7XG4gICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMC4xKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM1LmxvZyhcIlVwZGF0aW5nIGF1ZGlvIFNvdXJjZUJ1ZmZlciB0aW1lc3RhbXBPZmZzZXQgdG8gXCIgKyBmcmFnU3RhcnQgKyBcIiAoZGVsdGE6IFwiICsgZGVsdGEgKyBcIikgc246IFwiICsgZnJhZy5zbiArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICBzYi50aW1lc3RhbXBPZmZzZXQgPSBmcmFnU3RhcnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXM1LmFwcGVuZEV4ZWN1dG9yKGRhdGEsIHR5cGUpO1xuICAgICAgICB9LFxuICAgICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KCkge1xuICAgICAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogJHt0eXBlfSBTb3VyY2VCdWZmZXIgdXBkYXRlc3RhcnRgKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gU291cmNlQnVmZmVyIHVwZGF0ZWVuZGApO1xuICAgICAgICAgIHZhciBlbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGNodW5rU3RhdHMuZXhlY3V0ZUVuZCA9IGNodW5rU3RhdHMuZW5kID0gZW5kO1xuICAgICAgICAgIGlmIChmcmFnQnVmZmVyaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgICBmcmFnQnVmZmVyaW5nLmZpcnN0ID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydEJ1ZmZlcmluZyAmJiBwYXJ0QnVmZmVyaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgICBwYXJ0QnVmZmVyaW5nLmZpcnN0ID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc291cmNlQnVmZmVyID0gX3RoaXM1LnNvdXJjZUJ1ZmZlcjtcbiAgICAgICAgICB2YXIgdGltZVJhbmdlcyA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIF90eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgICAgdGltZVJhbmdlc1tfdHlwZV0gPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc291cmNlQnVmZmVyW190eXBlXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzNS5hcHBlbmRFcnJvcnNbdHlwZV0gPSAwO1xuICAgICAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nIHx8IHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIF90aGlzNS5hcHBlbmRFcnJvcnMuYXVkaW92aWRlbyA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzNS5hcHBlbmRFcnJvcnMuYXVkaW8gPSAwO1xuICAgICAgICAgICAgX3RoaXM1LmFwcGVuZEVycm9ycy52aWRlbyA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzNS5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVOREVELCB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICBjaHVua01ldGE6IGNodW5rTWV0YSxcbiAgICAgICAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgICAgICAgdGltZVJhbmdlczogdGltZVJhbmdlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBhbnkgZXJyb3Igb2NjdXJlZCB3aGlsZSBhcHBlbmRpbmcsIHB1dCBiYWNrIHNlZ21lbnQgaW4gc2VnbWVudHMgdGFibGVcbiAgICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUixcbiAgICAgICAgICAgIHNvdXJjZUJ1ZmZlck5hbWU6IHR5cGUsXG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgZXJyOiBlcnJvcixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IERPTUV4Y2VwdGlvbi5RVU9UQV9FWENFRURFRF9FUlIpIHtcbiAgICAgICAgICAgIC8vIFF1b3RhRXhjZWVkZWRFcnJvcjogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNxdW90YWV4Y2VlZGVkZXJyb3JcbiAgICAgICAgICAgIC8vIGxldCdzIHN0b3AgYXBwZW5kaW5nIGFueSBzZWdtZW50cywgYW5kIHJlcG9ydCBCVUZGRVJfRlVMTF9FUlJPUiBlcnJvclxuICAgICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFwcGVuZEVycm9yQ291bnQgPSArK190aGlzNS5hcHBlbmRFcnJvcnNbdHlwZV07XG4gICAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I7XG4gICAgICAgICAgICAvKiB3aXRoIFVIRCBjb250ZW50LCB3ZSBjb3VsZCBnZXQgbG9vcCBvZiBxdW90YSBleGNlZWRlZCBlcnJvciB1bnRpbFxuICAgICAgICAgICAgICBicm93c2VyIGlzIGFibGUgdG8gZXZpY3Qgc29tZSBkYXRhIGZyb20gc291cmNlYnVmZmVyLiBSZXRyeWluZyBjYW4gaGVscCByZWNvdmVyLlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90aGlzNS53YXJuKFwiRmFpbGVkIFwiICsgYXBwZW5kRXJyb3JDb3VudCArIFwiL1wiICsgaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5ICsgXCIgdGltZXMgdG8gYXBwZW5kIHNlZ21lbnQgaW4gXFxcIlwiICsgdHlwZSArIFwiXFxcIiBzb3VyY2VCdWZmZXJcIik7XG4gICAgICAgICAgICBpZiAoYXBwZW5kRXJyb3JDb3VudCA+PSBobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkpIHtcbiAgICAgICAgICAgICAgZXZlbnQuZmF0YWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChvcGVyYXRpb24sIHR5cGUsICEhdGhpcy5wZW5kaW5nVHJhY2tzW3R5cGVdKTtcbiAgICB9O1xuICAgIF9wcm90by5vbkJ1ZmZlckZsdXNoaW5nID0gZnVuY3Rpb24gb25CdWZmZXJGbHVzaGluZyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgICB2YXIgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlO1xuICAgICAgdmFyIGZsdXNoT3BlcmF0aW9uID0gZnVuY3Rpb24gZmx1c2hPcGVyYXRpb24odHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV4ZWN1dGU6IF90aGlzNi5yZW1vdmVFeGVjdXRvci5iaW5kKF90aGlzNiwgdHlwZSwgZGF0YS5zdGFydE9mZnNldCwgZGF0YS5lbmRPZmZzZXQpLFxuICAgICAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IFN0YXJ0ZWQgZmx1c2hpbmcgJHtkYXRhLnN0YXJ0T2Zmc2V0fSAtPiAke2RhdGEuZW5kT2Zmc2V0fSBmb3IgJHt0eXBlfSBTb3VyY2UgQnVmZmVyYCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBGaW5pc2hlZCBmbHVzaGluZyAke2RhdGEuc3RhcnRPZmZzZXR9IC0+ICR7ZGF0YS5lbmRPZmZzZXR9IGZvciAke3R5cGV9IFNvdXJjZSBCdWZmZXJgKTtcbiAgICAgICAgICAgIF90aGlzNi5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHtcbiAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpczYud2FybihcIkZhaWxlZCB0byByZW1vdmUgZnJvbSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXJcIiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBpZiAoZGF0YS50eXBlKSB7XG4gICAgICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChmbHVzaE9wZXJhdGlvbihkYXRhLnR5cGUpLCBkYXRhLnR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQoZmx1c2hPcGVyYXRpb24odHlwZSksIHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkZyYWdQYXJzZWQgPSBmdW5jdGlvbiBvbkZyYWdQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgdmFyIGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgIHBhcnQgPSBkYXRhLnBhcnQ7XG4gICAgICB2YXIgYnVmZmVyc0FwcGVuZGVkVG8gPSBbXTtcbiAgICAgIHZhciBlbGVtZW50YXJ5U3RyZWFtcyA9IHBhcnQgPyBwYXJ0LmVsZW1lbnRhcnlTdHJlYW1zIDogZnJhZy5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICAgIGlmIChlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT10pIHtcbiAgICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgnYXVkaW92aWRlbycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT10pIHtcbiAgICAgICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCdhdWRpbycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9dKSB7XG4gICAgICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgndmlkZW8nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG9uVW5ibG9ja2VkID0gZnVuY3Rpb24gb25VbmJsb2NrZWQoKSB7XG4gICAgICAgIHZhciBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBmcmFnLnN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBub3c7XG4gICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgcGFydC5zdGF0cy5idWZmZXJpbmcuZW5kID0gbm93O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgICAgX3RoaXM3Lmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB7XG4gICAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgIHN0YXRzOiBzdGF0cyxcbiAgICAgICAgICBpZDogZnJhZy50eXBlXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmIChidWZmZXJzQXBwZW5kZWRUby5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy53YXJuKFwiRnJhZ21lbnRzIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgRWxlbWVudGFyeVN0cmVhbVR5cGUgc2V0LiB0eXBlOiBcIiArIGZyYWcudHlwZSArIFwiIGxldmVsOiBcIiArIGZyYWcubGV2ZWwgKyBcIiBzbjogXCIgKyBmcmFnLnNuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYmxvY2tCdWZmZXJzKG9uVW5ibG9ja2VkLCBidWZmZXJzQXBwZW5kZWRUbyk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnQ2hhbmdlZCA9IGZ1bmN0aW9uIG9uRnJhZ0NoYW5nZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHRoaXMudHJpbUJ1ZmZlcnMoKTtcbiAgICB9XG5cbiAgICAvLyBvbiBCVUZGRVJfRU9TIG1hcmsgbWF0Y2hpbmcgc291cmNlYnVmZmVyKHMpIGFzIGVuZGVkIGFuZCB0cmlnZ2VyIGNoZWNrRW9zKClcbiAgICAvLyBhbiB1bmRlZmluZWQgZGF0YS50eXBlIHdpbGwgbWFyayBhbGwgYnVmZmVycyBhcyBFT1MuXG4gICAgO1xuICAgIF9wcm90by5vbkJ1ZmZlckVvcyA9IGZ1bmN0aW9uIG9uQnVmZmVyRW9zKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcbiAgICAgIHZhciBlbmRlZCA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdHlwZSkge1xuICAgICAgICB2YXIgc2IgPSBfdGhpczguc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICBpZiAoc2IgJiYgKCFkYXRhLnR5cGUgfHwgZGF0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICAgIHNiLmVuZGluZyA9IHRydWU7XG4gICAgICAgICAgaWYgKCFzYi5lbmRlZCkge1xuICAgICAgICAgICAgc2IuZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXM4LmxvZyh0eXBlICsgXCIgc291cmNlQnVmZmVyIG5vdyBFT1NcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2MgJiYgISEoIXNiIHx8IHNiLmVuZGVkKTtcbiAgICAgIH0sIHRydWUpO1xuICAgICAgaWYgKGVuZGVkKSB7XG4gICAgICAgIHRoaXMubG9nKFwiUXVldWVpbmcgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKVwiKTtcbiAgICAgICAgdGhpcy5ibG9ja0J1ZmZlcnMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzOC5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBzYiA9IF90aGlzOC5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgICBpZiAoc2IpIHtcbiAgICAgICAgICAgICAgc2IuZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIG1lZGlhU291cmNlID0gX3RoaXM4Lm1lZGlhU291cmNlO1xuICAgICAgICAgIGlmICghbWVkaWFTb3VyY2UgfHwgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgICAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgICAgICAgICAgX3RoaXM4LmxvZyhcIkNvdWxkIG5vdCBjYWxsIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCkuIG1lZGlhU291cmNlLnJlYWR5U3RhdGU6IFwiICsgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzOC5sb2coXCJDYWxsaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKClcIik7XG4gICAgICAgICAgLy8gQWxsb3cgdGhpcyB0byB0aHJvdyBhbmQgYmUgY2F1Z2h0IGJ5IHRoZSBlbnF1ZXVlaW5nIGZ1bmN0aW9uXG4gICAgICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbFVwZGF0ZWQgPSBmdW5jdGlvbiBvbkxldmVsVXBkYXRlZChldmVudCwgX3JlZikge1xuICAgICAgdmFyIGRldGFpbHMgPSBfcmVmLmRldGFpbHM7XG4gICAgICBpZiAoIWRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgaWYgKHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5ibG9ja0J1ZmZlcnModGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50cmltQnVmZmVycyA9IGZ1bmN0aW9uIHRyaW1CdWZmZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzLFxuICAgICAgICBkZXRhaWxzID0gdGhpcy5kZXRhaWxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAoIW1lZGlhIHx8IGRldGFpbHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZUJ1ZmZlclR5cGVzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuICAgICAgaWYgKCFzb3VyY2VCdWZmZXJUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIHZhciB0YXJnZXREdXJhdGlvbiA9IGRldGFpbHMubGV2ZWxUYXJnZXREdXJhdGlvbjtcblxuICAgICAgLy8gU3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBsaXZlQmFja0J1ZmZlckxlbmd0aFxuICAgICAgdmFyIGJhY2tCdWZmZXJMZW5ndGggPSBkZXRhaWxzLmxpdmUgJiYgY29uZmlnLmxpdmVCYWNrQnVmZmVyTGVuZ3RoICE9PSBudWxsID8gY29uZmlnLmxpdmVCYWNrQnVmZmVyTGVuZ3RoIDogY29uZmlnLmJhY2tCdWZmZXJMZW5ndGg7XG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoYmFja0J1ZmZlckxlbmd0aCkgJiYgYmFja0J1ZmZlckxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG1heEJhY2tCdWZmZXJMZW5ndGggPSBNYXRoLm1heChiYWNrQnVmZmVyTGVuZ3RoLCB0YXJnZXREdXJhdGlvbik7XG4gICAgICAgIHZhciB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRUaW1lIC8gdGFyZ2V0RHVyYXRpb24pICogdGFyZ2V0RHVyYXRpb24gLSBtYXhCYWNrQnVmZmVyTGVuZ3RoO1xuICAgICAgICB0aGlzLmZsdXNoQmFja0J1ZmZlcihjdXJyZW50VGltZSwgdGFyZ2V0RHVyYXRpb24sIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoY29uZmlnLmZyb250QnVmZmVyRmx1c2hUaHJlc2hvbGQpICYmIGNvbmZpZy5mcm9udEJ1ZmZlckZsdXNoVGhyZXNob2xkID4gMCkge1xuICAgICAgICB2YXIgZnJvbnRCdWZmZXJMZW5ndGggPSBNYXRoLm1heChjb25maWcubWF4QnVmZmVyTGVuZ3RoLCBjb25maWcuZnJvbnRCdWZmZXJGbHVzaFRocmVzaG9sZCk7XG4gICAgICAgIHZhciBtYXhGcm9udEJ1ZmZlckxlbmd0aCA9IE1hdGgubWF4KGZyb250QnVmZmVyTGVuZ3RoLCB0YXJnZXREdXJhdGlvbik7XG4gICAgICAgIHZhciB0YXJnZXRGcm9udEJ1ZmZlclBvc2l0aW9uID0gTWF0aC5mbG9vcihjdXJyZW50VGltZSAvIHRhcmdldER1cmF0aW9uKSAqIHRhcmdldER1cmF0aW9uICsgbWF4RnJvbnRCdWZmZXJMZW5ndGg7XG4gICAgICAgIHRoaXMuZmx1c2hGcm9udEJ1ZmZlcihjdXJyZW50VGltZSwgdGFyZ2V0RHVyYXRpb24sIHRhcmdldEZyb250QnVmZmVyUG9zaXRpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoQmFja0J1ZmZlciA9IGZ1bmN0aW9uIGZsdXNoQmFja0J1ZmZlcihjdXJyZW50VGltZSwgdGFyZ2V0RHVyYXRpb24sIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbikge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG4gICAgICB2YXIgZGV0YWlscyA9IHRoaXMuZGV0YWlscyxcbiAgICAgICAgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXI7XG4gICAgICB2YXIgc291cmNlQnVmZmVyVHlwZXMgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCk7XG4gICAgICBzb3VyY2VCdWZmZXJUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKHNiKTtcbiAgICAgICAgICAvLyB3aGVuIHRhcmdldCBidWZmZXIgc3RhcnQgZXhjZWVkcyBhY3R1YWwgYnVmZmVyIHN0YXJ0XG4gICAgICAgICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCA+IDAgJiYgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uID4gYnVmZmVyZWQuc3RhcnQoMCkpIHtcbiAgICAgICAgICAgIF90aGlzOS5obHMudHJpZ2dlcihFdmVudHMuQkFDS19CVUZGRVJfUkVBQ0hFRCwge1xuICAgICAgICAgICAgICBidWZmZXJFbmQ6IHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQgZm9yIGRlcHJlY2F0ZWQgZXZlbnQ6XG4gICAgICAgICAgICBpZiAoZGV0YWlscyAhPSBudWxsICYmIGRldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgICBfdGhpczkuaGxzLnRyaWdnZXIoRXZlbnRzLkxJVkVfQkFDS19CVUZGRVJfUkVBQ0hFRCwge1xuICAgICAgICAgICAgICAgIGJ1ZmZlckVuZDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzYi5lbmRlZCAmJiBidWZmZXJlZC5lbmQoYnVmZmVyZWQubGVuZ3RoIC0gMSkgLSBjdXJyZW50VGltZSA8IHRhcmdldER1cmF0aW9uICogMikge1xuICAgICAgICAgICAgICBfdGhpczkubG9nKFwiQ2Fubm90IGZsdXNoIFwiICsgdHlwZSArIFwiIGJhY2sgYnVmZmVyIHdoaWxlIFNvdXJjZUJ1ZmZlciBpcyBpbiBlbmRlZCBzdGF0ZVwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXM5Lmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgIGVuZE9mZnNldDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoRnJvbnRCdWZmZXIgPSBmdW5jdGlvbiBmbHVzaEZyb250QnVmZmVyKGN1cnJlbnRUaW1lLCB0YXJnZXREdXJhdGlvbiwgdGFyZ2V0RnJvbnRCdWZmZXJQb3NpdGlvbikge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuICAgICAgdmFyIHNvdXJjZUJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyO1xuICAgICAgdmFyIHNvdXJjZUJ1ZmZlclR5cGVzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuICAgICAgc291cmNlQnVmZmVyVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgIGlmIChzYikge1xuICAgICAgICAgIHZhciBidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChzYik7XG4gICAgICAgICAgdmFyIG51bUJ1ZmZlcmVkUmFuZ2VzID0gYnVmZmVyZWQubGVuZ3RoO1xuICAgICAgICAgIC8vIFRoZSBidWZmZXIgaXMgZWl0aGVyIGVtcHR5IG9yIGNvbnRpZ3VvdXNcbiAgICAgICAgICBpZiAobnVtQnVmZmVyZWRSYW5nZXMgPCAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBidWZmZXJTdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KG51bUJ1ZmZlcmVkUmFuZ2VzIC0gMSk7XG4gICAgICAgICAgdmFyIGJ1ZmZlckVuZCA9IGJ1ZmZlcmVkLmVuZChudW1CdWZmZXJlZFJhbmdlcyAtIDEpO1xuICAgICAgICAgIC8vIE5vIGZsdXNoIGlmIHdlIGNhbiB0b2xlcmF0ZSB0aGUgY3VycmVudCBidWZmZXIgbGVuZ3RoIG9yIHRoZSBjdXJyZW50IGJ1ZmZlciByYW5nZSB3ZSB3b3VsZCBmbHVzaCBpcyBjb250aWd1b3VzIHdpdGggY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgIGlmICh0YXJnZXRGcm9udEJ1ZmZlclBvc2l0aW9uID4gYnVmZmVyU3RhcnQgfHwgY3VycmVudFRpbWUgPj0gYnVmZmVyU3RhcnQgJiYgY3VycmVudFRpbWUgPD0gYnVmZmVyRW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChzYi5lbmRlZCAmJiBjdXJyZW50VGltZSAtIGJ1ZmZlckVuZCA8IDIgKiB0YXJnZXREdXJhdGlvbikge1xuICAgICAgICAgICAgX3RoaXMxMC5sb2coXCJDYW5ub3QgZmx1c2ggXCIgKyB0eXBlICsgXCIgZnJvbnQgYnVmZmVyIHdoaWxlIFNvdXJjZUJ1ZmZlciBpcyBpbiBlbmRlZCBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMxMC5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB7XG4gICAgICAgICAgICBzdGFydE9mZnNldDogYnVmZmVyU3RhcnQsXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IEluZmluaXR5LFxuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvIGN1cnJlbnQgbGV2ZWwgZHVyYXRpb24gb3Igb3ZlcnJpZGUgdG8gSW5maW5pdHkgaWYgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJcbiAgICAgKiAnbGl2ZUR1cmF0aW9uSW5maW5pdHlgIGlzIHNldCB0byBgdHJ1ZWBcbiAgICAgKiBNb3JlIGRldGFpbHM6IGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8zNTVcbiAgICAgKi87XG4gICAgX3Byb3RvLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uID0gZnVuY3Rpb24gdXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuZGV0YWlscyB8fCAhdGhpcy5tZWRpYSB8fCAhdGhpcy5tZWRpYVNvdXJjZSB8fCB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGV0YWlscyA9IHRoaXMuZGV0YWlscyxcbiAgICAgICAgaGxzID0gdGhpcy5obHMsXG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgICAgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgdmFyIGxldmVsRHVyYXRpb24gPSBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydCArIGRldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICAgIHZhciBtZWRpYUR1cmF0aW9uID0gbWVkaWEuZHVyYXRpb247XG4gICAgICB2YXIgbXNEdXJhdGlvbiA9IGlzRmluaXRlTnVtYmVyKG1lZGlhU291cmNlLmR1cmF0aW9uKSA/IG1lZGlhU291cmNlLmR1cmF0aW9uIDogMDtcbiAgICAgIGlmIChkZXRhaWxzLmxpdmUgJiYgaGxzLmNvbmZpZy5saXZlRHVyYXRpb25JbmZpbml0eSkge1xuICAgICAgICAvLyBPdmVycmlkZSBkdXJhdGlvbiB0byBJbmZpbml0eVxuICAgICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLnVwZGF0ZVNlZWthYmxlUmFuZ2UoZGV0YWlscyk7XG4gICAgICB9IGVsc2UgaWYgKGxldmVsRHVyYXRpb24gPiBtc0R1cmF0aW9uICYmIGxldmVsRHVyYXRpb24gPiBtZWRpYUR1cmF0aW9uIHx8ICFpc0Zpbml0ZU51bWJlcihtZWRpYUR1cmF0aW9uKSkge1xuICAgICAgICAvLyBsZXZlbER1cmF0aW9uIHdhcyB0aGUgbGFzdCB2YWx1ZSB3ZSBzZXQuXG4gICAgICAgIC8vIG5vdCB1c2luZyBtZWRpYVNvdXJjZS5kdXJhdGlvbiBhcyB0aGUgYnJvd3NlciBtYXkgdHdlYWsgdGhpcyB2YWx1ZVxuICAgICAgICAvLyBvbmx5IHVwZGF0ZSBNZWRpYSBTb3VyY2UgZHVyYXRpb24gaWYgaXRzIHZhbHVlIGluY3JlYXNlLCB0aGlzIGlzIHRvIGF2b2lkXG4gICAgICAgIC8vIGZsdXNoaW5nIGFscmVhZHkgYnVmZmVyZWQgcG9ydGlvbiB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIHF1YWxpdHkgbGV2ZWxcbiAgICAgICAgdGhpcy5sb2coXCJVcGRhdGluZyBNZWRpYSBTb3VyY2UgZHVyYXRpb24gdG8gXCIgKyBsZXZlbER1cmF0aW9uLnRvRml4ZWQoMykpO1xuICAgICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IGxldmVsRHVyYXRpb247XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udXBkYXRlU2Vla2FibGVSYW5nZSA9IGZ1bmN0aW9uIHVwZGF0ZVNlZWthYmxlUmFuZ2UobGV2ZWxEZXRhaWxzKSB7XG4gICAgICB2YXIgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgICAgdmFyIGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHM7XG4gICAgICB2YXIgbGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gJiYgbGV2ZWxEZXRhaWxzLmxpdmUgJiYgbWVkaWFTb3VyY2UgIT0gbnVsbCAmJiBtZWRpYVNvdXJjZS5zZXRMaXZlU2Vla2FibGVSYW5nZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCgwLCBmcmFnbWVudHNbMF0uc3RhcnQpO1xuICAgICAgICB2YXIgZW5kID0gTWF0aC5tYXgoc3RhcnQsIHN0YXJ0ICsgbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb24pO1xuICAgICAgICB0aGlzLmxvZyhcIk1lZGlhIFNvdXJjZSBkdXJhdGlvbiBpcyBzZXQgdG8gXCIgKyBtZWRpYVNvdXJjZS5kdXJhdGlvbiArIFwiLiBTZXR0aW5nIHNlZWthYmxlIHJhbmdlIHRvIFwiICsgc3RhcnQgKyBcIi1cIiArIGVuZCArIFwiLlwiKTtcbiAgICAgICAgbWVkaWFTb3VyY2Uuc2V0TGl2ZVNlZWthYmxlUmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY2hlY2tQZW5kaW5nVHJhY2tzID0gZnVuY3Rpb24gY2hlY2tQZW5kaW5nVHJhY2tzKCkge1xuICAgICAgdmFyIGJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQsXG4gICAgICAgIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZSxcbiAgICAgICAgcGVuZGluZ1RyYWNrcyA9IHRoaXMucGVuZGluZ1RyYWNrcztcblxuICAgICAgLy8gQ2hlY2sgaWYgd2UndmUgcmVjZWl2ZWQgYWxsIG9mIHRoZSBleHBlY3RlZCBidWZmZXJDb2RlYyBldmVudHMuIFdoZW4gbm9uZSByZW1haW4sIGNyZWF0ZSBhbGwgdGhlIHNvdXJjZUJ1ZmZlcnMgYXQgb25jZS5cbiAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIE1TRSBzcGVjIGFsbG93cyBpbXBsZW1lbnRhdGlvbnMgdG8gdGhyb3cgUXVvdGFFeGNlZWRlZEVycm9ycyBpZiBjcmVhdGluZyBuZXcgc291cmNlQnVmZmVycyBhZnRlclxuICAgICAgLy8gZGF0YSBoYXMgYmVlbiBhcHBlbmRlZCB0byBleGlzdGluZyBvbmVzLlxuICAgICAgLy8gMiB0cmFja3MgaXMgdGhlIG1heCAob25lIGZvciBhdWRpbywgb25lIGZvciB2aWRlbykuIElmIHdlJ3ZlIHJlYWNoIHRoaXMgbWF4IGdvIGFoZWFkIGFuZCBjcmVhdGUgdGhlIGJ1ZmZlcnMuXG4gICAgICB2YXIgcGVuZGluZ1RyYWNrc0NvdW50ID0gT2JqZWN0LmtleXMocGVuZGluZ1RyYWNrcykubGVuZ3RoO1xuICAgICAgaWYgKHBlbmRpbmdUcmFja3NDb3VudCAmJiAoIWJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgfHwgcGVuZGluZ1RyYWNrc0NvdW50ID09PSAyIHx8ICdhdWRpb3ZpZGVvJyBpbiBwZW5kaW5nVHJhY2tzKSkge1xuICAgICAgICAvLyBvaywgbGV0J3MgY3JlYXRlIHRoZW0gbm93ICFcbiAgICAgICAgdGhpcy5jcmVhdGVTb3VyY2VCdWZmZXJzKHBlbmRpbmdUcmFja3MpO1xuICAgICAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICAgICAgLy8gYXBwZW5kIGFueSBwZW5kaW5nIHNlZ21lbnRzIG5vdyAhXG4gICAgICAgIHZhciBidWZmZXJzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuICAgICAgICBpZiAoYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwge1xuICAgICAgICAgICAgdHJhY2tzOiB0aGlzLnRyYWNrc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgb3BlcmF0aW9uUXVldWUuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdjb3VsZCBub3QgY3JlYXRlIHNvdXJjZSBidWZmZXIgZm9yIG1lZGlhIGNvZGVjKHMpJyk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY3JlYXRlU291cmNlQnVmZmVycyA9IGZ1bmN0aW9uIGNyZWF0ZVNvdXJjZUJ1ZmZlcnModHJhY2tzKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG4gICAgICB2YXIgc291cmNlQnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXIsXG4gICAgICAgIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICAgIGlmICghbWVkaWFTb3VyY2UpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2NyZWF0ZVNvdXJjZUJ1ZmZlcnMgY2FsbGVkIHdoZW4gbWVkaWFTb3VyY2Ugd2FzIG51bGwnKTtcbiAgICAgIH1cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHRyYWNrTmFtZSkge1xuICAgICAgICBpZiAoIXNvdXJjZUJ1ZmZlclt0cmFja05hbWVdKSB7XG4gICAgICAgICAgdmFyIF90cmFjayRsZXZlbENvZGVjO1xuICAgICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwic291cmNlIGJ1ZmZlciBleGlzdHMgZm9yIHRyYWNrIFwiICsgdHJhY2tOYW1lICsgXCIsIGhvd2V2ZXIgdHJhY2sgZG9lcyBub3RcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5IHVubGVzcyBpdCBjb250YWlucyBtdWx0aXBsZSBjb21tYS1zZXBhcmF0ZWQgY29kZWMgdmFsdWVzXG4gICAgICAgICAgdmFyIGNvZGVjID0gKChfdHJhY2skbGV2ZWxDb2RlYyA9IHRyYWNrLmxldmVsQ29kZWMpID09IG51bGwgPyB2b2lkIDAgOiBfdHJhY2skbGV2ZWxDb2RlYy5pbmRleE9mKCcsJykpID09PSAtMSA/IHRyYWNrLmxldmVsQ29kZWMgOiB0cmFjay5jb2RlYztcbiAgICAgICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgICAgIGlmICh0cmFja05hbWUuc2xpY2UoMCwgNSkgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgY29kZWMgPSBnZXRDb2RlY0NvbXBhdGlibGVOYW1lKGNvZGVjLCBfdGhpczExLmFwcGVuZFNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtaW1lVHlwZSA9IHRyYWNrLmNvbnRhaW5lciArIFwiO2NvZGVjcz1cIiArIGNvZGVjO1xuICAgICAgICAgIF90aGlzMTEubG9nKFwiY3JlYXRpbmcgc291cmNlQnVmZmVyKFwiICsgbWltZVR5cGUgKyBcIilcIik7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0cmFja05hbWVdID0gbWVkaWFTb3VyY2UuYWRkU291cmNlQnVmZmVyKG1pbWVUeXBlKTtcbiAgICAgICAgICAgIHZhciBzYk5hbWUgPSB0cmFja05hbWU7XG4gICAgICAgICAgICBfdGhpczExLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ3VwZGF0ZXN0YXJ0JywgX3RoaXMxMS5fb25TQlVwZGF0ZVN0YXJ0KTtcbiAgICAgICAgICAgIF90aGlzMTEuYWRkQnVmZmVyTGlzdGVuZXIoc2JOYW1lLCAndXBkYXRlZW5kJywgX3RoaXMxMS5fb25TQlVwZGF0ZUVuZCk7XG4gICAgICAgICAgICBfdGhpczExLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ2Vycm9yJywgX3RoaXMxMS5fb25TQlVwZGF0ZUVycm9yKTtcbiAgICAgICAgICAgIC8vIE1hbmFnZWRTb3VyY2VCdWZmZXIgYnVmZmVyZWRjaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgIGlmIChfdGhpczExLmFwcGVuZFNvdXJjZSkge1xuICAgICAgICAgICAgICBfdGhpczExLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ2J1ZmZlcmVkY2hhbmdlJywgZnVuY3Rpb24gKHR5cGUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbWVkaWEgd2FzIGVqZWN0ZWQgY2hlY2sgZm9yIGEgY2hhbmdlLiBBZGRlZCByYW5nZXMgYXJlIHJlZHVuZGFudCB3aXRoIGNoYW5nZXMgb24gJ3VwZGF0ZWVuZCcgZXZlbnQuXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRSYW5nZXMgPSBldmVudC5yZW1vdmVkUmFuZ2VzO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkUmFuZ2VzICE9IG51bGwgJiYgcmVtb3ZlZFJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMTEuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRyYWNrTmFtZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzMTEudHJhY2tzW3RyYWNrTmFtZV0gPSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcjogc2IsXG4gICAgICAgICAgICAgIGNvZGVjOiBjb2RlYyxcbiAgICAgICAgICAgICAgY29udGFpbmVyOiB0cmFjay5jb250YWluZXIsXG4gICAgICAgICAgICAgIGxldmVsQ29kZWM6IHRyYWNrLmxldmVsQ29kZWMsXG4gICAgICAgICAgICAgIG1ldGFkYXRhOiB0cmFjay5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgaWQ6IHRyYWNrLmlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX3RoaXMxMS5lcnJvcihcImVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIF90aGlzMTEuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgIHNvdXJjZUJ1ZmZlck5hbWU6IHRyYWNrTmFtZSxcbiAgICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IgKHZhciB0cmFja05hbWUgaW4gdHJhY2tzKSB7XG4gICAgICAgIF9sb29wKHRyYWNrTmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uX29uU0JVcGRhdGVTdGFydCA9IGZ1bmN0aW9uIF9vblNCVXBkYXRlU3RhcnQodHlwZSkge1xuICAgICAgdmFyIG9wZXJhdGlvblF1ZXVlID0gdGhpcy5vcGVyYXRpb25RdWV1ZTtcbiAgICAgIHZhciBvcGVyYXRpb24gPSBvcGVyYXRpb25RdWV1ZS5jdXJyZW50KHR5cGUpO1xuICAgICAgb3BlcmF0aW9uLm9uU3RhcnQoKTtcbiAgICB9O1xuICAgIF9wcm90by5fb25TQlVwZGF0ZUVuZCA9IGZ1bmN0aW9uIF9vblNCVXBkYXRlRW5kKHR5cGUpIHtcbiAgICAgIHZhciBfdGhpcyRtZWRpYVNvdXJjZTI7XG4gICAgICBpZiAoKChfdGhpcyRtZWRpYVNvdXJjZTIgPSB0aGlzLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWFTb3VyY2UyLnJlYWR5U3RhdGUpID09PSAnY2xvc2VkJykge1xuICAgICAgICB0aGlzLnJlc2V0QnVmZmVyKHR5cGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlO1xuICAgICAgdmFyIG9wZXJhdGlvbiA9IG9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgICBvcGVyYXRpb24ub25Db21wbGV0ZSgpO1xuICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICB9O1xuICAgIF9wcm90by5fb25TQlVwZGF0ZUVycm9yID0gZnVuY3Rpb24gX29uU0JVcGRhdGVFcnJvcih0eXBlLCBldmVudCkge1xuICAgICAgdmFyIF90aGlzJG1lZGlhU291cmNlMztcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcih0eXBlICsgXCIgU291cmNlQnVmZmVyIGVycm9yLiBNZWRpYVNvdXJjZSByZWFkeVN0YXRlOiBcIiArICgoX3RoaXMkbWVkaWFTb3VyY2UzID0gdGhpcy5tZWRpYVNvdXJjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhU291cmNlMy5yZWFkeVN0YXRlKSk7XG4gICAgICB0aGlzLmVycm9yKFwiXCIgKyBlcnJvciwgZXZlbnQpO1xuICAgICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jc291cmNlYnVmZmVyLWFwcGVuZC1lcnJvclxuICAgICAgLy8gU291cmNlQnVmZmVyIGVycm9ycyBhcmUgbm90IG5lY2Vzc2FyaWx5IGZhdGFsOyBpZiBzbywgdGhlIEhUTUxNZWRpYUVsZW1lbnQgd2lsbCBmaXJlIGFuIGVycm9yIGV2ZW50XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORElOR19FUlJPUixcbiAgICAgICAgc291cmNlQnVmZmVyTmFtZTogdHlwZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gdXBkYXRlZW5kIGlzIGFsd2F5cyBmaXJlZCBhZnRlciBlcnJvciwgc28gd2UnbGwgYWxsb3cgdGhhdCB0byBzaGlmdCB0aGUgY3VycmVudCBvcGVyYXRpb24gb2ZmIG9mIHRoZSBxdWV1ZVxuICAgICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMub3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcbiAgICAgIGlmIChvcGVyYXRpb24pIHtcbiAgICAgICAgb3BlcmF0aW9uLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgbWV0aG9kIG11c3QgcmVzdWx0IGluIGFuIHVwZGF0ZWVuZCBldmVudDsgaWYgcmVtb3ZlIGlzIG5vdCBjYWxsZWQsIF9vblNCVXBkYXRlRW5kIG11c3QgYmUgY2FsbGVkIG1hbnVhbGx5XG4gICAgO1xuICAgIF9wcm90by5yZW1vdmVFeGVjdXRvciA9IGZ1bmN0aW9uIHJlbW92ZUV4ZWN1dG9yKHR5cGUsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZSxcbiAgICAgICAgb3BlcmF0aW9uUXVldWUgPSB0aGlzLm9wZXJhdGlvblF1ZXVlLFxuICAgICAgICBzb3VyY2VCdWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlcjtcbiAgICAgIHZhciBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgIGlmICghbWVkaWEgfHwgIW1lZGlhU291cmNlIHx8ICFzYikge1xuICAgICAgICB0aGlzLndhcm4oXCJBdHRlbXB0aW5nIHRvIHJlbW92ZSBmcm9tIHRoZSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdFwiKTtcbiAgICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG1lZGlhRHVyYXRpb24gPSBpc0Zpbml0ZU51bWJlcihtZWRpYS5kdXJhdGlvbikgPyBtZWRpYS5kdXJhdGlvbiA6IEluZmluaXR5O1xuICAgICAgdmFyIG1zRHVyYXRpb24gPSBpc0Zpbml0ZU51bWJlcihtZWRpYVNvdXJjZS5kdXJhdGlvbikgPyBtZWRpYVNvdXJjZS5kdXJhdGlvbiA6IEluZmluaXR5O1xuICAgICAgdmFyIHJlbW92ZVN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnRPZmZzZXQpO1xuICAgICAgdmFyIHJlbW92ZUVuZCA9IE1hdGgubWluKGVuZE9mZnNldCwgbWVkaWFEdXJhdGlvbiwgbXNEdXJhdGlvbik7XG4gICAgICBpZiAocmVtb3ZlRW5kID4gcmVtb3ZlU3RhcnQgJiYgKCFzYi5lbmRpbmcgfHwgc2IuZW5kZWQpKSB7XG4gICAgICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9nKFwiUmVtb3ZpbmcgW1wiICsgcmVtb3ZlU3RhcnQgKyBcIixcIiArIHJlbW92ZUVuZCArIFwiXSBmcm9tIHRoZSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXJcIik7XG4gICAgICAgIHNiLnJlbW92ZShyZW1vdmVTdGFydCwgcmVtb3ZlRW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEN5Y2xlIHRoZSBxdWV1ZVxuICAgICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgbWV0aG9kIG11c3QgcmVzdWx0IGluIGFuIHVwZGF0ZWVuZCBldmVudDsgaWYgYXBwZW5kIGlzIG5vdCBjYWxsZWQsIF9vblNCVXBkYXRlRW5kIG11c3QgYmUgY2FsbGVkIG1hbnVhbGx5XG4gICAgO1xuICAgIF9wcm90by5hcHBlbmRFeGVjdXRvciA9IGZ1bmN0aW9uIGFwcGVuZEV4ZWN1dG9yKGRhdGEsIHR5cGUpIHtcbiAgICAgIHZhciBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgaWYgKCFzYikge1xuICAgICAgICBpZiAoIXRoaXMucGVuZGluZ1RyYWNrc1t0eXBlXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRpbmcgdG8gYXBwZW5kIHRvIHRoZSBcIiArIHR5cGUgKyBcIiBTb3VyY2VCdWZmZXIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzYi5lbmRlZCA9IGZhbHNlO1xuICAgICAgc2IuYXBwZW5kQnVmZmVyKGRhdGEpO1xuICAgIH1cblxuICAgIC8vIEVucXVldWVzIGFuIG9wZXJhdGlvbiB0byBlYWNoIFNvdXJjZUJ1ZmZlciBxdWV1ZSB3aGljaCwgdXBvbiBleGVjdXRpb24sIHJlc29sdmVzIGEgcHJvbWlzZS4gV2hlbiBhbGwgcHJvbWlzZXNcbiAgICAvLyByZXNvbHZlLCB0aGUgb25VbmJsb2NrZWQgZnVuY3Rpb24gaXMgZXhlY3V0ZWQuIEZ1bmN0aW9ucyBjYWxsaW5nIHRoaXMgbWV0aG9kIGRvIG5vdCBuZWVkIHRvIHVuYmxvY2sgdGhlIHF1ZXVlXG4gICAgLy8gdXBvbiBjb21wbGV0aW9uLCBzaW5jZSB3ZSBhbHJlYWR5IGRvIGl0IGhlcmVcbiAgICA7XG4gICAgX3Byb3RvLmJsb2NrQnVmZmVycyA9IGZ1bmN0aW9uIGJsb2NrQnVmZmVycyhvblVuYmxvY2tlZCwgYnVmZmVycykge1xuICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuICAgICAgaWYgKGJ1ZmZlcnMgPT09IHZvaWQgMCkge1xuICAgICAgICBidWZmZXJzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuICAgICAgfVxuICAgICAgaWYgKCFidWZmZXJzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmxvZygnQmxvY2tpbmcgb3BlcmF0aW9uIHJlcXVlc3RlZCwgYnV0IG5vIFNvdXJjZUJ1ZmZlcnMgZXhpc3QnKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihvblVuYmxvY2tlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvcGVyYXRpb25RdWV1ZSA9IHRoaXMub3BlcmF0aW9uUXVldWU7XG5cbiAgICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogQmxvY2tpbmcgJHtidWZmZXJzfSBTb3VyY2VCdWZmZXJgKTtcbiAgICAgIHZhciBibG9ja2luZ09wZXJhdGlvbnMgPSBidWZmZXJzLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uUXVldWUuYXBwZW5kQmxvY2tlcih0eXBlKTtcbiAgICAgIH0pO1xuICAgICAgUHJvbWlzZS5hbGwoYmxvY2tpbmdPcGVyYXRpb25zKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBCbG9ja2luZyBvcGVyYXRpb24gcmVzb2x2ZWQ7IHVuYmxvY2tpbmcgJHtidWZmZXJzfSBTb3VyY2VCdWZmZXJgKTtcbiAgICAgICAgb25VbmJsb2NrZWQoKTtcbiAgICAgICAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgdmFyIHNiID0gX3RoaXMxMi5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgLy8gT25seSBjeWNsZSB0aGUgcXVldWUgaWYgdGhlIFNCIGlzIG5vdCB1cGRhdGluZy4gVGhlcmUncyBhIGJ1ZyBpbiBDaHJvbWUgd2hpY2ggc2V0cyB0aGUgU0IgdXBkYXRpbmcgZmxhZyB0b1xuICAgICAgICAgIC8vIHRydWUgd2hlbiBjaGFuZ2luZyB0aGUgTWVkaWFTb3VyY2UgZHVyYXRpb24gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk1OTM1OSZjYW49MiZxPW1lZGlhc291cmNlJTIwZHVyYXRpb24pXG4gICAgICAgICAgLy8gV2hpbGUgdGhpcyBpcyBhIHdvcmthcm91bmQsIGl0J3MgcHJvYmFibHkgdXNlZnVsIHRvIGhhdmUgYXJvdW5kXG4gICAgICAgICAgaWYgKCEoc2IgIT0gbnVsbCAmJiBzYi51cGRhdGluZykpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFNvdXJjZUJ1ZmZlclR5cGVzID0gZnVuY3Rpb24gZ2V0U291cmNlQnVmZmVyVHlwZXMoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXIpO1xuICAgIH07XG4gICAgX3Byb3RvLmFkZEJ1ZmZlckxpc3RlbmVyID0gZnVuY3Rpb24gYWRkQnVmZmVyTGlzdGVuZXIodHlwZSwgZXZlbnQsIGZuKSB7XG4gICAgICB2YXIgYnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGlzdGVuZXIgPSBmbi5iaW5kKHRoaXMsIHR5cGUpO1xuICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gICAgICB9KTtcbiAgICAgIGJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlQnVmZmVyTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQnVmZmVyTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBidWZmZXIgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgYnVmZmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobC5ldmVudCwgbC5saXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9jcmVhdGVDbGFzcyhCdWZmZXJDb250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcIm1lZGlhU3JjXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIF90aGlzJG1lZGlhLCBfdGhpcyRtZWRpYSRxdWVyeVNlbGU7XG4gICAgICAgIHZhciBtZWRpYSA9ICgoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzJG1lZGlhJHF1ZXJ5U2VsZSA9IF90aGlzJG1lZGlhLnF1ZXJ5U2VsZWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYSRxdWVyeVNlbGUuY2FsbChfdGhpcyRtZWRpYSwgJ3NvdXJjZScpKSB8fCB0aGlzLm1lZGlhO1xuICAgICAgICByZXR1cm4gbWVkaWEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhLnNyYztcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEJ1ZmZlckNvbnRyb2xsZXI7XG4gIH0oKTtcbiAgZnVuY3Rpb24gcmVtb3ZlU291cmNlQ2hpbGRyZW4obm9kZSkge1xuICAgIHZhciBzb3VyY2VDaGlsZHJlbiA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnc291cmNlJyk7XG4gICAgW10uc2xpY2UuY2FsbChzb3VyY2VDaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKHNvdXJjZSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkU291cmNlKG1lZGlhLCB1cmwpIHtcbiAgICB2YXIgc291cmNlID0gc2VsZi5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKTtcbiAgICBzb3VyY2UudHlwZSA9ICd2aWRlby9tcDQnO1xuICAgIHNvdXJjZS5zcmMgPSB1cmw7XG4gICAgbWVkaWEuYXBwZW5kQ2hpbGQoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBUaGlzIGNvZGUgd2FzIHBvcnRlZCBmcm9tIHRoZSBkYXNoLmpzIHByb2plY3QgYXQ6XG4gICAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9ibG9iL2RldmVsb3BtZW50L2V4dGVybmFscy9jZWE2MDgtcGFyc2VyLmpzXG4gICAqICAgaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9jb21taXQvODI2OWIyNmE3NjFlMDg1M2JiMjFkNzg3ODBlZDk0NTE0NGVjZGQ0ZCNkaWZmLTcxYmMyOTVhMmQ2YjZiNzA5M2ExZDMyOTBkNTNhNGIyXG4gICAqXG4gICAqIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgYXBwZWFycyBiZWxvdzpcbiAgICpcbiAgICogVGhlIGNvcHlyaWdodCBpbiB0aGlzIHNvZnR3YXJlIGlzIGJlaW5nIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSBCU0QgTGljZW5zZSxcbiAgICogaW5jbHVkZWQgYmVsb3cuIFRoaXMgc29mdHdhcmUgbWF5IGJlIHN1YmplY3QgdG8gb3RoZXIgdGhpcmQgcGFydHkgYW5kIGNvbnRyaWJ1dG9yXG4gICAqIHJpZ2h0cywgaW5jbHVkaW5nIHBhdGVudCByaWdodHMsIGFuZCBubyBzdWNoIHJpZ2h0cyBhcmUgZ3JhbnRlZCB1bmRlciB0aGlzIGxpY2Vuc2UuXG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE2LCBEQVNIIEluZHVzdHJ5IEZvcnVtLlxuICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICAgKlxuICAgKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuICAgKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gICAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICogIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAqICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vclxuICAgKiAgb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAgICogIDIuIE5laXRoZXIgdGhlIG5hbWUgb2YgRGFzaCBJbmR1c3RyeSBGb3J1bSBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICAgKiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICAgKiAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gICAqXG4gICAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIEFTIElTIEFORCBBTllcbiAgICogIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICogIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC5cbiAgICogIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsXG4gICAqICBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUXG4gICAqICBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gICAqICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAgICogIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAgICogIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gICAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgICovXG4gIC8qKlxuICAgKiAgRXhjZXB0aW9ucyBmcm9tIHJlZ3VsYXIgQVNDSUkuIENvZGVQb2ludHMgYXJlIG1hcHBlZCB0byBVVEYtMTYgY29kZXNcbiAgICovXG5cbiAgdmFyIHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzID0ge1xuICAgIDB4MmE6IDB4ZTEsXG4gICAgLy8gbG93ZXJjYXNlIGEsIGFjdXRlIGFjY2VudFxuICAgIDB4NWM6IDB4ZTksXG4gICAgLy8gbG93ZXJjYXNlIGUsIGFjdXRlIGFjY2VudFxuICAgIDB4NWU6IDB4ZWQsXG4gICAgLy8gbG93ZXJjYXNlIGksIGFjdXRlIGFjY2VudFxuICAgIDB4NWY6IDB4ZjMsXG4gICAgLy8gbG93ZXJjYXNlIG8sIGFjdXRlIGFjY2VudFxuICAgIDB4NjA6IDB4ZmEsXG4gICAgLy8gbG93ZXJjYXNlIHUsIGFjdXRlIGFjY2VudFxuICAgIDB4N2I6IDB4ZTcsXG4gICAgLy8gbG93ZXJjYXNlIGMgd2l0aCBjZWRpbGxhXG4gICAgMHg3YzogMHhmNyxcbiAgICAvLyBkaXZpc2lvbiBzeW1ib2xcbiAgICAweDdkOiAweGQxLFxuICAgIC8vIHVwcGVyY2FzZSBOIHRpbGRlXG4gICAgMHg3ZTogMHhmMSxcbiAgICAvLyBsb3dlcmNhc2UgbiB0aWxkZVxuICAgIDB4N2Y6IDB4MjU4OCxcbiAgICAvLyBGdWxsIGJsb2NrXG4gICAgLy8gVEhJUyBCTE9DSyBJTkNMVURFUyBUSEUgMTYgRVhURU5ERUQgKFRXTy1CWVRFKSBMSU5FIDIxIENIQVJBQ1RFUlNcbiAgICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTEgQU5EIExPVyBCRVRXRUVOIDB4MzAgQU5EIDB4M0ZcbiAgICAvLyBUSElTIE1FQU5TIFRIQVQgXFx4NTAgTVVTVCBCRSBBRERFRCBUTyBUSEUgVkFMVUVTXG4gICAgMHg4MDogMHhhZSxcbiAgICAvLyBSZWdpc3RlcmVkIHN5bWJvbCAoUilcbiAgICAweDgxOiAweGIwLFxuICAgIC8vIGRlZ3JlZSBzaWduXG4gICAgMHg4MjogMHhiZCxcbiAgICAvLyAxLzIgc3ltYm9sXG4gICAgMHg4MzogMHhiZixcbiAgICAvLyBJbnZlcnRlZCAob3BlbikgcXVlc3Rpb24gbWFya1xuICAgIDB4ODQ6IDB4MjEyMixcbiAgICAvLyBUcmFkZW1hcmsgc3ltYm9sIChUTSlcbiAgICAweDg1OiAweGEyLFxuICAgIC8vIENlbnRzIHN5bWJvbFxuICAgIDB4ODY6IDB4YTMsXG4gICAgLy8gUG91bmRzIHN0ZXJsaW5nXG4gICAgMHg4NzogMHgyNjZhLFxuICAgIC8vIE11c2ljIDgndGggbm90ZVxuICAgIDB4ODg6IDB4ZTAsXG4gICAgLy8gbG93ZXJjYXNlIGEsIGdyYXZlIGFjY2VudFxuICAgIDB4ODk6IDB4MjAsXG4gICAgLy8gdHJhbnNwYXJlbnQgc3BhY2UgKHJlZ3VsYXIpXG4gICAgMHg4YTogMHhlOCxcbiAgICAvLyBsb3dlcmNhc2UgZSwgZ3JhdmUgYWNjZW50XG4gICAgMHg4YjogMHhlMixcbiAgICAvLyBsb3dlcmNhc2UgYSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgICAweDhjOiAweGVhLFxuICAgIC8vIGxvd2VyY2FzZSBlLCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIDB4OGQ6IDB4ZWUsXG4gICAgLy8gbG93ZXJjYXNlIGksIGNpcmN1bWZsZXggYWNjZW50XG4gICAgMHg4ZTogMHhmNCxcbiAgICAvLyBsb3dlcmNhc2UgbywgY2lyY3VtZmxleCBhY2NlbnRcbiAgICAweDhmOiAweGZiLFxuICAgIC8vIGxvd2VyY2FzZSB1LCBjaXJjdW1mbGV4IGFjY2VudFxuICAgIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEyIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gICAgMHg5MDogMHhjMSxcbiAgICAvLyBjYXBpdGFsIGxldHRlciBBIHdpdGggYWN1dGVcbiAgICAweDkxOiAweGM5LFxuICAgIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBhY3V0ZVxuICAgIDB4OTI6IDB4ZDMsXG4gICAgLy8gY2FwaXRhbCBsZXR0ZXIgTyB3aXRoIGFjdXRlXG4gICAgMHg5MzogMHhkYSxcbiAgICAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggYWN1dGVcbiAgICAweDk0OiAweGRjLFxuICAgIC8vIGNhcGl0YWwgbGV0dGVyIFUgd2l0aCBkaWFyZXNpc1xuICAgIDB4OTU6IDB4ZmMsXG4gICAgLy8gbG93ZXJjYXNlIGxldHRlciBVIHdpdGggZGlhZXJlc2lzXG4gICAgMHg5NjogMHgyMDE4LFxuICAgIC8vIG9wZW5pbmcgc2luZ2xlIHF1b3RlXG4gICAgMHg5NzogMHhhMSxcbiAgICAvLyBpbnZlcnRlZCBleGNsYW1hdGlvbiBtYXJrXG4gICAgMHg5ODogMHgyYSxcbiAgICAvLyBhc3Rlcmlza1xuICAgIDB4OTk6IDB4MjAxOSxcbiAgICAvLyBjbG9zaW5nIHNpbmdsZSBxdW90ZVxuICAgIDB4OWE6IDB4MjUwMSxcbiAgICAvLyBib3ggZHJhd2luZ3MgaGVhdnkgaG9yaXpvbnRhbFxuICAgIDB4OWI6IDB4YTksXG4gICAgLy8gY29weXJpZ2h0IHNpZ25cbiAgICAweDljOiAweDIxMjAsXG4gICAgLy8gU2VydmljZSBtYXJrXG4gICAgMHg5ZDogMHgyMDIyLFxuICAgIC8vIChyb3VuZCkgYnVsbGV0XG4gICAgMHg5ZTogMHgyMDFjLFxuICAgIC8vIExlZnQgZG91YmxlIHF1b3RhdGlvbiBtYXJrXG4gICAgMHg5ZjogMHgyMDFkLFxuICAgIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAgIDB4YTA6IDB4YzAsXG4gICAgLy8gdXBwZXJjYXNlIEEsIGdyYXZlIGFjY2VudFxuICAgIDB4YTE6IDB4YzIsXG4gICAgLy8gdXBwZXJjYXNlIEEsIGNpcmN1bWZsZXhcbiAgICAweGEyOiAweGM3LFxuICAgIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxuICAgIDB4YTM6IDB4YzgsXG4gICAgLy8gdXBwZXJjYXNlIEUsIGdyYXZlIGFjY2VudFxuICAgIDB4YTQ6IDB4Y2EsXG4gICAgLy8gdXBwZXJjYXNlIEUsIGNpcmN1bWZsZXhcbiAgICAweGE1OiAweGNiLFxuICAgIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTY6IDB4ZWIsXG4gICAgLy8gbG93ZXJjYXNlIGxldHRlciBlIHdpdGggZGlhcmVzaXNcbiAgICAweGE3OiAweGNlLFxuICAgIC8vIHVwcGVyY2FzZSBJLCBjaXJjdW1mbGV4XG4gICAgMHhhODogMHhjZixcbiAgICAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xuICAgIDB4YTk6IDB4ZWYsXG4gICAgLy8gbG93ZXJjYXNlIGksIHdpdGggZGlhcmVzaXNcbiAgICAweGFhOiAweGQ0LFxuICAgIC8vIHVwcGVyY2FzZSBPLCBjaXJjdW1mbGV4XG4gICAgMHhhYjogMHhkOSxcbiAgICAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhYzogMHhmOSxcbiAgICAvLyBsb3dlcmNhc2UgdSwgZ3JhdmUgYWNjZW50XG4gICAgMHhhZDogMHhkYixcbiAgICAvLyB1cHBlcmNhc2UgVSwgY2lyY3VtZmxleFxuICAgIDB4YWU6IDB4YWIsXG4gICAgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgICAweGFmOiAweGJiLFxuICAgIC8vIHJpZ2h0LXBvaW50aW5nIGRvdWJsZSBhbmdsZSBxdW90YXRpb24gbWFya1xuICAgIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gICAgLy8gVEhBVCBDT01FIEZST00gSEkgQllURT0weDEzIEFORCBMT1cgQkVUV0VFTiAweDIwIEFORCAweDNGXG4gICAgMHhiMDogMHhjMyxcbiAgICAvLyBVcHBlcmNhc2UgQSwgdGlsZGVcbiAgICAweGIxOiAweGUzLFxuICAgIC8vIExvd2VyY2FzZSBhLCB0aWxkZVxuICAgIDB4YjI6IDB4Y2QsXG4gICAgLy8gVXBwZXJjYXNlIEksIGFjdXRlIGFjY2VudFxuICAgIDB4YjM6IDB4Y2MsXG4gICAgLy8gVXBwZXJjYXNlIEksIGdyYXZlIGFjY2VudFxuICAgIDB4YjQ6IDB4ZWMsXG4gICAgLy8gTG93ZXJjYXNlIGksIGdyYXZlIGFjY2VudFxuICAgIDB4YjU6IDB4ZDIsXG4gICAgLy8gVXBwZXJjYXNlIE8sIGdyYXZlIGFjY2VudFxuICAgIDB4YjY6IDB4ZjIsXG4gICAgLy8gTG93ZXJjYXNlIG8sIGdyYXZlIGFjY2VudFxuICAgIDB4Yjc6IDB4ZDUsXG4gICAgLy8gVXBwZXJjYXNlIE8sIHRpbGRlXG4gICAgMHhiODogMHhmNSxcbiAgICAvLyBMb3dlcmNhc2UgbywgdGlsZGVcbiAgICAweGI5OiAweDdiLFxuICAgIC8vIE9wZW4gY3VybHkgYnJhY2VcbiAgICAweGJhOiAweDdkLFxuICAgIC8vIENsb3NpbmcgY3VybHkgYnJhY2VcbiAgICAweGJiOiAweDVjLFxuICAgIC8vIEJhY2tzbGFzaFxuICAgIDB4YmM6IDB4NWUsXG4gICAgLy8gQ2FyZXRcbiAgICAweGJkOiAweDVmLFxuICAgIC8vIFVuZGVyc2NvcmVcbiAgICAweGJlOiAweDdjLFxuICAgIC8vIFBpcGUgKHZlcnRpY2FsIGxpbmUpXG4gICAgMHhiZjogMHgyMjNjLFxuICAgIC8vIFRpbGRlIG9wZXJhdG9yXG4gICAgMHhjMDogMHhjNCxcbiAgICAvLyBVcHBlcmNhc2UgQSwgdW1sYXV0XG4gICAgMHhjMTogMHhlNCxcbiAgICAvLyBMb3dlcmNhc2UgQSwgdW1sYXV0XG4gICAgMHhjMjogMHhkNixcbiAgICAvLyBVcHBlcmNhc2UgTywgdW1sYXV0XG4gICAgMHhjMzogMHhmNixcbiAgICAvLyBMb3dlcmNhc2UgbywgdW1sYXV0XG4gICAgMHhjNDogMHhkZixcbiAgICAvLyBFc3N6ZXR0IChzaGFycCBTKVxuICAgIDB4YzU6IDB4YTUsXG4gICAgLy8gWWVuIHN5bWJvbFxuICAgIDB4YzY6IDB4YTQsXG4gICAgLy8gR2VuZXJpYyBjdXJyZW5jeSBzaWduXG4gICAgMHhjNzogMHgyNTAzLFxuICAgIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB2ZXJ0aWNhbFxuICAgIDB4Yzg6IDB4YzUsXG4gICAgLy8gVXBwZXJjYXNlIEEsIHJpbmdcbiAgICAweGM5OiAweGU1LFxuICAgIC8vIExvd2VyY2FzZSBBLCByaW5nXG4gICAgMHhjYTogMHhkOCxcbiAgICAvLyBVcHBlcmNhc2UgTywgc3Ryb2tlXG4gICAgMHhjYjogMHhmOCxcbiAgICAvLyBMb3dlcmNhc2Ugbywgc3Ryb2tcbiAgICAweGNjOiAweDI1MGYsXG4gICAgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IGRvd24gYW5kIHJpZ2h0XG4gICAgMHhjZDogMHgyNTEzLFxuICAgIC8vIEJveCBkcmF3aW5ncyBoZWF2eSBkb3duIGFuZCBsZWZ0XG4gICAgMHhjZTogMHgyNTE3LFxuICAgIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgcmlnaHRcbiAgICAweGNmOiAweDI1MWIgLy8gQm94IGRyYXdpbmdzIGhlYXZ5IHVwIGFuZCBsZWZ0XG4gIH07XG5cbiAgLyoqXG4gICAqIFV0aWxzXG4gICAqL1xuICB2YXIgZ2V0Q2hhckZvckJ5dGUgPSBmdW5jdGlvbiBnZXRDaGFyRm9yQnl0ZShfYnl0ZSkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzW19ieXRlXSB8fCBfYnl0ZSk7XG4gIH07XG4gIHZhciBOUl9ST1dTID0gMTU7XG4gIHZhciBOUl9DT0xTID0gMTAwO1xuICAvLyBUYWJsZXMgdG8gbG9vayB1cCByb3cgZnJvbSBQQUMgZGF0YVxuICB2YXIgcm93c0xvd0NoMSA9IHtcbiAgICAweDExOiAxLFxuICAgIDB4MTI6IDMsXG4gICAgMHgxNTogNSxcbiAgICAweDE2OiA3LFxuICAgIDB4MTc6IDksXG4gICAgMHgxMDogMTEsXG4gICAgMHgxMzogMTIsXG4gICAgMHgxNDogMTRcbiAgfTtcbiAgdmFyIHJvd3NIaWdoQ2gxID0ge1xuICAgIDB4MTE6IDIsXG4gICAgMHgxMjogNCxcbiAgICAweDE1OiA2LFxuICAgIDB4MTY6IDgsXG4gICAgMHgxNzogMTAsXG4gICAgMHgxMzogMTMsXG4gICAgMHgxNDogMTVcbiAgfTtcbiAgdmFyIHJvd3NMb3dDaDIgPSB7XG4gICAgMHgxOTogMSxcbiAgICAweDFhOiAzLFxuICAgIDB4MWQ6IDUsXG4gICAgMHgxZTogNyxcbiAgICAweDFmOiA5LFxuICAgIDB4MTg6IDExLFxuICAgIDB4MWI6IDEyLFxuICAgIDB4MWM6IDE0XG4gIH07XG4gIHZhciByb3dzSGlnaENoMiA9IHtcbiAgICAweDE5OiAyLFxuICAgIDB4MWE6IDQsXG4gICAgMHgxZDogNixcbiAgICAweDFlOiA4LFxuICAgIDB4MWY6IDEwLFxuICAgIDB4MWI6IDEzLFxuICAgIDB4MWM6IDE1XG4gIH07XG4gIHZhciBiYWNrZ3JvdW5kQ29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ2JsYWNrJywgJ3RyYW5zcGFyZW50J107XG4gIHZhciBDYXB0aW9uc0xvZ2dlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FwdGlvbnNMb2dnZXIoKSB7XG4gICAgICB0aGlzLnRpbWUgPSBudWxsO1xuICAgICAgdGhpcy52ZXJib3NlTGV2ZWwgPSAwO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ2FwdGlvbnNMb2dnZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5sb2cgPSBmdW5jdGlvbiBsb2coc2V2ZXJpdHksIG1zZykge1xuICAgICAgaWYgKHRoaXMudmVyYm9zZUxldmVsID49IHNldmVyaXR5KSB7XG4gICAgICAgIHZhciBtID0gdHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJyA/IG1zZygpIDogbXNnO1xuICAgICAgICBsb2dnZXIubG9nKHRoaXMudGltZSArIFwiIFtcIiArIHNldmVyaXR5ICsgXCJdIFwiICsgbSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2FwdGlvbnNMb2dnZXI7XG4gIH0oKTtcbiAgdmFyIG51bUFycmF5VG9IZXhBcnJheSA9IGZ1bmN0aW9uIG51bUFycmF5VG9IZXhBcnJheShudW1BcnJheSkge1xuICAgIHZhciBoZXhBcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgIGhleEFycmF5LnB1c2gobnVtQXJyYXlbal0udG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleEFycmF5O1xuICB9O1xuICB2YXIgUGVuU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBlblN0YXRlKCkge1xuICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICAgIHRoaXMudW5kZXJsaW5lID0gZmFsc2U7XG4gICAgICB0aGlzLml0YWxpY3MgPSBmYWxzZTtcbiAgICAgIHRoaXMuYmFja2dyb3VuZCA9ICdibGFjayc7XG4gICAgICB0aGlzLmZsYXNoID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBfcHJvdG8yID0gUGVuU3RhdGUucHJvdG90eXBlO1xuICAgIF9wcm90bzIucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgICB0aGlzLnVuZGVybGluZSA9IGZhbHNlO1xuICAgICAgdGhpcy5pdGFsaWNzID0gZmFsc2U7XG4gICAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xuICAgICAgdGhpcy5mbGFzaCA9IGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvMi5zZXRTdHlsZXMgPSBmdW5jdGlvbiBzZXRTdHlsZXMoc3R5bGVzKSB7XG4gICAgICB2YXIgYXR0cmlicyA9IFsnZm9yZWdyb3VuZCcsICd1bmRlcmxpbmUnLCAnaXRhbGljcycsICdiYWNrZ3JvdW5kJywgJ2ZsYXNoJ107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0eWxlID0gYXR0cmlic1tpXTtcbiAgICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgICB0aGlzW3N0eWxlXSA9IHN0eWxlc1tzdHlsZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90bzIuaXNEZWZhdWx0ID0gZnVuY3Rpb24gaXNEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9yZWdyb3VuZCA9PT0gJ3doaXRlJyAmJiAhdGhpcy51bmRlcmxpbmUgJiYgIXRoaXMuaXRhbGljcyAmJiB0aGlzLmJhY2tncm91bmQgPT09ICdibGFjaycgJiYgIXRoaXMuZmxhc2g7XG4gICAgfTtcbiAgICBfcHJvdG8yLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMuZm9yZWdyb3VuZCA9PT0gb3RoZXIuZm9yZWdyb3VuZCAmJiB0aGlzLnVuZGVybGluZSA9PT0gb3RoZXIudW5kZXJsaW5lICYmIHRoaXMuaXRhbGljcyA9PT0gb3RoZXIuaXRhbGljcyAmJiB0aGlzLmJhY2tncm91bmQgPT09IG90aGVyLmJhY2tncm91bmQgJiYgdGhpcy5mbGFzaCA9PT0gb3RoZXIuZmxhc2g7XG4gICAgfTtcbiAgICBfcHJvdG8yLmNvcHkgPSBmdW5jdGlvbiBjb3B5KG5ld1BlblN0YXRlKSB7XG4gICAgICB0aGlzLmZvcmVncm91bmQgPSBuZXdQZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgICAgdGhpcy51bmRlcmxpbmUgPSBuZXdQZW5TdGF0ZS51bmRlcmxpbmU7XG4gICAgICB0aGlzLml0YWxpY3MgPSBuZXdQZW5TdGF0ZS5pdGFsaWNzO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3UGVuU3RhdGUuYmFja2dyb3VuZDtcbiAgICAgIHRoaXMuZmxhc2ggPSBuZXdQZW5TdGF0ZS5mbGFzaDtcbiAgICB9O1xuICAgIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnY29sb3I9JyArIHRoaXMuZm9yZWdyb3VuZCArICcsIHVuZGVybGluZT0nICsgdGhpcy51bmRlcmxpbmUgKyAnLCBpdGFsaWNzPScgKyB0aGlzLml0YWxpY3MgKyAnLCBiYWNrZ3JvdW5kPScgKyB0aGlzLmJhY2tncm91bmQgKyAnLCBmbGFzaD0nICsgdGhpcy5mbGFzaDtcbiAgICB9O1xuICAgIHJldHVybiBQZW5TdGF0ZTtcbiAgfSgpO1xuICAvKipcbiAgICogVW5pY29kZSBjaGFyYWN0ZXIgd2l0aCBzdHlsaW5nIGFuZCBiYWNrZ3JvdW5kLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHZhciBTdHlsZWRVbmljb2RlQ2hhciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVkVW5pY29kZUNoYXIoKSB7XG4gICAgICB0aGlzLnVjaGFyID0gJyAnO1xuICAgICAgdGhpcy5wZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvMyA9IFN0eWxlZFVuaWNvZGVDaGFyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8zLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnVjaGFyID0gJyAnO1xuICAgICAgdGhpcy5wZW5TdGF0ZS5yZXNldCgpO1xuICAgIH07XG4gICAgX3Byb3RvMy5zZXRDaGFyID0gZnVuY3Rpb24gc2V0Q2hhcih1Y2hhciwgbmV3UGVuU3RhdGUpIHtcbiAgICAgIHRoaXMudWNoYXIgPSB1Y2hhcjtcbiAgICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gICAgfTtcbiAgICBfcHJvdG8zLnNldFBlblN0YXRlID0gZnVuY3Rpb24gc2V0UGVuU3RhdGUobmV3UGVuU3RhdGUpIHtcbiAgICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gICAgfTtcbiAgICBfcHJvdG8zLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMudWNoYXIgPT09IG90aGVyLnVjaGFyICYmIHRoaXMucGVuU3RhdGUuZXF1YWxzKG90aGVyLnBlblN0YXRlKTtcbiAgICB9O1xuICAgIF9wcm90bzMuY29weSA9IGZ1bmN0aW9uIGNvcHkobmV3Q2hhcikge1xuICAgICAgdGhpcy51Y2hhciA9IG5ld0NoYXIudWNoYXI7XG4gICAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3Q2hhci5wZW5TdGF0ZSk7XG4gICAgfTtcbiAgICBfcHJvdG8zLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMudWNoYXIgPT09ICcgJyAmJiB0aGlzLnBlblN0YXRlLmlzRGVmYXVsdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlZFVuaWNvZGVDaGFyO1xuICB9KCk7XG4gIC8qKlxuICAgKiBDRUEtNjA4IHJvdyBjb25zaXN0aW5nIG9mIE5SX0NPTFMgaW5zdGFuY2VzIG9mIFN0eWxlZFVuaWNvZGVDaGFyLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHZhciBSb3cgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvdyhsb2dnZXIpIHtcbiAgICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgIHRoaXMuY3VyclBlblN0YXRlID0gbmV3IFBlblN0YXRlKCk7XG4gICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IG51bGw7XG4gICAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2hhcnMucHVzaChuZXcgU3R5bGVkVW5pY29kZUNoYXIoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG4gICAgdmFyIF9wcm90bzQgPSBSb3cucHJvdG90eXBlO1xuICAgIF9wcm90bzQuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uZXF1YWxzKG90aGVyLmNoYXJzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG80LmNvcHkgPSBmdW5jdGlvbiBjb3B5KG90aGVyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICB0aGlzLmNoYXJzW2ldLmNvcHkob3RoZXIuY2hhcnNbaV0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvNC5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMuY2hhcnNbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXQgdGhlIGN1cnNvciB0byBhIHZhbGlkIGNvbHVtbi5cbiAgICAgKi87XG4gICAgX3Byb3RvNC5zZXRDdXJzb3IgPSBmdW5jdGlvbiBzZXRDdXJzb3IoYWJzUG9zKSB7XG4gICAgICBpZiAodGhpcy5wb3MgIT09IGFic1Bvcykge1xuICAgICAgICB0aGlzLnBvcyA9IGFic1BvcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBvcyA8IDApIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdOZWdhdGl2ZSBjdXJzb3IgcG9zaXRpb24gJyArIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBvcyA+IE5SX0NPTFMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdUb28gbGFyZ2UgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zID0gTlJfQ09MUztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBjdXJzb3IgcmVsYXRpdmUgdG8gY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKi87XG4gICAgX3Byb3RvNC5tb3ZlQ3Vyc29yID0gZnVuY3Rpb24gbW92ZUN1cnNvcihyZWxQb3MpIHtcbiAgICAgIHZhciBuZXdQb3MgPSB0aGlzLnBvcyArIHJlbFBvcztcbiAgICAgIGlmIChyZWxQb3MgPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBvcyArIDE7IGkgPCBuZXdQb3MgKyAxOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmNoYXJzW2ldLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zZXRDdXJzb3IobmV3UG9zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCYWNrc3BhY2UsIG1vdmUgb25lIHN0ZXAgYmFjayBhbmQgY2xlYXIgY2hhcmFjdGVyLlxuICAgICAqLztcbiAgICBfcHJvdG80LmJhY2tTcGFjZSA9IGZ1bmN0aW9uIGJhY2tTcGFjZSgpIHtcbiAgICAgIHRoaXMubW92ZUN1cnNvcigtMSk7XG4gICAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKCcgJywgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgIH07XG4gICAgX3Byb3RvNC5pbnNlcnRDaGFyID0gZnVuY3Rpb24gaW5zZXJ0Q2hhcihfYnl0ZTIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoX2J5dGUyID49IDB4OTApIHtcbiAgICAgICAgLy8gRXh0ZW5kZWQgY2hhclxuICAgICAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgICAgfVxuICAgICAgdmFyIF9jaGFyID0gZ2V0Q2hhckZvckJ5dGUoX2J5dGUyKTtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSBOUl9DT0xTKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICdDYW5ub3QgaW5zZXJ0ICcgKyBfYnl0ZTIudG9TdHJpbmcoMTYpICsgJyAoJyArIF9jaGFyICsgJykgYXQgcG9zaXRpb24gJyArIF90aGlzLnBvcyArICcuIFNraXBwaW5nIGl0ISc7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNoYXJzW3RoaXMucG9zXS5zZXRDaGFyKF9jaGFyLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICB0aGlzLm1vdmVDdXJzb3IoMSk7XG4gICAgfTtcbiAgICBfcHJvdG80LmNsZWFyRnJvbVBvcyA9IGZ1bmN0aW9uIGNsZWFyRnJvbVBvcyhzdGFydFBvcykge1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSBzdGFydFBvczsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICB0aGlzLmNoYXJzW2ldLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG80LmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmNsZWFyRnJvbVBvcygwKTtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgIHRoaXMuY3VyclBlblN0YXRlLnJlc2V0KCk7XG4gICAgfTtcbiAgICBfcHJvdG80LmNsZWFyVG9FbmRPZlJvdyA9IGZ1bmN0aW9uIGNsZWFyVG9FbmRPZlJvdygpIHtcbiAgICAgIHRoaXMuY2xlYXJGcm9tUG9zKHRoaXMucG9zKTtcbiAgICB9O1xuICAgIF9wcm90bzQuZ2V0VGV4dFN0cmluZyA9IGZ1bmN0aW9uIGdldFRleHRTdHJpbmcoKSB7XG4gICAgICB2YXIgY2hhcnMgPSBbXTtcbiAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgICB2YXIgX2NoYXIyID0gdGhpcy5jaGFyc1tpXS51Y2hhcjtcbiAgICAgICAgaWYgKF9jaGFyMiAhPT0gJyAnKSB7XG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjaGFycy5wdXNoKF9jaGFyMik7XG4gICAgICB9XG4gICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvNC5zZXRQZW5TdHlsZXMgPSBmdW5jdGlvbiBzZXRQZW5TdHlsZXMoc3R5bGVzKSB7XG4gICAgICB0aGlzLmN1cnJQZW5TdGF0ZS5zZXRTdHlsZXMoc3R5bGVzKTtcbiAgICAgIHZhciBjdXJyQ2hhciA9IHRoaXMuY2hhcnNbdGhpcy5wb3NdO1xuICAgICAgY3VyckNoYXIuc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFJvdztcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBLZWVwIGEgQ0VBLTYwOCBzY3JlZW4gb2YgMzJ4MTUgc3R5bGVkIGNoYXJhY3RlcnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB2YXIgQ2FwdGlvblNjcmVlbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FwdGlvblNjcmVlbihsb2dnZXIpIHtcbiAgICAgIHRoaXMucm93cyA9IFtdO1xuICAgICAgdGhpcy5jdXJyUm93ID0gTlJfUk9XUyAtIDE7XG4gICAgICB0aGlzLm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBudWxsO1xuICAgICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICB0aGlzLnJvd3MucHVzaChuZXcgUm93KGxvZ2dlcikpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuICAgIHZhciBfcHJvdG81ID0gQ2FwdGlvblNjcmVlbi5wcm90b3R5cGU7XG4gICAgX3Byb3RvNS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnJSb3cgPSBOUl9ST1dTIC0gMTtcbiAgICB9O1xuICAgIF9wcm90bzUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgICB2YXIgZXF1YWwgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uZXF1YWxzKG90aGVyLnJvd3NbaV0pKSB7XG4gICAgICAgICAgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVxdWFsO1xuICAgIH07XG4gICAgX3Byb3RvNS5jb3B5ID0gZnVuY3Rpb24gY29weShvdGhlcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgdGhpcy5yb3dzW2ldLmNvcHkob3RoZXIucm93c1tpXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG81LmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5yb3dzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9O1xuICAgIF9wcm90bzUuYmFja1NwYWNlID0gZnVuY3Rpb24gYmFja1NwYWNlKCkge1xuICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgICAgcm93LmJhY2tTcGFjZSgpO1xuICAgIH07XG4gICAgX3Byb3RvNS5jbGVhclRvRW5kT2ZSb3cgPSBmdW5jdGlvbiBjbGVhclRvRW5kT2ZSb3coKSB7XG4gICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICByb3cuY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgY2hhcmFjdGVyICh3aXRob3V0IHN0eWxpbmcpIGluIHRoZSBjdXJyZW50IHJvdy5cbiAgICAgKi87XG4gICAgX3Byb3RvNS5pbnNlcnRDaGFyID0gZnVuY3Rpb24gaW5zZXJ0Q2hhcihfY2hhcjMpIHtcbiAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgIHJvdy5pbnNlcnRDaGFyKF9jaGFyMyk7XG4gICAgfTtcbiAgICBfcHJvdG81LnNldFBlbiA9IGZ1bmN0aW9uIHNldFBlbihzdHlsZXMpIHtcbiAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgIHJvdy5zZXRQZW5TdHlsZXMoc3R5bGVzKTtcbiAgICB9O1xuICAgIF9wcm90bzUubW92ZUN1cnNvciA9IGZ1bmN0aW9uIG1vdmVDdXJzb3IocmVsUG9zKSB7XG4gICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICByb3cubW92ZUN1cnNvcihyZWxQb3MpO1xuICAgIH07XG4gICAgX3Byb3RvNS5zZXRDdXJzb3IgPSBmdW5jdGlvbiBzZXRDdXJzb3IoYWJzUG9zKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ3NldEN1cnNvcjogJyArIGFic1Bvcyk7XG4gICAgICB2YXIgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgICByb3cuc2V0Q3Vyc29yKGFic1Bvcyk7XG4gICAgfTtcbiAgICBfcHJvdG81LnNldFBBQyA9IGZ1bmN0aW9uIHNldFBBQyhwYWNEYXRhKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ3BhY0RhdGEgPSAnICsgSlNPTi5zdHJpbmdpZnkocGFjRGF0YSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBuZXdSb3cgPSBwYWNEYXRhLnJvdyAtIDE7XG4gICAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgJiYgbmV3Um93IDwgdGhpcy5uclJvbGxVcFJvd3MgLSAxKSB7XG4gICAgICAgIG5ld1JvdyA9IHRoaXMubnJSb2xsVXBSb3dzIC0gMTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIHRoaXMgb25seSBhZmZlY3RzIFJvbGwtdXAgQ2FwdGlvbnMgYnkgY2hlY2tpbmcgdGhpcy5uclJvbGxVcFJvd3NcbiAgICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiB0aGlzLmN1cnJSb3cgIT09IG5ld1Jvdykge1xuICAgICAgICAvLyBjbGVhciBhbGwgcm93cyBmaXJzdFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICAgIHRoaXMucm93c1tpXS5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29weSB0aGlzLm5yUm9sbFVwUm93cyByb3dzIGZyb20gbGFzdE91dHB1dFNjcmVlbiBhbmQgcGxhY2UgaXQgaW4gdGhlIG5ld1JvdyBsb2NhdGlvblxuICAgICAgICAvLyB0b3BSb3dJbmRleCAtIHRoZSBzdGFydCBvZiByb3dzIHRvIGNvcHkgKGluY2x1c2l2ZSBpbmRleClcbiAgICAgICAgdmFyIHRvcFJvd0luZGV4ID0gdGhpcy5jdXJyUm93ICsgMSAtIHRoaXMubnJSb2xsVXBSb3dzO1xuICAgICAgICAvLyBXZSBvbmx5IGNvcHkgaWYgdGhlIGxhc3QgcG9zaXRpb24gd2FzIGFscmVhZHkgc2hvd24uXG4gICAgICAgIC8vIFdlIHVzZSB0aGUgY3VlU3RhcnRUaW1lIHZhbHVlIHRvIGNoZWNrIHRoaXMuXG4gICAgICAgIHZhciBsYXN0T3V0cHV0U2NyZWVuID0gdGhpcy5sYXN0T3V0cHV0U2NyZWVuO1xuICAgICAgICBpZiAobGFzdE91dHB1dFNjcmVlbikge1xuICAgICAgICAgIHZhciBwcmV2TGluZVRpbWUgPSBsYXN0T3V0cHV0U2NyZWVuLnJvd3NbdG9wUm93SW5kZXhdLmN1ZVN0YXJ0VGltZTtcbiAgICAgICAgICB2YXIgdGltZSA9IHRoaXMubG9nZ2VyLnRpbWU7XG4gICAgICAgICAgaWYgKHByZXZMaW5lVGltZSAhPT0gbnVsbCAmJiB0aW1lICE9PSBudWxsICYmIHByZXZMaW5lVGltZSA8IHRpbWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLm5yUm9sbFVwUm93czsgX2krKykge1xuICAgICAgICAgICAgICB0aGlzLnJvd3NbbmV3Um93IC0gdGhpcy5uclJvbGxVcFJvd3MgKyBfaSArIDFdLmNvcHkobGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4ICsgX2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY3VyclJvdyA9IG5ld1JvdztcbiAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICAgIGlmIChwYWNEYXRhLmluZGVudCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZW50ID0gcGFjRGF0YS5pbmRlbnQ7XG4gICAgICAgIHZhciBwcmV2UG9zID0gTWF0aC5tYXgoaW5kZW50IC0gMSwgMCk7XG4gICAgICAgIHJvdy5zZXRDdXJzb3IocGFjRGF0YS5pbmRlbnQpO1xuICAgICAgICBwYWNEYXRhLmNvbG9yID0gcm93LmNoYXJzW3ByZXZQb3NdLnBlblN0YXRlLmZvcmVncm91bmQ7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgICBmb3JlZ3JvdW5kOiBwYWNEYXRhLmNvbG9yLFxuICAgICAgICB1bmRlcmxpbmU6IHBhY0RhdGEudW5kZXJsaW5lLFxuICAgICAgICBpdGFsaWNzOiBwYWNEYXRhLml0YWxpY3MsXG4gICAgICAgIGJhY2tncm91bmQ6ICdibGFjaycsXG4gICAgICAgIGZsYXNoOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHRoaXMuc2V0UGVuKHN0eWxlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGJhY2tncm91bmQvZXh0cmEgZm9yZWdyb3VuZCwgYnV0IGZpcnN0IGRvIGJhY2tfc3BhY2UsIGFuZCB0aGVuIGluc2VydCBzcGFjZSAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLlxuICAgICAqLztcbiAgICBfcHJvdG81LnNldEJrZ0RhdGEgPSBmdW5jdGlvbiBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnYmtnRGF0YSA9ICcgKyBKU09OLnN0cmluZ2lmeShia2dEYXRhKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICAgIHRoaXMuc2V0UGVuKGJrZ0RhdGEpO1xuICAgICAgdGhpcy5pbnNlcnRDaGFyKDB4MjApOyAvLyBTcGFjZVxuICAgIH07XG4gICAgX3Byb3RvNS5zZXRSb2xsVXBSb3dzID0gZnVuY3Rpb24gc2V0Um9sbFVwUm93cyhuclJvd3MpIHtcbiAgICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnJSb3dzO1xuICAgIH07XG4gICAgX3Byb3RvNS5yb2xsVXAgPSBmdW5jdGlvbiByb2xsVXAoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coMywgJ3JvbGxfdXAgYnV0IG5yUm9sbFVwUm93cyBub3Qgc2V0IHlldCcpO1xuICAgICAgICByZXR1cm47IC8vIE5vdCBwcm9wZXJseSBzZXR1cFxuICAgICAgfVxuICAgICAgdGhpcy5sb2dnZXIubG9nKDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5nZXREaXNwbGF5VGV4dCgpO1xuICAgICAgfSk7XG4gICAgICB2YXIgdG9wUm93SW5kZXggPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3M7XG4gICAgICB2YXIgdG9wUm93ID0gdGhpcy5yb3dzLnNwbGljZSh0b3BSb3dJbmRleCwgMSlbMF07XG4gICAgICB0b3BSb3cuY2xlYXIoKTtcbiAgICAgIHRoaXMucm93cy5zcGxpY2UodGhpcy5jdXJyUm93LCAwLCB0b3BSb3cpO1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsICdSb2xsaW5nIHVwJyk7XG4gICAgICAvLyB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLlRFWFQsIHRoaXMuZ2V0X2Rpc3BsYXlfdGV4dCgpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXG4gICAgICovO1xuICAgIF9wcm90bzUuZ2V0RGlzcGxheVRleHQgPSBmdW5jdGlvbiBnZXREaXNwbGF5VGV4dChhc09uZVJvdykge1xuICAgICAgYXNPbmVSb3cgPSBhc09uZVJvdyB8fCBmYWxzZTtcbiAgICAgIHZhciBkaXNwbGF5VGV4dCA9IFtdO1xuICAgICAgdmFyIHRleHQgPSAnJztcbiAgICAgIHZhciByb3dOciA9IC0xO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgICAgdmFyIHJvd1RleHQgPSB0aGlzLnJvd3NbaV0uZ2V0VGV4dFN0cmluZygpO1xuICAgICAgICBpZiAocm93VGV4dCkge1xuICAgICAgICAgIHJvd05yID0gaSArIDE7XG4gICAgICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKCdSb3cgJyArIHJvd05yICsgXCI6ICdcIiArIHJvd1RleHQgKyBcIidcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2gocm93VGV4dC50cmltKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpc3BsYXlUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgICAgdGV4dCA9ICdbJyArIGRpc3BsYXlUZXh0LmpvaW4oJyB8ICcpICsgJ10nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICBfcHJvdG81LmdldFRleHRBbmRGb3JtYXQgPSBmdW5jdGlvbiBnZXRUZXh0QW5kRm9ybWF0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucm93cztcbiAgICB9O1xuICAgIHJldHVybiBDYXB0aW9uU2NyZWVuO1xuICB9KCk7XG5cbiAgLy8gdmFyIG1vZGVzID0gWydNT0RFX1JPTEwtVVAnLCAnTU9ERV9QT1AtT04nLCAnTU9ERV9QQUlOVC1PTicsICdNT0RFX1RFWFQnXTtcbiAgdmFyIENlYTYwOENoYW5uZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENlYTYwOENoYW5uZWwoY2hhbm5lbE51bWJlciwgb3V0cHV0RmlsdGVyLCBsb2dnZXIpIHtcbiAgICAgIHRoaXMuY2hOciA9IHZvaWQgMDtcbiAgICAgIHRoaXMub3V0cHV0RmlsdGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5tb2RlID0gdm9pZCAwO1xuICAgICAgdGhpcy52ZXJib3NlID0gdm9pZCAwO1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB2b2lkIDA7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IHZvaWQgMDtcbiAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY3VyclJvbGxVcFJvdyA9IHZvaWQgMDtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB2b2lkIDA7XG4gICAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgICAgdGhpcy5jaE5yID0gY2hhbm5lbE51bWJlcjtcbiAgICAgIHRoaXMub3V0cHV0RmlsdGVyID0gb3V0cHV0RmlsdGVyO1xuICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgIHRoaXMudmVyYm9zZSA9IDA7XG4gICAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBuZXcgQ2FwdGlvblNjcmVlbihsb2dnZXIpO1xuICAgICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxuICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuICAgIHZhciBfcHJvdG82ID0gQ2VhNjA4Q2hhbm5lbC5wcm90b3R5cGU7XG4gICAgX3Byb3RvNi5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgICAgdGhpcy5sYXN0T3V0cHV0U2NyZWVuLnJlc2V0KCk7XG4gICAgICB0aGlzLm91dHB1dEZpbHRlci5yZXNldCgpO1xuICAgICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvNi5nZXRIYW5kbGVyID0gZnVuY3Rpb24gZ2V0SGFuZGxlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLm91dHB1dEZpbHRlcjtcbiAgICB9O1xuICAgIF9wcm90bzYuc2V0SGFuZGxlciA9IGZ1bmN0aW9uIHNldEhhbmRsZXIobmV3SGFuZGxlcikge1xuICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIgPSBuZXdIYW5kbGVyO1xuICAgIH07XG4gICAgX3Byb3RvNi5zZXRQQUMgPSBmdW5jdGlvbiBzZXRQQUMocGFjRGF0YSkge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5zZXRQQUMocGFjRGF0YSk7XG4gICAgfTtcbiAgICBfcHJvdG82LnNldEJrZ0RhdGEgPSBmdW5jdGlvbiBzZXRCa2dEYXRhKGJrZ0RhdGEpIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgICB9O1xuICAgIF9wcm90bzYuc2V0TW9kZSA9IGZ1bmN0aW9uIHNldE1vZGUobmV3TW9kZSkge1xuICAgICAgaWYgKG5ld01vZGUgPT09IHRoaXMubW9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdNT0RFPScgKyBuZXdNb2RlO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy53cml0ZVNjcmVlbi5yZXNldCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubW9kZSAhPT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgfTtcbiAgICBfcHJvdG82Lmluc2VydENoYXJzID0gZnVuY3Rpb24gaW5zZXJ0Q2hhcnMoY2hhcnMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndyaXRlU2NyZWVuLmluc2VydENoYXIoY2hhcnNbaV0pO1xuICAgICAgfVxuICAgICAgdmFyIHNjcmVlbiA9IHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5ID8gJ0RJU1AnIDogJ05PTl9ESVNQJztcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzY3JlZW4gKyAnOiAnICsgX3RoaXMzLndyaXRlU2NyZWVuLmdldERpc3BsYXlUZXh0KHRydWUpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QQUlOVC1PTicgfHwgdGhpcy5tb2RlID09PSAnTU9ERV9ST0xMLVVQJykge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnRElTUExBWUVEOiAnICsgX3RoaXMzLmRpc3BsYXllZE1lbW9yeS5nZXREaXNwbGF5VGV4dCh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvNi5jY1JDTCA9IGZ1bmN0aW9uIGNjUkNMKCkge1xuICAgICAgLy8gUmVzdW1lIENhcHRpb24gTG9hZGluZyAoc3dpdGNoIG1vZGUgdG8gUG9wIE9uKVxuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsICdSQ0wgLSBSZXN1bWUgQ2FwdGlvbiBMb2FkaW5nJyk7XG4gICAgICB0aGlzLnNldE1vZGUoJ01PREVfUE9QLU9OJyk7XG4gICAgfTtcbiAgICBfcHJvdG82LmNjQlMgPSBmdW5jdGlvbiBjY0JTKCkge1xuICAgICAgLy8gQmFja1NwYWNlXG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0JTIC0gQmFja1NwYWNlJyk7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9URVhUJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLndyaXRlU2NyZWVuLmJhY2tTcGFjZSgpO1xuICAgICAgaWYgKHRoaXMud3JpdGVTY3JlZW4gPT09IHRoaXMuZGlzcGxheWVkTWVtb3J5KSB7XG4gICAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvNi5jY0FPRiA9IGZ1bmN0aW9uIGNjQU9GKCkge1xuICAgICAgLy8gUmVzZXJ2ZWQgKGZvcm1lcmx5IEFsYXJtIE9mZilcbiAgICB9O1xuICAgIF9wcm90bzYuY2NBT04gPSBmdW5jdGlvbiBjY0FPTigpIHtcbiAgICAgIC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcbiAgICB9O1xuICAgIF9wcm90bzYuY2NERVIgPSBmdW5jdGlvbiBjY0RFUigpIHtcbiAgICAgIC8vIERlbGV0ZSB0byBFbmQgb2YgUm93XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0RFUi0gRGVsZXRlIHRvIEVuZCBvZiBSb3cnKTtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoKTtcbiAgICB9O1xuICAgIF9wcm90bzYuY2NSVSA9IGZ1bmN0aW9uIGNjUlUobnJSb3dzKSB7XG4gICAgICAvLyBSb2xsLVVwIENhcHRpb25zLTIsMyxvciA0IFJvd3NcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnUlUoJyArIG5yUm93cyArICcpIC0gUm9sbCBVcCcpO1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1JPTEwtVVAnKTtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0Um9sbFVwUm93cyhuclJvd3MpO1xuICAgIH07XG4gICAgX3Byb3RvNi5jY0ZPTiA9IGZ1bmN0aW9uIGNjRk9OKCkge1xuICAgICAgLy8gRmxhc2ggT25cbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnRk9OIC0gRmxhc2ggT24nKTtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHtcbiAgICAgICAgZmxhc2g6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvNi5jY1JEQyA9IGZ1bmN0aW9uIGNjUkRDKCkge1xuICAgICAgLy8gUmVzdW1lIERpcmVjdCBDYXB0aW9uaW5nIChzd2l0Y2ggbW9kZSB0byBQYWludE9uKVxuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsICdSREMgLSBSZXN1bWUgRGlyZWN0IENhcHRpb25pbmcnKTtcbiAgICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QQUlOVC1PTicpO1xuICAgIH07XG4gICAgX3Byb3RvNi5jY1RSID0gZnVuY3Rpb24gY2NUUigpIHtcbiAgICAgIC8vIFRleHQgUmVzdGFydCBpbiB0ZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1RSJyk7XG4gICAgICB0aGlzLnNldE1vZGUoJ01PREVfVEVYVCcpO1xuICAgIH07XG4gICAgX3Byb3RvNi5jY1JURCA9IGZ1bmN0aW9uIGNjUlREKCkge1xuICAgICAgLy8gUmVzdW1lIFRleHQgRGlzcGxheSBpbiBUZXh0IG1vZGUgKG5vdCBzdXBwb3J0ZWQsIGhvd2V2ZXIpXG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JURCcpO1xuICAgICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgICB9O1xuICAgIF9wcm90bzYuY2NFRE0gPSBmdW5jdGlvbiBjY0VETSgpIHtcbiAgICAgIC8vIEVyYXNlIERpc3BsYXllZCBNZW1vcnlcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgICB9O1xuICAgIF9wcm90bzYuY2NDUiA9IGZ1bmN0aW9uIGNjQ1IoKSB7XG4gICAgICAvLyBDYXJyaWFnZSBSZXR1cm5cbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnQ1IgLSBDYXJyaWFnZSBSZXR1cm4nKTtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4ucm9sbFVwKCk7XG4gICAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUodHJ1ZSk7XG4gICAgfTtcbiAgICBfcHJvdG82LmNjRU5NID0gZnVuY3Rpb24gY2NFTk0oKSB7XG4gICAgICAvLyBFcmFzZSBOb24tRGlzcGxheWVkIE1lbW9yeVxuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB9O1xuICAgIF9wcm90bzYuY2NFT0MgPSBmdW5jdGlvbiBjY0VPQygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgLy8gRW5kIG9mIENhcHRpb24gKEZsaXAgTWVtb3JpZXMpXG4gICAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0VPQyAtIEVuZCBPZiBDYXB0aW9uJyk7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSB0bXA7XG4gICAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gJ0RJU1A6ICcgKyBfdGhpczQuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICAgIH07XG4gICAgX3Byb3RvNi5jY1RPID0gZnVuY3Rpb24gY2NUTyhuckNvbHMpIHtcbiAgICAgIC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnVE8oJyArIG5yQ29scyArICcpIC0gVGFiIE9mZnNldCcpO1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5tb3ZlQ3Vyc29yKG5yQ29scyk7XG4gICAgfTtcbiAgICBfcHJvdG82LmNjTUlEUk9XID0gZnVuY3Rpb24gY2NNSURST1coc2Vjb25kQnl0ZSkge1xuICAgICAgLy8gUGFyc2UgTUlEUk9XIGNvbW1hbmRcbiAgICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICAgIGZsYXNoOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHN0eWxlcy51bmRlcmxpbmUgPSBzZWNvbmRCeXRlICUgMiA9PT0gMTtcbiAgICAgIHN0eWxlcy5pdGFsaWNzID0gc2Vjb25kQnl0ZSA+PSAweDJlO1xuICAgICAgaWYgKCFzdHlsZXMuaXRhbGljcykge1xuICAgICAgICB2YXIgY29sb3JJbmRleCA9IE1hdGguZmxvb3Ioc2Vjb25kQnl0ZSAvIDIpIC0gMHgxMDtcbiAgICAgICAgdmFyIGNvbG9ycyA9IFsnd2hpdGUnLCAnZ3JlZW4nLCAnYmx1ZScsICdjeWFuJywgJ3JlZCcsICd5ZWxsb3cnLCAnbWFnZW50YSddO1xuICAgICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9IGNvbG9yc1tjb2xvckluZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnTUlEUk9XOiAnICsgSlNPTi5zdHJpbmdpZnkoc3R5bGVzKSk7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbihzdHlsZXMpO1xuICAgIH07XG4gICAgX3Byb3RvNi5vdXRwdXREYXRhVXBkYXRlID0gZnVuY3Rpb24gb3V0cHV0RGF0YVVwZGF0ZShkaXNwYXRjaCkge1xuICAgICAgaWYgKGRpc3BhdGNoID09PSB2b2lkIDApIHtcbiAgICAgICAgZGlzcGF0Y2ggPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0aW1lID0gdGhpcy5sb2dnZXIudGltZTtcbiAgICAgIGlmICh0aW1lID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgICBpZiAodGhpcy5jdWVTdGFydFRpbWUgPT09IG51bGwgJiYgIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xuICAgICAgICAgIC8vIFN0YXJ0IG9mIGEgbmV3IGN1ZVxuICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdGltZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZGlzcGxheWVkTWVtb3J5LmVxdWFscyh0aGlzLmxhc3RPdXRwdXRTY3JlZW4pKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHRpbWUsIHRoaXMubGFzdE91dHB1dFNjcmVlbik7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2ggJiYgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpID8gbnVsbCA6IHRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5jb3B5KHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90bzYuY3VlU3BsaXRBdFRpbWUgPSBmdW5jdGlvbiBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWx0ZXIubmV3Q3VlKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2VhNjA4Q2hhbm5lbDtcbiAgfSgpOyAvLyBXaWxsIGJlIDEgb3IgMiB3aGVuIHBhcnNpbmcgY2FwdGlvbnNcbiAgdmFyIENlYTYwOFBhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2VhNjA4UGFyc2VyKGZpZWxkLCBvdXQxLCBvdXQyKSB7XG4gICAgICB0aGlzLmNoYW5uZWxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5jdXJyZW50Q2hhbm5lbCA9IDA7XG4gICAgICB0aGlzLmNtZEhpc3RvcnkgPSBjcmVhdGVDbWRIaXN0b3J5KCk7XG4gICAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICAgIHZhciBsb2dnZXIgPSB0aGlzLmxvZ2dlciA9IG5ldyBDYXB0aW9uc0xvZ2dlcigpO1xuICAgICAgdGhpcy5jaGFubmVscyA9IFtudWxsLCBuZXcgQ2VhNjA4Q2hhbm5lbChmaWVsZCwgb3V0MSwgbG9nZ2VyKSwgbmV3IENlYTYwOENoYW5uZWwoZmllbGQgKyAxLCBvdXQyLCBsb2dnZXIpXTtcbiAgICB9XG4gICAgdmFyIF9wcm90bzcgPSBDZWE2MDhQYXJzZXIucHJvdG90eXBlO1xuICAgIF9wcm90bzcuZ2V0SGFuZGxlciA9IGZ1bmN0aW9uIGdldEhhbmRsZXIoY2hhbm5lbCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uZ2V0SGFuZGxlcigpO1xuICAgIH07XG4gICAgX3Byb3RvNy5zZXRIYW5kbGVyID0gZnVuY3Rpb24gc2V0SGFuZGxlcihjaGFubmVsLCBuZXdIYW5kbGVyKSB7XG4gICAgICB0aGlzLmNoYW5uZWxzW2NoYW5uZWxdLnNldEhhbmRsZXIobmV3SGFuZGxlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgZm9yIHRpbWUgdCBpbiBmb3JtcyBvZiBsaXN0IG9mIGJ5dGVzICh1bnNpZ25lZCBpbnRzKS4gVGhlIGJ5dGVzIGFyZSB0cmVhdGVkIGFzIHBhaXJzLlxuICAgICAqLztcbiAgICBfcHJvdG83LmFkZERhdGEgPSBmdW5jdGlvbiBhZGREYXRhKHRpbWUsIGJ5dGVMaXN0KSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgIHRoaXMubG9nZ2VyLnRpbWUgPSB0aW1lO1xuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAgIHZhciBhID0gYnl0ZUxpc3RbaV0gJiAweDdmO1xuICAgICAgICAgIHZhciBiID0gYnl0ZUxpc3RbaSArIDFdICYgMHg3ZjtcbiAgICAgICAgICB2YXIgY21kRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgY2hhcnNGb3VuZCA9IG51bGw7XG4gICAgICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzNS5sb2dnZXIubG9nKDMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdbJyArIG51bUFycmF5VG9IZXhBcnJheShbYnl0ZUxpc3RbaV0sIGJ5dGVMaXN0W2kgKyAxXV0pICsgJ10gLT4gKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY21kSGlzdG9yeSA9IF90aGlzNS5jbWRIaXN0b3J5O1xuICAgICAgICAgIHZhciBpc0NvbnRyb2xDb2RlID0gYSA+PSAweDEwICYmIGEgPD0gMHgxZjtcbiAgICAgICAgICBpZiAoaXNDb250cm9sQ29kZSkge1xuICAgICAgICAgICAgLy8gU2tpcCByZWR1bmRhbnQgY29udHJvbCBjb2Rlc1xuICAgICAgICAgICAgaWYgKGhhc0NtZFJlcGVhdGVkKGEsIGIsIGNtZEhpc3RvcnkpKSB7XG4gICAgICAgICAgICAgIHNldExhc3RDbWQobnVsbCwgbnVsbCwgY21kSGlzdG9yeSk7XG4gICAgICAgICAgICAgIF90aGlzNS5sb2dnZXIubG9nKDMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1JlcGVhdGVkIGNvbW1hbmQgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpIGlzIGRyb3BwZWQnO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRMYXN0Q21kKGEsIGIsIF90aGlzNS5jbWRIaXN0b3J5KTtcbiAgICAgICAgICAgIGNtZEZvdW5kID0gX3RoaXM1LnBhcnNlQ21kKGEsIGIpO1xuICAgICAgICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICAgICAgICBjbWRGb3VuZCA9IF90aGlzNS5wYXJzZU1pZHJvdyhhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgICAgY21kRm91bmQgPSBfdGhpczUucGFyc2VQQUMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgICAgICAgIGNtZEZvdW5kID0gX3RoaXM1LnBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldExhc3RDbWQobnVsbCwgbnVsbCwgY21kSGlzdG9yeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgICAgIGNoYXJzRm91bmQgPSBfdGhpczUucGFyc2VDaGFycyhhLCBiKTtcbiAgICAgICAgICAgIGlmIChjaGFyc0ZvdW5kKSB7XG4gICAgICAgICAgICAgIHZhciBjdXJyQ2hOciA9IF90aGlzNS5jdXJyZW50Q2hhbm5lbDtcbiAgICAgICAgICAgICAgaWYgKGN1cnJDaE5yICYmIGN1cnJDaE5yID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gX3RoaXM1LmNoYW5uZWxzW2N1cnJDaE5yXTtcbiAgICAgICAgICAgICAgICBjaGFubmVsLmluc2VydENoYXJzKGNoYXJzRm91bmQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzNS5sb2dnZXIubG9nKDIsICdObyBjaGFubmVsIGZvdW5kIHlldC4gVEVYVC1NT0RFPycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY21kRm91bmQgJiYgIWNoYXJzRm91bmQpIHtcbiAgICAgICAgICAgIF90aGlzNS5sb2dnZXIubG9nKDIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiQ291bGRuJ3QgcGFyc2UgY2xlYW5lZCBkYXRhIFwiICsgbnVtQXJyYXlUb0hleEFycmF5KFthLCBiXSkgKyAnIG9yaWc6ICcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2J5dGVMaXN0W2ldLCBieXRlTGlzdFtpICsgMV1dKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3JldDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZUxpc3QubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgX3JldCA9IF9sb29wKGkpO1xuICAgICAgICBpZiAoX3JldCA9PT0gMCkgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgQ29tbWFuZC5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGEgY29tbWFuZCB3YXMgZm91bmRcbiAgICAgKi87XG4gICAgX3Byb3RvNy5wYXJzZUNtZCA9IGZ1bmN0aW9uIHBhcnNlQ21kKGEsIGIpIHtcbiAgICAgIHZhciBjb25kMSA9IChhID09PSAweDE0IHx8IGEgPT09IDB4MWMgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDFkKSAmJiBiID49IDB4MjAgJiYgYiA8PSAweDJmO1xuICAgICAgdmFyIGNvbmQyID0gKGEgPT09IDB4MTcgfHwgYSA9PT0gMHgxZikgJiYgYiA+PSAweDIxICYmIGIgPD0gMHgyMztcbiAgICAgIGlmICghKGNvbmQxIHx8IGNvbmQyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgY2hOciA9IGEgPT09IDB4MTQgfHwgYSA9PT0gMHgxNSB8fCBhID09PSAweDE3ID8gMSA6IDI7XG4gICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG4gICAgICBpZiAoYSA9PT0gMHgxNCB8fCBhID09PSAweDE1IHx8IGEgPT09IDB4MWMgfHwgYSA9PT0gMHgxZCkge1xuICAgICAgICBpZiAoYiA9PT0gMHgyMCkge1xuICAgICAgICAgIGNoYW5uZWwuY2NSQ0woKTtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDIxKSB7XG4gICAgICAgICAgY2hhbm5lbC5jY0JTKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyMikge1xuICAgICAgICAgIGNoYW5uZWwuY2NBT0YoKTtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDIzKSB7XG4gICAgICAgICAgY2hhbm5lbC5jY0FPTigpO1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjQpIHtcbiAgICAgICAgICBjaGFubmVsLmNjREVSKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNSkge1xuICAgICAgICAgIGNoYW5uZWwuY2NSVSgyKTtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI2KSB7XG4gICAgICAgICAgY2hhbm5lbC5jY1JVKDMpO1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjcpIHtcbiAgICAgICAgICBjaGFubmVsLmNjUlUoNCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyOCkge1xuICAgICAgICAgIGNoYW5uZWwuY2NGT04oKTtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDI5KSB7XG4gICAgICAgICAgY2hhbm5lbC5jY1JEQygpO1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmEpIHtcbiAgICAgICAgICBjaGFubmVsLmNjVFIoKTtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAweDJiKSB7XG4gICAgICAgICAgY2hhbm5lbC5jY1JURCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmMpIHtcbiAgICAgICAgICBjaGFubmVsLmNjRURNKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZCkge1xuICAgICAgICAgIGNoYW5uZWwuY2NDUigpO1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmUpIHtcbiAgICAgICAgICBjaGFubmVsLmNjRU5NKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZikge1xuICAgICAgICAgIGNoYW5uZWwuY2NFT0MoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYSA9PSAweDE3IHx8IGEgPT0gMHgxRlxuICAgICAgICBjaGFubmVsLmNjVE8oYiAtIDB4MjApO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50Q2hhbm5lbCA9IGNoTnI7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAgICovO1xuICAgIF9wcm90bzcucGFyc2VNaWRyb3cgPSBmdW5jdGlvbiBwYXJzZU1pZHJvdyhhLCBiKSB7XG4gICAgICB2YXIgY2hOciA9IDA7XG4gICAgICBpZiAoKGEgPT09IDB4MTEgfHwgYSA9PT0gMHgxOSkgJiYgYiA+PSAweDIwICYmIGIgPD0gMHgyZikge1xuICAgICAgICBpZiAoYSA9PT0gMHgxMSkge1xuICAgICAgICAgIGNoTnIgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoTnIgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaE5yICE9PSB0aGlzLmN1cnJlbnRDaGFubmVsKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIubG9nKDAsICdNaXNtYXRjaCBjaGFubmVsIGluIG1pZHJvdyBwYXJzaW5nJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcbiAgICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5uZWwuY2NNSURST1coYik7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICdNSURST1cgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIFByZWFibGUgQWNjZXNzIENvZGVzIChUYWJsZSA1MykuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIFBBQyBmb3VuZFxuICAgICAqLztcbiAgICBfcHJvdG83LnBhcnNlUEFDID0gZnVuY3Rpb24gcGFyc2VQQUMoYSwgYikge1xuICAgICAgdmFyIHJvdztcbiAgICAgIHZhciBjYXNlMSA9IChhID49IDB4MTEgJiYgYSA8PSAweDE3IHx8IGEgPj0gMHgxOSAmJiBhIDw9IDB4MWYpICYmIGIgPj0gMHg0MCAmJiBiIDw9IDB4N2Y7XG4gICAgICB2YXIgY2FzZTIgPSAoYSA9PT0gMHgxMCB8fCBhID09PSAweDE4KSAmJiBiID49IDB4NDAgJiYgYiA8PSAweDVmO1xuICAgICAgaWYgKCEoY2FzZTEgfHwgY2FzZTIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBjaE5yID0gYSA8PSAweDE3ID8gMSA6IDI7XG4gICAgICBpZiAoYiA+PSAweDQwICYmIGIgPD0gMHg1Zikge1xuICAgICAgICByb3cgPSBjaE5yID09PSAxID8gcm93c0xvd0NoMVthXSA6IHJvd3NMb3dDaDJbYV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAweDYwIDw9IGIgPD0gMHg3RlxuICAgICAgICByb3cgPSBjaE5yID09PSAxID8gcm93c0hpZ2hDaDFbYV0gOiByb3dzSGlnaENoMlthXTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcbiAgICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaGFubmVsLnNldFBBQyh0aGlzLmludGVycHJldFBBQyhyb3csIGIpKTtcbiAgICAgIHRoaXMuY3VycmVudENoYW5uZWwgPSBjaE5yO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJwcmV0IHRoZSBzZWNvbmQgYnl0ZSBvZiB0aGUgcGFjLCBhbmQgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcmV0dXJucyBwYWNEYXRhIHdpdGggc3R5bGUgcGFyYW1ldGVyc1xuICAgICAqLztcbiAgICBfcHJvdG83LmludGVycHJldFBBQyA9IGZ1bmN0aW9uIGludGVycHJldFBBQyhyb3csIF9ieXRlMykge1xuICAgICAgdmFyIHBhY0luZGV4O1xuICAgICAgdmFyIHBhY0RhdGEgPSB7XG4gICAgICAgIGNvbG9yOiBudWxsLFxuICAgICAgICBpdGFsaWNzOiBmYWxzZSxcbiAgICAgICAgaW5kZW50OiBudWxsLFxuICAgICAgICB1bmRlcmxpbmU6IGZhbHNlLFxuICAgICAgICByb3c6IHJvd1xuICAgICAgfTtcbiAgICAgIGlmIChfYnl0ZTMgPiAweDVmKSB7XG4gICAgICAgIHBhY0luZGV4ID0gX2J5dGUzIC0gMHg2MDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhY0luZGV4ID0gX2J5dGUzIC0gMHg0MDtcbiAgICAgIH1cbiAgICAgIHBhY0RhdGEudW5kZXJsaW5lID0gKHBhY0luZGV4ICYgMSkgPT09IDE7XG4gICAgICBpZiAocGFjSW5kZXggPD0gMHhkKSB7XG4gICAgICAgIHBhY0RhdGEuY29sb3IgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnd2hpdGUnXVtNYXRoLmZsb29yKHBhY0luZGV4IC8gMildO1xuICAgICAgfSBlbHNlIGlmIChwYWNJbmRleCA8PSAweGYpIHtcbiAgICAgICAgcGFjRGF0YS5pdGFsaWNzID0gdHJ1ZTtcbiAgICAgICAgcGFjRGF0YS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWNEYXRhLmluZGVudCA9IE1hdGguZmxvb3IoKHBhY0luZGV4IC0gMHgxMCkgLyAyKSAqIDQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFjRGF0YTsgLy8gTm90ZSB0aGF0IHJvdyBoYXMgemVybyBvZmZzZXQuIFRoZSBzcGVjIHVzZXMgMS5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggMSB0byAyIGNvZGVzIGNvcnJlc3BvbmRpbmcgdG8gY2hhcnMsIGlmIGZvdW5kLiBudWxsIG90aGVyd2lzZS5cbiAgICAgKi87XG4gICAgX3Byb3RvNy5wYXJzZUNoYXJzID0gZnVuY3Rpb24gcGFyc2VDaGFycyhhLCBiKSB7XG4gICAgICB2YXIgY2hhbm5lbE5yO1xuICAgICAgdmFyIGNoYXJDb2RlcyA9IG51bGw7XG4gICAgICB2YXIgY2hhckNvZGUxID0gbnVsbDtcbiAgICAgIGlmIChhID49IDB4MTkpIHtcbiAgICAgICAgY2hhbm5lbE5yID0gMjtcbiAgICAgICAgY2hhckNvZGUxID0gYSAtIDg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGFubmVsTnIgPSAxO1xuICAgICAgICBjaGFyQ29kZTEgPSBhO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXJDb2RlMSA+PSAweDExICYmIGNoYXJDb2RlMSA8PSAweDEzKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICAgIHZhciBvbmVDb2RlO1xuICAgICAgICBpZiAoY2hhckNvZGUxID09PSAweDExKSB7XG4gICAgICAgICAgb25lQ29kZSA9IGIgKyAweDUwO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlMSA9PT0gMHgxMikge1xuICAgICAgICAgIG9uZUNvZGUgPSBiICsgMHg3MDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbmVDb2RlID0gYiArIDB4OTA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKDIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gXCJTcGVjaWFsIGNoYXIgJ1wiICsgZ2V0Q2hhckZvckJ5dGUob25lQ29kZSkgKyBcIicgaW4gY2hhbm5lbCBcIiArIGNoYW5uZWxOcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoYXJDb2RlcyA9IFtvbmVDb2RlXTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+PSAweDIwICYmIGEgPD0gMHg3Zikge1xuICAgICAgICBjaGFyQ29kZXMgPSBiID09PSAwID8gW2FdIDogW2EsIGJdO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXJDb2Rlcykge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coMywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiAnQ2hhciBjb2RlcyA9ICAnICsgbnVtQXJyYXlUb0hleEFycmF5KGNoYXJDb2Rlcykuam9pbignLCcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFyQ29kZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgZXh0ZW5kZWQgYmFja2dyb3VuZCBhdHRyaWJ1dGVzIGFzIHdlbGwgYXMgbmV3IGZvcmVncm91bmQgY29sb3IgYmxhY2suXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXG4gICAgICovO1xuICAgIF9wcm90bzcucGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHBhcnNlQmFja2dyb3VuZEF0dHJpYnV0ZXMoYSwgYikge1xuICAgICAgdmFyIGNhc2UxID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgYiA+PSAweDIwICYmIGIgPD0gMHgyZjtcbiAgICAgIHZhciBjYXNlMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MWYpICYmIGIgPj0gMHgyZCAmJiBiIDw9IDB4MmY7XG4gICAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4O1xuICAgICAgdmFyIGJrZ0RhdGEgPSB7fTtcbiAgICAgIGlmIChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpIHtcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChiIC0gMHgyMCkgLyAyKTtcbiAgICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZENvbG9yc1tpbmRleF07XG4gICAgICAgIGlmIChiICUgMiA9PT0gMSkge1xuICAgICAgICAgIGJrZ0RhdGEuYmFja2dyb3VuZCA9IGJrZ0RhdGEuYmFja2dyb3VuZCArICdfc2VtaSc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZCkge1xuICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmtnRGF0YS5mb3JlZ3JvdW5kID0gJ2JsYWNrJztcbiAgICAgICAgaWYgKGIgPT09IDB4MmYpIHtcbiAgICAgICAgICBia2dEYXRhLnVuZGVybGluZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaE5yID0gYSA8PSAweDE3ID8gMSA6IDI7XG4gICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbY2hOcl07XG4gICAgICBjaGFubmVsLnNldEJrZ0RhdGEoYmtnRGF0YSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCBzdGF0ZSBvZiBwYXJzZXIgYW5kIGl0cyBjaGFubmVscy5cbiAgICAgKi87XG4gICAgX3Byb3RvNy5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBPYmplY3Qua2V5cyh0aGlzLmNoYW5uZWxzKS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV07XG4gICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgY2hhbm5lbC5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRMYXN0Q21kKG51bGwsIG51bGwsIHRoaXMuY21kSGlzdG9yeSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlciB0aGUgZ2VuZXJhdGlvbiBvZiBhIGN1ZSwgYW5kIHRoZSBzdGFydCBvZiBhIG5ldyBvbmUgaWYgZGlzcGxheVNjcmVlbnMgYXJlIG5vdCBlbXB0eS5cbiAgICAgKi87XG4gICAgX3Byb3RvNy5jdWVTcGxpdEF0VGltZSA9IGZ1bmN0aW9uIGN1ZVNwbGl0QXRUaW1lKHQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbaV07XG4gICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgY2hhbm5lbC5jdWVTcGxpdEF0VGltZSh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENlYTYwOFBhcnNlcjtcbiAgfSgpO1xuICBmdW5jdGlvbiBzZXRMYXN0Q21kKGEsIGIsIGNtZEhpc3RvcnkpIHtcbiAgICBjbWRIaXN0b3J5LmEgPSBhO1xuICAgIGNtZEhpc3RvcnkuYiA9IGI7XG4gIH1cbiAgZnVuY3Rpb24gaGFzQ21kUmVwZWF0ZWQoYSwgYiwgY21kSGlzdG9yeSkge1xuICAgIHJldHVybiBjbWRIaXN0b3J5LmEgPT09IGEgJiYgY21kSGlzdG9yeS5iID09PSBiO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUNtZEhpc3RvcnkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IG51bGwsXG4gICAgICBiOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHZhciBPdXRwdXRGaWx0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE91dHB1dEZpbHRlcih0aW1lbGluZUNvbnRyb2xsZXIsIHRyYWNrTmFtZSkge1xuICAgICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuICAgICAgdGhpcy50cmFja05hbWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgICB0aGlzLmVuZFRpbWUgPSBudWxsO1xuICAgICAgdGhpcy5zY3JlZW4gPSBudWxsO1xuICAgICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIgPSB0aW1lbGluZUNvbnRyb2xsZXI7XG4gICAgICB0aGlzLnRyYWNrTmFtZSA9IHRyYWNrTmFtZTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IE91dHB1dEZpbHRlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmRpc3BhdGNoQ3VlID0gZnVuY3Rpb24gZGlzcGF0Y2hDdWUoKSB7XG4gICAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50aW1lbGluZUNvbnRyb2xsZXIuYWRkQ3Vlcyh0aGlzLnRyYWNrTmFtZSwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZW5kVGltZSwgdGhpcy5zY3JlZW4sIHRoaXMuY3VlUmFuZ2VzKTtcbiAgICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5uZXdDdWUgPSBmdW5jdGlvbiBuZXdDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pIHtcbiAgICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCB8fCB0aGlzLnN0YXJ0VGltZSA+IHN0YXJ0VGltZSkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgICB0aGlzLnNjcmVlbiA9IHNjcmVlbjtcbiAgICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyLmNyZWF0ZUNhcHRpb25zVHJhY2sodGhpcy50cmFja05hbWUpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmN1ZVJhbmdlcyA9IFtdO1xuICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIE91dHB1dEZpbHRlcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gICAqXG4gICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgKlxuICAgKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgKlxuICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsXG4gICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgKi9cblxuICB2YXIgVlRUQ3VlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAob3B0aW9uYWxTZWxmICE9IG51bGwgJiYgb3B0aW9uYWxTZWxmLlZUVEN1ZSkge1xuICAgICAgcmV0dXJuIHNlbGYuVlRUQ3VlO1xuICAgIH1cbiAgICB2YXIgQWxsb3dlZERpcmVjdGlvbnMgPSBbJycsICdscicsICdybCddO1xuICAgIHZhciBBbGxvd2VkQWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnbWlkZGxlJywgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J107XG4gICAgZnVuY3Rpb24gaXNBbGxvd2VkVmFsdWUoYWxsb3dlZCwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIG5lY2Vzc2FyeSBmb3IgYXNzdXJpbmcgdGhlIGdlbmVyaWMgY29uZm9ybXMgdG8gdGhlIEFycmF5IGludGVyZmFjZVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFsbG93ZWQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIHJlc2V0IHRoZSB0eXBlIHNvIHRoYXQgdGhlIG5leHQgbmFycm93aW5nIHdvcmtzIHdlbGxcbiAgICAgIHZhciBsY1ZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIC8vIHVzZSB0aGUgYWxsb3cgbGlzdCB0byBuYXJyb3cgdGhlIHR5cGUgdG8gYSBzcGVjaWZpYyBzdWJzZXQgb2Ygc3RyaW5nc1xuICAgICAgaWYgKH5hbGxvd2VkLmluZGV4T2YobGNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGxjVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBbGxvd2VkVmFsdWUoQWxsb3dlZERpcmVjdGlvbnMsIHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEFsaWduU2V0dGluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQWxsb3dlZFZhbHVlKEFsbG93ZWRBbGlnbm1lbnRzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgcmVzdFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICB2YXIgaSA9IDE7XG4gICAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29iaiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb2JqKSB7XG4gICAgICAgICAgb2JqW3BdID0gY29ialtwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZnVuY3Rpb24gVlRUQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xuICAgICAgdmFyIGN1ZSA9IHRoaXM7XG4gICAgICB2YXIgYmFzZU9iaiA9IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogU2hpbSBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBwcm9wZXJ0aWVzLiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgaW5cbiAgICAgICAqIHRoZSBzcGVjLlxuICAgICAgICovXG5cbiAgICAgIC8vIExldHMgdXMga25vdyB3aGVuIHRoZSBWVFRDdWUncyBkYXRhIGhhcyBjaGFuZ2VkIGluIHN1Y2ggYSB3YXkgdGhhdCB3ZSBuZWVkXG4gICAgICAvLyB0byByZWNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGUuIFRoaXMgbGV0cyB1cyBjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlXG4gICAgICAvLyBsYXppbHkuXG4gICAgICBjdWUuaGFzQmVlblJlc2V0ID0gZmFsc2U7XG5cbiAgICAgIC8qKlxuICAgICAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xuICAgICAgICogaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRjdWUtaW50ZXJmYWNlXG4gICAgICAgKi9cblxuICAgICAgdmFyIF9pZCA9ICcnO1xuICAgICAgdmFyIF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xuICAgICAgdmFyIF9zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICB2YXIgX2VuZFRpbWUgPSBlbmRUaW1lO1xuICAgICAgdmFyIF90ZXh0ID0gdGV4dDtcbiAgICAgIHZhciBfcmVnaW9uID0gbnVsbDtcbiAgICAgIHZhciBfdmVydGljYWwgPSAnJztcbiAgICAgIHZhciBfc25hcFRvTGluZXMgPSB0cnVlO1xuICAgICAgdmFyIF9saW5lID0gJ2F1dG8nO1xuICAgICAgdmFyIF9saW5lQWxpZ24gPSAnc3RhcnQnO1xuICAgICAgdmFyIF9wb3NpdGlvbiA9IDUwO1xuICAgICAgdmFyIF9wb3NpdGlvbkFsaWduID0gJ21pZGRsZSc7XG4gICAgICB2YXIgX3NpemUgPSA1MDtcbiAgICAgIHZhciBfYWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdpZCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX2lkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIF9pZCA9ICcnICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwYXVzZU9uRXhpdCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX3BhdXNlT25FeGl0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzdGFydFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF9zdGFydFRpbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N0YXJ0IHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9zdGFydFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdlbmRUaW1lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBfZW5kVGltZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5kIHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lbmRUaW1lID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndGV4dCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX3RleHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgX3RleHQgPSAnJyArIHZhbHVlO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICAvLyB0b2RvOiBpbXBsZW1lbnQgVlRUUmVnaW9uIHBvbHlmaWxsP1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3JlZ2lvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gX3JlZ2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBfcmVnaW9uID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndmVydGljYWwnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF92ZXJ0aWNhbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBiZWNhdXNlIHRoZSBzZXR0aW5nIGFuIGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdmVydGljYWwgPSBzZXR0aW5nO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NuYXBUb0xpbmVzJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBfc25hcFRvTGluZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgX3NuYXBUb0xpbmVzID0gISF2YWx1ZTtcbiAgICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdsaW5lJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBfbGluZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9saW5lID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZUFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBfbGluZUFsaWduO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XG4gICAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAncG9zaXRpb24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uQWxpZ24nLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3Bvc2l0aW9uQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3NpemUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2FsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfYWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICAvKipcbiAgICAgICAqIE90aGVyIDx0cmFjaz4gc3BlYyBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICAgICAqL1xuXG4gICAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtdmlkZW8tZWxlbWVudC5odG1sI3RleHQtdHJhY2stY3VlLWRpc3BsYXktc3RhdGVcbiAgICAgIGN1ZS5kaXNwbGF5U3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVlRUQ3VlIG1ldGhvZHNcbiAgICAgKi9cblxuICAgIFZUVEN1ZS5wcm90b3R5cGUuZ2V0Q3VlQXNIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQXNzdW1lIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlIGlzIG9uIHRoZSBnbG9iYWwuXG4gICAgICB2YXIgV2ViVlRUID0gc2VsZi5XZWJWVFQ7XG4gICAgICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUoc2VsZiwgdGhpcy50ZXh0KTtcbiAgICB9O1xuICAgIC8vIHRoaXMgaXMgYSBwb2x5ZmlsbCBoYWNrXG4gICAgcmV0dXJuIFZUVEN1ZTtcbiAgfSkoKTtcblxuICAvKlxuICAgKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcy9ibG9iL21hc3Rlci9kaXN0L3Z0dC5qc1xuICAgKi9cblxuICB2YXIgU3RyaW5nRGVjb2RlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nRGVjb2RlcigpIHt9XG4gICAgdmFyIF9wcm90byA9IFN0cmluZ0RlY29kZXIucHJvdG90eXBlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBfcHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgLSBleHBlY3RlZCBzdHJpbmcgZGF0YS4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdEZWNvZGVyO1xuICB9KCk7IC8vIFRyeSB0byBwYXJzZSBpbnB1dCBhcyBhIHRpbWUgc3RhbXAuXG4gIGZ1bmN0aW9uIHBhcnNlVGltZVN0YW1wKGlucHV0KSB7XG4gICAgZnVuY3Rpb24gY29tcHV0ZVNlY29uZHMoaCwgbSwgcywgZikge1xuICAgICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIHBhcnNlRmxvYXQoZiB8fCAwKTtcbiAgICB9XG4gICAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXig/OihcXGQrKTopPyhcXGR7Mn0pOihcXGR7Mn0pKFxcLlxcZCspPy8pO1xuICAgIGlmICghbSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwYXJzZUZsb2F0KG1bMl0pID4gNTkpIHtcbiAgICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXS5bbWlsbGlzZWNvbmRzXVxuICAgICAgLy8gRmlyc3QgcG9zaXRpb24gaXMgaG91cnMgYXMgaXQncyBvdmVyIDU5LlxuICAgICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMl0sIG1bM10sIDAsIG1bNF0pO1xuICAgIH1cbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzIChvcHRpb25hbCldOlttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgbVszXSwgbVs0XSk7XG4gIH1cblxuICAvLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3RcbiAgLy8gYXNzaWdubWVudCB0byBhIHNwZWNpZmljIGtleS5cbiAgdmFyIFNldHRpbmdzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXR0aW5ncygpIHtcbiAgICAgIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgdmFyIF9wcm90bzIgPSBTZXR0aW5ncy5wcm90b3R5cGU7XG4gICAgLy8gT25seSBhY2NlcHQgdGhlIGZpcnN0IGFzc2lnbm1lbnQgdG8gYW55IGtleS5cbiAgICBfcHJvdG8yLnNldCA9IGZ1bmN0aW9uIHNldChrLCB2KSB7XG4gICAgICBpZiAoIXRoaXMuZ2V0KGspICYmIHYgIT09ICcnKSB7XG4gICAgICAgIHRoaXMudmFsdWVzW2tdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgYSBrZXksIG9yIGEgZGVmYXVsdCB2YWx1ZS5cbiAgICAvLyBJZiAnZGVmYXVsdEtleScgaXMgcGFzc2VkIHRoZW4gJ2RmbHQnIGlzIGFzc3VtZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGhcbiAgICAvLyBhIG51bWJlciBvZiBwb3NzaWJsZSBkZWZhdWx0IHZhbHVlcyBhcyBwcm9wZXJ0aWVzIHdoZXJlICdkZWZhdWx0S2V5JyBpc1xuICAgIC8vIHRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBjaG9zZW47IG90aGVyd2lzZSBpdCdzIGFzc3VtZWQgdG8gYmVcbiAgICAvLyBhIHNpbmdsZSB2YWx1ZS5cbiAgICA7XG4gICAgX3Byb3RvMi5nZXQgPSBmdW5jdGlvbiBnZXQoaywgZGZsdCwgZGVmYXVsdEtleSkge1xuICAgICAgaWYgKGRlZmF1bHRLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0W2RlZmF1bHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xuICAgIH1cbiAgICAvLyBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSB2YWx1ZSBmb3IgYSBrZXkuXG4gICAgO1xuICAgIF9wcm90bzIuaGFzID0gZnVuY3Rpb24gaGFzKGspIHtcbiAgICAgIHJldHVybiBrIGluIHRoaXMudmFsdWVzO1xuICAgIH1cbiAgICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgICA7XG4gICAgX3Byb3RvMi5hbHQgPSBmdW5jdGlvbiBhbHQoaywgdiwgYSkge1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIGlmICh2ID09PSBhW25dKSB7XG4gICAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICAgIDtcbiAgICBfcHJvdG8yLmludGVnZXIgPSBmdW5jdGlvbiBpbnRlZ2VyKGssIHYpIHtcbiAgICAgIGlmICgvXi0/XFxkKyQvLnRlc3QodikpIHtcbiAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICB0aGlzLnNldChrLCBwYXJzZUludCh2LCAxMCkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXG4gICAgO1xuICAgIF9wcm90bzIucGVyY2VudCA9IGZ1bmN0aW9uIHBlcmNlbnQoaywgdikge1xuICAgICAgaWYgKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvLnRlc3QodikpIHtcbiAgICAgICAgdmFyIHBlcmNlbnQgPSBwYXJzZUZsb2F0KHYpO1xuICAgICAgICBpZiAocGVyY2VudCA+PSAwICYmIHBlcmNlbnQgPD0gMTAwKSB7XG4gICAgICAgICAgdGhpcy5zZXQoaywgcGVyY2VudCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBTZXR0aW5ncztcbiAgfSgpOyAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gcGFyc2UgaW5wdXQgaW50byBncm91cHMgc2VwYXJhdGVkIGJ5ICdncm91cERlbGltJywgYW5kXG4gIC8vIGludGVycHJldCBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cbiAgZnVuY3Rpb24gcGFyc2VPcHRpb25zKGlucHV0LCBjYWxsYmFjaywga2V5VmFsdWVEZWxpbSwgZ3JvdXBEZWxpbSkge1xuICAgIHZhciBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xuICAgIGZvciAodmFyIGkgaW4gZ3JvdXBzKSB7XG4gICAgICBpZiAodHlwZW9mIGdyb3Vwc1tpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIga3YgPSBncm91cHNbaV0uc3BsaXQoa2V5VmFsdWVEZWxpbSk7XG4gICAgICBpZiAoa3YubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIF9rID0ga3ZbMF07XG4gICAgICB2YXIgX3YgPSBrdlsxXTtcbiAgICAgIGNhbGxiYWNrKF9rLCBfdik7XG4gICAgfVxuICB9XG4gIHZhciBkZWZhdWx0cyA9IG5ldyBWVFRDdWUoMCwgMCwgJycpO1xuICAvLyAnbWlkZGxlJyB3YXMgY2hhbmdlZCB0byAnY2VudGVyJyBpbiB0aGUgc3BlYzogaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJ2dHQvcHVsbC8yNDRcbiAgLy8gIFNhZmFyaSBkb2Vzbid0IHlldCBzdXBwb3J0IHRoaXMgY2hhbmdlLCBidXQgRkYgYW5kIENocm9tZSBkby5cbiAgdmFyIGNlbnRlciA9IGRlZmF1bHRzLmFsaWduID09PSAnbWlkZGxlJyA/ICdtaWRkbGUnIDogJ2NlbnRlcic7XG4gIGZ1bmN0aW9uIHBhcnNlQ3VlKGlucHV0LCBjdWUsIHJlZ2lvbkxpc3QpIHtcbiAgICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgICB2YXIgb0lucHV0ID0gaW5wdXQ7XG4gICAgLy8gNC4xIFdlYlZUVCB0aW1lc3RhbXBcbiAgICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wKCkge1xuICAgICAgdmFyIHRzID0gcGFyc2VUaW1lU3RhbXAoaW5wdXQpO1xuICAgICAgaWYgKHRzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIHRpbWVzdGFtcDogJyArIG9JbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aW1lIHN0YW1wIGZyb20gaW5wdXQuXG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15bXlxcc2EtekEtWi1dKy8sICcnKTtcbiAgICAgIHJldHVybiB0cztcbiAgICB9XG5cbiAgICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXG4gICAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICB2YXIgdmFscztcbiAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgICAgY2FzZSAncmVnaW9uJzpcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgcmVnaW9uIHdlIHBhcnNlZCB3aXRoIHRoZSBzYW1lIHJlZ2lvbiBpZC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSByZWdpb25MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHJlZ2lvbkxpc3RbaV0ucmVnaW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsncmwnLCAnbHInXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgICAgIHZhbHMgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHNbMF0pO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSkpIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3Muc2V0KCdzbmFwVG9MaW5lcycsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzWzBdLCBbJ2F1dG8nXSk7XG4gICAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdsaW5lQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSk7XG4gICAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdwb3NpdGlvbkFsaWduJywgdmFsc1sxXSwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsaW5lLWxlZnQnLCAnbGluZS1yaWdodCcsICdhdXRvJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2l6ZSc6XG4gICAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYWxpZ24nOlxuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGVmdCcsICdyaWdodCddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LCAvOi8sIC9cXHMvKTtcblxuICAgICAgLy8gQXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIGFueSBtaXNzaW5nIGZpZWxkcy5cbiAgICAgIGN1ZS5yZWdpb24gPSBzZXR0aW5ncy5nZXQoJ3JlZ2lvbicsIG51bGwpO1xuICAgICAgY3VlLnZlcnRpY2FsID0gc2V0dGluZ3MuZ2V0KCd2ZXJ0aWNhbCcsICcnKTtcbiAgICAgIHZhciBsaW5lID0gc2V0dGluZ3MuZ2V0KCdsaW5lJywgJ2F1dG8nKTtcbiAgICAgIGlmIChsaW5lID09PSAnYXV0bycgJiYgZGVmYXVsdHMubGluZSA9PT0gLTEpIHtcbiAgICAgICAgLy8gc2V0IG51bWVyaWMgbGluZSBudW1iZXIgZm9yIFNhZmFyaVxuICAgICAgICBsaW5lID0gLTE7XG4gICAgICB9XG4gICAgICBjdWUubGluZSA9IGxpbmU7XG4gICAgICBjdWUubGluZUFsaWduID0gc2V0dGluZ3MuZ2V0KCdsaW5lQWxpZ24nLCAnc3RhcnQnKTtcbiAgICAgIGN1ZS5zbmFwVG9MaW5lcyA9IHNldHRpbmdzLmdldCgnc25hcFRvTGluZXMnLCB0cnVlKTtcbiAgICAgIGN1ZS5zaXplID0gc2V0dGluZ3MuZ2V0KCdzaXplJywgMTAwKTtcbiAgICAgIGN1ZS5hbGlnbiA9IHNldHRpbmdzLmdldCgnYWxpZ24nLCBjZW50ZXIpO1xuICAgICAgdmFyIHBvc2l0aW9uID0gc2V0dGluZ3MuZ2V0KCdwb3NpdGlvbicsICdhdXRvJyk7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdhdXRvJyAmJiBkZWZhdWx0cy5wb3NpdGlvbiA9PT0gNTApIHtcbiAgICAgICAgLy8gc2V0IG51bWVyaWMgcG9zaXRpb24gZm9yIFNhZmFyaVxuICAgICAgICBwb3NpdGlvbiA9IGN1ZS5hbGlnbiA9PT0gJ3N0YXJ0JyB8fCBjdWUuYWxpZ24gPT09ICdsZWZ0JyA/IDAgOiBjdWUuYWxpZ24gPT09ICdlbmQnIHx8IGN1ZS5hbGlnbiA9PT0gJ3JpZ2h0JyA/IDEwMCA6IDUwO1xuICAgICAgfVxuICAgICAgY3VlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbiAgICB9XG5cbiAgICAvLyA0LjEgV2ViVlRUIGN1ZSB0aW1pbmdzLlxuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcbiAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgIGlmIChpbnB1dC5zbGljZSgwLCAzKSAhPT0gJy0tPicpIHtcbiAgICAgIC8vICgzKSBuZXh0IGNoYXJhY3RlcnMgbXVzdCBtYXRjaCAnLS0+J1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHRpbWUgc3RhbXAgKHRpbWUgc3RhbXBzIG11c3QgYmUgc2VwYXJhdGVkIGJ5ICctLT4nKTogXCIgKyBvSW5wdXQpO1xuICAgIH1cbiAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDMpO1xuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgY3VlLmVuZFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7IC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxuXG4gICAgLy8gNC4xIFdlYlZUVCBjdWUgc2V0dGluZ3MgbGlzdC5cbiAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKTtcbiAgfVxuICBmdW5jdGlvbiBmaXhMaW5lQnJlYWtzKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoLzxicig/OiBcXC8pPz4vZ2ksICdcXG4nKTtcbiAgfVxuICB2YXIgVlRUUGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWVFRQYXJzZXIoKSB7XG4gICAgICB0aGlzLnN0YXRlID0gJ0lOSVRJQUwnO1xuICAgICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCk7XG4gICAgICB0aGlzLnJlZ2lvbkxpc3QgPSBbXTtcbiAgICAgIHRoaXMuY3VlID0gbnVsbDtcbiAgICAgIHRoaXMub25jdWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLm9ucGFyc2luZ2Vycm9yID0gdm9pZCAwO1xuICAgICAgdGhpcy5vbmZsdXNoID0gdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvMyA9IFZUVFBhcnNlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvMy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXG4gICAgICAvLyB3aGF0ZXZlciBpcyBpbiBidWZmZXIgYWxyZWFkeS4gVGhpcyBtYXkgb2NjdXIgaW4gY2lyY3Vtc3RhbmNlcywgZm9yXG4gICAgICAvLyBleGFtcGxlIHdoZW4gZmx1c2goKSBpcyBjYWxsZWQuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBkYXRhIHRoYXQgd2UgcmVjZWl2ZWQuXG4gICAgICAgIF90aGlzLmJ1ZmZlciArPSBfdGhpcy5kZWNvZGVyLmRlY29kZShkYXRhLCB7XG4gICAgICAgICAgc3RyZWFtOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gX3RoaXMuYnVmZmVyO1xuICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgYnVmZmVyID0gZml4TGluZUJyZWFrcyhidWZmZXIpO1xuICAgICAgICB3aGlsZSAocG9zIDwgYnVmZmVyLmxlbmd0aCAmJiBidWZmZXJbcG9zXSAhPT0gJ1xccicgJiYgYnVmZmVyW3Bvc10gIT09ICdcXG4nKSB7XG4gICAgICAgICAgKytwb3M7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmUgPSBidWZmZXIuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cbiAgICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxyJykge1xuICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICArK3BvcztcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5idWZmZXIgPSBidWZmZXIuc2xpY2UocG9zKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICB9XG5cbiAgICAgIC8vIDMuMiBXZWJWVFQgbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIoaW5wdXQpIHtcbiAgICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgIC8vIHN3aXRjaCAoaykge1xuICAgICAgICAgIC8vIGNhc2UgJ3JlZ2lvbic6XG4gICAgICAgICAgLy8gMy4zIFdlYlZUVCByZWdpb24gbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdwYXJzZSByZWdpb24nLCB2KTtcbiAgICAgICAgICAvLyBwYXJzZVJlZ2lvbih2KTtcbiAgICAgICAgICAvLyBicmVhaztcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH0sIC86Lyk7XG4gICAgICB9XG5cbiAgICAgIC8vIDUuMSBXZWJWVFQgZmlsZSBwYXJzaW5nLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGxpbmUgPSAnJztcbiAgICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcpIHtcbiAgICAgICAgICAvLyBXZSBjYW4ndCBzdGFydCBwYXJzaW5nIHVudGlsIHdlIGhhdmUgdGhlIGZpcnN0IGxpbmUuXG4gICAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChfdGhpcy5idWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICAgIC8vIHN0cmlwIG9mIFVURi04IEJPTSBpZiBhbnlcbiAgICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CeXRlX29yZGVyX21hcmsjVVRGLThcbiAgICAgICAgICB2YXIgbSA9IGxpbmUubWF0Y2goL14ow6/Cu8K/KT9XRUJWVFQoWyBcXHRdLiopPyQvKTtcbiAgICAgICAgICBpZiAoIShtICE9IG51bGwgJiYgbVswXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0hFQURFUic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChfdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAvLyBXZSBjYW4ndCBwYXJzZSBhIGxpbmUgdW50aWwgd2UgaGF2ZSB0aGUgZnVsbCBsaW5lLlxuICAgICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3QoX3RoaXMuYnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYWxyZWFkeUNvbGxlY3RlZExpbmUpIHtcbiAgICAgICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChfdGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnSEVBREVSJzpcbiAgICAgICAgICAgICAgLy8gMTMtMTggLSBBbGxvdyBhIGhlYWRlciAobWV0YWRhdGEpIHVuZGVyIHRoZSBXRUJWVFQgbGluZS5cbiAgICAgICAgICAgICAgaWYgKC86Ly50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBBbiBlbXB0eSBsaW5lIHRlcm1pbmF0ZXMgdGhlIGhlYWRlciBhbmQgc3RhcnRzIHRoZSBib2R5IChjdWVzKS5cbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlICdOT1RFJzpcbiAgICAgICAgICAgICAgLy8gSWdub3JlIE5PVEUgYmxvY2tzLlxuICAgICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlICdJRCc6XG4gICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXG4gICAgICAgICAgICAgIGlmICgvXk5PVEUoJHxbIFxcdF0pLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnTk9URSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gMTktMjkgLSBBbGxvdyBhbnkgbnVtYmVyIG9mIGxpbmUgdGVybWluYXRvcnMsIHRoZW4gaW5pdGlhbGl6ZSBuZXcgY3VlIHZhbHVlcy5cbiAgICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3RoaXMuY3VlID0gbmV3IFZUVEN1ZSgwLCAwLCAnJyk7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0NVRSc7XG4gICAgICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJy0tPicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmN1ZS5pZCA9IGxpbmU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgbGluZSBhcyBzdGFydCBvZiBhIGN1ZS5cbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ0NVRSc6XG4gICAgICAgICAgICAgIC8vIDQwIC0gQ29sbGVjdCBjdWUgdGltaW5ncyBhbmQgc2V0dGluZ3MuXG4gICAgICAgICAgICAgIGlmICghX3RoaXMuY3VlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnQkFEQ1VFJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnNlQ3VlKGxpbmUsIF90aGlzLmN1ZSwgX3RoaXMucmVnaW9uTGlzdCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdCQURDVUUnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0NVRVRFWFQnO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgJ0NVRVRFWFQnOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1N1YnN0cmluZyA9IGxpbmUuaW5kZXhPZignLS0+JykgIT09IC0xO1xuICAgICAgICAgICAgICAgIC8vIDM0IC0gSWYgd2UgaGF2ZSBhbiBlbXB0eSBsaW5lIHRoZW4gcmVwb3J0IHRoZSBjdWUuXG4gICAgICAgICAgICAgICAgLy8gMzUgLSBJZiB3ZSBoYXZlIHRoZSBzcGVjaWFsIHN1YnN0cmluZyAnLS0+JyB0aGVuIHJlcG9ydCB0aGUgY3VlLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAvLyBvbmUgYXMgYSBuZXcgY3VlLlxuICAgICAgICAgICAgICAgIGlmICghbGluZSB8fCBoYXNTdWJzdHJpbmcgJiYgKGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub25jdWUgJiYgX3RoaXMuY3VlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uY3VlKF90aGlzLmN1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfdGhpcy5jdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY3VlLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLmN1ZS50ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5jdWUudGV4dCArPSBsaW5lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSAnQkFEQ1VFJzpcbiAgICAgICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxuICAgICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBwYXJzaW5nIGEgY3VlLCByZXBvcnQgd2hhdCB3ZSBoYXZlLlxuICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdDVUVURVhUJyAmJiBfdGhpcy5jdWUgJiYgX3RoaXMub25jdWUpIHtcbiAgICAgICAgICBfdGhpcy5vbmN1ZShfdGhpcy5jdWUpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmN1ZSA9IG51bGw7XG4gICAgICAgIC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxuICAgICAgICAvLyBhbm90aGVyIGV4Y2VwdGlvbiBvY2N1cnJlZCBzbyBlbnRlciBCQURDVUUgc3RhdGUuXG4gICAgICAgIF90aGlzLnN0YXRlID0gX3RoaXMuc3RhdGUgPT09ICdJTklUSUFMJyA/ICdCQURXRUJWVFQnIDogJ0JBRENVRSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90bzMuZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgICAgLy8gX3RoaXMuYnVmZmVyICs9IF90aGlzLmRlY29kZXIuZGVjb2RlKCk7XG4gICAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxuICAgICAgICBpZiAoX3RoaXMuY3VlIHx8IF90aGlzLnN0YXRlID09PSAnSEVBREVSJykge1xuICAgICAgICAgIF90aGlzLmJ1ZmZlciArPSAnXFxuXFxuJztcbiAgICAgICAgICBfdGhpcy5wYXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3ZlIGZsdXNoZWQsIHBhcnNlZCwgYW5kIHdlJ3JlIHN0aWxsIG9uIHRoZSBJTklUSUFMIHN0YXRlIHRoZW5cbiAgICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxuICAgICAgICAvLyBsaW5lLlxuICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdJTklUSUFMJyB8fCBfdGhpcy5zdGF0ZSA9PT0gJ0JBRFdFQlZUVCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChfdGhpcy5vbnBhcnNpbmdlcnJvcikge1xuICAgICAgICAgIF90aGlzLm9ucGFyc2luZ2Vycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMub25mbHVzaCkge1xuICAgICAgICBfdGhpcy5vbmZsdXNoKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBWVFRQYXJzZXI7XG4gIH0oKTtcblxuICB2YXIgTElORUJSRUFLUyA9IC9cXHJcXG58XFxuXFxyfFxcbnxcXHIvZztcblxuICAvLyBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggaXMgbm90IHN1cHBvcnRlZCBpbiBJRTExXG4gIHZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aChpbnB1dFN0cmluZywgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBwb3NpdGlvbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xuICB9O1xuICB2YXIgY3VlU3RyaW5nMm1pbGxpcyA9IGZ1bmN0aW9uIGN1ZVN0cmluZzJtaWxsaXModGltZVN0cmluZykge1xuICAgIHZhciB0cyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoLTMpKTtcbiAgICB2YXIgc2VjcyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoLTYsIC00KSk7XG4gICAgdmFyIG1pbnMgPSBwYXJzZUludCh0aW1lU3RyaW5nLnNsaWNlKC05LCAtNykpO1xuICAgIHZhciBob3VycyA9IHRpbWVTdHJpbmcubGVuZ3RoID4gOSA/IHBhcnNlSW50KHRpbWVTdHJpbmcuc3Vic3RyaW5nKDAsIHRpbWVTdHJpbmcuaW5kZXhPZignOicpKSkgOiAwO1xuICAgIGlmICghaXNGaW5pdGVOdW1iZXIodHMpIHx8ICFpc0Zpbml0ZU51bWJlcihzZWNzKSB8fCAhaXNGaW5pdGVOdW1iZXIobWlucykgfHwgIWlzRmluaXRlTnVtYmVyKGhvdXJzKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiBMb2NhbDpcIiArIHRpbWVTdHJpbmcpO1xuICAgIH1cbiAgICB0cyArPSAxMDAwICogc2VjcztcbiAgICB0cyArPSA2MCAqIDEwMDAgKiBtaW5zO1xuICAgIHRzICs9IDYwICogNjAgKiAxMDAwICogaG91cnM7XG4gICAgcmV0dXJuIHRzO1xuICB9O1xuXG4gIC8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2hcbiAgdmFyIGhhc2ggPSBmdW5jdGlvbiBoYXNoKHRleHQpIHtcbiAgICB2YXIgaGFzaCA9IDUzODE7XG4gICAgdmFyIGkgPSB0ZXh0Lmxlbmd0aDtcbiAgICB3aGlsZSAoaSkge1xuICAgICAgaGFzaCA9IGhhc2ggKiAzMyBeIHRleHQuY2hhckNvZGVBdCgtLWkpO1xuICAgIH1cbiAgICByZXR1cm4gKGhhc2ggPj4+IDApLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgdW5pcXVlIGhhc2ggaWQgZm9yIGEgY3VlIGJhc2VkIG9uIHN0YXJ0L2VuZCB0aW1lcyBhbmQgdGV4dC5cbiAgLy8gVGhpcyBoZWxwcyB0aW1lbGluZS1jb250cm9sbGVyIHRvIGF2b2lkIHNob3dpbmcgcmVwZWF0ZWQgY2FwdGlvbnMuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlQ3VlSWQoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XG4gICAgcmV0dXJuIGhhc2goc3RhcnRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaChlbmRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaCh0ZXh0KTtcbiAgfVxuICB2YXIgY2FsY3VsYXRlT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHByZXNlbnRhdGlvblRpbWUpIHtcbiAgICB2YXIgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICB2YXIgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGlzY29udGludWl0eSBvciBjdWVzIGhhdmUgYmVlbiBwcm9jZXNzZWQgc2luY2UgdGhlIGxhc3QgZGlzY29udGludWl0eVxuICAgIC8vIE9mZnNldCA9IGN1cnJlbnQgZGlzY29udGludWl0eSB0aW1lXG4gICAgaWYgKCFwcmV2Q0MgfHwgIXByZXZDQy5uZXcgJiYgY3VyckNDLm5ldykge1xuICAgICAgdnR0Q0NzLmNjT2Zmc2V0ID0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGVyZSBoYXZlIGJlZW4gZGlzY29udGludWl0aWVzIHNpbmNlIGN1ZXMgd2VyZSBsYXN0IHBhcnNlZC5cbiAgICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcbiAgICB3aGlsZSAoKF9wcmV2Q0MgPSBwcmV2Q0MpICE9IG51bGwgJiYgX3ByZXZDQy5uZXcpIHtcbiAgICAgIHZhciBfcHJldkNDO1xuICAgICAgdnR0Q0NzLmNjT2Zmc2V0ICs9IGN1cnJDQy5zdGFydCAtIHByZXZDQy5zdGFydDtcbiAgICAgIGN1cnJDQy5uZXcgPSBmYWxzZTtcbiAgICAgIGN1cnJDQyA9IHByZXZDQztcbiAgICAgIHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcbiAgICB9XG4gICAgdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldCA9IHByZXNlbnRhdGlvblRpbWU7XG4gIH07XG4gIGZ1bmN0aW9uIHBhcnNlV2ViVlRUKHZ0dEJ5dGVBcnJheSwgaW5pdFBUUywgdnR0Q0NzLCBjYywgdGltZU9mZnNldCwgY2FsbEJhY2ssIGVycm9yQ2FsbEJhY2spIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IFZUVFBhcnNlcigpO1xuICAgIC8vIENvbnZlcnQgYnl0ZUFycmF5IGludG8gc3RyaW5nLCByZXBsYWNpbmcgYW55IHNvbWV3aGF0IGV4b3RpYyBsaW5lZmVlZHMgd2l0aCBcIlxcblwiLCB0aGVuIHNwbGl0IG9uIHRoYXQgY2hhcmFjdGVyLlxuICAgIC8vIFVpbnQ4QXJyYXkucHJvdG90eXBlLnJlZHVjZSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gSUUxMVxuICAgIHZhciB2dHRMaW5lcyA9IHV0ZjhBcnJheVRvU3RyKG5ldyBVaW50OEFycmF5KHZ0dEJ5dGVBcnJheSkpLnRyaW0oKS5yZXBsYWNlKExJTkVCUkVBS1MsICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIGN1ZXMgPSBbXTtcbiAgICB2YXIgaW5pdDkwa0h6ID0gaW5pdFBUUyA/IHRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlKGluaXRQVFMuYmFzZVRpbWUsIGluaXRQVFMudGltZXNjYWxlKSA6IDA7XG4gICAgdmFyIGN1ZVRpbWUgPSAnMDA6MDAuMDAwJztcbiAgICB2YXIgdGltZXN0YW1wTWFwTVBFR1RTID0gMDtcbiAgICB2YXIgdGltZXN0YW1wTWFwTE9DQUwgPSAwO1xuICAgIHZhciBwYXJzaW5nRXJyb3I7XG4gICAgdmFyIGluSGVhZGVyID0gdHJ1ZTtcbiAgICBwYXJzZXIub25jdWUgPSBmdW5jdGlvbiAoY3VlKSB7XG4gICAgICAvLyBBZGp1c3QgY3VlIHRpbWluZzsgY2xhbXAgY3VlcyB0byBzdGFydCBubyBlYXJsaWVyIHRoYW4gLSBhbmQgZHJvcCBjdWVzIHRoYXQgZG9uJ3QgZW5kIGFmdGVyIC0gMCBvbiB0aW1lbGluZS5cbiAgICAgIHZhciBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICAgICAgdmFyIGN1ZU9mZnNldCA9IHZ0dENDcy5jY09mZnNldDtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHN1YnRpdGxlIFBUUyBvZmZzZXRcbiAgICAgIHZhciB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQgPSAodGltZXN0YW1wTWFwTVBFR1RTIC0gaW5pdDkwa0h6KSAvIDkwMDAwO1xuXG4gICAgICAvLyBVcGRhdGUgb2Zmc2V0cyBmb3IgbmV3IGRpc2NvbnRpbnVpdGllc1xuICAgICAgaWYgKGN1cnJDQyAhPSBudWxsICYmIGN1cnJDQy5uZXcpIHtcbiAgICAgICAgaWYgKHRpbWVzdGFtcE1hcExPQ0FMICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGxvY2FsIHRpbWUgaXMgcHJvdmlkZWQsIG9mZnNldCA9IGRpc2NvbnRpbnVpdHkgc3RhcnQgdGltZSAtIGxvY2FsIHRpbWVcbiAgICAgICAgICBjdWVPZmZzZXQgPSB2dHRDQ3MuY2NPZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsY3VsYXRlT2Zmc2V0KHZ0dENDcywgY2MsIHdlYlZ0dE1wZWdUc01hcE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh3ZWJWdHRNcGVnVHNNYXBPZmZzZXQpIHtcbiAgICAgICAgaWYgKCFpbml0UFRTKSB7XG4gICAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdNaXNzaW5nIGluaXRQVFMgZm9yIFZUVCBNUEVHVFMnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBNUEVHVFMsIG9mZnNldCA9IHByZXNlbnRhdGlvbiB0aW1lICsgZGlzY29udGludWl0eSBvZmZzZXRcbiAgICAgICAgY3VlT2Zmc2V0ID0gd2ViVnR0TXBlZ1RzTWFwT2Zmc2V0IC0gdnR0Q0NzLnByZXNlbnRhdGlvbk9mZnNldDtcbiAgICAgIH1cbiAgICAgIHZhciBkdXJhdGlvbiA9IGN1ZS5lbmRUaW1lIC0gY3VlLnN0YXJ0VGltZTtcbiAgICAgIHZhciBzdGFydFRpbWUgPSBub3JtYWxpemVQdHMoKGN1ZS5zdGFydFRpbWUgKyBjdWVPZmZzZXQgLSB0aW1lc3RhbXBNYXBMT0NBTCkgKiA5MDAwMCwgdGltZU9mZnNldCAqIDkwMDAwKSAvIDkwMDAwO1xuICAgICAgY3VlLnN0YXJ0VGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSwgMCk7XG4gICAgICBjdWUuZW5kVGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSArIGR1cmF0aW9uLCAwKTtcblxuICAgICAgLy90cmltIHRyYWlsaW5nIHdlYnZ0dCBibG9jayB3aGl0ZXNwYWNlc1xuICAgICAgdmFyIHRleHQgPSBjdWUudGV4dC50cmltKCk7XG5cbiAgICAgIC8vIEZpeCBlbmNvZGluZyBvZiBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICAgIGN1ZS50ZXh0ID0gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudCh0ZXh0KSk7XG5cbiAgICAgIC8vIElmIHRoZSBjdWUgd2FzIG5vdCBhc3NpZ25lZCBhbiBpZCBmcm9tIHRoZSBWVFQgZmlsZSAobGluZSBhYm92ZSB0aGUgY29udGVudCksIGNyZWF0ZSBvbmUuXG4gICAgICBpZiAoIWN1ZS5pZCkge1xuICAgICAgICBjdWUuaWQgPSBnZW5lcmF0ZUN1ZUlkKGN1ZS5zdGFydFRpbWUsIGN1ZS5lbmRUaW1lLCB0ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmIChjdWUuZW5kVGltZSA+IDApIHtcbiAgICAgICAgY3Vlcy5wdXNoKGN1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBwYXJzZXIub25wYXJzaW5nZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHBhcnNpbmdFcnJvciA9IGVycm9yO1xuICAgIH07XG4gICAgcGFyc2VyLm9uZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGFyc2luZ0Vycm9yKSB7XG4gICAgICAgIGVycm9yQ2FsbEJhY2socGFyc2luZ0Vycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbEJhY2soY3Vlcyk7XG4gICAgfTtcblxuICAgIC8vIEdvIHRocm91Z2ggY29udGVudHMgbGluZSBieSBsaW5lLlxuICAgIHZ0dExpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChpbkhlYWRlcikge1xuICAgICAgICAvLyBMb29rIGZvciBYLVRJTUVTVEFNUC1NQVAgaW4gaGVhZGVyLlxuICAgICAgICBpZiAoc3RhcnRzV2l0aChsaW5lLCAnWC1USU1FU1RBTVAtTUFQPScpKSB7XG4gICAgICAgICAgLy8gT25jZSBmb3VuZCwgbm8gbW9yZSBhcmUgYWxsb3dlZCBhbnl3YXksIHNvIHN0b3Agc2VhcmNoaW5nLlxuICAgICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICAgICAgLy8gRXh0cmFjdCBMT0NBTCBhbmQgTVBFR1RTLlxuICAgICAgICAgIGxpbmUuc2xpY2UoMTYpLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRzV2l0aCh0aW1lc3RhbXAsICdMT0NBTDonKSkge1xuICAgICAgICAgICAgICBjdWVUaW1lID0gdGltZXN0YW1wLnNsaWNlKDYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ01QRUdUUzonKSkge1xuICAgICAgICAgICAgICB0aW1lc3RhbXBNYXBNUEVHVFMgPSBwYXJzZUludCh0aW1lc3RhbXAuc2xpY2UoNykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGN1ZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgICAgIHRpbWVzdGFtcE1hcExPQ0FMID0gY3VlU3RyaW5nMm1pbGxpcyhjdWVUaW1lKSAvIDEwMDA7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHBhcnNpbmdFcnJvciA9IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gd2l0aG91dCBwYXJzaW5nIFgtVElNRVNUQU1QLU1BUCBsaW5lLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChsaW5lID09PSAnJykge1xuICAgICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFBhcnNlIGxpbmUgYnkgZGVmYXVsdC5cbiAgICAgIHBhcnNlci5wYXJzZShsaW5lICsgJ1xcbicpO1xuICAgIH0pO1xuICAgIHBhcnNlci5mbHVzaCgpO1xuICB9XG5cbiAgdmFyIElNU0MxX0NPREVDID0gJ3N0cHAudHRtbC5pbTF0JztcblxuICAvLyBUaW1lIGZvcm1hdDogaDptOnM6ZnJhbWVzKC5zdWJmcmFtZXMpXG4gIHZhciBITVNGX1JFR0VYID0gL14oXFxkezIsfSk6KFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSlcXC4/KFxcZCspPyQvO1xuXG4gIC8vIFRpbWUgZm9ybWF0OiBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCBmcmFtZXMsIHRpY2tzXG4gIHZhciBUSU1FX1VOSVRfUkVHRVggPSAvXihcXGQqKD86XFwuXFxkKik/KShofG18c3xtc3xmfHQpJC87XG4gIHZhciB0ZXh0QWxpZ25Ub0xpbmVBbGlnbiA9IHtcbiAgICBsZWZ0OiAnc3RhcnQnLFxuICAgIGNlbnRlcjogJ2NlbnRlcicsXG4gICAgcmlnaHQ6ICdlbmQnLFxuICAgIHN0YXJ0OiAnc3RhcnQnLFxuICAgIGVuZDogJ2VuZCdcbiAgfTtcbiAgZnVuY3Rpb24gcGFyc2VJTVNDMShwYXlsb2FkLCBpbml0UFRTLCBjYWxsQmFjaywgZXJyb3JDYWxsQmFjaykge1xuICAgIHZhciByZXN1bHRzID0gZmluZEJveChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgWydtZGF0J10pO1xuICAgIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZXJyb3JDYWxsQmFjayhuZXcgRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBJTVNDMSBtZGF0JykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdHRtbExpc3QgPSByZXN1bHRzLm1hcChmdW5jdGlvbiAobWRhdCkge1xuICAgICAgcmV0dXJuIHV0ZjhBcnJheVRvU3RyKG1kYXQpO1xuICAgIH0pO1xuICAgIHZhciBzeW5jVGltZSA9IHRvVGltZXNjYWxlRnJvbVNjYWxlKGluaXRQVFMuYmFzZVRpbWUsIDEsIGluaXRQVFMudGltZXNjYWxlKTtcbiAgICB0cnkge1xuICAgICAgdHRtbExpc3QuZm9yRWFjaChmdW5jdGlvbiAodHRtbCkge1xuICAgICAgICByZXR1cm4gY2FsbEJhY2socGFyc2VUVE1MKHR0bWwsIHN5bmNUaW1lKSk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZXJyb3JDYWxsQmFjayhlcnJvcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlVFRNTCh0dG1sLCBzeW5jVGltZSkge1xuICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgdmFyIHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodHRtbCwgJ3RleHQveG1sJyk7XG4gICAgdmFyIHR0ID0geG1sRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0dCcpWzBdO1xuICAgIGlmICghdHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0dG1sJyk7XG4gICAgfVxuICAgIHZhciBkZWZhdWx0UmF0ZUluZm8gPSB7XG4gICAgICBmcmFtZVJhdGU6IDMwLFxuICAgICAgc3ViRnJhbWVSYXRlOiAxLFxuICAgICAgZnJhbWVSYXRlTXVsdGlwbGllcjogMCxcbiAgICAgIHRpY2tSYXRlOiAwXG4gICAgfTtcbiAgICB2YXIgcmF0ZUluZm8gPSBPYmplY3Qua2V5cyhkZWZhdWx0UmF0ZUluZm8pLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdHQuZ2V0QXR0cmlidXRlKFwidHRwOlwiICsga2V5KSB8fCBkZWZhdWx0UmF0ZUluZm9ba2V5XTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuICAgIHZhciB0cmltID0gdHQuZ2V0QXR0cmlidXRlKCd4bWw6c3BhY2UnKSAhPT0gJ3ByZXNlcnZlJztcbiAgICB2YXIgc3R5bGVFbGVtZW50cyA9IGNvbGxlY3Rpb25Ub0RpY3Rpb25hcnkoZ2V0RWxlbWVudENvbGxlY3Rpb24odHQsICdzdHlsaW5nJywgJ3N0eWxlJykpO1xuICAgIHZhciByZWdpb25FbGVtZW50cyA9IGNvbGxlY3Rpb25Ub0RpY3Rpb25hcnkoZ2V0RWxlbWVudENvbGxlY3Rpb24odHQsICdsYXlvdXQnLCAncmVnaW9uJykpO1xuICAgIHZhciBjdWVFbGVtZW50cyA9IGdldEVsZW1lbnRDb2xsZWN0aW9uKHR0LCAnYm9keScsICdbYmVnaW5dJyk7XG4gICAgcmV0dXJuIFtdLm1hcC5jYWxsKGN1ZUVsZW1lbnRzLCBmdW5jdGlvbiAoY3VlRWxlbWVudCkge1xuICAgICAgdmFyIGN1ZVRleHQgPSBnZXRUZXh0Q29udGVudChjdWVFbGVtZW50LCB0cmltKTtcbiAgICAgIGlmICghY3VlVGV4dCB8fCAhY3VlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2JlZ2luJykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgc3RhcnRUaW1lID0gcGFyc2VUdG1sVGltZShjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnYmVnaW4nKSwgcmF0ZUluZm8pO1xuICAgICAgdmFyIGR1cmF0aW9uID0gcGFyc2VUdG1sVGltZShjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnZHVyJyksIHJhdGVJbmZvKTtcbiAgICAgIHZhciBlbmRUaW1lID0gcGFyc2VUdG1sVGltZShjdWVFbGVtZW50LmdldEF0dHJpYnV0ZSgnZW5kJyksIHJhdGVJbmZvKTtcbiAgICAgIGlmIChzdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgdGltZXN0YW1wUGFyc2luZ0Vycm9yKGN1ZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZFRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgdGltZXN0YW1wUGFyc2luZ0Vycm9yKGN1ZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHZhciBjdWUgPSBuZXcgVlRUQ3VlKHN0YXJ0VGltZSAtIHN5bmNUaW1lLCBlbmRUaW1lIC0gc3luY1RpbWUsIGN1ZVRleHQpO1xuICAgICAgY3VlLmlkID0gZ2VuZXJhdGVDdWVJZChjdWUuc3RhcnRUaW1lLCBjdWUuZW5kVGltZSwgY3VlLnRleHQpO1xuICAgICAgdmFyIHJlZ2lvbiA9IHJlZ2lvbkVsZW1lbnRzW2N1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWdpb24nKV07XG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZUVsZW1lbnRzW2N1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpXTtcblxuICAgICAgLy8gQXBwbHkgc3R5bGVzIHRvIGN1ZVxuICAgICAgdmFyIHN0eWxlcyA9IGdldFR0bWxTdHlsZXMocmVnaW9uLCBzdHlsZSwgc3R5bGVFbGVtZW50cyk7XG4gICAgICB2YXIgdGV4dEFsaWduID0gc3R5bGVzLnRleHRBbGlnbjtcbiAgICAgIGlmICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgLy8gY3VlLnBvc2l0aW9uQWxpZ24gbm90IHNldHRhYmxlIGluIEZGfjIwMTZcbiAgICAgICAgdmFyIGxpbmVBbGlnbiA9IHRleHRBbGlnblRvTGluZUFsaWduW3RleHRBbGlnbl07XG4gICAgICAgIGlmIChsaW5lQWxpZ24pIHtcbiAgICAgICAgICBjdWUubGluZUFsaWduID0gbGluZUFsaWduO1xuICAgICAgICB9XG4gICAgICAgIGN1ZS5hbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgIH1cbiAgICAgIF9leHRlbmRzKGN1ZSwgc3R5bGVzKTtcbiAgICAgIHJldHVybiBjdWU7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgIHJldHVybiBjdWUgIT09IG51bGw7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudENvbGxlY3Rpb24oZnJvbUVsZW1lbnQsIHBhcmVudE5hbWUsIGNoaWxkTmFtZSkge1xuICAgIHZhciBwYXJlbnQgPSBmcm9tRWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShwYXJlbnROYW1lKVswXTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChwYXJlbnQucXVlcnlTZWxlY3RvckFsbChjaGlsZE5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGZ1bmN0aW9uIGNvbGxlY3Rpb25Ub0RpY3Rpb25hcnkoZWxlbWVudHNXaXRoSWQpIHtcbiAgICByZXR1cm4gZWxlbWVudHNXaXRoSWQucmVkdWNlKGZ1bmN0aW9uIChkaWN0LCBlbGVtZW50KSB7XG4gICAgICB2YXIgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneG1sOmlkJyk7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgZGljdFtpZF0gPSBlbGVtZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpY3Q7XG4gICAgfSwge30pO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRleHRDb250ZW50KGVsZW1lbnQsIHRyaW0pIHtcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbChlbGVtZW50LmNoaWxkTm9kZXMpLnJlZHVjZShmdW5jdGlvbiAoc3RyLCBub2RlLCBpKSB7XG4gICAgICB2YXIgX25vZGUkY2hpbGROb2RlcztcbiAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSAnYnInICYmIGkpIHtcbiAgICAgICAgcmV0dXJuIHN0ciArICdcXG4nO1xuICAgICAgfVxuICAgICAgaWYgKChfbm9kZSRjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzKSAhPSBudWxsICYmIF9ub2RlJGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBnZXRUZXh0Q29udGVudChub2RlLCB0cmltKTtcbiAgICAgIH0gZWxzZSBpZiAodHJpbSkge1xuICAgICAgICByZXR1cm4gc3RyICsgbm9kZS50ZXh0Q29udGVudC50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0ciArIG5vZGUudGV4dENvbnRlbnQ7XG4gICAgfSwgJycpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFR0bWxTdHlsZXMocmVnaW9uLCBzdHlsZSwgc3R5bGVFbGVtZW50cykge1xuICAgIHZhciB0dHNOcyA9ICdodHRwOi8vd3d3LnczLm9yZy9ucy90dG1sI3N0eWxpbmcnO1xuICAgIHZhciByZWdpb25TdHlsZSA9IG51bGw7XG4gICAgdmFyIHN0eWxlQXR0cmlidXRlcyA9IFsnZGlzcGxheUFsaWduJywgJ3RleHRBbGlnbicsICdjb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InLCAnZm9udFNpemUnLCAnZm9udEZhbWlseSdcbiAgICAvLyAnZm9udFdlaWdodCcsXG4gICAgLy8gJ2xpbmVIZWlnaHQnLFxuICAgIC8vICd3cmFwT3B0aW9uJyxcbiAgICAvLyAnZm9udFN0eWxlJyxcbiAgICAvLyAnZGlyZWN0aW9uJyxcbiAgICAvLyAnd3JpdGluZ01vZGUnXG4gICAgXTtcbiAgICB2YXIgcmVnaW9uU3R5bGVOYW1lID0gcmVnaW9uICE9IG51bGwgJiYgcmVnaW9uLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKSA/IHJlZ2lvbi5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgOiBudWxsO1xuICAgIGlmIChyZWdpb25TdHlsZU5hbWUgJiYgc3R5bGVFbGVtZW50cy5oYXNPd25Qcm9wZXJ0eShyZWdpb25TdHlsZU5hbWUpKSB7XG4gICAgICByZWdpb25TdHlsZSA9IHN0eWxlRWxlbWVudHNbcmVnaW9uU3R5bGVOYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlQXR0cmlidXRlcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlcywgbmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0QXR0cmlidXRlTlMoc3R5bGUsIHR0c05zLCBuYW1lKSB8fCBnZXRBdHRyaWJ1dGVOUyhyZWdpb24sIHR0c05zLCBuYW1lKSB8fCBnZXRBdHRyaWJ1dGVOUyhyZWdpb25TdHlsZSwgdHRzTnMsIG5hbWUpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHN0eWxlc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9LCB7fSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlTlMoZWxlbWVudCwgbnMsIG5hbWUpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGVOUyhucywgbmFtZSkgPyBlbGVtZW50LmdldEF0dHJpYnV0ZU5TKG5zLCBuYW1lKSA6IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gdGltZXN0YW1wUGFyc2luZ0Vycm9yKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIHR0bWwgdGltZXN0YW1wIFwiICsgbm9kZSk7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VUdG1sVGltZSh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKSB7XG4gICAgaWYgKCF0aW1lQXR0cmlidXRlVmFsdWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc2Vjb25kcyA9IHBhcnNlVGltZVN0YW1wKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG4gICAgaWYgKHNlY29uZHMgPT09IG51bGwpIHtcbiAgICAgIGlmIChITVNGX1JFR0VYLnRlc3QodGltZUF0dHJpYnV0ZVZhbHVlKSkge1xuICAgICAgICBzZWNvbmRzID0gcGFyc2VIb3Vyc01pbnV0ZXNTZWNvbmRzRnJhbWVzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pO1xuICAgICAgfSBlbHNlIGlmIChUSU1FX1VOSVRfUkVHRVgudGVzdCh0aW1lQXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICAgIHNlY29uZHMgPSBwYXJzZVRpbWVVbml0cyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlY29uZHM7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VIb3Vyc01pbnV0ZXNTZWNvbmRzRnJhbWVzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pIHtcbiAgICB2YXIgbSA9IEhNU0ZfUkVHRVguZXhlYyh0aW1lQXR0cmlidXRlVmFsdWUpO1xuICAgIHZhciBmcmFtZXMgPSAobVs0XSB8IDApICsgKG1bNV0gfCAwKSAvIHJhdGVJbmZvLnN1YkZyYW1lUmF0ZTtcbiAgICByZXR1cm4gKG1bMV0gfCAwKSAqIDM2MDAgKyAobVsyXSB8IDApICogNjAgKyAobVszXSB8IDApICsgZnJhbWVzIC8gcmF0ZUluZm8uZnJhbWVSYXRlO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlVGltZVVuaXRzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pIHtcbiAgICB2YXIgbSA9IFRJTUVfVU5JVF9SRUdFWC5leGVjKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG4gICAgdmFyIHZhbHVlID0gTnVtYmVyKG1bMV0pO1xuICAgIHZhciB1bml0ID0gbVsyXTtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJ2gnOlxuICAgICAgICByZXR1cm4gdmFsdWUgKiAzNjAwO1xuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIHJldHVybiB2YWx1ZSAqIDYwO1xuICAgICAgY2FzZSAnbXMnOlxuICAgICAgICByZXR1cm4gdmFsdWUgKiAxMDAwO1xuICAgICAgY2FzZSAnZic6XG4gICAgICAgIHJldHVybiB2YWx1ZSAvIHJhdGVJbmZvLmZyYW1lUmF0ZTtcbiAgICAgIGNhc2UgJ3QnOlxuICAgICAgICByZXR1cm4gdmFsdWUgLyByYXRlSW5mby50aWNrUmF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdmFyIFRpbWVsaW5lQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZWxpbmVDb250cm9sbGVyKGhscykge1xuICAgICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuQ3VlcyA9IHZvaWQgMDtcbiAgICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gICAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge307XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjEgPSB2b2lkIDA7XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmxhc3RDYyA9IC0xO1xuICAgICAgLy8gTGFzdCB2aWRlbyAoQ0VBLTYwOCkgZnJhZ21lbnQgQ0NcbiAgICAgIHRoaXMubGFzdFNuID0gLTE7XG4gICAgICAvLyBMYXN0IHZpZGVvIChDRUEtNjA4KSBmcmFnbWVudCBNU05cbiAgICAgIHRoaXMubGFzdFBhcnRJbmRleCA9IC0xO1xuICAgICAgLy8gTGFzdCB2aWRlbyAoQ0VBLTYwOCkgZnJhZ21lbnQgUGFydCBJbmRleFxuICAgICAgdGhpcy5wcmV2Q0MgPSAtMTtcbiAgICAgIC8vIExhc3Qgc3VidGl0bGUgZnJhZ21lbnQgQ0NcbiAgICAgIHRoaXMudnR0Q0NzID0gbmV3VlRUQ0NzKCk7XG4gICAgICB0aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaGxzID0gaGxzO1xuICAgICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgICAgdGhpcy5DdWVzID0gaGxzLmNvbmZpZy5jdWVIYW5kbGVyO1xuICAgICAgdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXMgPSB7XG4gICAgICAgIHRleHRUcmFjazE6IHtcbiAgICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWwsXG4gICAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGVcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dFRyYWNrMjoge1xuICAgICAgICAgIGxhYmVsOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYWJlbCxcbiAgICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZVxuICAgICAgICB9LFxuICAgICAgICB0ZXh0VHJhY2szOiB7XG4gICAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrM0xhYmVsLFxuICAgICAgICAgIGxhbmd1YWdlQ29kZTogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlXG4gICAgICAgIH0sXG4gICAgICAgIHRleHRUcmFjazQ6IHtcbiAgICAgICAgICBsYWJlbDogdGhpcy5jb25maWcuY2FwdGlvbnNUZXh0VHJhY2s0TGFiZWwsXG4gICAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazRMYW5ndWFnZUNvZGVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHRoaXMub25GcmFnUGFyc2luZ1VzZXJkYXRhLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRlJBR19ERUNSWVBURUQsIHRoaXMub25GcmFnRGVjcnlwdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFRpbWVsaW5lQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwgdGhpcy5vbkZyYWdEZWNyeXB0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5obHMgPSB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjEgPSB0aGlzLmNlYTYwOFBhcnNlcjIgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uaW5pdENlYTYwOFBhcnNlcnMgPSBmdW5jdGlvbiBpbml0Q2VhNjA4UGFyc2VycygpIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVDRUE3MDhDYXB0aW9ucyAmJiAoIXRoaXMuY2VhNjA4UGFyc2VyMSB8fCAhdGhpcy5jZWE2MDhQYXJzZXIyKSkge1xuICAgICAgICB2YXIgY2hhbm5lbDEgPSBuZXcgT3V0cHV0RmlsdGVyKHRoaXMsICd0ZXh0VHJhY2sxJyk7XG4gICAgICAgIHZhciBjaGFubmVsMiA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazInKTtcbiAgICAgICAgdmFyIGNoYW5uZWwzID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMycpO1xuICAgICAgICB2YXIgY2hhbm5lbDQgPSBuZXcgT3V0cHV0RmlsdGVyKHRoaXMsICd0ZXh0VHJhY2s0Jyk7XG4gICAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMSA9IG5ldyBDZWE2MDhQYXJzZXIoMSwgY2hhbm5lbDEsIGNoYW5uZWwyKTtcbiAgICAgICAgdGhpcy5jZWE2MDhQYXJzZXIyID0gbmV3IENlYTYwOFBhcnNlcigzLCBjaGFubmVsMywgY2hhbm5lbDQpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmFkZEN1ZXMgPSBmdW5jdGlvbiBhZGRDdWVzKHRyYWNrTmFtZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4sIGN1ZVJhbmdlcykge1xuICAgICAgLy8gc2tpcCBjdWVzIHdoaWNoIG92ZXJsYXAgbW9yZSB0aGFuIDUwJSB3aXRoIHByZXZpb3VzbHkgcGFyc2VkIHRpbWUgcmFuZ2VzXG4gICAgICB2YXIgbWVyZ2VkID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gY3VlUmFuZ2VzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICB2YXIgY3VlUmFuZ2UgPSBjdWVSYW5nZXNbaV07XG4gICAgICAgIHZhciBvdmVybGFwID0gaW50ZXJzZWN0aW9uKGN1ZVJhbmdlWzBdLCBjdWVSYW5nZVsxXSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcbiAgICAgICAgaWYgKG92ZXJsYXAgPj0gMCkge1xuICAgICAgICAgIGN1ZVJhbmdlWzBdID0gTWF0aC5taW4oY3VlUmFuZ2VbMF0sIHN0YXJ0VGltZSk7XG4gICAgICAgICAgY3VlUmFuZ2VbMV0gPSBNYXRoLm1heChjdWVSYW5nZVsxXSwgZW5kVGltZSk7XG4gICAgICAgICAgbWVyZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAob3ZlcmxhcCAvIChlbmRUaW1lIC0gc3RhcnRUaW1lKSA+IDAuNSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFtZXJnZWQpIHtcbiAgICAgICAgY3VlUmFuZ2VzLnB1c2goW3N0YXJ0VGltZSwgZW5kVGltZV0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLmNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIHRoaXMuQ3Vlcy5uZXdDdWUodHJhY2ssIHN0YXJ0VGltZSwgZW5kVGltZSwgc2NyZWVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdWVzID0gdGhpcy5DdWVzLm5ld0N1ZShudWxsLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkNVRVNfUEFSU0VELCB7XG4gICAgICAgICAgdHlwZTogJ2NhcHRpb25zJyxcbiAgICAgICAgICBjdWVzOiBjdWVzLFxuICAgICAgICAgIHRyYWNrOiB0cmFja05hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gaW5pdGlhbCBQVFMgaXMgZm91bmQ7IHVzZWQgZm9yIHN5bmNocm9uaXNhdGlvbiBvZiBXZWJWVFQuXG4gICAgO1xuICAgIF9wcm90by5vbkluaXRQdHNGb3VuZCA9IGZ1bmN0aW9uIG9uSW5pdFB0c0ZvdW5kKGV2ZW50LCBfcmVmKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGZyYWcgPSBfcmVmLmZyYWcsXG4gICAgICAgIGlkID0gX3JlZi5pZCxcbiAgICAgICAgaW5pdFBUUyA9IF9yZWYuaW5pdFBUUyxcbiAgICAgICAgdGltZXNjYWxlID0gX3JlZi50aW1lc2NhbGU7XG4gICAgICB2YXIgdW5wYXJzZWRWdHRGcmFncyA9IHRoaXMudW5wYXJzZWRWdHRGcmFncztcbiAgICAgIGlmIChpZCA9PT0gJ21haW4nKSB7XG4gICAgICAgIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSA9IHtcbiAgICAgICAgICBiYXNlVGltZTogaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBEdWUgdG8gYXN5bmNocm9ub3VzIHByb2Nlc3NpbmcsIGluaXRpYWwgUFRTIG1heSBhcnJpdmUgbGF0ZXIgdGhhbiB0aGUgZmlyc3QgVlRUIGZyYWdtZW50cyBhcmUgbG9hZGVkLlxuICAgICAgLy8gUGFyc2UgYW55IHVucGFyc2VkIGZyYWdtZW50cyB1cG9uIHJlY2VpdmluZyB0aGUgaW5pdGlhbCBQVFMuXG4gICAgICBpZiAodW5wYXJzZWRWdHRGcmFncy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgICAgIHVucGFyc2VkVnR0RnJhZ3MuZm9yRWFjaChmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICAgIF90aGlzLm9uRnJhZ0xvYWRlZChFdmVudHMuRlJBR19MT0FERUQsIGZyYWcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZXRFeGlzdGluZ1RyYWNrID0gZnVuY3Rpb24gZ2V0RXhpc3RpbmdUcmFjayhsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWRpYS50ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHRleHRUcmFjayA9IG1lZGlhLnRleHRUcmFja3NbaV07XG4gICAgICAgICAgaWYgKGNhblJldXNlVnR0VGV4dFRyYWNrKHRleHRUcmFjaywge1xuICAgICAgICAgICAgbmFtZTogbGFiZWwsXG4gICAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICAgIGF0dHJzOiB7fVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8uY3JlYXRlQ2FwdGlvbnNUcmFjayA9IGZ1bmN0aW9uIGNyZWF0ZUNhcHRpb25zVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICAgIHRoaXMuY3JlYXRlTmF0aXZlVHJhY2sodHJhY2tOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3JlYXRlTm9uTmF0aXZlVHJhY2sodHJhY2tOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5jcmVhdGVOYXRpdmVUcmFjayA9IGZ1bmN0aW9uIGNyZWF0ZU5hdGl2ZVRyYWNrKHRyYWNrTmFtZSkge1xuICAgICAgaWYgKHRoaXMuY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY2FwdGlvbnNQcm9wZXJ0aWVzID0gdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXMsXG4gICAgICAgIGNhcHRpb25zVHJhY2tzID0gdGhpcy5jYXB0aW9uc1RyYWNrcyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgdmFyIF9jYXB0aW9uc1Byb3BlcnRpZXMkdCA9IGNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdLFxuICAgICAgICBsYWJlbCA9IF9jYXB0aW9uc1Byb3BlcnRpZXMkdC5sYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlID0gX2NhcHRpb25zUHJvcGVydGllcyR0Lmxhbmd1YWdlQ29kZTtcbiAgICAgIC8vIEVuYWJsZSByZXVzZSBvZiBleGlzdGluZyB0ZXh0IHRyYWNrLlxuICAgICAgdmFyIGV4aXN0aW5nVHJhY2sgPSB0aGlzLmdldEV4aXN0aW5nVHJhY2sobGFiZWwsIGxhbmd1YWdlQ29kZSk7XG4gICAgICBpZiAoIWV4aXN0aW5nVHJhY2spIHtcbiAgICAgICAgdmFyIHRleHRUcmFjayA9IHRoaXMuY3JlYXRlVGV4dFRyYWNrKCdjYXB0aW9ucycsIGxhYmVsLCBsYW5ndWFnZUNvZGUpO1xuICAgICAgICBpZiAodGV4dFRyYWNrKSB7XG4gICAgICAgICAgLy8gU2V0IGEgc3BlY2lhbCBwcm9wZXJ0eSBvbiB0aGUgdHJhY2sgc28gd2Uga25vdyBpdCdzIG1hbmFnZWQgYnkgSGxzLmpzXG4gICAgICAgICAgdGV4dFRyYWNrW3RyYWNrTmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0ZXh0VHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSBleGlzdGluZ1RyYWNrO1xuICAgICAgICBjbGVhckN1cnJlbnRDdWVzKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgICBzZW5kQWRkVHJhY2tFdmVudChjYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdLCBtZWRpYSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY3JlYXRlTm9uTmF0aXZlVHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVOb25OYXRpdmVUcmFjayh0cmFja05hbWUpIHtcbiAgICAgIGlmICh0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQ3JlYXRlIGEgbGlzdCBvZiBhIHNpbmdsZSB0cmFjayBmb3IgdGhlIHByb3ZpZGVyIHRvIGNvbnN1bWVcbiAgICAgIHZhciB0cmFja1Byb3BlcnRpZXMgPSB0aGlzLmNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdO1xuICAgICAgaWYgKCF0cmFja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxhYmVsID0gdHJhY2tQcm9wZXJ0aWVzLmxhYmVsO1xuICAgICAgdmFyIHRyYWNrID0ge1xuICAgICAgICBfaWQ6IHRyYWNrTmFtZSxcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBraW5kOiAnY2FwdGlvbnMnLFxuICAgICAgICBkZWZhdWx0OiB0cmFja1Byb3BlcnRpZXMubWVkaWEgPyAhIXRyYWNrUHJvcGVydGllcy5tZWRpYS5kZWZhdWx0IDogZmFsc2UsXG4gICAgICAgIGNsb3NlZENhcHRpb25zOiB0cmFja1Byb3BlcnRpZXMubWVkaWFcbiAgICAgIH07XG4gICAgICB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0gPSB0cmFjaztcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQsIHtcbiAgICAgICAgdHJhY2tzOiBbdHJhY2tdXG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5jcmVhdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAoIW1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZWRpYS5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmcpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFBdHRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICAgIHRoaXMuX2NsZWFuVHJhY2tzKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgICB2YXIgY2FwdGlvbnNUcmFja3MgPSB0aGlzLmNhcHRpb25zVHJhY2tzO1xuICAgICAgT2JqZWN0LmtleXMoY2FwdGlvbnNUcmFja3MpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrTmFtZSkge1xuICAgICAgICBjbGVhckN1cnJlbnRDdWVzKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgICBkZWxldGUgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgICAvLyBEZXRlY3QgZGlzY29udGludWl0eSBpbiB2aWRlbyBmcmFnbWVudCAoQ0VBLTYwOCkgcGFyc2luZ1xuICAgICAgdGhpcy5sYXN0Q2MgPSAtMTtcbiAgICAgIHRoaXMubGFzdFNuID0gLTE7XG4gICAgICB0aGlzLmxhc3RQYXJ0SW5kZXggPSAtMTtcbiAgICAgIC8vIERldGVjdCBkaXNjb250aW51aXR5IGluIHN1YnRpdGxlIG1hbmlmZXN0c1xuICAgICAgdGhpcy5wcmV2Q0MgPSAtMTtcbiAgICAgIHRoaXMudnR0Q0NzID0gbmV3VlRUQ0NzKCk7XG4gICAgICAvLyBSZXNldCB0cmFja3NcbiAgICAgIHRoaXMuX2NsZWFuVHJhY2tzKCk7XG4gICAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgICAgdGhpcy5jYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgICAgdGhpcy50ZXh0VHJhY2tzID0gW107XG4gICAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgICAgaWYgKHRoaXMuY2VhNjA4UGFyc2VyMSAmJiB0aGlzLmNlYTYwOFBhcnNlcjIpIHtcbiAgICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuY2VhNjA4UGFyc2VyMi5yZXNldCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLl9jbGVhblRyYWNrcyA9IGZ1bmN0aW9uIF9jbGVhblRyYWNrcygpIHtcbiAgICAgIC8vIGNsZWFyIG91dGRhdGVkIHN1YnRpdGxlc1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmICghbWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRleHRUcmFja3MgPSBtZWRpYS50ZXh0VHJhY2tzO1xuICAgICAgaWYgKHRleHRUcmFja3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2xlYXJDdXJyZW50Q3Vlcyh0ZXh0VHJhY2tzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkID0gZnVuY3Rpb24gb25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3MgfHwgW107XG4gICAgICB2YXIgaGFzSU1TQzEgPSB0cmFja3Muc29tZShmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrLnRleHRDb2RlYyA9PT0gSU1TQzFfQ09ERUM7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVXZWJWVFQgfHwgaGFzSU1TQzEgJiYgdGhpcy5jb25maWcuZW5hYmxlSU1TQzEpIHtcbiAgICAgICAgdmFyIGxpc3RJc0lkZW50aWNhbCA9IHN1YnRpdGxlT3B0aW9uc0lkZW50aWNhbCh0aGlzLnRyYWNrcywgdHJhY2tzKTtcbiAgICAgICAgaWYgKGxpc3RJc0lkZW50aWNhbCkge1xuICAgICAgICAgIHRoaXMudHJhY2tzID0gdHJhY2tzO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICAgIHZhciBpblVzZVRyYWNrcyA9IG1lZGlhID8gZmlsdGVyU3VidGl0bGVUcmFja3MobWVkaWEudGV4dFRyYWNrcykgOiBudWxsO1xuICAgICAgICAgIHRoaXMudHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrLCBpbmRleCkge1xuICAgICAgICAgICAgLy8gUmV1c2UgdHJhY2tzIHdpdGggdGhlIHNhbWUgbGFiZWwgYW5kIGxhbmcsIGJ1dCBkbyBub3QgcmV1c2UgNjA4LzcwOCB0cmFja3NcbiAgICAgICAgICAgIHZhciB0ZXh0VHJhY2s7XG4gICAgICAgICAgICBpZiAoaW5Vc2VUcmFja3MpIHtcbiAgICAgICAgICAgICAgdmFyIGluVXNlVHJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluVXNlVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluVXNlVHJhY2tzW2ldICYmIGNhblJldXNlVnR0VGV4dFRyYWNrKGluVXNlVHJhY2tzW2ldLCB0cmFjaykpIHtcbiAgICAgICAgICAgICAgICAgIGluVXNlVHJhY2sgPSBpblVzZVRyYWNrc1tpXTtcbiAgICAgICAgICAgICAgICAgIGluVXNlVHJhY2tzW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaW5Vc2VUcmFjaykge1xuICAgICAgICAgICAgICAgIHRleHRUcmFjayA9IGluVXNlVHJhY2s7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgICAgY2xlYXJDdXJyZW50Q3Vlcyh0ZXh0VHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHRleHRUcmFja0tpbmQgPSBjYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyh0cmFjayk7XG4gICAgICAgICAgICAgIHRleHRUcmFjayA9IF90aGlzMi5jcmVhdGVUZXh0VHJhY2sodGV4dFRyYWNrS2luZCwgdHJhY2submFtZSwgdHJhY2subGFuZyk7XG4gICAgICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgICAgICB0ZXh0VHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgICAgX3RoaXMyLnRleHRUcmFja3MucHVzaCh0ZXh0VHJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFdhcm4gd2hlbiB2aWRlbyBlbGVtZW50IGhhcyBjYXB0aW9ucyBvciBzdWJ0aXRsZSBUZXh0VHJhY2tzIGNhcnJpZWQgb3ZlciBmcm9tIGFub3RoZXIgc291cmNlXG4gICAgICAgICAgaWYgKGluVXNlVHJhY2tzICE9IG51bGwgJiYgaW5Vc2VUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdW51c2VkVGV4dFRyYWNrcyA9IGluVXNlVHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdCAhPT0gbnVsbDtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdC5sYWJlbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHVudXNlZFRleHRUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiTWVkaWEgZWxlbWVudCBjb250YWlucyB1bnVzZWQgc3VidGl0bGUgdHJhY2tzOiBcIiArIHVudXNlZFRleHRUcmFja3Muam9pbignLCAnKSArIFwiLiBSZXBsYWNlIG1lZGlhIGVsZW1lbnQgZm9yIGVhY2ggc291cmNlIHRvIGNsZWFyIFRleHRUcmFja3MgYW5kIGNhcHRpb25zIG1lbnUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgYSBsaXN0IG9mIHRyYWNrcyBmb3IgdGhlIHByb3ZpZGVyIHRvIGNvbnN1bWVcbiAgICAgICAgICB2YXIgdHJhY2tzTGlzdCA9IHRoaXMudHJhY2tzLm1hcChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGxhYmVsOiB0cmFjay5uYW1lLFxuICAgICAgICAgICAgICBraW5kOiB0cmFjay50eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IHRyYWNrLmRlZmF1bHQsXG4gICAgICAgICAgICAgIHN1YnRpdGxlVHJhY2s6IHRyYWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQsIHtcbiAgICAgICAgICAgIHRyYWNrczogdHJhY2tzTGlzdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUNFQTcwOENhcHRpb25zICYmIGRhdGEuY2FwdGlvbnMpIHtcbiAgICAgICAgZGF0YS5jYXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjYXB0aW9uc1RyYWNrKSB7XG4gICAgICAgICAgdmFyIGluc3RyZWFtSWRNYXRjaCA9IC8oPzpDQ3xTRVJWSUNFKShbMS00XSkvLmV4ZWMoY2FwdGlvbnNUcmFjay5pbnN0cmVhbUlkKTtcbiAgICAgICAgICBpZiAoIWluc3RyZWFtSWRNYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdHJhY2tOYW1lID0gXCJ0ZXh0VHJhY2tcIiArIGluc3RyZWFtSWRNYXRjaFsxXTtcbiAgICAgICAgICB2YXIgdHJhY2tQcm9wZXJ0aWVzID0gX3RoaXMzLmNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdO1xuICAgICAgICAgIGlmICghdHJhY2tQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYWNrUHJvcGVydGllcy5sYWJlbCA9IGNhcHRpb25zVHJhY2submFtZTtcbiAgICAgICAgICBpZiAoY2FwdGlvbnNUcmFjay5sYW5nKSB7XG4gICAgICAgICAgICAvLyBvcHRpb25hbCBhdHRyaWJ1dGVcbiAgICAgICAgICAgIHRyYWNrUHJvcGVydGllcy5sYW5ndWFnZUNvZGUgPSBjYXB0aW9uc1RyYWNrLmxhbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYWNrUHJvcGVydGllcy5tZWRpYSA9IGNhcHRpb25zVHJhY2s7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNsb3NlZENhcHRpb25zRm9yTGV2ZWwgPSBmdW5jdGlvbiBjbG9zZWRDYXB0aW9uc0ZvckxldmVsKGZyYWcpIHtcbiAgICAgIHZhciBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgIHJldHVybiBsZXZlbCA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWwuYXR0cnNbJ0NMT1NFRC1DQVBUSU9OUyddO1xuICAgIH07XG4gICAgX3Byb3RvLm9uRnJhZ0xvYWRpbmcgPSBmdW5jdGlvbiBvbkZyYWdMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICAvLyBpZiB0aGlzIGZyYWcgaXNuJ3QgY29udGlndW91cywgY2xlYXIgdGhlIHBhcnNlciBzbyBjdWVzIHdpdGggYmFkIHN0YXJ0L2VuZCB0aW1lcyBhcmVuJ3QgYWRkZWQgdG8gdGhlIHRleHRUcmFja1xuICAgICAgaWYgKHRoaXMuZW5hYmxlZCAmJiBkYXRhLmZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgICB2YXIgX2RhdGEkcGFydCRpbmRleCwgX2RhdGEkcGFydDtcbiAgICAgICAgdmFyIGNlYTYwOFBhcnNlcjEgPSB0aGlzLmNlYTYwOFBhcnNlcjEsXG4gICAgICAgICAgY2VhNjA4UGFyc2VyMiA9IHRoaXMuY2VhNjA4UGFyc2VyMixcbiAgICAgICAgICBsYXN0U24gPSB0aGlzLmxhc3RTbjtcbiAgICAgICAgdmFyIF9kYXRhJGZyYWcgPSBkYXRhLmZyYWcsXG4gICAgICAgICAgY2MgPSBfZGF0YSRmcmFnLmNjLFxuICAgICAgICAgIHNuID0gX2RhdGEkZnJhZy5zbjtcbiAgICAgICAgdmFyIHBhcnRJbmRleCA9IChfZGF0YSRwYXJ0JGluZGV4ID0gKF9kYXRhJHBhcnQgPSBkYXRhLnBhcnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRwYXJ0LmluZGV4KSAhPSBudWxsID8gX2RhdGEkcGFydCRpbmRleCA6IC0xO1xuICAgICAgICBpZiAoY2VhNjA4UGFyc2VyMSAmJiBjZWE2MDhQYXJzZXIyKSB7XG4gICAgICAgICAgaWYgKHNuICE9PSBsYXN0U24gKyAxIHx8IHNuID09PSBsYXN0U24gJiYgcGFydEluZGV4ICE9PSB0aGlzLmxhc3RQYXJ0SW5kZXggKyAxIHx8IGNjICE9PSB0aGlzLmxhc3RDYykge1xuICAgICAgICAgICAgY2VhNjA4UGFyc2VyMS5yZXNldCgpO1xuICAgICAgICAgICAgY2VhNjA4UGFyc2VyMi5yZXNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RDYyA9IGNjO1xuICAgICAgICB0aGlzLmxhc3RTbiA9IHNuO1xuICAgICAgICB0aGlzLmxhc3RQYXJ0SW5kZXggPSBwYXJ0SW5kZXg7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnTG9hZGVkID0gZnVuY3Rpb24gb25GcmFnTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZyxcbiAgICAgICAgcGF5bG9hZCA9IGRhdGEucGF5bG9hZDtcbiAgICAgIGlmIChmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKSB7XG4gICAgICAgIC8vIElmIGZyYWdtZW50IGlzIHN1YnRpdGxlIHR5cGUsIHBhcnNlIGFzIFdlYlZUVC5cbiAgICAgICAgaWYgKHBheWxvYWQuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHZhciBkZWNyeXB0RGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgICAgICAgLy8gZnJhZ21lbnQgYWZ0ZXIgZGVjcnlwdGlvbiBoYXMgYSBzdGF0cyBvYmplY3RcbiAgICAgICAgICB2YXIgZGVjcnlwdGVkID0gKCdzdGF0cycgaW4gZGF0YSk7XG4gICAgICAgICAgLy8gSWYgdGhlIHN1YnRpdGxlcyBhcmUgbm90IGVuY3J5cHRlZCwgcGFyc2UgVlRUcyBub3cuIE90aGVyd2lzZSwgd2UgbmVlZCB0byB3YWl0LlxuICAgICAgICAgIGlmIChkZWNyeXB0RGF0YSA9PSBudWxsIHx8ICFkZWNyeXB0RGF0YS5lbmNyeXB0ZWQgfHwgZGVjcnlwdGVkKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tQbGF5bGlzdE1lZGlhID0gdGhpcy50cmFja3NbZnJhZy5sZXZlbF07XG4gICAgICAgICAgICB2YXIgdnR0Q0NzID0gdGhpcy52dHRDQ3M7XG4gICAgICAgICAgICBpZiAoIXZ0dENDc1tmcmFnLmNjXSkge1xuICAgICAgICAgICAgICB2dHRDQ3NbZnJhZy5jY10gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZyYWcuc3RhcnQsXG4gICAgICAgICAgICAgICAgcHJldkNDOiB0aGlzLnByZXZDQyxcbiAgICAgICAgICAgICAgICBuZXc6IHRydWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdGhpcy5wcmV2Q0MgPSBmcmFnLmNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYWNrUGxheWxpc3RNZWRpYSAmJiB0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjID09PSBJTVNDMV9DT0RFQykge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyc2VWVFRzKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIHBheWxvYWQsIGZpbmlzaCB1bnN1Y2Nlc3NmdWxseS5cbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignRW1wdHkgc3VidGl0bGUgcGF5bG9hZCcpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5fcGFyc2VJTVNDMSA9IGZ1bmN0aW9uIF9wYXJzZUlNU0MxKGZyYWcsIHBheWxvYWQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgcGFyc2VJTVNDMShwYXlsb2FkLCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIGZ1bmN0aW9uIChjdWVzKSB7XG4gICAgICAgIF90aGlzNC5fYXBwZW5kQ3VlcyhjdWVzLCBmcmFnLmxldmVsKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBmcmFnOiBmcmFnXG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJGYWlsZWQgdG8gcGFyc2UgSU1TQzE6IFwiICsgZXJyb3IpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLl9wYXJzZVZUVHMgPSBmdW5jdGlvbiBfcGFyc2VWVFRzKGRhdGEpIHtcbiAgICAgIHZhciBfZnJhZyRpbml0U2VnbWVudCxcbiAgICAgICAgX3RoaXM1ID0gdGhpcztcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgICAgLy8gV2UgbmVlZCBhbiBpbml0aWFsIHN5bmNocm9uaXNhdGlvbiBQVFMuIFN0b3JlIGZyYWdtZW50cyBhcyBsb25nIGFzIG5vbmUgaGFzIGFycml2ZWRcbiAgICAgIHZhciBpbml0UFRTID0gdGhpcy5pbml0UFRTLFxuICAgICAgICB1bnBhcnNlZFZ0dEZyYWdzID0gdGhpcy51bnBhcnNlZFZ0dEZyYWdzO1xuICAgICAgdmFyIG1heEF2Q0MgPSBpbml0UFRTLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoIWluaXRQVFNbZnJhZy5jY10gJiYgbWF4QXZDQyA9PT0gLTEpIHtcbiAgICAgICAgdW5wYXJzZWRWdHRGcmFncy5wdXNoKGRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICAvLyBQYXJzZSB0aGUgV2ViVlRUIGZpbGUgY29udGVudHMuXG4gICAgICB2YXIgcGF5bG9hZFdlYlZUVCA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpICE9IG51bGwgJiYgX2ZyYWckaW5pdFNlZ21lbnQuZGF0YSA/IGFwcGVuZFVpbnQ4QXJyYXkoZnJhZy5pbml0U2VnbWVudC5kYXRhLCBuZXcgVWludDhBcnJheShwYXlsb2FkKSkgOiBwYXlsb2FkO1xuICAgICAgcGFyc2VXZWJWVFQocGF5bG9hZFdlYlZUVCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCB0aGlzLnZ0dENDcywgZnJhZy5jYywgZnJhZy5zdGFydCwgZnVuY3Rpb24gKGN1ZXMpIHtcbiAgICAgICAgX3RoaXM1Ll9hcHBlbmRDdWVzKGN1ZXMsIGZyYWcubGV2ZWwpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIGZyYWc6IGZyYWdcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdmFyIG1pc3NpbmdJbml0UFRTID0gZXJyb3IubWVzc2FnZSA9PT0gJ01pc3NpbmcgaW5pdFBUUyBmb3IgVlRUIE1QRUdUUyc7XG4gICAgICAgIGlmIChtaXNzaW5nSW5pdFBUUykge1xuICAgICAgICAgIHVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczUuX2ZhbGxiYWNrVG9JTVNDMShmcmFnLCBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBwYXJzaW5nLiBUcmlnZ2VyIGV2ZW50IHdpdGggc3VjY2VzcyBmYWxzZS5cbiAgICAgICAgbG9nZ2VyLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBWVFQgY3VlOiBcIiArIGVycm9yKTtcbiAgICAgICAgaWYgKG1pc3NpbmdJbml0UFRTICYmIG1heEF2Q0MgPiBmcmFnLmNjKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uX2ZhbGxiYWNrVG9JTVNDMSA9IGZ1bmN0aW9uIF9mYWxsYmFja1RvSU1TQzEoZnJhZywgcGF5bG9hZCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgICAvLyBJZiB0ZXh0Q29kZWMgaXMgdW5rbm93biwgdHJ5IHBhcnNpbmcgYXMgSU1TQzEuIFNldCB0ZXh0Q29kZWMgYmFzZWQgb24gdGhlIHJlc3VsdFxuICAgICAgdmFyIHRyYWNrUGxheWxpc3RNZWRpYSA9IHRoaXMudHJhY2tzW2ZyYWcubGV2ZWxdO1xuICAgICAgaWYgKCF0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjKSB7XG4gICAgICAgIHBhcnNlSU1TQzEocGF5bG9hZCwgdGhpcy5pbml0UFRTW2ZyYWcuY2NdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdHJhY2tQbGF5bGlzdE1lZGlhLnRleHRDb2RlYyA9IElNU0MxX0NPREVDO1xuICAgICAgICAgIF90aGlzNi5fcGFyc2VJTVNDMShmcmFnLCBwYXlsb2FkKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPSAnd3Z0dCc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLl9hcHBlbmRDdWVzID0gZnVuY3Rpb24gX2FwcGVuZEN1ZXMoY3VlcywgZnJhZ0xldmVsKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICAgIHZhciB0ZXh0VHJhY2sgPSB0aGlzLnRleHRUcmFja3NbZnJhZ0xldmVsXTtcbiAgICAgICAgLy8gV2ViVlRUUGFyc2VyLnBhcnNlIGlzIGFuIGFzeW5jIG1ldGhvZCBhbmQgaWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0IHRyYWNrIG1vZGUgaXMgc2V0IHRvIFwiZGlzYWJsZWRcIlxuICAgICAgICAvLyBiZWZvcmUgcGFyc2luZyBpcyBkb25lIHRoZW4gZG9uJ3QgdHJ5IHRvIGFjY2VzcyBjdXJyZW50VHJhY2suY3Vlcy5nZXRDdWVCeUlkIGFzIGN1ZXMgd2lsbCBiZSBudWxsXG4gICAgICAgIC8vIGFuZCB0cnlpbmcgdG8gYWNjZXNzIGdldEN1ZUJ5SWQgbWV0aG9kIG9mIGN1ZXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICAgICAgLy8gQmVjYXVzZSB3ZSBjaGVjayBpZiB0aGUgbW9kZSBpcyBkaXNhYmxlZCwgd2UgY2FuIGZvcmNlIGNoZWNrIGBjdWVzYCBiZWxvdy4gVGhleSBjYW4ndCBiZSBudWxsLlxuICAgICAgICBpZiAoIXRleHRUcmFjayB8fCB0ZXh0VHJhY2subW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdWVzLmZvckVhY2goZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgICAgIHJldHVybiBhZGRDdWVUb1RyYWNrKHRleHRUcmFjaywgY3VlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NbZnJhZ0xldmVsXTtcbiAgICAgICAgaWYgKCFjdXJyZW50VHJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYWNrID0gY3VycmVudFRyYWNrLmRlZmF1bHQgPyAnZGVmYXVsdCcgOiAnc3VidGl0bGVzJyArIGZyYWdMZXZlbDtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkNVRVNfUEFSU0VELCB7XG4gICAgICAgICAgdHlwZTogJ3N1YnRpdGxlcycsXG4gICAgICAgICAgY3VlczogY3VlcyxcbiAgICAgICAgICB0cmFjazogdHJhY2tcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnRGVjcnlwdGVkID0gZnVuY3Rpb24gb25GcmFnRGVjcnlwdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgIGlmIChmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKSB7XG4gICAgICAgIHRoaXMub25GcmFnTG9hZGVkKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQgPSBmdW5jdGlvbiBvblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCgpIHtcbiAgICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgICB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnUGFyc2luZ1VzZXJkYXRhID0gZnVuY3Rpb24gb25GcmFnUGFyc2luZ1VzZXJkYXRhKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLmluaXRDZWE2MDhQYXJzZXJzKCk7XG4gICAgICB2YXIgY2VhNjA4UGFyc2VyMSA9IHRoaXMuY2VhNjA4UGFyc2VyMSxcbiAgICAgICAgY2VhNjA4UGFyc2VyMiA9IHRoaXMuY2VhNjA4UGFyc2VyMjtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICFjZWE2MDhQYXJzZXIxIHx8ICFjZWE2MDhQYXJzZXIyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBzYW1wbGVzID0gZGF0YS5zYW1wbGVzO1xuICAgICAgaWYgKGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiAmJiB0aGlzLmNsb3NlZENhcHRpb25zRm9yTGV2ZWwoZnJhZykgPT09ICdOT05FJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgZXZlbnQgY29udGFpbnMgY2FwdGlvbnMgKGZvdW5kIGluIHRoZSBieXRlcyBwcm9wZXJ0eSksIHB1c2ggYWxsIGJ5dGVzIGludG8gdGhlIHBhcnNlciBpbW1lZGlhdGVseVxuICAgICAgLy8gSXQgd2lsbCBjcmVhdGUgdGhlIHByb3BlciB0aW1lc3RhbXBzIGJhc2VkIG9uIHRoZSBQVFMgdmFsdWVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2NCeXRlcyA9IHNhbXBsZXNbaV0uYnl0ZXM7XG4gICAgICAgIGlmIChjY0J5dGVzKSB7XG4gICAgICAgICAgdmFyIGNjZGF0YXMgPSB0aGlzLmV4dHJhY3RDZWE2MDhEYXRhKGNjQnl0ZXMpO1xuICAgICAgICAgIGNlYTYwOFBhcnNlcjEuYWRkRGF0YShzYW1wbGVzW2ldLnB0cywgY2NkYXRhc1swXSk7XG4gICAgICAgICAgY2VhNjA4UGFyc2VyMi5hZGREYXRhKHNhbXBsZXNbaV0ucHRzLCBjY2RhdGFzWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uQnVmZmVyRmx1c2hpbmcgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCBfcmVmMikge1xuICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gX3JlZjIuc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZE9mZnNldCA9IF9yZWYyLmVuZE9mZnNldCxcbiAgICAgICAgZW5kT2Zmc2V0U3VidGl0bGVzID0gX3JlZjIuZW5kT2Zmc2V0U3VidGl0bGVzLFxuICAgICAgICB0eXBlID0gX3JlZjIudHlwZTtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAoIW1lZGlhIHx8IG1lZGlhLmN1cnJlbnRUaW1lIDwgZW5kT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIDYwOCBjYXB0aW9uIGN1ZXMgZnJvbSB0aGUgY2FwdGlvbnMgVGV4dFRyYWNrcyB3aGVuIHRoZSB2aWRlbyBiYWNrIGJ1ZmZlciBpcyBmbHVzaGVkXG4gICAgICAvLyBGb3J3YXJkIGN1ZXMgYXJlIG5ldmVyIHJlbW92ZWQgYmVjYXVzZSB3ZSBjYW4gbG9vc2Ugc3RyZWFtZWQgNjA4IGNvbnRlbnQgZnJvbSByZWNlbnQgZnJhZ21lbnRzXG4gICAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICB2YXIgY2FwdGlvbnNUcmFja3MgPSB0aGlzLmNhcHRpb25zVHJhY2tzO1xuICAgICAgICBPYmplY3Qua2V5cyhjYXB0aW9uc1RyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbW92ZUN1ZXNJblJhbmdlKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgICAgLy8gQ2xlYXIgVlRUL0lNU0MxIHN1YnRpdGxlIGN1ZXMgZnJvbSB0aGUgc3VidGl0bGUgVGV4dFRyYWNrcyB3aGVuIHRoZSBiYWNrIGJ1ZmZlciBpcyBmbHVzaGVkXG4gICAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXRTdWJ0aXRsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciB0ZXh0VHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHRleHRUcmFja3MpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUN1ZXNJblJhbmdlKHRleHRUcmFja3NbdHJhY2tOYW1lXSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldFN1YnRpdGxlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5leHRyYWN0Q2VhNjA4RGF0YSA9IGZ1bmN0aW9uIGV4dHJhY3RDZWE2MDhEYXRhKGJ5dGVBcnJheSkge1xuICAgICAgdmFyIGFjdHVhbENDQnl0ZXMgPSBbW10sIFtdXTtcbiAgICAgIHZhciBjb3VudCA9IGJ5dGVBcnJheVswXSAmIDB4MWY7XG4gICAgICB2YXIgcG9zaXRpb24gPSAyO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIHZhciB0bXBCeXRlID0gYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgICB2YXIgY2NieXRlMSA9IDB4N2YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICAgIHZhciBjY2J5dGUyID0gMHg3ZiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgICAgaWYgKGNjYnl0ZTEgPT09IDAgJiYgY2NieXRlMiA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjY1ZhbGlkID0gKDB4MDQgJiB0bXBCeXRlKSAhPT0gMDsgLy8gU3VwcG9ydCBhbGwgZm91ciBjaGFubmVsc1xuICAgICAgICBpZiAoY2NWYWxpZCkge1xuICAgICAgICAgIHZhciBjY1R5cGUgPSAweDAzICYgdG1wQnl0ZTtcbiAgICAgICAgICBpZiAoMHgwMCAvKiBDRUE2MDggZmllbGQxKi8gPT09IGNjVHlwZSB8fCAweDAxIC8qIENFQTYwOCBmaWVsZDIqLyA9PT0gY2NUeXBlKSB7XG4gICAgICAgICAgICAvLyBFeGNsdWRlIENFQTcwOCBDQyBkYXRhLlxuICAgICAgICAgICAgYWN0dWFsQ0NCeXRlc1tjY1R5cGVdLnB1c2goY2NieXRlMSk7XG4gICAgICAgICAgICBhY3R1YWxDQ0J5dGVzW2NjVHlwZV0ucHVzaChjY2J5dGUyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVsaW5lQ29udHJvbGxlcjtcbiAgfSgpO1xuICBmdW5jdGlvbiBjYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyh0cmFjaykge1xuICAgIGlmICh0cmFjay5jaGFyYWN0ZXJpc3RpY3MpIHtcbiAgICAgIGlmICgvdHJhbnNjcmliZXMtc3Bva2VuLWRpYWxvZy9naS50ZXN0KHRyYWNrLmNoYXJhY3RlcmlzdGljcykgJiYgL2Rlc2NyaWJlcy1tdXNpYy1hbmQtc291bmQvZ2kudGVzdCh0cmFjay5jaGFyYWN0ZXJpc3RpY3MpKSB7XG4gICAgICAgIHJldHVybiAnY2FwdGlvbnMnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ3N1YnRpdGxlcyc7XG4gIH1cbiAgZnVuY3Rpb24gY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFjaywgbWFuaWZlc3RUcmFjaykge1xuICAgIHJldHVybiAhIWluVXNlVHJhY2sgJiYgaW5Vc2VUcmFjay5raW5kID09PSBjYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyhtYW5pZmVzdFRyYWNrKSAmJiBzdWJ0aXRsZVRyYWNrTWF0Y2hlc1RleHRUcmFjayhtYW5pZmVzdFRyYWNrLCBpblVzZVRyYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oeDEsIHgyLCB5MSwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oeDIsIHkyKSAtIE1hdGgubWF4KHgxLCB5MSk7XG4gIH1cbiAgZnVuY3Rpb24gbmV3VlRUQ0NzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjY09mZnNldDogMCxcbiAgICAgIHByZXNlbnRhdGlvbk9mZnNldDogMCxcbiAgICAgIDA6IHtcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIHByZXZDQzogLTEsXG4gICAgICAgIG5ldzogdHJ1ZVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgQ2FwTGV2ZWxDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXBMZXZlbENvbnRyb2xsZXIoaGxzKSB7XG4gICAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZmlyc3RMZXZlbCA9IHZvaWQgMDtcbiAgICAgIHRoaXMubWVkaWEgPSB2b2lkIDA7XG4gICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSB2b2lkIDA7XG4gICAgICB0aGlzLnRpbWVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5jbGllbnRSZWN0ID0gdm9pZCAwO1xuICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB0aGlzLmZpcnN0TGV2ZWwgPSAtMTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IENhcExldmVsQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnNldFN0cmVhbUNvbnRyb2xsZXIgPSBmdW5jdGlvbiBzZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHN0cmVhbUNvbnRyb2xsZXI7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy5obHMpIHtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgIHRoaXMuc3RvcENhcHBpbmcoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuaGxzID0gdGhpcy5zdHJlYW1Db250cm9sbGVyID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9uKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcigpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vZmYoRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHRoaXMub25GcHNEcm9wTGV2ZWxDYXBwaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5vbkZwc0Ryb3BMZXZlbENhcHBpbmcgPSBmdW5jdGlvbiBvbkZwc0Ryb3BMZXZlbENhcHBpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIC8vIERvbid0IGFkZCBhIHJlc3RyaWN0ZWQgbGV2ZWwgbW9yZSB0aGFuIG9uY2VcbiAgICAgIHZhciBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tkYXRhLmRyb3BwZWRMZXZlbF07XG4gICAgICBpZiAodGhpcy5pc0xldmVsQWxsb3dlZChsZXZlbCkpIHtcbiAgICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goe1xuICAgICAgICAgIGJpdHJhdGU6IGxldmVsLmJpdHJhdGUsXG4gICAgICAgICAgaGVpZ2h0OiBsZXZlbC5oZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IGxldmVsLndpZHRoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFBdHRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhQXR0YWNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgICBpZiAodGhpcy50aW1lciAmJiB0aGlzLmhscy5sZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RQYXJzZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICAgIHRoaXMuZmlyc3RMZXZlbCA9IGRhdGEuZmlyc3RMZXZlbDtcbiAgICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplICYmIGRhdGEudmlkZW8pIHtcbiAgICAgICAgLy8gU3RhcnQgY2FwcGluZyBpbW1lZGlhdGVseSBpZiB0aGUgbWFuaWZlc3QgaGFzIHNpZ25hbGVkIHZpZGVvIGNvZGVjc1xuICAgICAgICB0aGlzLnN0YXJ0Q2FwcGluZygpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uTGV2ZWxzVXBkYXRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxzVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgICAgaWYgKHRoaXMudGltZXIgJiYgaXNGaW5pdGVOdW1iZXIodGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSkge1xuICAgICAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPbmx5IGFjdGl2YXRlIGNhcHBpbmcgd2hlbiBwbGF5aW5nIGEgdmlkZW8gc3RyZWFtOyBvdGhlcndpc2UsIG11bHRpLWJpdHJhdGUgYXVkaW8tb25seSBzdHJlYW1zIHdpbGwgYmUgcmVzdHJpY3RlZFxuICAgIC8vIHRvIHRoZSBmaXJzdCBsZXZlbFxuICAgIDtcbiAgICBfcHJvdG8ub25CdWZmZXJDb2RlY3MgPSBmdW5jdGlvbiBvbkJ1ZmZlckNvZGVjcyhldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgICAvLyBJZiB0aGUgbWFuaWZlc3QgZGlkIG5vdCBzaWduYWwgYSB2aWRlbyBjb2RlYyBjYXBwaW5nIGhhcyBiZWVuIGRlZmVycmVkIHVudGlsIHdlJ3JlIGNlcnRhaW4gdmlkZW8gaXMgcHJlc2VudFxuICAgICAgICB0aGlzLnN0YXJ0Q2FwcGluZygpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFEZXRhY2hpbmcgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgICAgdGhpcy5zdG9wQ2FwcGluZygpO1xuICAgIH07XG4gICAgX3Byb3RvLmRldGVjdFBsYXllclNpemUgPSBmdW5jdGlvbiBkZXRlY3RQbGF5ZXJTaXplKCkge1xuICAgICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgICAgaWYgKHRoaXMubWVkaWFIZWlnaHQgPD0gMCB8fCB0aGlzLm1lZGlhV2lkdGggPD0gMCkge1xuICAgICAgICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICAgIGlmIChsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICAgIHZhciBtYXhMZXZlbCA9IHRoaXMuZ2V0TWF4TGV2ZWwobGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGlmIChtYXhMZXZlbCAhPT0gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiU2V0dGluZyBhdXRvTGV2ZWxDYXBwaW5nIHRvIFwiICsgbWF4TGV2ZWwgKyBcIjogXCIgKyBsZXZlbHNbbWF4TGV2ZWxdLmhlaWdodCArIFwicEBcIiArIGxldmVsc1ttYXhMZXZlbF0uYml0cmF0ZSArIFwiIGZvciBtZWRpYSBcIiArIHRoaXMubWVkaWFXaWR0aCArIFwieFwiICsgdGhpcy5tZWRpYUhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gbWF4TGV2ZWw7XG4gICAgICAgICAgaWYgKGhscy5hdXRvTGV2ZWxDYXBwaW5nID4gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nICYmIHRoaXMuc3RyZWFtQ29udHJvbGxlcikge1xuICAgICAgICAgICAgLy8gaWYgYXV0byBsZXZlbCBjYXBwaW5nIGhhcyBhIGhpZ2hlciB2YWx1ZSBmb3IgdGhlIHByZXZpb3VzIG9uZSwgZmx1c2ggdGhlIGJ1ZmZlciB1c2luZyBuZXh0TGV2ZWxTd2l0Y2hcbiAgICAgICAgICAgIC8vIHVzdWFsbHkgaGFwcGVuIHdoZW4gdGhlIHVzZXIgZ28gdG8gdGhlIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gaGxzLmF1dG9MZXZlbENhcHBpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIHJldHVybnMgbGV2ZWwgc2hvdWxkIGJlIHRoZSBvbmUgd2l0aCB0aGUgZGltZW5zaW9ucyBlcXVhbCBvciBncmVhdGVyIHRoYW4gdGhlIG1lZGlhIChwbGF5ZXIpIGRpbWVuc2lvbnMgKHNvIHRoZSB2aWRlbyB3aWxsIGJlIGRvd25zY2FsZWQpXG4gICAgICovO1xuICAgIF9wcm90by5nZXRNYXhMZXZlbCA9IGZ1bmN0aW9uIGdldE1heExldmVsKGNhcExldmVsSW5kZXgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgaWYgKCFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWxpZExldmVscyA9IGxldmVscy5maWx0ZXIoZnVuY3Rpb24gKGxldmVsLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuaXNMZXZlbEFsbG93ZWQobGV2ZWwpICYmIGluZGV4IDw9IGNhcExldmVsSW5kZXg7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgICByZXR1cm4gQ2FwTGV2ZWxDb250cm9sbGVyLmdldE1heExldmVsQnlNZWRpYVNpemUodmFsaWRMZXZlbHMsIHRoaXMubWVkaWFXaWR0aCwgdGhpcy5tZWRpYUhlaWdodCk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3RhcnRDYXBwaW5nID0gZnVuY3Rpb24gc3RhcnRDYXBwaW5nKCkge1xuICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVzZXQgY2FwcGluZyBpZiBzdGFydGVkIHR3aWNlOyB0aGlzIGNhbiBoYXBwZW4gaWYgdGhlIG1hbmlmZXN0IHNpZ25hbHMgYSB2aWRlbyBjb2RlY1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLmRldGVjdFBsYXllclNpemUuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgICB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgICB9O1xuICAgIF9wcm90by5zdG9wQ2FwcGluZyA9IGZ1bmN0aW9uIHN0b3BDYXBwaW5nKCkge1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgICB0aGlzLmZpcnN0TGV2ZWwgPSAtMTtcbiAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZXREaW1lbnNpb25zID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9ucygpIHtcbiAgICAgIGlmICh0aGlzLmNsaWVudFJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50UmVjdDtcbiAgICAgIH1cbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICB2YXIgYm91bmRzUmVjdCA9IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICB2YXIgY2xpZW50UmVjdCA9IG1lZGlhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBib3VuZHNSZWN0LndpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgICAgICAgYm91bmRzUmVjdC5oZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgICAgICAgaWYgKCFib3VuZHNSZWN0LndpZHRoICYmICFib3VuZHNSZWN0LmhlaWdodCkge1xuICAgICAgICAgIC8vIFdoZW4gdGhlIG1lZGlhIGVsZW1lbnQgaGFzIG5vIHdpZHRoIG9yIGhlaWdodCAoZXF1aXZhbGVudCB0byBub3QgYmVpbmcgaW4gdGhlIERPTSksXG4gICAgICAgICAgLy8gdGhlbiB1c2UgaXRzIHdpZHRoIGFuZCBoZWlnaHQgYXR0cmlidXRlcyAobWVkaWEud2lkdGgsIG1lZGlhLmhlaWdodClcbiAgICAgICAgICBib3VuZHNSZWN0LndpZHRoID0gY2xpZW50UmVjdC5yaWdodCAtIGNsaWVudFJlY3QubGVmdCB8fCBtZWRpYS53aWR0aCB8fCAwO1xuICAgICAgICAgIGJvdW5kc1JlY3QuaGVpZ2h0ID0gY2xpZW50UmVjdC5ib3R0b20gLSBjbGllbnRSZWN0LnRvcCB8fCBtZWRpYS5oZWlnaHQgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5jbGllbnRSZWN0ID0gYm91bmRzUmVjdDtcbiAgICAgIHJldHVybiBib3VuZHNSZWN0O1xuICAgIH07XG4gICAgX3Byb3RvLmlzTGV2ZWxBbGxvd2VkID0gZnVuY3Rpb24gaXNMZXZlbEFsbG93ZWQobGV2ZWwpIHtcbiAgICAgIHZhciByZXN0cmljdGVkTGV2ZWxzID0gdGhpcy5yZXN0cmljdGVkTGV2ZWxzO1xuICAgICAgcmV0dXJuICFyZXN0cmljdGVkTGV2ZWxzLnNvbWUoZnVuY3Rpb24gKHJlc3RyaWN0ZWRMZXZlbCkge1xuICAgICAgICByZXR1cm4gbGV2ZWwuYml0cmF0ZSA9PT0gcmVzdHJpY3RlZExldmVsLmJpdHJhdGUgJiYgbGV2ZWwud2lkdGggPT09IHJlc3RyaWN0ZWRMZXZlbC53aWR0aCAmJiBsZXZlbC5oZWlnaHQgPT09IHJlc3RyaWN0ZWRMZXZlbC5oZWlnaHQ7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIENhcExldmVsQ29udHJvbGxlci5nZXRNYXhMZXZlbEJ5TWVkaWFTaXplID0gZnVuY3Rpb24gZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZShsZXZlbHMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmICghKGxldmVscyAhPSBudWxsICYmIGxldmVscy5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgLy8gTGV2ZWxzIGNhbiBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMgYnV0IGRpZmZlcmluZyBiYW5kd2lkdGhzIC0gc2luY2UgbGV2ZWxzIGFyZSBvcmRlcmVkLCB3ZSBjYW4gbG9vayB0byB0aGUgbmV4dFxuICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UndmUgY2hvc2VuIHRoZSBncmVhdGVzdCBiYW5kd2lkdGggZm9yIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnNcbiAgICAgIHZhciBhdEdyZWF0ZXN0QmFuZHdpZHRoID0gZnVuY3Rpb24gYXRHcmVhdGVzdEJhbmR3aWR0aChjdXJMZXZlbCwgbmV4dExldmVsKSB7XG4gICAgICAgIGlmICghbmV4dExldmVsKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1ckxldmVsLndpZHRoICE9PSBuZXh0TGV2ZWwud2lkdGggfHwgY3VyTGV2ZWwuaGVpZ2h0ICE9PSBuZXh0TGV2ZWwuaGVpZ2h0O1xuICAgICAgfTtcblxuICAgICAgLy8gSWYgd2UgcnVuIHRocm91Z2ggdGhlIGxvb3Agd2l0aG91dCBicmVha2luZywgdGhlIG1lZGlhJ3MgZGltZW5zaW9ucyBhcmUgZ3JlYXRlciB0aGFuIGV2ZXJ5IGxldmVsLCBzbyBkZWZhdWx0IHRvXG4gICAgICAvLyB0aGUgbWF4IGxldmVsXG4gICAgICB2YXIgbWF4TGV2ZWxJbmRleCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgICAgLy8gUHJldmVudCBjaGFuZ2VzIGluIGFzcGVjdC1yYXRpbyBmcm9tIGNhdXNpbmcgY2FwcGluZyB0byB0b2dnbGUgYmFjayBhbmQgZm9ydGhcbiAgICAgIHZhciBzcXVhcmVTaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICAgIGlmICgobGV2ZWwud2lkdGggPj0gc3F1YXJlU2l6ZSB8fCBsZXZlbC5oZWlnaHQgPj0gc3F1YXJlU2l6ZSkgJiYgYXRHcmVhdGVzdEJhbmR3aWR0aChsZXZlbCwgbGV2ZWxzW2kgKyAxXSkpIHtcbiAgICAgICAgICBtYXhMZXZlbEluZGV4ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1heExldmVsSW5kZXg7XG4gICAgfTtcbiAgICBfY3JlYXRlQ2xhc3MoQ2FwTGV2ZWxDb250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcIm1lZGlhV2lkdGhcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREaW1lbnNpb25zKCkud2lkdGggKiB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWVkaWFIZWlnaHRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREaW1lbnNpb25zKCkuaGVpZ2h0ICogdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNvbnRlbnRTY2FsZUZhY3RvclwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gMTtcbiAgICAgICAgaWYgKCF0aGlzLmhscy5jb25maWcuaWdub3JlRGV2aWNlUGl4ZWxSYXRpbykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gc2VsZi5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIG5vLW9wICovXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXhlbFJhdGlvO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQ2FwTGV2ZWxDb250cm9sbGVyO1xuICB9KCk7XG5cbiAgdmFyIEZQU0NvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZQU0NvbnRyb2xsZXIoaGxzKSB7XG4gICAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy50aW1lciA9IHZvaWQgMDtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0VGltZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSAwO1xuICAgICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IDA7XG4gICAgICAvLyBzdHJlYW0gY29udHJvbGxlciBtdXN0IGJlIHByb3ZpZGVkIGFzIGEgZGVwZW5kZW5jeSFcbiAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaGxzID0gaGxzO1xuICAgICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gRlBTQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnNldFN0cmVhbUNvbnRyb2xsZXIgPSBmdW5jdGlvbiBzZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHN0cmVhbUNvbnRyb2xsZXI7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB9XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYUF0dGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgICBpZiAoY29uZmlnLmNhcExldmVsT25GUFNEcm9wKSB7XG4gICAgICAgIHZhciBtZWRpYSA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBzZWxmLkhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICAgICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgICAgICBpZiAobWVkaWEgJiYgdHlwZW9mIG1lZGlhLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHRoaXMuY2hlY2tGUFNJbnRlcnZhbC5iaW5kKHRoaXMpLCBjb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2QpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNoZWNrRlBTID0gZnVuY3Rpb24gY2hlY2tGUFModmlkZW8sIGRlY29kZWRGcmFtZXMsIGRyb3BwZWRGcmFtZXMpIHtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgaWYgKGRlY29kZWRGcmFtZXMpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZTtcbiAgICAgICAgICB2YXIgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcztcbiAgICAgICAgICB2YXIgY3VycmVudERlY29kZWQgPSBkZWNvZGVkRnJhbWVzIC0gdGhpcy5sYXN0RGVjb2RlZEZyYW1lcztcbiAgICAgICAgICB2YXIgZHJvcHBlZEZQUyA9IDEwMDAgKiBjdXJyZW50RHJvcHBlZCAvIGN1cnJlbnRQZXJpb2Q7XG4gICAgICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUFNfRFJPUCwge1xuICAgICAgICAgICAgY3VycmVudERyb3BwZWQ6IGN1cnJlbnREcm9wcGVkLFxuICAgICAgICAgICAgY3VycmVudERlY29kZWQ6IGN1cnJlbnREZWNvZGVkLFxuICAgICAgICAgICAgdG90YWxEcm9wcGVkRnJhbWVzOiBkcm9wcGVkRnJhbWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGRyb3BwZWRGUFMgPiAwKSB7XG4gICAgICAgICAgICAvLyBsb2dnZXIubG9nKCdjaGVja0ZQUyA6IGRyb3BwZWRGUFMvZGVjb2RlZEZQUzonICsgZHJvcHBlZEZQUy8oMTAwMCAqIGN1cnJlbnREZWNvZGVkIC8gY3VycmVudFBlcmlvZCkpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREcm9wcGVkID4gaGxzLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCAqIGN1cnJlbnREZWNvZGVkKSB7XG4gICAgICAgICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSBobHMuY3VycmVudExldmVsO1xuICAgICAgICAgICAgICBsb2dnZXIud2FybignZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6ICcgKyBjdXJyZW50TGV2ZWwpO1xuICAgICAgICAgICAgICBpZiAoY3VycmVudExldmVsID4gMCAmJiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8IGhscy5hdXRvTGV2ZWxDYXBwaW5nID49IGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWwgLSAxO1xuICAgICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB7XG4gICAgICAgICAgICAgICAgICBsZXZlbDogY3VycmVudExldmVsLFxuICAgICAgICAgICAgICAgICAgZHJvcHBlZExldmVsOiBobHMuY3VycmVudExldmVsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IGRyb3BwZWRGcmFtZXM7XG4gICAgICAgIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSBkZWNvZGVkRnJhbWVzO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNoZWNrRlBTSW50ZXJ2YWwgPSBmdW5jdGlvbiBjaGVja0ZQU0ludGVydmFsKCkge1xuICAgICAgdmFyIHZpZGVvID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmICh2aWRlbykge1xuICAgICAgICBpZiAodGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlKSB7XG4gICAgICAgICAgdmFyIHZpZGVvUGxheWJhY2tRdWFsaXR5ID0gdmlkZW8uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKTtcbiAgICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlb1BsYXliYWNrUXVhbGl0eS50b3RhbFZpZGVvRnJhbWVzLCB2aWRlb1BsYXliYWNrUXVhbGl0eS5kcm9wcGVkVmlkZW9GcmFtZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEhUTUxWaWRlb0VsZW1lbnQgZG9lc24ndCBpbmNsdWRlIHRoZSB3ZWJraXQgdHlwZXNcbiAgICAgICAgICB0aGlzLmNoZWNrRlBTKHZpZGVvLCB2aWRlby53ZWJraXREZWNvZGVkRnJhbWVDb3VudCwgdmlkZW8ud2Via2l0RHJvcHBlZEZyYW1lQ291bnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRlBTQ29udHJvbGxlcjtcbiAgfSgpO1xuXG4gIHZhciBMT0dHRVJfUFJFRklYID0gJ1tlbWVdJztcbiAgLyoqXG4gICAqIENvbnRyb2xsZXIgdG8gZGVhbCB3aXRoIGVuY3J5cHRlZCBtZWRpYSBleHRlbnNpb25zIChFTUUpXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VuY3J5cHRlZF9NZWRpYV9FeHRlbnNpb25zX0FQSVxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB2YXIgRU1FQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRU1FQ29udHJvbGxlcihobHMpIHtcbiAgICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IG51bGw7XG4gICAgICB0aGlzLmtleVN5c3RlbUFjY2Vzc1Byb21pc2VzID0ge307XG4gICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgICB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMgPSBbXTtcbiAgICAgIHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlID0ge307XG4gICAgICB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlID0gRU1FQ29udHJvbGxlci5DRE1DbGVhbnVwUHJvbWlzZSA/IFtFTUVDb250cm9sbGVyLkNETUNsZWFudXBQcm9taXNlXSA6IFtdO1xuICAgICAgdGhpcy5vbk1lZGlhRW5jcnlwdGVkID0gdGhpcy5fb25NZWRpYUVuY3J5cHRlZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5vbldhaXRpbmdGb3JLZXkgPSB0aGlzLl9vbldhaXRpbmdGb3JLZXkuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuZGVidWcgPSBsb2dnZXIuZGVidWcuYmluZChsb2dnZXIsIExPR0dFUl9QUkVGSVgpO1xuICAgICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBMT0dHRVJfUFJFRklYKTtcbiAgICAgIHRoaXMud2FybiA9IGxvZ2dlci53YXJuLmJpbmQobG9nZ2VyLCBMT0dHRVJfUFJFRklYKTtcbiAgICAgIHRoaXMuZXJyb3IgPSBsb2dnZXIuZXJyb3IuYmluZChsb2dnZXIsIExPR0dFUl9QUkVGSVgpO1xuICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBFTUVDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMub25NZWRpYURldGFjaGVkKCk7XG4gICAgICAvLyBSZW1vdmUgYW55IHJlZmVyZW5jZXMgdGhhdCBjb3VsZCBiZSBoZWxkIGluIGNvbmZpZyBvcHRpb25zIG9yIGNhbGxiYWNrc1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgY29uZmlnLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMgPSBudWxsO1xuICAgICAgY29uZmlnLmxpY2Vuc2VYaHJTZXR1cCA9IGNvbmZpZy5saWNlbnNlUmVzcG9uc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgIGNvbmZpZy5kcm1TeXN0ZW1zID0gY29uZmlnLmRybVN5c3RlbU9wdGlvbnMgPSB7fTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuaGxzID0gdGhpcy5vbk1lZGlhRW5jcnlwdGVkID0gdGhpcy5vbldhaXRpbmdGb3JLZXkgPSB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgICB0aGlzLmhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICB0aGlzLmhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldExpY2Vuc2VTZXJ2ZXJVcmwgPSBmdW5jdGlvbiBnZXRMaWNlbnNlU2VydmVyVXJsKGtleVN5c3RlbSkge1xuICAgICAgdmFyIF90aGlzJGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBkcm1TeXN0ZW1zID0gX3RoaXMkY29uZmlnLmRybVN5c3RlbXMsXG4gICAgICAgIHdpZGV2aW5lTGljZW5zZVVybCA9IF90aGlzJGNvbmZpZy53aWRldmluZUxpY2Vuc2VVcmw7XG4gICAgICB2YXIga2V5U3lzdGVtQ29uZmlndXJhdGlvbiA9IGRybVN5c3RlbXNba2V5U3lzdGVtXTtcbiAgICAgIGlmIChrZXlTeXN0ZW1Db25maWd1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBrZXlTeXN0ZW1Db25maWd1cmF0aW9uLmxpY2Vuc2VVcmw7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICBpZiAoa2V5U3lzdGVtID09PSBLZXlTeXN0ZW1zLldJREVWSU5FICYmIHdpZGV2aW5lTGljZW5zZVVybCkge1xuICAgICAgICByZXR1cm4gd2lkZXZpbmVMaWNlbnNlVXJsO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gbGljZW5zZSBzZXJ2ZXIgVVJMIGNvbmZpZ3VyZWQgZm9yIGtleS1zeXN0ZW0gXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiXCIpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFNlcnZlckNlcnRpZmljYXRlVXJsID0gZnVuY3Rpb24gZ2V0U2VydmVyQ2VydGlmaWNhdGVVcmwoa2V5U3lzdGVtKSB7XG4gICAgICB2YXIgZHJtU3lzdGVtcyA9IHRoaXMuY29uZmlnLmRybVN5c3RlbXM7XG4gICAgICB2YXIga2V5U3lzdGVtQ29uZmlndXJhdGlvbiA9IGRybVN5c3RlbXNba2V5U3lzdGVtXTtcbiAgICAgIGlmIChrZXlTeXN0ZW1Db25maWd1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBrZXlTeXN0ZW1Db25maWd1cmF0aW9uLnNlcnZlckNlcnRpZmljYXRlVXJsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2coXCJObyBTZXJ2ZXIgQ2VydGlmaWNhdGUgaW4gY29uZmlnLmRybVN5c3RlbXNbXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiXVwiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5hdHRlbXB0S2V5U3lzdGVtQWNjZXNzID0gZnVuY3Rpb24gYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW1zVG9BdHRlbXB0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICAgIHZhciB1bmlxdWVDb2RlYyA9IGZ1bmN0aW9uIHVuaXF1ZUNvZGVjKHZhbHVlLCBpLCBhKSB7XG4gICAgICAgIHJldHVybiAhIXZhbHVlICYmIGEuaW5kZXhPZih2YWx1ZSkgPT09IGk7XG4gICAgICB9O1xuICAgICAgdmFyIGF1ZGlvQ29kZWNzID0gbGV2ZWxzLm1hcChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIGxldmVsLmF1ZGlvQ29kZWM7XG4gICAgICB9KS5maWx0ZXIodW5pcXVlQ29kZWMpO1xuICAgICAgdmFyIHZpZGVvQ29kZWNzID0gbGV2ZWxzLm1hcChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIGxldmVsLnZpZGVvQ29kZWM7XG4gICAgICB9KS5maWx0ZXIodW5pcXVlQ29kZWMpO1xuICAgICAgaWYgKGF1ZGlvQ29kZWNzLmxlbmd0aCArIHZpZGVvQ29kZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2aWRlb0NvZGVjcy5wdXNoKCdhdmMxLjQyZTAxZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGF0dGVtcHQgPSBmdW5jdGlvbiBhdHRlbXB0KGtleVN5c3RlbXMpIHtcbiAgICAgICAgICB2YXIga2V5U3lzdGVtID0ga2V5U3lzdGVtcy5zaGlmdCgpO1xuICAgICAgICAgIF90aGlzLmdldE1lZGlhS2V5c1Byb21pc2Uoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpLnRoZW4oZnVuY3Rpb24gKG1lZGlhS2V5cykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe1xuICAgICAgICAgICAgICBrZXlTeXN0ZW06IGtleVN5c3RlbSxcbiAgICAgICAgICAgICAgbWVkaWFLZXlzOiBtZWRpYUtleXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGtleVN5c3RlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGF0dGVtcHQoa2V5U3lzdGVtcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgRU1FS2V5RXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19BQ0NFU1MsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgICAgIH0sIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgYXR0ZW1wdChrZXlTeXN0ZW1zVG9BdHRlbXB0KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA9IGZ1bmN0aW9uIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyQxKGtleVN5c3RlbSwgc3VwcG9ydGVkQ29uZmlndXJhdGlvbnMpIHtcbiAgICAgIHZhciByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jID0gdGhpcy5jb25maWcucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYztcbiAgICAgIGlmICghKHR5cGVvZiByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB2YXIgZXJyTWVzc2FnZSA9IFwiQ29uZmlndXJlZCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgaXMgbm90IGEgZnVuY3Rpb24gXCIgKyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jO1xuICAgICAgICBpZiAocmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID09PSBudWxsICYmIHNlbGYubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICAgICAgICBlcnJNZXNzYWdlID0gXCJuYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIGlzIG5vdCBhdmFpbGFibGUgb3ZlciBpbnNlY3VyZSBwcm90b2NvbCBcIiArIGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoZXJyTWVzc2FnZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMoa2V5U3lzdGVtLCBzdXBwb3J0ZWRDb25maWd1cmF0aW9ucyk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TWVkaWFLZXlzUHJvbWlzZSA9IGZ1bmN0aW9uIGdldE1lZGlhS2V5c1Byb21pc2Uoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgLy8gVGhpcyBjYW4gdGhyb3csIGJ1dCBpcyBjYXVnaHQgaW4gZXZlbnQgaGFuZGxlciBjYWxscGF0aFxuICAgICAgdmFyIG1lZGlhS2V5U3lzdGVtQ29uZmlncyA9IGdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMoa2V5U3lzdGVtLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIHRoaXMuY29uZmlnLmRybVN5c3RlbU9wdGlvbnMpO1xuICAgICAgdmFyIGtleVN5c3RlbUFjY2Vzc1Byb21pc2VzID0gdGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlc1trZXlTeXN0ZW1dO1xuICAgICAgdmFyIGtleVN5c3RlbUFjY2VzcyA9IGtleVN5c3RlbUFjY2Vzc1Byb21pc2VzID09IG51bGwgPyB2b2lkIDAgOiBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5rZXlTeXN0ZW1BY2Nlc3M7XG4gICAgICBpZiAoIWtleVN5c3RlbUFjY2Vzcykge1xuICAgICAgICB0aGlzLmxvZyhcIlJlcXVlc3RpbmcgZW5jcnlwdGVkIG1lZGlhIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIiBrZXktc3lzdGVtIGFjY2VzcyB3aXRoIGNvbmZpZzogXCIgKyBKU09OLnN0cmluZ2lmeShtZWRpYUtleVN5c3RlbUNvbmZpZ3MpKTtcbiAgICAgICAga2V5U3lzdGVtQWNjZXNzID0gdGhpcy5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtLCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MpO1xuICAgICAgICB2YXIgX2tleVN5c3RlbUFjY2Vzc1Byb21pc2VzID0gdGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlc1trZXlTeXN0ZW1dID0ge1xuICAgICAgICAgIGtleVN5c3RlbUFjY2Vzczoga2V5U3lzdGVtQWNjZXNzXG4gICAgICAgIH07XG4gICAgICAgIGtleVN5c3RlbUFjY2Vzcy5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBfdGhpczIubG9nKFwiRmFpbGVkIHRvIG9idGFpbiBhY2Nlc3MgdG8ga2V5LXN5c3RlbSBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCI6IFwiICsgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGtleVN5c3RlbUFjY2Vzcy50aGVuKGZ1bmN0aW9uIChtZWRpYUtleVN5c3RlbUFjY2Vzcykge1xuICAgICAgICAgIF90aGlzMi5sb2coXCJBY2Nlc3MgZm9yIGtleS1zeXN0ZW0gXFxcIlwiICsgbWVkaWFLZXlTeXN0ZW1BY2Nlc3Mua2V5U3lzdGVtICsgXCJcXFwiIG9idGFpbmVkXCIpO1xuICAgICAgICAgIHZhciBjZXJ0aWZpY2F0ZVJlcXVlc3QgPSBfdGhpczIuZmV0Y2hTZXJ2ZXJDZXJ0aWZpY2F0ZShrZXlTeXN0ZW0pO1xuICAgICAgICAgIF90aGlzMi5sb2coXCJDcmVhdGUgbWVkaWEta2V5cyBmb3IgXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiXCIpO1xuICAgICAgICAgIF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5tZWRpYUtleXMgPSBtZWRpYUtleVN5c3RlbUFjY2Vzcy5jcmVhdGVNZWRpYUtleXMoKS50aGVuKGZ1bmN0aW9uIChtZWRpYUtleXMpIHtcbiAgICAgICAgICAgIF90aGlzMi5sb2coXCJNZWRpYS1rZXlzIGNyZWF0ZWQgZm9yIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiBjZXJ0aWZpY2F0ZVJlcXVlc3QudGhlbihmdW5jdGlvbiAoY2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgICAgaWYgKGNlcnRpZmljYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5zZXRNZWRpYUtleXNTZXJ2ZXJDZXJ0aWZpY2F0ZShtZWRpYUtleXMsIGtleVN5c3RlbSwgY2VydGlmaWNhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBtZWRpYUtleXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfa2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMubWVkaWFLZXlzLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMyLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBtZWRpYS1rZXlzIGZvciBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCJ9OiBcIiArIGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gX2tleVN5c3RlbUFjY2Vzc1Byb21pc2VzLm1lZGlhS2V5cztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5U3lzdGVtQWNjZXNzLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMubWVkaWFLZXlzO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQoX3JlZikge1xuICAgICAgdmFyIGRlY3J5cHRkYXRhID0gX3JlZi5kZWNyeXB0ZGF0YSxcbiAgICAgICAga2V5U3lzdGVtID0gX3JlZi5rZXlTeXN0ZW0sXG4gICAgICAgIG1lZGlhS2V5cyA9IF9yZWYubWVkaWFLZXlzO1xuICAgICAgdGhpcy5sb2coXCJDcmVhdGluZyBrZXktc3lzdGVtIHNlc3Npb24gXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiIGtleUlkOiBcIiArIEhleC5oZXhEdW1wKGRlY3J5cHRkYXRhLmtleUlkIHx8IFtdKSk7XG4gICAgICB2YXIgbWVkaWFLZXlzU2Vzc2lvbiA9IG1lZGlhS2V5cy5jcmVhdGVTZXNzaW9uKCk7XG4gICAgICB2YXIgbWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9IHtcbiAgICAgICAgZGVjcnlwdGRhdGE6IGRlY3J5cHRkYXRhLFxuICAgICAgICBrZXlTeXN0ZW06IGtleVN5c3RlbSxcbiAgICAgICAgbWVkaWFLZXlzOiBtZWRpYUtleXMsXG4gICAgICAgIG1lZGlhS2V5c1Nlc3Npb246IG1lZGlhS2V5c1Nlc3Npb24sXG4gICAgICAgIGtleVN0YXR1czogJ3N0YXR1cy1wZW5kaW5nJ1xuICAgICAgfTtcbiAgICAgIHRoaXMubWVkaWFLZXlTZXNzaW9ucy5wdXNoKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgICAgcmV0dXJuIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQ7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVuZXdLZXlTZXNzaW9uID0gZnVuY3Rpb24gcmVuZXdLZXlTZXNzaW9uKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICAgIHZhciBkZWNyeXB0ZGF0YSA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGE7XG4gICAgICBpZiAoZGVjcnlwdGRhdGEucHNzaCkge1xuICAgICAgICB2YXIga2V5U2Vzc2lvbkNvbnRleHQgPSB0aGlzLmNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQobWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgICAgIHZhciBfa2V5SWQgPSB0aGlzLmdldEtleUlkU3RyaW5nKGRlY3J5cHRkYXRhKTtcbiAgICAgICAgdmFyIHNjaGVtZSA9ICdjZW5jJztcbiAgICAgICAgdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2VbX2tleUlkXSA9IHRoaXMuZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oa2V5U2Vzc2lvbkNvbnRleHQsIHNjaGVtZSwgZGVjcnlwdGRhdGEucHNzaCwgJ2V4cGlyZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2FybihcIkNvdWxkIG5vdCByZW5ldyBleHBpcmVkIHNlc3Npb24uIE1pc3NpbmcgcHNzaCBpbml0RGF0YS5cIik7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0S2V5SWRTdHJpbmcgPSBmdW5jdGlvbiBnZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSkge1xuICAgICAgaWYgKCFkZWNyeXB0ZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZWFkIGtleUlkIG9mIHVuZGVmaW5lZCBkZWNyeXB0ZGF0YScpO1xuICAgICAgfVxuICAgICAgaWYgKGRlY3J5cHRkYXRhLmtleUlkID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5SWQgaXMgbnVsbCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEhleC5oZXhEdW1wKGRlY3J5cHRkYXRhLmtleUlkKTtcbiAgICB9O1xuICAgIF9wcm90by51cGRhdGVLZXlTZXNzaW9uID0gZnVuY3Rpb24gdXBkYXRlS2V5U2Vzc2lvbihtZWRpYUtleVNlc3Npb25Db250ZXh0LCBkYXRhKSB7XG4gICAgICB2YXIgX21lZGlhS2V5U2Vzc2lvbkNvbnRlO1xuICAgICAgdmFyIGtleVNlc3Npb24gPSBtZWRpYUtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb247XG4gICAgICB0aGlzLmxvZyhcIlVwZGF0aW5nIGtleS1zZXNzaW9uIFxcXCJcIiArIGtleVNlc3Npb24uc2Vzc2lvbklkICsgXCJcXFwiIGZvciBrZXlJRCBcIiArIEhleC5oZXhEdW1wKCgoX21lZGlhS2V5U2Vzc2lvbkNvbnRlID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5kZWNyeXB0ZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tZWRpYUtleVNlc3Npb25Db250ZS5rZXlJZCkgfHwgW10pICsgXCJcXG4gICAgICB9IChkYXRhIGxlbmd0aDogXCIgKyAoZGF0YSA/IGRhdGEuYnl0ZUxlbmd0aCA6IGRhdGEpICsgXCIpXCIpO1xuICAgICAgcmV0dXJuIGtleVNlc3Npb24udXBkYXRlKGRhdGEpO1xuICAgIH07XG4gICAgX3Byb3RvLnNlbGVjdEtleVN5c3RlbUZvcm1hdCA9IGZ1bmN0aW9uIHNlbGVjdEtleVN5c3RlbUZvcm1hdChmcmFnKSB7XG4gICAgICB2YXIga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKGZyYWcubGV2ZWxrZXlzIHx8IHt9KTtcbiAgICAgIGlmICghdGhpcy5rZXlGb3JtYXRQcm9taXNlKSB7XG4gICAgICAgIHRoaXMubG9nKFwiU2VsZWN0aW5nIGtleS1zeXN0ZW0gZnJvbSBmcmFnbWVudCAoc246IFwiICsgZnJhZy5zbiArIFwiIFwiICsgZnJhZy50eXBlICsgXCI6IFwiICsgZnJhZy5sZXZlbCArIFwiKSBrZXkgZm9ybWF0cyBcIiArIGtleUZvcm1hdHMuam9pbignLCAnKSk7XG4gICAgICAgIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IHRoaXMuZ2V0S2V5Rm9ybWF0UHJvbWlzZShrZXlGb3JtYXRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmtleUZvcm1hdFByb21pc2U7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0S2V5Rm9ybWF0UHJvbWlzZSA9IGZ1bmN0aW9uIGdldEtleUZvcm1hdFByb21pc2Uoa2V5Rm9ybWF0cykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIga2V5U3lzdGVtc0luQ29uZmlnID0gZ2V0S2V5U3lzdGVtc0ZvckNvbmZpZyhfdGhpczMuY29uZmlnKTtcbiAgICAgICAgdmFyIGtleVN5c3RlbXNUb0F0dGVtcHQgPSBrZXlGb3JtYXRzLm1hcChrZXlTeXN0ZW1Gb3JtYXRUb0tleVN5c3RlbURvbWFpbikuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiAhIXZhbHVlICYmIGtleVN5c3RlbXNJbkNvbmZpZy5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXMzLmdldEtleVN5c3RlbVNlbGVjdGlvblByb21pc2Uoa2V5U3lzdGVtc1RvQXR0ZW1wdCkudGhlbihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICB2YXIga2V5U3lzdGVtID0gX3JlZjIua2V5U3lzdGVtO1xuICAgICAgICAgIHZhciBrZXlTeXN0ZW1Gb3JtYXQgPSBrZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdChrZXlTeXN0ZW0pO1xuICAgICAgICAgIGlmIChrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICAgICAgICAgIHJlc29sdmUoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGZvcm1hdCBmb3Iga2V5LXN5c3RlbSBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRLZXkgPSBmdW5jdGlvbiBsb2FkS2V5KGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIGRlY3J5cHRkYXRhID0gZGF0YS5rZXlJbmZvLmRlY3J5cHRkYXRhO1xuICAgICAgdmFyIGtleUlkID0gdGhpcy5nZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSk7XG4gICAgICB2YXIga2V5RGV0YWlscyA9IFwiKGtleUlkOiBcIiArIGtleUlkICsgXCIgZm9ybWF0OiBcXFwiXCIgKyBkZWNyeXB0ZGF0YS5rZXlGb3JtYXQgKyBcIlxcXCIgbWV0aG9kOiBcIiArIGRlY3J5cHRkYXRhLm1ldGhvZCArIFwiIHVyaTogXCIgKyBkZWNyeXB0ZGF0YS51cmkgKyBcIilcIjtcbiAgICAgIHRoaXMubG9nKFwiU3RhcnRpbmcgc2Vzc2lvbiBmb3Iga2V5IFwiICsga2V5RGV0YWlscyk7XG4gICAgICB2YXIga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdO1xuICAgICAgaWYgKCFrZXlTZXNzaW9uQ29udGV4dFByb21pc2UpIHtcbiAgICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdID0gdGhpcy5nZXRLZXlTeXN0ZW1Gb3JLZXlQcm9taXNlKGRlY3J5cHRkYXRhKS50aGVuKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICAgIHZhciBrZXlTeXN0ZW0gPSBfcmVmMy5rZXlTeXN0ZW0sXG4gICAgICAgICAgICBtZWRpYUtleXMgPSBfcmVmMy5tZWRpYUtleXM7XG4gICAgICAgICAgX3RoaXM0LnRocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICBfdGhpczQubG9nKFwiSGFuZGxlIGVuY3J5cHRlZCBtZWRpYSBzbjogXCIgKyBkYXRhLmZyYWcuc24gKyBcIiBcIiArIGRhdGEuZnJhZy50eXBlICsgXCI6IFwiICsgZGF0YS5mcmFnLmxldmVsICsgXCIgdXNpbmcga2V5IFwiICsga2V5RGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5hdHRlbXB0U2V0TWVkaWFLZXlzKGtleVN5c3RlbSwgbWVkaWFLZXlzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNC50aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgICB2YXIga2V5U2Vzc2lvbkNvbnRleHQgPSBfdGhpczQuY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dCh7XG4gICAgICAgICAgICAgIGtleVN5c3RlbToga2V5U3lzdGVtLFxuICAgICAgICAgICAgICBtZWRpYUtleXM6IG1lZGlhS2V5cyxcbiAgICAgICAgICAgICAgZGVjcnlwdGRhdGE6IGRlY3J5cHRkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzY2hlbWUgPSAnY2VuYyc7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM0LmdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGtleVNlc3Npb25Db250ZXh0LCBzY2hlbWUsIGRlY3J5cHRkYXRhLnBzc2gsICdwbGF5bGlzdC1rZXknKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlO1xuICAgIH07XG4gICAgX3Byb3RvLnRocm93SWZEZXN0cm95ZWQgPSBmdW5jdGlvbiB0aHJvd0lmRGVzdHJveWVkKG1lc3NhZ2UpIHtcbiAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRU1FS2V5RXJyb3IpIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGVycm9yLmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fS0VZUyxcbiAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0S2V5U3lzdGVtRm9yS2V5UHJvbWlzZSA9IGZ1bmN0aW9uIGdldEtleVN5c3RlbUZvcktleVByb21pc2UoZGVjcnlwdGRhdGEpIHtcbiAgICAgIHZhciBrZXlJZCA9IHRoaXMuZ2V0S2V5SWRTdHJpbmcoZGVjcnlwdGRhdGEpO1xuICAgICAgdmFyIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgPSB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZF07XG4gICAgICBpZiAoIW1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpIHtcbiAgICAgICAgdmFyIGtleVN5c3RlbSA9IGtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluKGRlY3J5cHRkYXRhLmtleUZvcm1hdCk7XG4gICAgICAgIHZhciBrZXlTeXN0ZW1zVG9BdHRlbXB0ID0ga2V5U3lzdGVtID8gW2tleVN5c3RlbV0gOiBnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKHRoaXMuY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW1zVG9BdHRlbXB0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZWRpYUtleVNlc3Npb25Db250ZXh0O1xuICAgIH07XG4gICAgX3Byb3RvLmdldEtleVN5c3RlbVNlbGVjdGlvblByb21pc2UgPSBmdW5jdGlvbiBnZXRLZXlTeXN0ZW1TZWxlY3Rpb25Qcm9taXNlKGtleVN5c3RlbXNUb0F0dGVtcHQpIHtcbiAgICAgIGlmICgha2V5U3lzdGVtc1RvQXR0ZW1wdC5sZW5ndGgpIHtcbiAgICAgICAga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGdldEtleVN5c3RlbXNGb3JDb25maWcodGhpcy5jb25maWcpO1xuICAgICAgfVxuICAgICAgaWYgKGtleVN5c3RlbXNUb0F0dGVtcHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX0NPTkZJR1VSRURfTElDRU5TRSxcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9LCBcIk1pc3Npbmcga2V5LXN5c3RlbSBsaWNlbnNlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBcIiArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBkcm1TeXN0ZW1zOiB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1zXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCk7XG4gICAgfTtcbiAgICBfcHJvdG8uX29uTWVkaWFFbmNyeXB0ZWQgPSBmdW5jdGlvbiBfb25NZWRpYUVuY3J5cHRlZChldmVudCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgaW5pdERhdGFUeXBlID0gZXZlbnQuaW5pdERhdGFUeXBlLFxuICAgICAgICBpbml0RGF0YSA9IGV2ZW50LmluaXREYXRhO1xuICAgICAgdmFyIGxvZ01lc3NhZ2UgPSBcIlxcXCJcIiArIGV2ZW50LnR5cGUgKyBcIlxcXCIgZXZlbnQ6IGluaXQgZGF0YSB0eXBlOiBcXFwiXCIgKyBpbml0RGF0YVR5cGUgKyBcIlxcXCJcIjtcbiAgICAgIHRoaXMuZGVidWcobG9nTWVzc2FnZSk7XG5cbiAgICAgIC8vIElnbm9yZSBldmVudCB3aGVuIGluaXREYXRhIGlzIG51bGxcbiAgICAgIGlmIChpbml0RGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIga2V5SWQ7XG4gICAgICB2YXIga2V5U3lzdGVtRG9tYWluO1xuICAgICAgaWYgKGluaXREYXRhVHlwZSA9PT0gJ3NpbmYnICYmIHRoaXMuY29uZmlnLmRybVN5c3RlbXNbS2V5U3lzdGVtcy5GQUlSUExBWV0pIHtcbiAgICAgICAgLy8gTWF0Y2ggc2luZiBrZXlJZCB0byBwbGF5bGlzdCBza2Q6Ly9rZXlJZD1cbiAgICAgICAgdmFyIGpzb24gPSBiaW4yc3RyKG5ldyBVaW50OEFycmF5KGluaXREYXRhKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHNpbmYgPSBiYXNlNjREZWNvZGUoSlNPTi5wYXJzZShqc29uKS5zaW5mKTtcbiAgICAgICAgICB2YXIgdGVuYyA9IHBhcnNlU2luZihuZXcgVWludDhBcnJheShzaW5mKSk7XG4gICAgICAgICAgaWYgKCF0ZW5jKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInc2NobScgYm94IG1pc3Npbmcgb3Igbm90IGNiY3MvY2VuYyB3aXRoIHNjaGkgPiB0ZW5jXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlJZCA9IHRlbmMuc3ViYXJyYXkoOCwgMjQpO1xuICAgICAgICAgIGtleVN5c3RlbURvbWFpbiA9IEtleVN5c3RlbXMuRkFJUlBMQVk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGxvZ01lc3NhZ2UgKyBcIiBGYWlsZWQgdG8gcGFyc2Ugc2luZjogXCIgKyBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdXBwb3J0IFdpZGV2aW5lIGNsZWFyLWxlYWQga2V5LXNlc3Npb24gY3JlYXRpb24gKG90aGVyd2lzZSBkZXBlbmQgb24gcGxheWxpc3Qga2V5cylcbiAgICAgICAgdmFyIHBzc2hSZXN1bHRzID0gcGFyc2VNdWx0aVBzc2goaW5pdERhdGEpO1xuICAgICAgICB2YXIgcHNzaEluZm8gPSBwc3NoUmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24gKHBzc2gpIHtcbiAgICAgICAgICByZXR1cm4gcHNzaC5zeXN0ZW1JZCA9PT0gS2V5U3lzdGVtSWRzLldJREVWSU5FO1xuICAgICAgICB9KVswXTtcbiAgICAgICAgaWYgKCFwc3NoSW5mbykge1xuICAgICAgICAgIGlmIChwc3NoUmVzdWx0cy5sZW5ndGggPT09IDAgfHwgcHNzaFJlc3VsdHMuc29tZShmdW5jdGlvbiAocHNzaCkge1xuICAgICAgICAgICAgcmV0dXJuICFwc3NoLnN5c3RlbUlkO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4obG9nTWVzc2FnZSArIFwiIGNvbnRhaW5zIGluY29tcGxldGUgb3IgaW52YWxpZCBwc3NoIGRhdGFcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiaWdub3JpbmcgXCIgKyBsb2dNZXNzYWdlICsgXCIgZm9yIFwiICsgcHNzaFJlc3VsdHMubWFwKGZ1bmN0aW9uIChwc3NoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBrZXlTeXN0ZW1JZFRvS2V5U3lzdGVtRG9tYWluKHBzc2guc3lzdGVtSWQpO1xuICAgICAgICAgICAgfSkuam9pbignLCcpICsgXCIgcHNzaCBkYXRhIGluIGZhdm9yIG9mIHBsYXlsaXN0IGtleXNcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBrZXlTeXN0ZW1Eb21haW4gPSBrZXlTeXN0ZW1JZFRvS2V5U3lzdGVtRG9tYWluKHBzc2hJbmZvLnN5c3RlbUlkKTtcbiAgICAgICAgaWYgKHBzc2hJbmZvLnZlcnNpb24gPT09IDAgJiYgcHNzaEluZm8uZGF0YSkge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSBwc3NoSW5mby5kYXRhLmxlbmd0aCAtIDIyO1xuICAgICAgICAgIGtleUlkID0gcHNzaEluZm8uZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDE2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFrZXlTeXN0ZW1Eb21haW4gfHwgIWtleUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBrZXlJZEhleCA9IEhleC5oZXhEdW1wKGtleUlkKTtcbiAgICAgIHZhciBrZXlJZFRvS2V5U2Vzc2lvblByb21pc2UgPSB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSxcbiAgICAgICAgbWVkaWFLZXlTZXNzaW9ucyA9IHRoaXMubWVkaWFLZXlTZXNzaW9ucztcbiAgICAgIHZhciBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UgPSBrZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRIZXhdO1xuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgICAgLy8gTWF0Y2ggcGxheWxpc3Qga2V5XG4gICAgICAgICAgdmFyIGtleUNvbnRleHQgPSBtZWRpYUtleVNlc3Npb25zW2ldO1xuICAgICAgICAgIHZhciBkZWNyeXB0ZGF0YSA9IGtleUNvbnRleHQuZGVjcnlwdGRhdGE7XG4gICAgICAgICAgaWYgKCFkZWNyeXB0ZGF0YS5rZXlJZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvbGRLZXlJZEhleCA9IEhleC5oZXhEdW1wKGRlY3J5cHRkYXRhLmtleUlkKTtcbiAgICAgICAgICBpZiAoa2V5SWRIZXggPT09IG9sZEtleUlkSGV4IHx8IGRlY3J5cHRkYXRhLnVyaS5yZXBsYWNlKC8tL2csICcnKS5pbmRleE9mKGtleUlkSGV4KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtvbGRLZXlJZEhleF07XG4gICAgICAgICAgICBpZiAoZGVjcnlwdGRhdGEucHNzaCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTsgLy8gYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBrZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vbb2xkS2V5SWRIZXhdO1xuICAgICAgICAgICAgZGVjcnlwdGRhdGEucHNzaCA9IG5ldyBVaW50OEFycmF5KGluaXREYXRhKTtcbiAgICAgICAgICAgIGRlY3J5cHRkYXRhLmtleUlkID0ga2V5SWQ7XG4gICAgICAgICAgICBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UgPSBrZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRIZXhdID0ga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1LmdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGtleUNvbnRleHQsIGluaXREYXRhVHlwZSwgaW5pdERhdGEsICdlbmNyeXB0ZWQtZXZlbnQta2V5LW1hdGNoJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAxOyAvLyBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3JldDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFLZXlTZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmV0ID0gX2xvb3AoKTtcbiAgICAgICAgaWYgKF9yZXQgPT09IDApIGNvbnRpbnVlO1xuICAgICAgICBpZiAoX3JldCA9PT0gMSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIWtleVNlc3Npb25Db250ZXh0UHJvbWlzZSkge1xuICAgICAgICAvLyBDbGVhci1sZWFkIGtleSAobm90IGVuY291bnRlcmVkIGluIHBsYXlsaXN0KVxuICAgICAgICBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UgPSBrZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRIZXhdID0gdGhpcy5nZXRLZXlTeXN0ZW1TZWxlY3Rpb25Qcm9taXNlKFtrZXlTeXN0ZW1Eb21haW5dKS50aGVuKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICAgIHZhciBfa2V5U3lzdGVtVG9LZXlTeXN0ZW07XG4gICAgICAgICAgdmFyIGtleVN5c3RlbSA9IF9yZWY0LmtleVN5c3RlbSxcbiAgICAgICAgICAgIG1lZGlhS2V5cyA9IF9yZWY0Lm1lZGlhS2V5cztcbiAgICAgICAgICBfdGhpczUudGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHZhciBkZWNyeXB0ZGF0YSA9IG5ldyBMZXZlbEtleSgnSVNPLTIzMDAxLTcnLCBrZXlJZEhleCwgKF9rZXlTeXN0ZW1Ub0tleVN5c3RlbSA9IGtleVN5c3RlbURvbWFpblRvS2V5U3lzdGVtRm9ybWF0KGtleVN5c3RlbSkpICE9IG51bGwgPyBfa2V5U3lzdGVtVG9LZXlTeXN0ZW0gOiAnJyk7XG4gICAgICAgICAgZGVjcnlwdGRhdGEucHNzaCA9IG5ldyBVaW50OEFycmF5KGluaXREYXRhKTtcbiAgICAgICAgICBkZWNyeXB0ZGF0YS5rZXlJZCA9IGtleUlkO1xuICAgICAgICAgIHJldHVybiBfdGhpczUuYXR0ZW1wdFNldE1lZGlhS2V5cyhrZXlTeXN0ZW0sIG1lZGlhS2V5cykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczUudGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgICAgdmFyIGtleVNlc3Npb25Db250ZXh0ID0gX3RoaXM1LmNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQoe1xuICAgICAgICAgICAgICBkZWNyeXB0ZGF0YTogZGVjcnlwdGRhdGEsXG4gICAgICAgICAgICAgIGtleVN5c3RlbToga2V5U3lzdGVtLFxuICAgICAgICAgICAgICBtZWRpYUtleXM6IG1lZGlhS2V5c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM1LmdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGtleVNlc3Npb25Db250ZXh0LCBpbml0RGF0YVR5cGUsIGluaXREYXRhLCAnZW5jcnlwdGVkLWV2ZW50LW5vLW1hdGNoJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4gX3RoaXM1LmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLl9vbldhaXRpbmdGb3JLZXkgPSBmdW5jdGlvbiBfb25XYWl0aW5nRm9yS2V5KGV2ZW50KSB7XG4gICAgICB0aGlzLmxvZyhcIlxcXCJcIiArIGV2ZW50LnR5cGUgKyBcIlxcXCIgZXZlbnRcIik7XG4gICAgfTtcbiAgICBfcHJvdG8uYXR0ZW1wdFNldE1lZGlhS2V5cyA9IGZ1bmN0aW9uIGF0dGVtcHRTZXRNZWRpYUtleXMoa2V5U3lzdGVtLCBtZWRpYUtleXMpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgICAgdmFyIHF1ZXVlID0gdGhpcy5zZXRNZWRpYUtleXNRdWV1ZS5zbGljZSgpO1xuICAgICAgdGhpcy5sb2coXCJTZXR0aW5nIG1lZGlhLWtleXMgZm9yIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcbiAgICAgIC8vIE9ubHkgb25lIHNldE1lZGlhS2V5cygpIGNhbiBydW4gYXQgb25lIHRpbWUsIGFuZCBtdWx0aXBsZSBzZXRNZWRpYUtleXMoKSBvcGVyYXRpb25zXG4gICAgICAvLyBjYW4gYmUgcXVldWVkIGZvciBleGVjdXRpb24gZm9yIG11bHRpcGxlIGtleSBzZXNzaW9ucy5cbiAgICAgIHZhciBzZXRNZWRpYUtleXNQcm9taXNlID0gUHJvbWlzZS5hbGwocXVldWUpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV90aGlzNi5tZWRpYSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHNldCBtZWRpYUtleXMgd2l0aG91dCBtZWRpYSBlbGVtZW50IGF0dGFjaGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzNi5tZWRpYS5zZXRNZWRpYUtleXMobWVkaWFLZXlzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRNZWRpYUtleXNRdWV1ZS5wdXNoKHNldE1lZGlhS2V5c1Byb21pc2UpO1xuICAgICAgcmV0dXJuIHNldE1lZGlhS2V5c1Byb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNi5sb2coXCJNZWRpYS1rZXlzIHNldCBmb3IgXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiXCIpO1xuICAgICAgICBxdWV1ZS5wdXNoKHNldE1lZGlhS2V5c1Byb21pc2UpO1xuICAgICAgICBfdGhpczYuc2V0TWVkaWFLZXlzUXVldWUgPSBfdGhpczYuc2V0TWVkaWFLZXlzUXVldWUuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIHF1ZXVlLmluZGV4T2YocCkgPT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uID0gZnVuY3Rpb24gZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oY29udGV4dCwgaW5pdERhdGFUeXBlLCBpbml0RGF0YSwgcmVhc29uKSB7XG4gICAgICB2YXIgX3RoaXMkY29uZmlnJGRybVN5c3RlLFxuICAgICAgICBfdGhpcyRjb25maWckZHJtU3lzdGUyLFxuICAgICAgICBfdGhpczcgPSB0aGlzO1xuICAgICAgdmFyIGdlbmVyYXRlUmVxdWVzdEZpbHRlciA9IChfdGhpcyRjb25maWckZHJtU3lzdGUgPSB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzJGNvbmZpZyRkcm1TeXN0ZTIgPSBfdGhpcyRjb25maWckZHJtU3lzdGVbY29udGV4dC5rZXlTeXN0ZW1dKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY29uZmlnJGRybVN5c3RlMi5nZW5lcmF0ZVJlcXVlc3Q7XG4gICAgICBpZiAoZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIG1hcHBlZEluaXREYXRhID0gZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyLmNhbGwodGhpcy5obHMsIGluaXREYXRhVHlwZSwgaW5pdERhdGEsIGNvbnRleHQpO1xuICAgICAgICAgIGlmICghbWFwcGVkSW5pdERhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmcm9tIGNvbmZpZ3VyZWQgZ2VuZXJhdGVSZXF1ZXN0IGZpbHRlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbml0RGF0YVR5cGUgPSBtYXBwZWRJbml0RGF0YS5pbml0RGF0YVR5cGU7XG4gICAgICAgICAgaW5pdERhdGEgPSBjb250ZXh0LmRlY3J5cHRkYXRhLnBzc2ggPSBtYXBwZWRJbml0RGF0YS5pbml0RGF0YSA/IG5ldyBVaW50OEFycmF5KG1hcHBlZEluaXREYXRhLmluaXREYXRhKSA6IG51bGw7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdmFyIF90aGlzJGhscztcbiAgICAgICAgICB0aGlzLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgaWYgKChfdGhpcyRobHMgPSB0aGlzLmhscykgIT0gbnVsbCAmJiBfdGhpcyRobHMuY29uZmlnLmRlYnVnKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbml0RGF0YSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmxvZyhcIlNraXBwaW5nIGtleS1zZXNzaW9uIHJlcXVlc3QgZm9yIFxcXCJcIiArIHJlYXNvbiArIFwiXFxcIiAobm8gaW5pdERhdGEpXCIpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgdmFyIGtleUlkID0gdGhpcy5nZXRLZXlJZFN0cmluZyhjb250ZXh0LmRlY3J5cHRkYXRhKTtcbiAgICAgIHRoaXMubG9nKFwiR2VuZXJhdGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0IGZvciBcXFwiXCIgKyByZWFzb24gKyBcIlxcXCI6IFwiICsga2V5SWQgKyBcIiAoaW5pdCBkYXRhIHR5cGU6IFwiICsgaW5pdERhdGFUeXBlICsgXCIgbGVuZ3RoOiBcIiArIChpbml0RGF0YSA/IGluaXREYXRhLmJ5dGVMZW5ndGggOiBudWxsKSArIFwiKVwiKTtcbiAgICAgIHZhciBsaWNlbnNlU3RhdHVzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgdmFyIG9ubWVzc2FnZSA9IGNvbnRleHQuX29ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIga2V5U2Vzc2lvbiA9IGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbjtcbiAgICAgICAgaWYgKCFrZXlTZXNzaW9uKSB7XG4gICAgICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2VUeXBlID0gZXZlbnQubWVzc2FnZVR5cGUsXG4gICAgICAgICAgbWVzc2FnZSA9IGV2ZW50Lm1lc3NhZ2U7XG4gICAgICAgIF90aGlzNy5sb2coXCJcXFwiXCIgKyBtZXNzYWdlVHlwZSArIFwiXFxcIiBtZXNzYWdlIGV2ZW50IGZvciBzZXNzaW9uIFxcXCJcIiArIGtleVNlc3Npb24uc2Vzc2lvbklkICsgXCJcXFwiIG1lc3NhZ2Ugc2l6ZTogXCIgKyBtZXNzYWdlLmJ5dGVMZW5ndGgpO1xuICAgICAgICBpZiAobWVzc2FnZVR5cGUgPT09ICdsaWNlbnNlLXJlcXVlc3QnIHx8IG1lc3NhZ2VUeXBlID09PSAnbGljZW5zZS1yZW5ld2FsJykge1xuICAgICAgICAgIF90aGlzNy5yZW5ld0xpY2Vuc2UoY29udGV4dCwgbWVzc2FnZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpczcuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlVHlwZSA9PT0gJ2xpY2Vuc2UtcmVsZWFzZScpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5rZXlTeXN0ZW0gPT09IEtleVN5c3RlbXMuRkFJUlBMQVkpIHtcbiAgICAgICAgICAgIF90aGlzNy51cGRhdGVLZXlTZXNzaW9uKGNvbnRleHQsIHN0clRvVXRmOGFycmF5KCdhY2tub3dsZWRnZWQnKSk7XG4gICAgICAgICAgICBfdGhpczcucmVtb3ZlU2Vzc2lvbihjb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXM3Lndhcm4oXCJ1bmhhbmRsZWQgbWVkaWEga2V5IG1lc3NhZ2UgdHlwZSBcXFwiXCIgKyBtZXNzYWdlVHlwZSArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBvbmtleXN0YXR1c2VzY2hhbmdlID0gY29udGV4dC5fb25rZXlzdGF0dXNlc2NoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIga2V5U2Vzc2lvbiA9IGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbjtcbiAgICAgICAgaWYgKCFrZXlTZXNzaW9uKSB7XG4gICAgICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXM3Lm9uS2V5U3RhdHVzQ2hhbmdlKGNvbnRleHQpO1xuICAgICAgICB2YXIga2V5U3RhdHVzID0gY29udGV4dC5rZXlTdGF0dXM7XG4gICAgICAgIGxpY2Vuc2VTdGF0dXMuZW1pdCgna2V5U3RhdHVzJywga2V5U3RhdHVzKTtcbiAgICAgICAgaWYgKGtleVN0YXR1cyA9PT0gJ2V4cGlyZWQnKSB7XG4gICAgICAgICAgX3RoaXM3Lndhcm4oY29udGV4dC5rZXlTeXN0ZW0gKyBcIiBleHBpcmVkIGZvciBrZXkgXCIgKyBrZXlJZCk7XG4gICAgICAgICAgX3RoaXM3LnJlbmV3S2V5U2Vzc2lvbihjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlKTtcbiAgICAgIGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdrZXlzdGF0dXNlc2NoYW5nZScsIG9ua2V5c3RhdHVzZXNjaGFuZ2UpO1xuICAgICAgdmFyIGtleVVzYWJsZVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxpY2Vuc2VTdGF0dXMub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgbGljZW5zZVN0YXR1cy5vbigna2V5U3RhdHVzJywgZnVuY3Rpb24gKGtleVN0YXR1cykge1xuICAgICAgICAgIGlmIChrZXlTdGF0dXMuc3RhcnRzV2l0aCgndXNhYmxlJykpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGtleVN0YXR1cyA9PT0gJ291dHB1dC1yZXN0cmljdGVkJykge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU1RBVFVTX09VVFBVVF9SRVNUUklDVEVELFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgICAgICAgIH0sICdIRENQIGxldmVsIG91dHB1dCByZXN0cmljdGVkJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoa2V5U3RhdHVzID09PSAnaW50ZXJuYWwtZXJyb3InKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TVEFUVVNfSU5URVJOQUxfRVJST1IsXG4gICAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgICB9LCBcImtleSBzdGF0dXMgY2hhbmdlZCB0byBcXFwiXCIgKyBrZXlTdGF0dXMgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoa2V5U3RhdHVzID09PSAnZXhwaXJlZCcpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2tleSBleHBpcmVkIHdoaWxlIGdlbmVyYXRpbmcgcmVxdWVzdCcpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXM3Lndhcm4oXCJ1bmhhbmRsZWQga2V5IHN0YXR1cyBjaGFuZ2UgXFxcIlwiICsga2V5U3RhdHVzICsgXCJcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24uZ2VuZXJhdGVSZXF1ZXN0KGluaXREYXRhVHlwZSwgaW5pdERhdGEpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2NvbnRleHQkbWVkaWFLZXlzU2VzO1xuICAgICAgICBfdGhpczcubG9nKFwiUmVxdWVzdCBnZW5lcmF0ZWQgZm9yIGtleS1zZXNzaW9uIFxcXCJcIiArICgoX2NvbnRleHQkbWVkaWFLZXlzU2VzID0gY29udGV4dC5tZWRpYUtleXNTZXNzaW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbnRleHQkbWVkaWFLZXlzU2VzLnNlc3Npb25JZCkgKyBcIlxcXCIga2V5SWQ6IFwiICsga2V5SWQpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX1NFU1NJT04sXG4gICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgICB9LCBcIkVycm9yIGdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdDogXCIgKyBlcnJvcik7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGtleVVzYWJsZVByb21pc2U7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgbGljZW5zZVN0YXR1cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgX3RoaXM3LnJlbW92ZVNlc3Npb24oY29udGV4dCk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxpY2Vuc2VTdGF0dXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25LZXlTdGF0dXNDaGFuZ2UgPSBmdW5jdGlvbiBvbktleVN0YXR1c0NoYW5nZShtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcbiAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5rZXlTdGF0dXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0dXMsIGtleUlkKSB7XG4gICAgICAgIF90aGlzOC5sb2coXCJrZXkgc3RhdHVzIGNoYW5nZSBcXFwiXCIgKyBzdGF0dXMgKyBcIlxcXCIgZm9yIGtleVN0YXR1c2VzIGtleUlkOiBcIiArIEhleC5oZXhEdW1wKCdidWZmZXInIGluIGtleUlkID8gbmV3IFVpbnQ4QXJyYXkoa2V5SWQuYnVmZmVyLCBrZXlJZC5ieXRlT2Zmc2V0LCBrZXlJZC5ieXRlTGVuZ3RoKSA6IG5ldyBVaW50OEFycmF5KGtleUlkKSkgKyBcIiBzZXNzaW9uIGtleUlkOiBcIiArIEhleC5oZXhEdW1wKG5ldyBVaW50OEFycmF5KG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGEua2V5SWQgfHwgW10pKSArIFwiIHVyaTogXCIgKyBtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhLnVyaSk7XG4gICAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQua2V5U3RhdHVzID0gc3RhdHVzO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZmV0Y2hTZXJ2ZXJDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uIGZldGNoU2VydmVyQ2VydGlmaWNhdGUoa2V5U3lzdGVtKSB7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICB2YXIgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICAgIHZhciBjZXJ0TG9hZGVyID0gbmV3IExvYWRlcihjb25maWcpO1xuICAgICAgdmFyIHVybCA9IHRoaXMuZ2V0U2VydmVyQ2VydGlmaWNhdGVVcmwoa2V5U3lzdGVtKTtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKFwiRmV0Y2hpbmcgc2VydmVyIGNlcnRpZmljYXRlIGZvciBcXFwiXCIgKyBrZXlTeXN0ZW0gKyBcIlxcXCJcIik7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgbG9hZGVyQ29udGV4dCA9IHtcbiAgICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxvYWRQb2xpY3kgPSBjb25maWcuY2VydExvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICAgICAgdmFyIGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgICBsb2FkUG9saWN5OiBsb2FkUG9saWN5LFxuICAgICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICAgIG1heFJldHJ5RGVsYXk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxvYWRlckNhbGxiYWNrcyA9IHtcbiAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIG9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcihyZXNwb25zZSwgY29udGV4LCBuZXR3b3JrRGV0YWlscywgc3RhdHMpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NFUlZFUl9DRVJUSUZJQ0FURV9SRVFVRVNUX0ZBSUxFRCxcbiAgICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICAgICB1cmw6IGxvYWRlckNvbnRleHQudXJsLFxuICAgICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICB9LCByZXNwb25zZSlcbiAgICAgICAgICAgIH0sIFwiXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiIGNlcnRpZmljYXRlIHJlcXVlc3QgZmFpbGVkIChcIiArIHVybCArIFwiKS4gU3RhdHVzOiBcIiArIHJlc3BvbnNlLmNvZGUgKyBcIiAoXCIgKyByZXNwb25zZS50ZXh0ICsgXCIpXCIpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uVGltZW91dDogZnVuY3Rpb24gb25UaW1lb3V0KHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFwiXFxcIlwiICsga2V5U3lzdGVtICsgXCJcXFwiIGNlcnRpZmljYXRlIHJlcXVlc3QgdGltZWQgb3V0IChcIiArIHVybCArIFwiKVwiKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkFib3J0OiBmdW5jdGlvbiBvbkFib3J0KHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignYWJvcnRlZCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNlcnRMb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5zZXRNZWRpYUtleXNTZXJ2ZXJDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uIHNldE1lZGlhS2V5c1NlcnZlckNlcnRpZmljYXRlKG1lZGlhS2V5cywga2V5U3lzdGVtLCBjZXJ0KSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIG1lZGlhS2V5cy5zZXRTZXJ2ZXJDZXJ0aWZpY2F0ZShjZXJ0KS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgX3RoaXM5LmxvZyhcInNldFNlcnZlckNlcnRpZmljYXRlIFwiICsgKHN1Y2Nlc3MgPyAnc3VjY2VzcycgOiAnbm90IHN1cHBvcnRlZCBieSBDRE0nKSArIFwiIChcIiArIChjZXJ0ID09IG51bGwgPyB2b2lkIDAgOiBjZXJ0LmJ5dGVMZW5ndGgpICsgXCIpIG9uIFxcXCJcIiArIGtleVN5c3RlbSArIFwiXFxcIlwiKTtcbiAgICAgICAgICByZXNvbHZlKG1lZGlhS2V5cyk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1VQREFURV9GQUlMRUQsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICAgIH0sIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5yZW5ld0xpY2Vuc2UgPSBmdW5jdGlvbiByZW5ld0xpY2Vuc2UoY29udGV4dCwga2V5TWVzc2FnZSkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdExpY2Vuc2UoY29udGV4dCwgbmV3IFVpbnQ4QXJyYXkoa2V5TWVzc2FnZSkpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTAudXBkYXRlS2V5U2Vzc2lvbihjb250ZXh0LCBuZXcgVWludDhBcnJheShkYXRhKSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NFU1NJT05fVVBEQVRFX0ZBSUxFRCxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgICAgfSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5wYWNrUGxheVJlYWR5S2V5TWVzc2FnZSA9IGZ1bmN0aW9uIHVucGFja1BsYXlSZWFkeUtleU1lc3NhZ2UoeGhyLCBsaWNlbnNlQ2hhbGxlbmdlKSB7XG4gICAgICAvLyBPbiBFZGdlLCB0aGUgcmF3IGxpY2Vuc2UgbWVzc2FnZSBpcyBVVEYtMTYtZW5jb2RlZCBYTUwuICBXZSBuZWVkXG4gICAgICAvLyB0byB1bnBhY2sgdGhlIENoYWxsZW5nZSBlbGVtZW50IChiYXNlNjQtZW5jb2RlZCBzdHJpbmcgY29udGFpbmluZyB0aGVcbiAgICAgIC8vIGFjdHVhbCBsaWNlbnNlIHJlcXVlc3QpIGFuZCBhbnkgSHR0cEhlYWRlciBlbGVtZW50cyAoc2VudCBhcyByZXF1ZXN0XG4gICAgICAvLyBoZWFkZXJzKS5cbiAgICAgIC8vIEZvciBQbGF5UmVhZHkgQ0RNcywgd2UgbmVlZCB0byBkaWcgdGhlIENoYWxsZW5nZSBvdXQgb2YgdGhlIFhNTC5cbiAgICAgIHZhciB4bWxTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShsaWNlbnNlQ2hhbGxlbmdlLmJ1ZmZlcikpO1xuICAgICAgaWYgKCF4bWxTdHJpbmcuaW5jbHVkZXMoJ1BsYXlSZWFkeUtleU1lc3NhZ2UnKSkge1xuICAgICAgICAvLyBUaGlzIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIHdyYXBwZWQgbWVzc2FnZSBhcyBvbiBFZGdlLiAgU29tZVxuICAgICAgICAvLyBjbGllbnRzIGRvIG5vdCBuZWVkIHRoaXMgdW53cmFwcGluZywgc28gd2Ugd2lsbCBhc3N1bWUgdGhpcyBpcyBvbmUgb2ZcbiAgICAgICAgLy8gdGhlbS4gIE5vdGUgdGhhdCBcInhtbFwiIGF0IHRoaXMgcG9pbnQgcHJvYmFibHkgbG9va3MgbGlrZSByYW5kb21cbiAgICAgICAgLy8gZ2FyYmFnZSwgc2luY2Ugd2UgaW50ZXJwcmV0ZWQgVVRGLTggYXMgVVRGLTE2LlxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQveG1sOyBjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICAgIHJldHVybiBsaWNlbnNlQ2hhbGxlbmdlO1xuICAgICAgfVxuICAgICAgdmFyIGtleU1lc3NhZ2VYbWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHhtbFN0cmluZywgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgICAgLy8gU2V0IHJlcXVlc3QgaGVhZGVycy5cbiAgICAgIHZhciBoZWFkZXJzID0ga2V5TWVzc2FnZVhtbC5xdWVyeVNlbGVjdG9yQWxsKCdIdHRwSGVhZGVyJyk7XG4gICAgICBpZiAoaGVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBoZWFkZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9oZWFkZXIkcXVlcnlTZWxlY3RvciwgX2hlYWRlciRxdWVyeVNlbGVjdG9yMjtcbiAgICAgICAgICBoZWFkZXIgPSBoZWFkZXJzW2ldO1xuICAgICAgICAgIHZhciBuYW1lID0gKF9oZWFkZXIkcXVlcnlTZWxlY3RvciA9IGhlYWRlci5xdWVyeVNlbGVjdG9yKCduYW1lJykpID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IudGV4dENvbnRlbnQ7XG4gICAgICAgICAgdmFyIF92YWx1ZSA9IChfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IyID0gaGVhZGVyLnF1ZXJ5U2VsZWN0b3IoJ3ZhbHVlJykpID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IyLnRleHRDb250ZW50O1xuICAgICAgICAgIGlmIChuYW1lICYmIF92YWx1ZSkge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgX3ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGFsbGVuZ2VFbGVtZW50ID0ga2V5TWVzc2FnZVhtbC5xdWVyeVNlbGVjdG9yKCdDaGFsbGVuZ2UnKTtcbiAgICAgIHZhciBjaGFsbGVuZ2VUZXh0ID0gY2hhbGxlbmdlRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogY2hhbGxlbmdlRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgIGlmICghY2hhbGxlbmdlVGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCA8Q2hhbGxlbmdlPiBpbiBrZXkgbWVzc2FnZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJUb1V0ZjhhcnJheShhdG9iKGNoYWxsZW5nZVRleHQpKTtcbiAgICB9O1xuICAgIF9wcm90by5zZXR1cExpY2Vuc2VYSFIgPSBmdW5jdGlvbiBzZXR1cExpY2Vuc2VYSFIoeGhyLCB1cmwsIGtleXNMaXN0SXRlbSwgbGljZW5zZUNoYWxsZW5nZSkge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuICAgICAgdmFyIGxpY2Vuc2VYaHJTZXR1cCA9IHRoaXMuY29uZmlnLmxpY2Vuc2VYaHJTZXR1cDtcbiAgICAgIGlmICghbGljZW5zZVhoclNldHVwKSB7XG4gICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgeGhyOiB4aHIsXG4gICAgICAgICAgbGljZW5zZUNoYWxsZW5nZTogbGljZW5zZUNoYWxsZW5nZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFrZXlzTGlzdEl0ZW0uZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSByZW1vdmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpY2Vuc2VYaHJTZXR1cC5jYWxsKF90aGlzMTEuaGxzLCB4aHIsIHVybCwga2V5c0xpc3RJdGVtLCBsaWNlbnNlQ2hhbGxlbmdlKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAoIWtleXNMaXN0SXRlbS5kZWNyeXB0ZGF0YSkge1xuICAgICAgICAgIC8vIEtleSBzZXNzaW9uIHJlbW92ZWQuIENhbmNlbCBsaWNlbnNlIHJlcXVlc3QuXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGV0J3MgdHJ5IHRvIG9wZW4gYmVmb3JlIHJ1bm5pbmcgc2V0dXBcbiAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB1cmwsIHRydWUpO1xuICAgICAgICByZXR1cm4gbGljZW5zZVhoclNldHVwLmNhbGwoX3RoaXMxMS5obHMsIHhociwgdXJsLCBrZXlzTGlzdEl0ZW0sIGxpY2Vuc2VDaGFsbGVuZ2UpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAobGljZW5zZVhoclNldHVwUmVzdWx0KSB7XG4gICAgICAgIC8vIGlmIGxpY2Vuc2VYaHJTZXR1cCBkaWQgbm90IHlldCBjYWxsIG9wZW4sIGxldCdzIGRvIGl0IG5vd1xuICAgICAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCB1cmwsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaW5hbExpY2Vuc2VDaGFsbGVuZ2UgPSBsaWNlbnNlWGhyU2V0dXBSZXN1bHQgPyBsaWNlbnNlWGhyU2V0dXBSZXN1bHQgOiBsaWNlbnNlQ2hhbGxlbmdlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHhocjogeGhyLFxuICAgICAgICAgIGxpY2Vuc2VDaGFsbGVuZ2U6IGZpbmFsTGljZW5zZUNoYWxsZW5nZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVxdWVzdExpY2Vuc2UgPSBmdW5jdGlvbiByZXF1ZXN0TGljZW5zZShrZXlTZXNzaW9uQ29udGV4dCwgbGljZW5zZUNoYWxsZW5nZSkge1xuICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuICAgICAgdmFyIGtleUxvYWRQb2xpY3kgPSB0aGlzLmNvbmZpZy5rZXlMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgdXJsID0gX3RoaXMxMi5nZXRMaWNlbnNlU2VydmVyVXJsKGtleVNlc3Npb25Db250ZXh0LmtleVN5c3RlbSk7XG4gICAgICAgIF90aGlzMTIubG9nKFwiU2VuZGluZyBsaWNlbnNlIHJlcXVlc3QgdG8gVVJMOiBcIiArIHVybCk7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFfdGhpczEyLmhscyB8fCAha2V5U2Vzc2lvbkNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUnKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICBfdGhpczEyLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgICAgICAgICAgIHZhciBkYXRhID0geGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgICBfdGhpczEyLmxvZyhcIkxpY2Vuc2UgcmVjZWl2ZWQgXCIgKyAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gZGF0YS5ieXRlTGVuZ3RoIDogZGF0YSkpO1xuICAgICAgICAgICAgICB2YXIgbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2sgPSBfdGhpczEyLmNvbmZpZy5saWNlbnNlUmVzcG9uc2VDYWxsYmFjaztcbiAgICAgICAgICAgICAgaWYgKGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGRhdGEgPSBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjay5jYWxsKF90aGlzMTIuaGxzLCB4aHIsIHVybCwga2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczEyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByZXRyeUNvbmZpZyA9IGtleUxvYWRQb2xpY3kuZXJyb3JSZXRyeTtcbiAgICAgICAgICAgICAgdmFyIG1heE51bVJldHJ5ID0gcmV0cnlDb25maWcgPyByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSA6IDA7XG4gICAgICAgICAgICAgIF90aGlzMTIuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50Kys7XG4gICAgICAgICAgICAgIGlmIChfdGhpczEyLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA+IG1heE51bVJldHJ5IHx8IHhoci5zdGF0dXMgPj0gNDAwICYmIHhoci5zdGF0dXMgPCA1MDApIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiB4aHIsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB4aHIuc3RhdHVzVGV4dFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFwiTGljZW5zZSBSZXF1ZXN0IFhIUiBmYWlsZWQgKFwiICsgdXJsICsgXCIpLiBTdGF0dXM6IFwiICsgeGhyLnN0YXR1cyArIFwiIChcIiArIHhoci5zdGF0dXNUZXh0ICsgXCIpXCIpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ZW1wdHNMZWZ0ID0gbWF4TnVtUmV0cnkgLSBfdGhpczEyLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCArIDE7XG4gICAgICAgICAgICAgICAgX3RoaXMxMi53YXJuKFwiUmV0cnlpbmcgbGljZW5zZSByZXF1ZXN0LCBcIiArIGF0dGVtcHRzTGVmdCArIFwiIGF0dGVtcHRzIGxlZnRcIik7XG4gICAgICAgICAgICAgICAgX3RoaXMxMi5yZXF1ZXN0TGljZW5zZShrZXlTZXNzaW9uQ29udGV4dCwgbGljZW5zZUNoYWxsZW5nZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoa2V5U2Vzc2lvbkNvbnRleHQubGljZW5zZVhociAmJiBrZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyLnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgICBrZXlTZXNzaW9uQ29udGV4dC5saWNlbnNlWGhyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAga2V5U2Vzc2lvbkNvbnRleHQubGljZW5zZVhociA9IHhocjtcbiAgICAgICAgX3RoaXMxMi5zZXR1cExpY2Vuc2VYSFIoeGhyLCB1cmwsIGtleVNlc3Npb25Db250ZXh0LCBsaWNlbnNlQ2hhbGxlbmdlKS50aGVuKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICAgIHZhciB4aHIgPSBfcmVmNS54aHIsXG4gICAgICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlID0gX3JlZjUubGljZW5zZUNoYWxsZW5nZTtcbiAgICAgICAgICBpZiAoa2V5U2Vzc2lvbkNvbnRleHQua2V5U3lzdGVtID09IEtleVN5c3RlbXMuUExBWVJFQURZKSB7XG4gICAgICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlID0gX3RoaXMxMi51bnBhY2tQbGF5UmVhZHlLZXlNZXNzYWdlKHhociwgbGljZW5zZUNoYWxsZW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHhoci5zZW5kKGxpY2Vuc2VDaGFsbGVuZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtZWRpYSA9IGRhdGEubWVkaWE7XG5cbiAgICAgIC8vIGtlZXAgcmVmZXJlbmNlIG9mIG1lZGlhXG4gICAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmNyeXB0ZWQnLCB0aGlzLm9uTWVkaWFFbmNyeXB0ZWQpO1xuICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignd2FpdGluZ2ZvcmtleScsIHRoaXMub25XYWl0aW5nRm9yS2V5KTtcbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhRGV0YWNoZWQgPSBmdW5jdGlvbiBvbk1lZGlhRGV0YWNoZWQoKSB7XG4gICAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgdmFyIG1lZGlhS2V5c0xpc3QgPSB0aGlzLm1lZGlhS2V5U2Vzc2lvbnM7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5jcnlwdGVkJywgdGhpcy5vbk1lZGlhRW5jcnlwdGVkKTtcbiAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2FpdGluZ2ZvcmtleScsIHRoaXMub25XYWl0aW5nRm9yS2V5KTtcbiAgICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgICB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlID0gW107XG4gICAgICB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMgPSBbXTtcbiAgICAgIHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlID0ge307XG4gICAgICBMZXZlbEtleS5jbGVhcktleVVyaVRvS2V5SWRNYXAoKTtcblxuICAgICAgLy8gQ2xvc2UgYWxsIHNlc3Npb25zIGFuZCByZW1vdmUgbWVkaWEga2V5cyBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgICAgdmFyIGtleVNlc3Npb25Db3VudCA9IG1lZGlhS2V5c0xpc3QubGVuZ3RoO1xuICAgICAgRU1FQ29udHJvbGxlci5DRE1DbGVhbnVwUHJvbWlzZSA9IFByb21pc2UuYWxsKG1lZGlhS2V5c0xpc3QubWFwKGZ1bmN0aW9uIChtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfdGhpczEzLnJlbW92ZVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgICB9KS5jb25jYXQobWVkaWEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lZGlhLnNldE1lZGlhS2V5cyhudWxsKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgX3RoaXMxMy5sb2coXCJDb3VsZCBub3QgY2xlYXIgbWVkaWEga2V5czogXCIgKyBlcnJvcik7XG4gICAgICB9KSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoa2V5U2Vzc2lvbkNvdW50KSB7XG4gICAgICAgICAgX3RoaXMxMy5sb2coJ2ZpbmlzaGVkIGNsb3Npbmcga2V5IHNlc3Npb25zIGFuZCBjbGVhcmluZyBtZWRpYSBrZXlzJyk7XG4gICAgICAgICAgbWVkaWFLZXlzTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgX3RoaXMxMy5sb2coXCJDb3VsZCBub3QgY2xvc2Ugc2Vzc2lvbnMgYW5kIGNsZWFyIG1lZGlhIGtleXM6IFwiICsgZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRpbmcgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAgIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIF9yZWY2KSB7XG4gICAgICB2YXIgc2Vzc2lvbktleXMgPSBfcmVmNi5zZXNzaW9uS2V5cztcbiAgICAgIGlmICghc2Vzc2lvbktleXMgfHwgIXRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmtleUZvcm1hdFByb21pc2UpIHtcbiAgICAgICAgdmFyIGtleUZvcm1hdHMgPSBzZXNzaW9uS2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGZvcm1hdHMsIHNlc3Npb25LZXkpIHtcbiAgICAgICAgICBpZiAoZm9ybWF0cy5pbmRleE9mKHNlc3Npb25LZXkua2V5Rm9ybWF0KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGZvcm1hdHMucHVzaChzZXNzaW9uS2V5LmtleUZvcm1hdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHRoaXMubG9nKFwiU2VsZWN0aW5nIGtleS1zeXN0ZW0gZnJvbSBzZXNzaW9uLWtleXMgXCIgKyBrZXlGb3JtYXRzLmpvaW4oJywgJykpO1xuICAgICAgICB0aGlzLmtleUZvcm1hdFByb21pc2UgPSB0aGlzLmdldEtleUZvcm1hdFByb21pc2Uoa2V5Rm9ybWF0cyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlU2Vzc2lvbiA9IGZ1bmN0aW9uIHJlbW92ZVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCkge1xuICAgICAgdmFyIF90aGlzMTQgPSB0aGlzO1xuICAgICAgdmFyIG1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24sXG4gICAgICAgIGxpY2Vuc2VYaHIgPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHI7XG4gICAgICBpZiAobWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgICB0aGlzLmxvZyhcIlJlbW92ZSBsaWNlbnNlcyBhbmQga2V5cyBhbmQgY2xvc2Ugc2Vzc2lvbiBcIiArIG1lZGlhS2V5c1Nlc3Npb24uc2Vzc2lvbklkKTtcbiAgICAgICAgaWYgKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuX29ubWVzc2FnZSkge1xuICAgICAgICAgIG1lZGlhS2V5c1Nlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuX29ubWVzc2FnZSk7XG4gICAgICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5fb25tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZWRpYUtleVNlc3Npb25Db250ZXh0Ll9vbmtleXN0YXR1c2VzY2hhbmdlKSB7XG4gICAgICAgICAgbWVkaWFLZXlzU2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlzdGF0dXNlc2NoYW5nZScsIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuX29ua2V5c3RhdHVzZXNjaGFuZ2UpO1xuICAgICAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuX29ua2V5c3RhdHVzZXNjaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpY2Vuc2VYaHIgJiYgbGljZW5zZVhoci5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgICAgbGljZW5zZVhoci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbiA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuZGVjcnlwdGRhdGEgPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubWVkaWFLZXlTZXNzaW9ucy5pbmRleE9mKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHRoaXMubWVkaWFLZXlTZXNzaW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZWRpYUtleXNTZXNzaW9uLnJlbW92ZSgpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIF90aGlzMTQubG9nKFwiQ291bGQgbm90IHJlbW92ZSBzZXNzaW9uOiBcIiArIGVycm9yKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG1lZGlhS2V5c1Nlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgX3RoaXMxNC5sb2coXCJDb3VsZCBub3QgY2xvc2Ugc2Vzc2lvbjogXCIgKyBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEVNRUNvbnRyb2xsZXI7XG4gIH0oKTtcbiAgRU1FQ29udHJvbGxlci5DRE1DbGVhbnVwUHJvbWlzZSA9IHZvaWQgMDtcbiAgdmFyIEVNRUtleUVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgICBfaW5oZXJpdHNMb29zZShFTUVLZXlFcnJvciwgX0Vycm9yKTtcbiAgICBmdW5jdGlvbiBFTUVLZXlFcnJvcihkYXRhLCBtZXNzYWdlKSB7XG4gICAgICB2YXIgX3RoaXMxNTtcbiAgICAgIF90aGlzMTUgPSBfRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgX3RoaXMxNS5kYXRhID0gdm9pZCAwO1xuICAgICAgZGF0YS5lcnJvciB8fCAoZGF0YS5lcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gICAgICBfdGhpczE1LmRhdGEgPSBkYXRhO1xuICAgICAgZGF0YS5lcnIgPSBkYXRhLmVycm9yO1xuICAgICAgcmV0dXJuIF90aGlzMTU7XG4gICAgfVxuICAgIHJldHVybiBFTUVLZXlFcnJvcjtcbiAgfSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxuICAvKipcbiAgICogQ29tbW9uIE1lZGlhIE9iamVjdCBUeXBlXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqIEBncm91cCBDTVNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICB2YXIgQ21PYmplY3RUeXBlO1xuICAoZnVuY3Rpb24gKENtT2JqZWN0VHlwZSkge1xuICAgIC8qKlxuICAgICAqIHRleHQgZmlsZSwgc3VjaCBhcyBhIG1hbmlmZXN0IG9yIHBsYXlsaXN0XG4gICAgICovXG4gICAgQ21PYmplY3RUeXBlW1wiTUFOSUZFU1RcIl0gPSBcIm1cIjtcbiAgICAvKipcbiAgICAgKiBhdWRpbyBvbmx5XG4gICAgICovXG4gICAgQ21PYmplY3RUeXBlW1wiQVVESU9cIl0gPSBcImFcIjtcbiAgICAvKipcbiAgICAgKiB2aWRlbyBvbmx5XG4gICAgICovXG4gICAgQ21PYmplY3RUeXBlW1wiVklERU9cIl0gPSBcInZcIjtcbiAgICAvKipcbiAgICAgKiBtdXhlZCBhdWRpbyBhbmQgdmlkZW9cbiAgICAgKi9cbiAgICBDbU9iamVjdFR5cGVbXCJNVVhFRFwiXSA9IFwiYXZcIjtcbiAgICAvKipcbiAgICAgKiBpbml0IHNlZ21lbnRcbiAgICAgKi9cbiAgICBDbU9iamVjdFR5cGVbXCJJTklUXCJdID0gXCJpXCI7XG4gICAgLyoqXG4gICAgICogY2FwdGlvbiBvciBzdWJ0aXRsZVxuICAgICAqL1xuICAgIENtT2JqZWN0VHlwZVtcIkNBUFRJT05cIl0gPSBcImNcIjtcbiAgICAvKipcbiAgICAgKiBJU09CTUZGIHRpbWVkIHRleHQgdHJhY2tcbiAgICAgKi9cbiAgICBDbU9iamVjdFR5cGVbXCJUSU1FRF9URVhUXCJdID0gXCJ0dFwiO1xuICAgIC8qKlxuICAgICAqIGNyeXB0b2dyYXBoaWMga2V5LCBsaWNlbnNlIG9yIGNlcnRpZmljYXRlLlxuICAgICAqL1xuICAgIENtT2JqZWN0VHlwZVtcIktFWVwiXSA9IFwia1wiO1xuICAgIC8qKlxuICAgICAqIG90aGVyXG4gICAgICovXG4gICAgQ21PYmplY3RUeXBlW1wiT1RIRVJcIl0gPSBcIm9cIjtcbiAgfSkoQ21PYmplY3RUeXBlIHx8IChDbU9iamVjdFR5cGUgPSB7fSkpO1xuXG4gIC8qKlxuICAgKiBDb21tb24gTWVkaWEgU3RyZWFtaW5nIEZvcm1hdFxuICAgKlxuICAgKiBAZ3JvdXAgQ01DRFxuICAgKiBAZ3JvdXAgQ01TRFxuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgdmFyIENtU3RyZWFtaW5nRm9ybWF0O1xuICAoZnVuY3Rpb24gKENtU3RyZWFtaW5nRm9ybWF0KSB7XG4gICAgLyoqXG4gICAgICogTVBFRyBEQVNIXG4gICAgICovXG4gICAgQ21TdHJlYW1pbmdGb3JtYXRbXCJEQVNIXCJdID0gXCJkXCI7XG4gICAgLyoqXG4gICAgICogSFRUUCBMaXZlIFN0cmVhbWluZyAoSExTKVxuICAgICAqL1xuICAgIENtU3RyZWFtaW5nRm9ybWF0W1wiSExTXCJdID0gXCJoXCI7XG4gICAgLyoqXG4gICAgICogU21vb3RoIFN0cmVhbWluZ1xuICAgICAqL1xuICAgIENtU3RyZWFtaW5nRm9ybWF0W1wiU01PT1RIXCJdID0gXCJzXCI7XG4gICAgLyoqXG4gICAgICogT3RoZXJcbiAgICAgKi9cbiAgICBDbVN0cmVhbWluZ0Zvcm1hdFtcIk9USEVSXCJdID0gXCJvXCI7XG4gIH0pKENtU3RyZWFtaW5nRm9ybWF0IHx8IChDbVN0cmVhbWluZ0Zvcm1hdCA9IHt9KSk7XG5cbiAgLyoqXG4gICAqIENNQ0QgaGVhZGVyIGZpZWxkcy5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHZhciBDbWNkSGVhZGVyRmllbGQ7XG4gIChmdW5jdGlvbiAoQ21jZEhlYWRlckZpZWxkKSB7XG4gICAgLyoqXG4gICAgICoga2V5cyB3aG9zZSB2YWx1ZXMgdmFyeSB3aXRoIHRoZSBvYmplY3QgYmVpbmcgcmVxdWVzdGVkLlxuICAgICAqL1xuICAgIENtY2RIZWFkZXJGaWVsZFtcIk9CSkVDVFwiXSA9IFwiQ01DRC1PYmplY3RcIjtcbiAgICAvKipcbiAgICAgKiBrZXlzIHdob3NlIHZhbHVlcyB2YXJ5IHdpdGggZWFjaCByZXF1ZXN0LlxuICAgICAqL1xuICAgIENtY2RIZWFkZXJGaWVsZFtcIlJFUVVFU1RcIl0gPSBcIkNNQ0QtUmVxdWVzdFwiO1xuICAgIC8qKlxuICAgICAqIGtleXMgd2hvc2UgdmFsdWVzIGFyZSBleHBlY3RlZCB0byBiZSBpbnZhcmlhbnQgb3ZlciB0aGUgbGlmZSBvZiB0aGUgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBDbWNkSGVhZGVyRmllbGRbXCJTRVNTSU9OXCJdID0gXCJDTUNELVNlc3Npb25cIjtcbiAgICAvKipcbiAgICAgKiBrZXlzIHdob3NlIHZhbHVlcyBkbyBub3QgdmFyeSB3aXRoIGV2ZXJ5IHJlcXVlc3Qgb3Igb2JqZWN0LlxuICAgICAqL1xuICAgIENtY2RIZWFkZXJGaWVsZFtcIlNUQVRVU1wiXSA9IFwiQ01DRC1TdGF0dXNcIjtcbiAgfSkoQ21jZEhlYWRlckZpZWxkIHx8IChDbWNkSGVhZGVyRmllbGQgPSB7fSkpO1xuXG4gIHZhciBfQ21jZEhlYWRlck1hcDtcbiAgLyoqXG4gICAqIFRoZSBtYXAgb2YgQ01DRCBoZWFkZXIgZmllbGRzIHRvIG9mZmljaWFsIENNQ0Qga2V5cy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqL1xuICB2YXIgQ21jZEhlYWRlck1hcCA9IChfQ21jZEhlYWRlck1hcCA9IHt9LCBfQ21jZEhlYWRlck1hcFtDbWNkSGVhZGVyRmllbGQuT0JKRUNUXSA9IFsnYnInLCAnZCcsICdvdCcsICd0YiddLCBfQ21jZEhlYWRlck1hcFtDbWNkSGVhZGVyRmllbGQuUkVRVUVTVF0gPSBbJ2JsJywgJ2RsJywgJ210cCcsICdub3InLCAnbnJyJywgJ3N1J10sIF9DbWNkSGVhZGVyTWFwW0NtY2RIZWFkZXJGaWVsZC5TRVNTSU9OXSA9IFsnY2lkJywgJ3ByJywgJ3NmJywgJ3NpZCcsICdzdCcsICd2J10sIF9DbWNkSGVhZGVyTWFwW0NtY2RIZWFkZXJGaWVsZC5TVEFUVVNdID0gWydicycsICdydHAnXSwgX0NtY2RIZWFkZXJNYXApO1xuXG4gIC8qKlxuICAgKiBTdHJ1Y3R1cmVkIEZpZWxkIEl0ZW1cbiAgICpcbiAgICogQGdyb3VwIFN0cnVjdHVyZWQgRmllbGRcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHZhciBTZkl0ZW0gPSBmdW5jdGlvbiBTZkl0ZW0odmFsdWUsIHBhcmFtcykge1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJhbXMgPSB2b2lkIDA7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdiBpbnN0YW5jZW9mIFNmSXRlbSA/IHYgOiBuZXcgU2ZJdGVtKHYpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgfTtcblxuICAvKipcbiAgICogQSBjbGFzcyB0byByZXByZXNlbnQgc3RydWN0dXJlZCBmaWVsZCB0b2tlbnMgd2hlbiBgU3ltYm9sYCBpcyBub3QgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAZ3JvdXAgU3RydWN0dXJlZCBGaWVsZFxuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgdmFyIFNmVG9rZW4gPSBmdW5jdGlvbiBTZlRva2VuKGRlc2NyaXB0aW9uKSB7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIH07XG5cbiAgdmFyIERJQ1QgPSAnRGljdCc7XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIHJldHVybiAnTWFwe30nO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIHJldHVybiAnU2V0e30nO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdGhyb3dFcnJvcihhY3Rpb24sIHNyYywgdHlwZSwgY2F1c2UpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiZmFpbGVkIHRvIFwiICsgYWN0aW9uICsgXCIgXFxcIlwiICsgZm9ybWF0KHNyYykgKyBcIlxcXCIgYXMgXCIgKyB0eXBlLCB7XG4gICAgICBjYXVzZTogY2F1c2VcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBCQVJFX0lURU0gPSAnQmFyZSBJdGVtJztcblxuICB2YXIgQk9PTEVBTiA9ICdCb29sZWFuJztcblxuICB2YXIgQllURVMgPSAnQnl0ZSBTZXF1ZW5jZSc7XG5cbiAgdmFyIERFQ0lNQUwgPSAnRGVjaW1hbCc7XG5cbiAgdmFyIElOVEVHRVIgPSAnSW50ZWdlcic7XG5cbiAgZnVuY3Rpb24gaXNJbnZhbGlkSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgLTk5OTk5OTk5OTk5OTk5OSB8fCA5OTk5OTk5OTk5OTk5OTkgPCB2YWx1ZTtcbiAgfVxuXG4gIHZhciBTVFJJTkdfUkVHRVggPSAvW1xceDAwLVxceDFmXFx4N2ZdKy87IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuXG4gIHZhciBUT0tFTiA9ICdUb2tlbic7XG5cbiAgdmFyIEtFWSA9ICdLZXknO1xuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yKHNyYywgdHlwZSwgY2F1c2UpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvcignc2VyaWFsaXplJywgc3JjLCB0eXBlLCBjYXVzZSk7XG4gIH1cblxuICAvLyA0LjEuOS4gIFNlcmlhbGl6aW5nIGEgQm9vbGVhblxuICAvL1xuICAvLyBHaXZlbiBhIEJvb2xlYW4gYXMgaW5wdXRfYm9vbGVhbiwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3JcbiAgLy8gdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbiAgLy9cbiAgLy8gMS4gIElmIGlucHV0X2Jvb2xlYW4gaXMgbm90IGEgYm9vbGVhbiwgZmFpbCBzZXJpYWxpemF0aW9uLlxuICAvL1xuICAvLyAyLiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gIC8vXG4gIC8vIDMuICBBcHBlbmQgXCI/XCIgdG8gb3V0cHV0LlxuICAvL1xuICAvLyA0LiAgSWYgaW5wdXRfYm9vbGVhbiBpcyB0cnVlLCBhcHBlbmQgXCIxXCIgdG8gb3V0cHV0LlxuICAvL1xuICAvLyA1LiAgSWYgaW5wdXRfYm9vbGVhbiBpcyBmYWxzZSwgYXBwZW5kIFwiMFwiIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gNi4gIFJldHVybiBvdXRwdXQuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUJvb2xlYW4odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBCT09MRUFOKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID8gJz8xJyA6ICc/MCc7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlcyBiaW5hcnkgZGF0YSB0byBiYXNlNjRcbiAgICpcbiAgICogQHBhcmFtIGJpbmFyeSAtIFRoZSBiaW5hcnkgZGF0YSB0byBlbmNvZGVcbiAgICogQHJldHVybnMgVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICAgKlxuICAgKiBAZ3JvdXAgVXRpbHNcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIGZ1bmN0aW9uIGJhc2U2NGVuY29kZShiaW5hcnkpIHtcbiAgICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgYmluYXJ5KSk7XG4gIH1cblxuICAvLyA0LjEuOC4gIFNlcmlhbGl6aW5nIGEgQnl0ZSBTZXF1ZW5jZVxuICAvL1xuICAvLyBHaXZlbiBhIEJ5dGUgU2VxdWVuY2UgYXMgaW5wdXRfYnl0ZXMsIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGVcbiAgLy8gZm9yIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4gIC8vXG4gIC8vIDEuICBJZiBpbnB1dF9ieXRlcyBpcyBub3QgYSBzZXF1ZW5jZSBvZiBieXRlcywgZmFpbCBzZXJpYWxpemF0aW9uLlxuICAvL1xuICAvLyAyLiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gIC8vXG4gIC8vIDMuICBBcHBlbmQgXCI6XCIgdG8gb3V0cHV0LlxuICAvL1xuICAvLyA0LiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgYmFzZTY0LWVuY29kaW5nIGlucHV0X2J5dGVzIGFzIHBlclxuICAvLyAgICAgW1JGQzQ2NDhdLCBTZWN0aW9uIDQsIHRha2luZyBhY2NvdW50IG9mIHRoZSByZXF1aXJlbWVudHMgYmVsb3cuXG4gIC8vXG4gIC8vIDUuICBBcHBlbmQgXCI6XCIgdG8gb3V0cHV0LlxuICAvL1xuICAvLyA2LiAgUmV0dXJuIG91dHB1dC5cbiAgLy9cbiAgLy8gVGhlIGVuY29kZWQgZGF0YSBpcyByZXF1aXJlZCB0byBiZSBwYWRkZWQgd2l0aCBcIj1cIiwgYXMgcGVyIFtSRkM0NjQ4XSxcbiAgLy8gU2VjdGlvbiAzLjIuXG4gIC8vXG4gIC8vIExpa2V3aXNlLCBlbmNvZGVkIGRhdGEgU0hPVUxEIGhhdmUgcGFkIGJpdHMgc2V0IHRvIHplcm8sIGFzIHBlclxuICAvLyBbUkZDNDY0OF0sIFNlY3Rpb24gMy41LCB1bmxlc3MgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGRvIHNvIGR1ZSB0b1xuICAvLyBpbXBsZW1lbnRhdGlvbiBjb25zdHJhaW50cy5cbiAgZnVuY3Rpb24gc2VyaWFsaXplQnl0ZVNlcXVlbmNlKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgQllURVMpO1xuICAgIH1cbiAgICByZXR1cm4gXCI6XCIgKyBiYXNlNjRlbmNvZGUodmFsdWUpICsgXCI6XCI7XG4gIH1cblxuICAvLyA0LjEuNC4gIFNlcmlhbGl6aW5nIGFuIEludGVnZXJcbiAgLy9cbiAgLy8gR2l2ZW4gYW4gSW50ZWdlciBhcyBpbnB1dF9pbnRlZ2VyLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlXG4gIC8vIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuICAvL1xuICAvLyAxLiAgSWYgaW5wdXRfaW50ZWdlciBpcyBub3QgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2ZcbiAgLy8gICAgIC05OTksOTk5LDk5OSw5OTksOTk5IHRvIDk5OSw5OTksOTk5LDk5OSw5OTkgaW5jbHVzaXZlLCBmYWlsXG4gIC8vICAgICBzZXJpYWxpemF0aW9uLlxuICAvL1xuICAvLyAyLiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gIC8vXG4gIC8vIDMuICBJZiBpbnB1dF9pbnRlZ2VyIGlzIGxlc3MgdGhhbiAoYnV0IG5vdCBlcXVhbCB0bykgMCwgYXBwZW5kIFwiLVwiIHRvXG4gIC8vICAgICBvdXRwdXQuXG4gIC8vXG4gIC8vIDQuICBBcHBlbmQgaW5wdXRfaW50ZWdlcidzIG51bWVyaWMgdmFsdWUgcmVwcmVzZW50ZWQgaW4gYmFzZSAxMCB1c2luZ1xuICAvLyAgICAgb25seSBkZWNpbWFsIGRpZ2l0cyB0byBvdXRwdXQuXG4gIC8vXG4gIC8vIDUuICBSZXR1cm4gb3V0cHV0LlxuICBmdW5jdGlvbiBzZXJpYWxpemVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgaWYgKGlzSW52YWxpZEludCh2YWx1ZSkpIHtcbiAgICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBJTlRFR0VSKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvLyA0LjEuMTAuICBTZXJpYWxpemluZyBhIERhdGVcbiAgLy9cbiAgLy8gR2l2ZW4gYSBEYXRlIGFzIGlucHV0X2ludGVnZXIsIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGUgZm9yXG4gIC8vIHVzZSBpbiBhbiBIVFRQIGZpZWxkIHZhbHVlLlxuICAvLyAxLiAgTGV0IG91dHB1dCBiZSBcIkBcIi5cbiAgLy8gMi4gIEFwcGVuZCB0byBvdXRwdXQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGFuIEludGVnZXJcbiAgLy8gICAgIHdpdGggaW5wdXRfZGF0ZSAoU2VjdGlvbiA0LjEuNCkuXG4gIC8vIDMuICBSZXR1cm4gb3V0cHV0LlxuICBmdW5jdGlvbiBzZXJpYWxpemVEYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFwiQFwiICsgc2VyaWFsaXplSW50ZWdlcih2YWx1ZS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGltcGxlbWVudHMgdGhlIHJvdW5kaW5nIHByb2NlZHVyZSBkZXNjcmliZWQgaW4gc3RlcCAyIG9mIHRoZSBcIlNlcmlhbGl6aW5nIGEgRGVjaW1hbFwiIHNwZWNpZmljYXRpb24uXG4gICAqIFRoaXMgcm91bmRpbmcgc3R5bGUgaXMga25vd24gYXMgXCJldmVuIHJvdW5kaW5nXCIsIFwiYmFua2VyJ3Mgcm91bmRpbmdcIiwgb3IgXCJjb21tZXJjaWFsIHJvdW5kaW5nXCIuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByb3VuZFxuICAgKiBAcGFyYW0gcHJlY2lzaW9uIC0gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byByb3VuZCB0b1xuICAgKiBAcmV0dXJucyBUaGUgcm91bmRlZCB2YWx1ZVxuICAgKlxuICAgKiBAZ3JvdXAgVXRpbHNcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIGZ1bmN0aW9uIHJvdW5kVG9FdmVuKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICByZXR1cm4gLXJvdW5kVG9FdmVuKC12YWx1ZSwgcHJlY2lzaW9uKTtcbiAgICB9XG4gICAgdmFyIGRlY2ltYWxTaGlmdCA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHZhciBpc0VxdWlkaXN0YW50ID0gTWF0aC5hYnModmFsdWUgKiBkZWNpbWFsU2hpZnQgJSAxIC0gMC41KSA8IE51bWJlci5FUFNJTE9OO1xuICAgIGlmIChpc0VxdWlkaXN0YW50KSB7XG4gICAgICAvLyBJZiB0aGUgdGFpbCBvZiB0aGUgZGVjaW1hbCBwbGFjZSBpcyAnZXF1aWRpc3RhbnQnIHdlIHJvdW5kIHRvIHRoZSBuZWFyZXN0IGV2ZW4gdmFsdWVcbiAgICAgIHZhciBmbG9vcmVkVmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlICogZGVjaW1hbFNoaWZ0KTtcbiAgICAgIHJldHVybiAoZmxvb3JlZFZhbHVlICUgMiA9PT0gMCA/IGZsb29yZWRWYWx1ZSA6IGZsb29yZWRWYWx1ZSArIDEpIC8gZGVjaW1hbFNoaWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHByb2NlZWQgYXMgbm9ybWFsXG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGRlY2ltYWxTaGlmdCkgLyBkZWNpbWFsU2hpZnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gNC4xLjUuICBTZXJpYWxpemluZyBhIERlY2ltYWxcbiAgLy9cbiAgLy8gR2l2ZW4gYSBkZWNpbWFsIG51bWJlciBhcyBpbnB1dF9kZWNpbWFsLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nXG4gIC8vIHN1aXRhYmxlIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuICAvL1xuICAvLyAxLiAgIElmIGlucHV0X2RlY2ltYWwgaXMgbm90IGEgZGVjaW1hbCBudW1iZXIsIGZhaWwgc2VyaWFsaXphdGlvbi5cbiAgLy9cbiAgLy8gMi4gICBJZiBpbnB1dF9kZWNpbWFsIGhhcyBtb3JlIHRoYW4gdGhyZWUgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIHRoZVxuICAvLyAgICAgIHJpZ2h0IG9mIHRoZSBkZWNpbWFsIHBvaW50LCByb3VuZCBpdCB0byB0aHJlZSBkZWNpbWFsIHBsYWNlcyxcbiAgLy8gICAgICByb3VuZGluZyB0aGUgZmluYWwgZGlnaXQgdG8gdGhlIG5lYXJlc3QgdmFsdWUsIG9yIHRvIHRoZSBldmVuXG4gIC8vICAgICAgdmFsdWUgaWYgaXQgaXMgZXF1aWRpc3RhbnQuXG4gIC8vXG4gIC8vIDMuICAgSWYgaW5wdXRfZGVjaW1hbCBoYXMgbW9yZSB0aGFuIDEyIHNpZ25pZmljYW50IGRpZ2l0cyB0byB0aGUgbGVmdFxuICAvLyAgICAgIG9mIHRoZSBkZWNpbWFsIHBvaW50IGFmdGVyIHJvdW5kaW5nLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4gIC8vXG4gIC8vIDQuICAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gIC8vXG4gIC8vIDUuICAgSWYgaW5wdXRfZGVjaW1hbCBpcyBsZXNzIHRoYW4gKGJ1dCBub3QgZXF1YWwgdG8pIDAsIGFwcGVuZCBcIi1cIlxuICAvLyAgICAgIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gNi4gICBBcHBlbmQgaW5wdXRfZGVjaW1hbCdzIGludGVnZXIgY29tcG9uZW50IHJlcHJlc2VudGVkIGluIGJhc2UgMTBcbiAgLy8gICAgICAodXNpbmcgb25seSBkZWNpbWFsIGRpZ2l0cykgdG8gb3V0cHV0OyBpZiBpdCBpcyB6ZXJvLCBhcHBlbmRcbiAgLy8gICAgICBcIjBcIi5cbiAgLy9cbiAgLy8gNy4gICBBcHBlbmQgXCIuXCIgdG8gb3V0cHV0LlxuICAvL1xuICAvLyA4LiAgIElmIGlucHV0X2RlY2ltYWwncyBmcmFjdGlvbmFsIGNvbXBvbmVudCBpcyB6ZXJvLCBhcHBlbmQgXCIwXCIgdG9cbiAgLy8gICAgICBvdXRwdXQuXG4gIC8vXG4gIC8vIDkuICAgT3RoZXJ3aXNlLCBhcHBlbmQgdGhlIHNpZ25pZmljYW50IGRpZ2l0cyBvZiBpbnB1dF9kZWNpbWFsJ3NcbiAgLy8gICAgICBmcmFjdGlvbmFsIGNvbXBvbmVudCByZXByZXNlbnRlZCBpbiBiYXNlIDEwICh1c2luZyBvbmx5IGRlY2ltYWxcbiAgLy8gICAgICBkaWdpdHMpIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gMTAuICBSZXR1cm4gb3V0cHV0LlxuICBmdW5jdGlvbiBzZXJpYWxpemVEZWNpbWFsKHZhbHVlKSB7XG4gICAgdmFyIHJvdW5kZWRWYWx1ZSA9IHJvdW5kVG9FdmVuKHZhbHVlLCAzKTsgLy8gcm91bmQgdG8gMyBkZWNpbWFsIHBsYWNlc1xuICAgIGlmIChNYXRoLmZsb29yKE1hdGguYWJzKHJvdW5kZWRWYWx1ZSkpLnRvU3RyaW5nKCkubGVuZ3RoID4gMTIpIHtcbiAgICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBERUNJTUFMKTtcbiAgICB9XG4gICAgdmFyIHN0cmluZ1ZhbHVlID0gcm91bmRlZFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHN0cmluZ1ZhbHVlLmluY2x1ZGVzKCcuJykgPyBzdHJpbmdWYWx1ZSA6IHN0cmluZ1ZhbHVlICsgXCIuMFwiO1xuICB9XG5cbiAgdmFyIFNUUklORyA9ICdTdHJpbmcnO1xuXG4gIC8vIDQuMS42LiAgU2VyaWFsaXppbmcgYSBTdHJpbmdcbiAgLy9cbiAgLy8gR2l2ZW4gYSBTdHJpbmcgYXMgaW5wdXRfc3RyaW5nLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvclxuICAvLyB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuICAvL1xuICAvLyAxLiAgQ29udmVydCBpbnB1dF9zdHJpbmcgaW50byBhIHNlcXVlbmNlIG9mIEFTQ0lJIGNoYXJhY3RlcnM7IGlmXG4gIC8vICAgICBjb252ZXJzaW9uIGZhaWxzLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4gIC8vXG4gIC8vIDIuICBJZiBpbnB1dF9zdHJpbmcgY29udGFpbnMgY2hhcmFjdGVycyBpbiB0aGUgcmFuZ2UgJXgwMC0xZiBvciAleDdmXG4gIC8vICAgICAoaS5lLiwgbm90IGluIFZDSEFSIG9yIFNQKSwgZmFpbCBzZXJpYWxpemF0aW9uLlxuICAvL1xuICAvLyAzLiAgTGV0IG91dHB1dCBiZSB0aGUgc3RyaW5nIERRVU9URS5cbiAgLy9cbiAgLy8gNC4gIEZvciBlYWNoIGNoYXJhY3RlciBjaGFyIGluIGlucHV0X3N0cmluZzpcbiAgLy9cbiAgLy8gICAgIDEuICBJZiBjaGFyIGlzIFwiXFxcIiBvciBEUVVPVEU6XG4gIC8vXG4gIC8vICAgICAgICAgMS4gIEFwcGVuZCBcIlxcXCIgdG8gb3V0cHV0LlxuICAvL1xuICAvLyAgICAgMi4gIEFwcGVuZCBjaGFyIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gNS4gIEFwcGVuZCBEUVVPVEUgdG8gb3V0cHV0LlxuICAvL1xuICAvLyA2LiAgUmV0dXJuIG91dHB1dC5cbiAgZnVuY3Rpb24gc2VyaWFsaXplU3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKFNUUklOR19SRUdFWC50ZXN0KHZhbHVlKSkge1xuICAgICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIFNUUklORyk7XG4gICAgfVxuICAgIHJldHVybiBcIlxcXCJcIiArIHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKC9cIi9nLCBcIlxcXFxcXFwiXCIpICsgXCJcXFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBzeW1ib2xUb1N0cihzeW1ib2wpIHtcbiAgICByZXR1cm4gc3ltYm9sLmRlc2NyaXB0aW9uIHx8IHN5bWJvbC50b1N0cmluZygpLnNsaWNlKDcsIC0xKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVRva2VuKHRva2VuKSB7XG4gICAgdmFyIHZhbHVlID0gc3ltYm9sVG9TdHIodG9rZW4pO1xuICAgIGlmICgvXihbYS16QS1aKl0pKFshIyQlJicqK1xcLS5eX2B8flxcdzovXSopJC8udGVzdCh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgVE9LRU4pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyA0LjEuMy4xLiAgU2VyaWFsaXppbmcgYSBCYXJlIEl0ZW1cbiAgLy9cbiAgLy8gR2l2ZW4gYW4gSXRlbSBhcyBpbnB1dF9pdGVtLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvciB1c2VcbiAgLy8gaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuICAvL1xuICAvLyAxLiAgSWYgaW5wdXRfaXRlbSBpcyBhbiBJbnRlZ2VyLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gIC8vICAgICBTZXJpYWxpemluZyBhbiBJbnRlZ2VyIChTZWN0aW9uIDQuMS40KSB3aXRoIGlucHV0X2l0ZW0uXG4gIC8vXG4gIC8vIDIuICBJZiBpbnB1dF9pdGVtIGlzIGEgRGVjaW1hbCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAvLyAgICAgU2VyaWFsaXppbmcgYSBEZWNpbWFsIChTZWN0aW9uIDQuMS41KSB3aXRoIGlucHV0X2l0ZW0uXG4gIC8vXG4gIC8vIDMuICBJZiBpbnB1dF9pdGVtIGlzIGEgU3RyaW5nLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gIC8vICAgICBTZXJpYWxpemluZyBhIFN0cmluZyAoU2VjdGlvbiA0LjEuNikgd2l0aCBpbnB1dF9pdGVtLlxuICAvL1xuICAvLyA0LiAgSWYgaW5wdXRfaXRlbSBpcyBhIFRva2VuLCByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gIC8vICAgICBTZXJpYWxpemluZyBhIFRva2VuIChTZWN0aW9uIDQuMS43KSB3aXRoIGlucHV0X2l0ZW0uXG4gIC8vXG4gIC8vIDUuICBJZiBpbnB1dF9pdGVtIGlzIGEgQm9vbGVhbiwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAvLyAgICAgU2VyaWFsaXppbmcgYSBCb29sZWFuIChTZWN0aW9uIDQuMS45KSB3aXRoIGlucHV0X2l0ZW0uXG4gIC8vXG4gIC8vIDYuICBJZiBpbnB1dF9pdGVtIGlzIGEgQnl0ZSBTZXF1ZW5jZSwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAvLyAgICAgU2VyaWFsaXppbmcgYSBCeXRlIFNlcXVlbmNlIChTZWN0aW9uIDQuMS44KSB3aXRoIGlucHV0X2l0ZW0uXG4gIC8vXG4gIC8vIDcuICBJZiBpbnB1dF9pdGVtIGlzIGEgRGF0ZSwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZ1xuICAvLyAgICAgYSBEYXRlIChTZWN0aW9uIDQuMS4xMCkgd2l0aCBpbnB1dF9pdGVtLlxuICAvL1xuICAvLyA4LiAgT3RoZXJ3aXNlLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUJhcmVJdGVtKHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIEJBUkVfSVRFTSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUludGVnZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVEZWNpbWFsKHZhbHVlKTtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVTdHJpbmcodmFsdWUpO1xuICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRva2VuKHZhbHVlKTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gc2VyaWFsaXplQm9vbGVhbih2YWx1ZSk7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZURhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplQnl0ZVNlcXVlbmNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZlRva2VuKSB7XG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRva2VuKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gZmFpbFxuICAgICAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgQkFSRV9JVEVNKTtcbiAgICB9XG4gIH1cblxuICAvLyA0LjEuMS4zLiAgU2VyaWFsaXppbmcgYSBLZXlcbiAgLy9cbiAgLy8gR2l2ZW4gYSBrZXkgYXMgaW5wdXRfa2V5LCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvciB1c2UgaW5cbiAgLy8gYSBIVFRQIGZpZWxkIHZhbHVlLlxuICAvL1xuICAvLyAxLiAgQ29udmVydCBpbnB1dF9rZXkgaW50byBhIHNlcXVlbmNlIG9mIEFTQ0lJIGNoYXJhY3RlcnM7IGlmXG4gIC8vICAgICBjb252ZXJzaW9uIGZhaWxzLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4gIC8vXG4gIC8vIDIuICBJZiBpbnB1dF9rZXkgY29udGFpbnMgY2hhcmFjdGVycyBub3QgaW4gbGNhbHBoYSwgRElHSVQsIFwiX1wiLCBcIi1cIixcbiAgLy8gICAgIFwiLlwiLCBvciBcIipcIiBmYWlsIHNlcmlhbGl6YXRpb24uXG4gIC8vXG4gIC8vIDMuICBJZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGlucHV0X2tleSBpcyBub3QgbGNhbHBoYSBvciBcIipcIiwgZmFpbFxuICAvLyAgICAgc2VyaWFsaXphdGlvbi5cbiAgLy9cbiAgLy8gNC4gIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAvL1xuICAvLyA1LiAgQXBwZW5kIGlucHV0X2tleSB0byBvdXRwdXQuXG4gIC8vXG4gIC8vIDYuICBSZXR1cm4gb3V0cHV0LlxuICBmdW5jdGlvbiBzZXJpYWxpemVLZXkodmFsdWUpIHtcbiAgICBpZiAoL15bYS16Kl1bYS16MC05XFwtXy4qXSokLy50ZXN0KHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBLRVkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyA0LjEuMS4yLiAgU2VyaWFsaXppbmcgUGFyYW1ldGVyc1xuICAvL1xuICAvLyBHaXZlbiBhbiBvcmRlcmVkIERpY3Rpb25hcnkgYXMgaW5wdXRfcGFyYW1ldGVycyAoZWFjaCBtZW1iZXIgaGF2aW5nIGFcbiAgLy8gcGFyYW1fbmFtZSBhbmQgYSBwYXJhbV92YWx1ZSksIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGUgZm9yXG4gIC8vIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4gIC8vXG4gIC8vIDEuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgLy9cbiAgLy8gMi4gIEZvciBlYWNoIHBhcmFtX25hbWUgd2l0aCBhIHZhbHVlIG9mIHBhcmFtX3ZhbHVlIGluXG4gIC8vICAgICBpbnB1dF9wYXJhbWV0ZXJzOlxuICAvL1xuICAvLyAgICAgMS4gIEFwcGVuZCBcIjtcIiB0byBvdXRwdXQuXG4gIC8vXG4gIC8vICAgICAyLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBhIEtleVxuICAvLyAgICAgICAgIChTZWN0aW9uIDQuMS4xLjMpIHdpdGggcGFyYW1fbmFtZSB0byBvdXRwdXQuXG4gIC8vXG4gIC8vICAgICAzLiAgSWYgcGFyYW1fdmFsdWUgaXMgbm90IEJvb2xlYW4gdHJ1ZTpcbiAgLy9cbiAgLy8gICAgICAgICAxLiAgQXBwZW5kIFwiPVwiIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gICAgICAgICAyLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBhIGJhcmUgSXRlbVxuICAvLyAgICAgICAgICAgICAoU2VjdGlvbiA0LjEuMy4xKSB3aXRoIHBhcmFtX3ZhbHVlIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gMy4gIFJldHVybiBvdXRwdXQuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHBhcmFtcykubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIga2V5ID0gX3JlZlswXSxcbiAgICAgICAgdmFsdWUgPSBfcmVmWzFdO1xuICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBcIjtcIiArIHNlcmlhbGl6ZUtleShrZXkpOyAvLyBvbWl0IHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIjtcIiArIHNlcmlhbGl6ZUtleShrZXkpICsgXCI9XCIgKyBzZXJpYWxpemVCYXJlSXRlbSh2YWx1ZSk7XG4gICAgfSkuam9pbignJyk7XG4gIH1cblxuICAvLyA0LjEuMy4gIFNlcmlhbGl6aW5nIGFuIEl0ZW1cbiAgLy9cbiAgLy8gR2l2ZW4gYW4gSXRlbSBhcyBiYXJlX2l0ZW0gYW5kIFBhcmFtZXRlcnMgYXMgaXRlbV9wYXJhbWV0ZXJzLCByZXR1cm5cbiAgLy8gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuICAvL1xuICAvLyAxLiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4gIC8vXG4gIC8vIDIuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGEgQmFyZSBJdGVtXG4gIC8vICAgICBTZWN0aW9uIDQuMS4zLjEgd2l0aCBiYXJlX2l0ZW0gdG8gb3V0cHV0LlxuICAvL1xuICAvLyAzLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBQYXJhbWV0ZXJzXG4gIC8vICAgICBTZWN0aW9uIDQuMS4xLjIgd2l0aCBpdGVtX3BhcmFtZXRlcnMgdG8gb3V0cHV0LlxuICAvL1xuICAvLyA0LiAgUmV0dXJuIG91dHB1dC5cbiAgZnVuY3Rpb24gc2VyaWFsaXplSXRlbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNmSXRlbSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBzZXJpYWxpemVCYXJlSXRlbSh2YWx1ZS52YWx1ZSkgKyBzZXJpYWxpemVQYXJhbXModmFsdWUucGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZUJhcmVJdGVtKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvLyA0LjEuMS4xLiAgU2VyaWFsaXppbmcgYW4gSW5uZXIgTGlzdFxuICAvL1xuICAvLyBHaXZlbiBhbiBhcnJheSBvZiAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKSB0dXBsZXMgYXMgaW5uZXJfbGlzdCxcbiAgLy8gYW5kIHBhcmFtZXRlcnMgYXMgbGlzdF9wYXJhbWV0ZXJzLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlXG4gIC8vIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuICAvL1xuICAvLyAxLiAgTGV0IG91dHB1dCBiZSB0aGUgc3RyaW5nIFwiKFwiLlxuICAvL1xuICAvLyAyLiAgRm9yIGVhY2ggKG1lbWJlcl92YWx1ZSwgcGFyYW1ldGVycykgb2YgaW5uZXJfbGlzdDpcbiAgLy9cbiAgLy8gICAgIDEuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGFuIEl0ZW1cbiAgLy8gICAgICAgICAoU2VjdGlvbiA0LjEuMykgd2l0aCAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKSB0byBvdXRwdXQuXG4gIC8vXG4gIC8vICAgICAyLiAgSWYgbW9yZSB2YWx1ZXMgcmVtYWluIGluIGlubmVyX2xpc3QsIGFwcGVuZCBhIHNpbmdsZSBTUCB0b1xuICAvLyAgICAgICAgIG91dHB1dC5cbiAgLy9cbiAgLy8gMy4gIEFwcGVuZCBcIilcIiB0byBvdXRwdXQuXG4gIC8vXG4gIC8vIDQuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIFBhcmFtZXRlcnNcbiAgLy8gICAgIChTZWN0aW9uIDQuMS4xLjIpIHdpdGggbGlzdF9wYXJhbWV0ZXJzIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gNS4gIFJldHVybiBvdXRwdXQuXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUlubmVyTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBcIihcIiArIHZhbHVlLnZhbHVlLm1hcChzZXJpYWxpemVJdGVtKS5qb2luKCcgJykgKyBcIilcIiArIHNlcmlhbGl6ZVBhcmFtcyh2YWx1ZS5wYXJhbXMpO1xuICB9XG5cbiAgLy8gNC4xLjIuICBTZXJpYWxpemluZyBhIERpY3Rpb25hcnlcbiAgLy9cbiAgLy8gR2l2ZW4gYW4gb3JkZXJlZCBEaWN0aW9uYXJ5IGFzIGlucHV0X2RpY3Rpb25hcnkgKGVhY2ggbWVtYmVyIGhhdmluZyBhXG4gIC8vIG1lbWJlcl9uYW1lIGFuZCBhIHR1cGxlIHZhbHVlIG9mIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpKSwgcmV0dXJuXG4gIC8vIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3IgdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbiAgLy9cbiAgLy8gMS4gIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAvL1xuICAvLyAyLiAgRm9yIGVhY2ggbWVtYmVyX25hbWUgd2l0aCBhIHZhbHVlIG9mIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpXG4gIC8vICAgICBpbiBpbnB1dF9kaWN0aW9uYXJ5OlxuICAvL1xuICAvLyAgICAgMS4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYSBLZXlcbiAgLy8gICAgICAgICAoU2VjdGlvbiA0LjEuMS4zKSB3aXRoIG1lbWJlcidzIG1lbWJlcl9uYW1lIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gICAgIDIuICBJZiBtZW1iZXJfdmFsdWUgaXMgQm9vbGVhbiB0cnVlOlxuICAvL1xuICAvLyAgICAgICAgIDEuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIFBhcmFtZXRlcnNcbiAgLy8gICAgICAgICAgICAgKFNlY3Rpb24gNC4xLjEuMikgd2l0aCBwYXJhbWV0ZXJzIHRvIG91dHB1dC5cbiAgLy9cbiAgLy8gICAgIDMuICBPdGhlcndpc2U6XG4gIC8vXG4gIC8vICAgICAgICAgMS4gIEFwcGVuZCBcIj1cIiB0byBvdXRwdXQuXG4gIC8vXG4gIC8vICAgICAgICAgMi4gIElmIG1lbWJlcl92YWx1ZSBpcyBhbiBhcnJheSwgYXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAvLyAgICAgICAgICAgICBTZXJpYWxpemluZyBhbiBJbm5lciBMaXN0IChTZWN0aW9uIDQuMS4xLjEpIHdpdGhcbiAgLy8gICAgICAgICAgICAgKG1lbWJlcl92YWx1ZSwgcGFyYW1ldGVycykgdG8gb3V0cHV0LlxuICAvL1xuICAvLyAgICAgICAgIDMuICBPdGhlcndpc2UsIGFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYW5cbiAgLy8gICAgICAgICAgICAgSXRlbSAoU2VjdGlvbiA0LjEuMykgd2l0aCAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKSB0b1xuICAvLyAgICAgICAgICAgICBvdXRwdXQuXG4gIC8vXG4gIC8vICAgICA0LiAgSWYgbW9yZSBtZW1iZXJzIHJlbWFpbiBpbiBpbnB1dF9kaWN0aW9uYXJ5OlxuICAvL1xuICAvLyAgICAgICAgIDEuICBBcHBlbmQgXCIsXCIgdG8gb3V0cHV0LlxuICAvL1xuICAvLyAgICAgICAgIDIuICBBcHBlbmQgYSBzaW5nbGUgU1AgdG8gb3V0cHV0LlxuICAvL1xuICAvLyAzLiAgUmV0dXJuIG91dHB1dC5cbiAgZnVuY3Rpb24gc2VyaWFsaXplRGljdChkaWN0LCBvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zO1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHdoaXRlc3BhY2U6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGljdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKGRpY3QsIERJQ1QpO1xuICAgIH1cbiAgICB2YXIgZW50cmllcyA9IGRpY3QgaW5zdGFuY2VvZiBNYXAgPyBkaWN0LmVudHJpZXMoKSA6IE9iamVjdC5lbnRyaWVzKGRpY3QpO1xuICAgIHZhciBvcHRpb25hbFdoaXRlU3BhY2UgPSAoX29wdGlvbnMgPSBvcHRpb25zKSAhPSBudWxsICYmIF9vcHRpb25zLndoaXRlc3BhY2UgPyAnICcgOiAnJztcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlbnRyaWVzKS5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBrZXkgPSBfcmVmWzBdLFxuICAgICAgICBpdGVtID0gX3JlZlsxXTtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgU2ZJdGVtID09PSBmYWxzZSkge1xuICAgICAgICBpdGVtID0gbmV3IFNmSXRlbShpdGVtKTtcbiAgICAgIH1cbiAgICAgIHZhciBvdXRwdXQgPSBzZXJpYWxpemVLZXkoa2V5KTtcbiAgICAgIGlmIChpdGVtLnZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIG91dHB1dCArPSBzZXJpYWxpemVQYXJhbXMoaXRlbS5wYXJhbXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ICs9ICc9JztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbS52YWx1ZSkpIHtcbiAgICAgICAgICBvdXRwdXQgKz0gc2VyaWFsaXplSW5uZXJMaXN0KGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dCArPSBzZXJpYWxpemVJdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pLmpvaW4oXCIsXCIgKyBvcHRpb25hbFdoaXRlU3BhY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhbiBvYmplY3QgaW50byBhIHN0cnVjdHVyZWQgZmllbGQgZGljdGlvbmFyeVxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXQgLSBUaGUgc3RydWN0dXJlZCBmaWVsZCBkaWN0aW9uYXJ5IHRvIGVuY29kZVxuICAgKiBAcmV0dXJucyBUaGUgc3RydWN0dXJlZCBmaWVsZCBzdHJpbmdcbiAgICpcbiAgICogQGdyb3VwIFN0cnVjdHVyZWQgRmllbGRcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIGZ1bmN0aW9uIGVuY29kZVNmRGljdCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBzZXJpYWxpemVEaWN0KHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGtleSBpcyBhIHRva2VuIGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBjaGVjay5cbiAgICpcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBrZXkgaXMgYSB0b2tlbiBmaWVsZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqL1xuICB2YXIgaXNUb2tlbkZpZWxkID0gZnVuY3Rpb24gaXNUb2tlbkZpZWxkKGtleSkge1xuICAgIHJldHVybiBrZXkgPT09ICdvdCcgfHwga2V5ID09PSAnc2YnIHx8IGtleSA9PT0gJ3N0JztcbiAgfTtcblxuICB2YXIgaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGlzRmluaXRlTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09ICcnICYmIHZhbHVlICE9PSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIHJlbGF0aXZlIHBhdGggZnJvbSBhIFVSTC5cbiAgICpcbiAgICogQHBhcmFtIHVybCAtIFRoZSBkZXN0aW5hdGlvbiBVUkxcbiAgICogQHBhcmFtIGJhc2UgLSBUaGUgYmFzZSBVUkxcbiAgICogQHJldHVybnMgVGhlIHJlbGF0aXZlIHBhdGhcbiAgICpcbiAgICogQGdyb3VwIFV0aWxzXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICBmdW5jdGlvbiB1cmxUb1JlbGF0aXZlUGF0aCh1cmwsIGJhc2UpIHtcbiAgICB2YXIgdG8gPSBuZXcgVVJMKHVybCk7XG4gICAgdmFyIGZyb20gPSBuZXcgVVJMKGJhc2UpO1xuICAgIGlmICh0by5vcmlnaW4gIT09IGZyb20ub3JpZ2luKSB7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICB2YXIgdG9QYXRoID0gdG8ucGF0aG5hbWUuc3BsaXQoJy8nKS5zbGljZSgxKTtcbiAgICB2YXIgZnJvbVBhdGggPSBmcm9tLnBhdGhuYW1lLnNwbGl0KCcvJykuc2xpY2UoMSwgLTEpO1xuICAgIC8vIHJlbW92ZSBjb21tb24gcGFyZW50c1xuICAgIHdoaWxlICh0b1BhdGhbMF0gPT09IGZyb21QYXRoWzBdKSB7XG4gICAgICB0b1BhdGguc2hpZnQoKTtcbiAgICAgIGZyb21QYXRoLnNoaWZ0KCk7XG4gICAgfVxuICAgIC8vIGFkZCBiYWNrIHBhdGhzXG4gICAgd2hpbGUgKGZyb21QYXRoLmxlbmd0aCkge1xuICAgICAgZnJvbVBhdGguc2hpZnQoKTtcbiAgICAgIHRvUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9QYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSB2NCBVVUlEXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcmFuZG9tIHY0IFVVSURcbiAgICpcbiAgICogQGdyb3VwIFV0aWxzXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICBmdW5jdGlvbiB1dWlkKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoKSk7XG4gICAgICAgIHZhciBfdXVpZCA9IHVybC50b1N0cmluZygpO1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgIHJldHVybiBfdXVpZC5zbGljZShfdXVpZC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIF91dWlkMiA9ICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICB2YXIgciA9IChkdCArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNiB8IDA7XG4gICAgICAgICAgZHQgPSBNYXRoLmZsb29yKGR0IC8gMTYpO1xuICAgICAgICAgIHJldHVybiAoYyA9PSAneCcgPyByIDogciAmIDB4MyB8IDB4OCkudG9TdHJpbmcoMTYpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF91dWlkMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdG9Sb3VuZGVkID0gZnVuY3Rpb24gdG9Sb3VuZGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICB9O1xuICB2YXIgdG9VcmxTYWZlID0gZnVuY3Rpb24gdG9VcmxTYWZlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmJhc2VVcmwpIHtcbiAgICAgIHZhbHVlID0gdXJsVG9SZWxhdGl2ZVBhdGgodmFsdWUsIG9wdGlvbnMuYmFzZVVybCk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICB9O1xuICB2YXIgdG9IdW5kcmVkID0gZnVuY3Rpb24gdG9IdW5kcmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvUm91bmRlZCh2YWx1ZSAvIDEwMCkgKiAxMDA7XG4gIH07XG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBmb3JtYXR0ZXJzIGZvciBDTUNEIHZhbHVlcy5cbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICpcbiAgICogQGJldGFcbiAgICovXG4gIHZhciBDbWNkRm9ybWF0dGVycyA9IHtcbiAgICAvKipcbiAgICAgKiBCaXRyYXRlIChrYnBzKSByb3VuZGVkIGludGVnZXJcbiAgICAgKi9cbiAgICBicjogdG9Sb3VuZGVkLFxuICAgIC8qKlxuICAgICAqIER1cmF0aW9uIChtaWxsaXNlY29uZHMpIHJvdW5kZWQgaW50ZWdlclxuICAgICAqL1xuICAgIGQ6IHRvUm91bmRlZCxcbiAgICAvKipcbiAgICAgKiBCdWZmZXIgTGVuZ3RoIChtaWxsaXNlY29uZHMpIHJvdW5kZWQgbmVhcmVzdCAxMDBtc1xuICAgICAqL1xuICAgIGJsOiB0b0h1bmRyZWQsXG4gICAgLyoqXG4gICAgICogRGVhZGxpbmUgKG1pbGxpc2Vjb25kcykgcm91bmRlZCBuZWFyZXN0IDEwMG1zXG4gICAgICovXG4gICAgZGw6IHRvSHVuZHJlZCxcbiAgICAvKipcbiAgICAgKiBNZWFzdXJlZCBUaHJvdWdocHV0IChrYnBzKSByb3VuZGVkIG5lYXJlc3QgMTAwa2Jwc1xuICAgICAqL1xuICAgIG10cDogdG9IdW5kcmVkLFxuICAgIC8qKlxuICAgICAqIE5leHQgT2JqZWN0IFJlcXVlc3QgVVJMIGVuY29kZWRcbiAgICAgKi9cbiAgICBub3I6IHRvVXJsU2FmZSxcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0ZWQgbWF4aW11bSB0aHJvdWdocHV0IChrYnBzKSByb3VuZGVkIG5lYXJlc3QgMTAwa2Jwc1xuICAgICAqL1xuICAgIHJ0cDogdG9IdW5kcmVkLFxuICAgIC8qKlxuICAgICAqIFRvcCBCaXRyYXRlIChrYnBzKSByb3VuZGVkIGludGVnZXJcbiAgICAgKi9cbiAgICB0YjogdG9Sb3VuZGVkXG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVybmFsIENNQ0QgcHJvY2Vzc2luZyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG9iaiAtIFRoZSBDTUNEIG9iamVjdCB0byBwcm9jZXNzLlxuICAgKiBAcGFyYW0gbWFwIC0gVGhlIG1hcHBpbmcgZnVuY3Rpb24gdG8gdXNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGVuY29kaW5nLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQGdyb3VwIENNQ0RcbiAgICovXG4gIGZ1bmN0aW9uIHByb2Nlc3NDbWNkKG9iaiwgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHRzID0ge307XG4gICAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopLnNvcnQoKTtcbiAgICB2YXIgZm9ybWF0dGVycyA9IF9leHRlbmRzKHt9LCBDbWNkRm9ybWF0dGVycywgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5mb3JtYXR0ZXJzKTtcbiAgICB2YXIgZmlsdGVyID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5maWx0ZXI7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChmaWx0ZXIgIT0gbnVsbCAmJiBmaWx0ZXIoa2V5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBmb3JtYXR0ZXJzW2tleV07XG4gICAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhbHVlID0gZm9ybWF0dGVyKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIC8vIFZlcnNpb24gc2hvdWxkIG9ubHkgYmUgcmVwb3J0ZWQgaWYgbm90IGVxdWFsIHRvIDEuXG4gICAgICBpZiAoa2V5ID09PSAndicgJiYgdmFsdWUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUGxheWJhY2sgcmF0ZSBzaG91bGQgb25seSBiZSBzZW50IGlmIG5vdCBlcXVhbCB0byAxLlxuICAgICAgaWYgKGtleSA9PSAncHInICYmIHZhbHVlID09PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGlnbm9yZSBpbnZhbGlkIHZhbHVlc1xuICAgICAgaWYgKCFpc1ZhbGlkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNUb2tlbkZpZWxkKGtleSkgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IG5ldyBTZlRva2VuKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHNba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhIENNQ0Qgb2JqZWN0IHRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gY21jZCAtIFRoZSBDTUNEIG9iamVjdCB0byBlbmNvZGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZW5jb2RpbmcuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIENNQ0Qgc3RyaW5nLlxuICAgKlxuICAgKiBAZ3JvdXAgQ01DRFxuICAgKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgZnVuY3Rpb24gZW5jb2RlQ21jZChjbWNkLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIWNtY2QpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZVNmRGljdChwcm9jZXNzQ21jZChjbWNkLCBvcHRpb25zKSwgX2V4dGVuZHMoe1xuICAgICAgd2hpdGVzcGFjZTogZmFsc2VcbiAgICB9LCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIENNQ0QgZGF0YSBvYmplY3QgdG8gcmVxdWVzdCBoZWFkZXJzXG4gICAqXG4gICAqIEBwYXJhbSBjbWNkIC0gVGhlIENNQ0QgZGF0YSBvYmplY3QgdG8gY29udmVydC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBlbmNvZGluZyB0aGUgQ01DRCBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBDTUNEIGhlYWRlciBzaGFyZHMuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICBmdW5jdGlvbiB0b0NtY2RIZWFkZXJzKGNtY2QsIG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIWNtY2QpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgdmFyIGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhjbWNkKTtcbiAgICB2YXIgaGVhZGVyTWFwID0gT2JqZWN0LmVudHJpZXMoQ21jZEhlYWRlck1hcCkuY29uY2F0KE9iamVjdC5lbnRyaWVzKCgoX29wdGlvbnMgPSBvcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX29wdGlvbnMuY3VzdG9tSGVhZGVyTWFwKSB8fCB7fSkpO1xuICAgIHZhciBzaGFyZHMgPSBlbnRyaWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBlbnRyeSkge1xuICAgICAgdmFyIF9oZWFkZXJNYXAkZmluZCwgX2FjYyRmaWVsZDtcbiAgICAgIHZhciBrZXkgPSBlbnRyeVswXSxcbiAgICAgICAgdmFsdWUgPSBlbnRyeVsxXTtcbiAgICAgIHZhciBmaWVsZCA9ICgoX2hlYWRlck1hcCRmaW5kID0gaGVhZGVyTWFwLmZpbmQoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBlbnRyeVsxXS5pbmNsdWRlcyhrZXkpO1xuICAgICAgfSkpID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyTWFwJGZpbmRbMF0pIHx8IENtY2RIZWFkZXJGaWVsZC5SRVFVRVNUO1xuICAgICAgKF9hY2MkZmllbGQgPSBhY2NbZmllbGRdKSAhPSBudWxsID8gX2FjYyRmaWVsZCA6IGFjY1tmaWVsZF0gPSB7fTtcbiAgICAgIGFjY1tmaWVsZF1ba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHNoYXJkcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIF9yZWYpIHtcbiAgICAgIHZhciBmaWVsZCA9IF9yZWZbMF0sXG4gICAgICAgIHZhbHVlID0gX3JlZlsxXTtcbiAgICAgIGFjY1tmaWVsZF0gPSBlbmNvZGVDbWNkKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBDTUNEIHF1ZXJ5IGFyZ3MgdG8gYSBoZWFkZXIgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gaGVhZGVycyAtIFRoZSBoZWFkZXJzIHRvIGFwcGVuZCB0by5cbiAgICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBvYmplY3QgdG8gYXBwZW5kLlxuICAgKiBAcGFyYW0gY3VzdG9tSGVhZGVyTWFwIC0gQSBtYXAgb2YgY3VzdG9tIENNQ0Qga2V5cyB0byBoZWFkZXIgZmllbGRzLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgaGVhZGVycyB3aXRoIHRoZSBDTUNEIGhlYWRlciBzaGFyZHMgYXBwZW5kZWQuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICBmdW5jdGlvbiBhcHBlbmRDbWNkSGVhZGVycyhoZWFkZXJzLCBjbWNkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKGhlYWRlcnMsIHRvQ21jZEhlYWRlcnMoY21jZCwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENNQ0QgcGFyYW1ldGVyIG5hbWUuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICB2YXIgQ01DRF9QQVJBTSA9ICdDTUNEJztcblxuICAvKipcbiAgICogQ29udmVydCBhIENNQ0QgZGF0YSBvYmplY3QgdG8gYSBxdWVyeSBhcmcuXG4gICAqXG4gICAqIEBwYXJhbSBjbWNkIC0gVGhlIENNQ0Qgb2JqZWN0IHRvIGNvbnZlcnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZW5jb2RpbmcgdGhlIENNQ0Qgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgQ01DRCBxdWVyeSBhcmcuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICBmdW5jdGlvbiB0b0NtY2RRdWVyeShjbWNkLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIWNtY2QpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHBhcmFtcyA9IGVuY29kZUNtY2QoY21jZCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIENNQ0RfUEFSQU0gKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXMpO1xuICB9XG5cbiAgdmFyIFJFR0VYID0gL0NNQ0Q9W14mI10rLztcbiAgLyoqXG4gICAqIEFwcGVuZCBDTUNEIHF1ZXJ5IGFyZ3MgdG8gYSBVUkwuXG4gICAqXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIGFwcGVuZCB0by5cbiAgICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBvYmplY3QgdG8gYXBwZW5kLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGVuY29kaW5nIHRoZSBDTUNEIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIFVSTCB3aXRoIHRoZSBDTUNEIHF1ZXJ5IGFyZ3MgYXBwZW5kZWQuXG4gICAqXG4gICAqIEBncm91cCBDTUNEXG4gICAqXG4gICAqIEBiZXRhXG4gICAqL1xuICBmdW5jdGlvbiBhcHBlbmRDbWNkUXVlcnkodXJsLCBjbWNkLCBvcHRpb25zKSB7XG4gICAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIFVSTFNlYXJjaFBhcmFtcyBvbmNlIHdlIGRyb3AgU2FmYXJpIDwgMTAuMSAmIENocm9tZSA8IDQ5IHN1cHBvcnQuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTFNlYXJjaFBhcmFtc1xuICAgIHZhciBxdWVyeSA9IHRvQ21jZFF1ZXJ5KGNtY2QsIG9wdGlvbnMpO1xuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGlmIChSRUdFWC50ZXN0KHVybCkpIHtcbiAgICAgIHJldHVybiB1cmwucmVwbGFjZShSRUdFWCwgcXVlcnkpO1xuICAgIH1cbiAgICB2YXIgc2VwYXJhdG9yID0gdXJsLmluY2x1ZGVzKCc/JykgPyAnJicgOiAnPyc7XG4gICAgcmV0dXJuIFwiXCIgKyB1cmwgKyBzZXBhcmF0b3IgKyBxdWVyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBDb21tb24gTWVkaWEgQ2xpZW50IERhdGEgKENNQ0QpXG4gICAqIEBzZWUgaHR0cHM6Ly9jZG4uY3RhLnRlY2gvY3RhL21lZGlhL21lZGlhL3Jlc291cmNlcy9zdGFuZGFyZHMvcGRmcy9jdGEtNTAwNC1maW5hbC5wZGZcbiAgICovXG4gIHZhciBDTUNEQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcblxuICAgIGZ1bmN0aW9uIENNQ0RDb250cm9sbGVyKGhscykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgICB0aGlzLm1lZGlhID0gdm9pZCAwO1xuICAgICAgdGhpcy5zaWQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmNpZCA9IHZvaWQgMDtcbiAgICAgIHRoaXMudXNlSGVhZGVycyA9IGZhbHNlO1xuICAgICAgdGhpcy5pbmNsdWRlS2V5cyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhcnZlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5idWZmZXJpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5hdWRpb0J1ZmZlciA9IHZvaWQgMDtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICB0aGlzLnZpZGVvQnVmZmVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5vbldhaXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgIF90aGlzLnN0YXJ2ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmJ1ZmZlcmluZyA9IHRydWU7XG4gICAgICB9O1xuICAgICAgdGhpcy5vblBsYXlpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghX3RoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICBfdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuYnVmZmVyaW5nID0gZmFsc2U7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBBcHBseSBDTUNEIGRhdGEgdG8gYSBtYW5pZmVzdCByZXF1ZXN0LlxuICAgICAgICovXG4gICAgICB0aGlzLmFwcGx5UGxheWxpc3REYXRhID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfdGhpcy5hcHBseShjb250ZXh0LCB7XG4gICAgICAgICAgICBvdDogQ21PYmplY3RUeXBlLk1BTklGRVNULFxuICAgICAgICAgICAgc3U6ICFfdGhpcy5pbml0aWFsaXplZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKCdDb3VsZCBub3QgZ2VuZXJhdGUgbWFuaWZlc3QgQ01DRCBkYXRhLicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQXBwbHkgQ01DRCBkYXRhIHRvIGEgc2VnbWVudCByZXF1ZXN0XG4gICAgICAgKi9cbiAgICAgIHRoaXMuYXBwbHlGcmFnbWVudERhdGEgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBmcmFnbWVudCA9IGNvbnRleHQuZnJhZztcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBfdGhpcy5obHMubGV2ZWxzW2ZyYWdtZW50LmxldmVsXTtcbiAgICAgICAgICB2YXIgb3QgPSBfdGhpcy5nZXRPYmplY3RUeXBlKGZyYWdtZW50KTtcbiAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGQ6IGZyYWdtZW50LmR1cmF0aW9uICogMTAwMCxcbiAgICAgICAgICAgIG90OiBvdFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKG90ID09PSBDbU9iamVjdFR5cGUuVklERU8gfHwgb3QgPT09IENtT2JqZWN0VHlwZS5BVURJTyB8fCBvdCA9PSBDbU9iamVjdFR5cGUuTVVYRUQpIHtcbiAgICAgICAgICAgIGRhdGEuYnIgPSBsZXZlbC5iaXRyYXRlIC8gMTAwMDtcbiAgICAgICAgICAgIGRhdGEudGIgPSBfdGhpcy5nZXRUb3BCYW5kd2lkdGgob3QpIC8gMTAwMDtcbiAgICAgICAgICAgIGRhdGEuYmwgPSBfdGhpcy5nZXRCdWZmZXJMZW5ndGgob3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5hcHBseShjb250ZXh0LCBkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dnZXIud2FybignQ291bGQgbm90IGdlbmVyYXRlIHNlZ21lbnQgQ01DRCBkYXRhLicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuaGxzID0gaGxzO1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICAgIHZhciBjbWNkID0gY29uZmlnLmNtY2Q7XG4gICAgICBpZiAoY21jZCAhPSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5wTG9hZGVyID0gdGhpcy5jcmVhdGVQbGF5bGlzdExvYWRlcigpO1xuICAgICAgICBjb25maWcuZkxvYWRlciA9IHRoaXMuY3JlYXRlRnJhZ21lbnRMb2FkZXIoKTtcbiAgICAgICAgdGhpcy5zaWQgPSBjbWNkLnNlc3Npb25JZCB8fCB1dWlkKCk7XG4gICAgICAgIHRoaXMuY2lkID0gY21jZC5jb250ZW50SWQ7XG4gICAgICAgIHRoaXMudXNlSGVhZGVycyA9IGNtY2QudXNlSGVhZGVycyA9PT0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbmNsdWRlS2V5cyA9IGNtY2QuaW5jbHVkZUtleXM7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9wcm90byA9IENNQ0RDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by51bnJlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgdGhpcy5vbk1lZGlhRGV0YWNoZWQoKTtcblxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5obHMgPSB0aGlzLmNvbmZpZyA9IHRoaXMuYXVkaW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMub25XYWl0aW5nID0gdGhpcy5vblBsYXlpbmcgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWVkaWFBdHRhY2hlZCA9IGZ1bmN0aW9uIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCB0aGlzLm9uV2FpdGluZyk7XG4gICAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9uUGxheWluZyk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYURldGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYURldGFjaGVkKCkge1xuICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2FpdGluZycsIHRoaXMub25XYWl0aW5nKTtcbiAgICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub25QbGF5aW5nKTtcblxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJDcmVhdGVkID0gZnVuY3Rpb24gb25CdWZmZXJDcmVhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgX2RhdGEkdHJhY2tzJGF1ZGlvLCBfZGF0YSR0cmFja3MkdmlkZW87XG4gICAgICB0aGlzLmF1ZGlvQnVmZmVyID0gKF9kYXRhJHRyYWNrcyRhdWRpbyA9IGRhdGEudHJhY2tzLmF1ZGlvKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkdHJhY2tzJGF1ZGlvLmJ1ZmZlcjtcbiAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSAoX2RhdGEkdHJhY2tzJHZpZGVvID0gZGF0YS50cmFja3MudmlkZW8pID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSR0cmFja3MkdmlkZW8uYnVmZmVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGJhc2VsaW5lIENNQ0QgZGF0YVxuICAgICAqL1xuICAgIF9wcm90by5jcmVhdGVEYXRhID0gZnVuY3Rpb24gY3JlYXRlRGF0YSgpIHtcbiAgICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHY6IDEsXG4gICAgICAgIHNmOiBDbVN0cmVhbWluZ0Zvcm1hdC5ITFMsXG4gICAgICAgIHNpZDogdGhpcy5zaWQsXG4gICAgICAgIGNpZDogdGhpcy5jaWQsXG4gICAgICAgIHByOiAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWEucGxheWJhY2tSYXRlLFxuICAgICAgICBtdHA6IHRoaXMuaGxzLmJhbmR3aWR0aEVzdGltYXRlIC8gMTAwMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBDTUNEIGRhdGEgdG8gYSByZXF1ZXN0LlxuICAgICAqLztcbiAgICBfcHJvdG8uYXBwbHkgPSBmdW5jdGlvbiBhcHBseShjb250ZXh0LCBkYXRhKSB7XG4gICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRhdGEgPSB7fTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IGJhc2VsaW5lIGRhdGFcbiAgICAgIF9leHRlbmRzKGRhdGEsIHRoaXMuY3JlYXRlRGF0YSgpKTtcbiAgICAgIHZhciBpc1ZpZGVvID0gZGF0YS5vdCA9PT0gQ21PYmplY3RUeXBlLklOSVQgfHwgZGF0YS5vdCA9PT0gQ21PYmplY3RUeXBlLlZJREVPIHx8IGRhdGEub3QgPT09IENtT2JqZWN0VHlwZS5NVVhFRDtcbiAgICAgIGlmICh0aGlzLnN0YXJ2ZWQgJiYgaXNWaWRlbykge1xuICAgICAgICBkYXRhLmJzID0gdHJ1ZTtcbiAgICAgICAgZGF0YS5zdSA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhcnZlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc3UgPT0gbnVsbCkge1xuICAgICAgICBkYXRhLnN1ID0gdGhpcy5idWZmZXJpbmc7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IEltcGxlbWVudCBydHAsIG5yciwgbm9yLCBkbFxuXG4gICAgICB2YXIgaW5jbHVkZUtleXMgPSB0aGlzLmluY2x1ZGVLZXlzO1xuICAgICAgaWYgKGluY2x1ZGVLZXlzKSB7XG4gICAgICAgIGRhdGEgPSBPYmplY3Qua2V5cyhkYXRhKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgICAgaW5jbHVkZUtleXMuaW5jbHVkZXMoa2V5KSAmJiAoYWNjW2tleV0gPSBkYXRhW2tleV0pO1xuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVzZUhlYWRlcnMpIHtcbiAgICAgICAgaWYgKCFjb250ZXh0LmhlYWRlcnMpIHtcbiAgICAgICAgICBjb250ZXh0LmhlYWRlcnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmRDbWNkSGVhZGVycyhjb250ZXh0LmhlYWRlcnMsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC51cmwgPSBhcHBlbmRDbWNkUXVlcnkoY29udGV4dC51cmwsIGRhdGEpO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIENNQ0Qgb2JqZWN0IHR5cGUuXG4gICAgICovXG4gICAgX3Byb3RvLmdldE9iamVjdFR5cGUgPSBmdW5jdGlvbiBnZXRPYmplY3RUeXBlKGZyYWdtZW50KSB7XG4gICAgICB2YXIgdHlwZSA9IGZyYWdtZW50LnR5cGU7XG4gICAgICBpZiAodHlwZSA9PT0gJ3N1YnRpdGxlJykge1xuICAgICAgICByZXR1cm4gQ21PYmplY3RUeXBlLlRJTUVEX1RFWFQ7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ21lbnQuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgcmV0dXJuIENtT2JqZWN0VHlwZS5JTklUO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcmV0dXJuIENtT2JqZWN0VHlwZS5BVURJTztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnbWFpbicpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhscy5hdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gQ21PYmplY3RUeXBlLk1VWEVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDbU9iamVjdFR5cGUuVklERU87XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaGlnaGVzdCBiaXRyYXRlLlxuICAgICAqLztcbiAgICBfcHJvdG8uZ2V0VG9wQmFuZHdpZHRoID0gZnVuY3Rpb24gZ2V0VG9wQmFuZHdpZHRoKHR5cGUpIHtcbiAgICAgIHZhciBiaXRyYXRlID0gMDtcbiAgICAgIHZhciBsZXZlbHM7XG4gICAgICB2YXIgaGxzID0gdGhpcy5obHM7XG4gICAgICBpZiAodHlwZSA9PT0gQ21PYmplY3RUeXBlLkFVRElPKSB7XG4gICAgICAgIGxldmVscyA9IGhscy5hdWRpb1RyYWNrcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXggPSBobHMubWF4QXV0b0xldmVsO1xuICAgICAgICB2YXIgbGVuID0gbWF4ID4gLTEgPyBtYXggKyAxIDogaGxzLmxldmVscy5sZW5ndGg7XG4gICAgICAgIGxldmVscyA9IGhscy5sZXZlbHMuc2xpY2UoMCwgbGVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobGV2ZWxzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGxldmVsID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIGlmIChsZXZlbC5iaXRyYXRlID4gYml0cmF0ZSkge1xuICAgICAgICAgIGJpdHJhdGUgPSBsZXZlbC5iaXRyYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYml0cmF0ZSA+IDAgPyBiaXRyYXRlIDogTmFOO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnVmZmVyIGxlbmd0aCBmb3IgYSBtZWRpYSB0eXBlIGluIG1pbGxpc2Vjb25kc1xuICAgICAqLztcbiAgICBfcHJvdG8uZ2V0QnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gZ2V0QnVmZmVyTGVuZ3RoKHR5cGUpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMuaGxzLm1lZGlhO1xuICAgICAgdmFyIGJ1ZmZlciA9IHR5cGUgPT09IENtT2JqZWN0VHlwZS5BVURJTyA/IHRoaXMuYXVkaW9CdWZmZXIgOiB0aGlzLnZpZGVvQnVmZmVyO1xuICAgICAgaWYgKCFidWZmZXIgfHwgIW1lZGlhKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG4gICAgICB2YXIgaW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKGJ1ZmZlciwgbWVkaWEuY3VycmVudFRpbWUsIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgICAgcmV0dXJuIGluZm8ubGVuICogMTAwMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBwbGF5bGlzdCBsb2FkZXJcbiAgICAgKi87XG4gICAgX3Byb3RvLmNyZWF0ZVBsYXlsaXN0TG9hZGVyID0gZnVuY3Rpb24gY3JlYXRlUGxheWxpc3RMb2FkZXIoKSB7XG4gICAgICB2YXIgcExvYWRlciA9IHRoaXMuY29uZmlnLnBMb2FkZXI7XG4gICAgICB2YXIgYXBwbHkgPSB0aGlzLmFwcGx5UGxheWxpc3REYXRhO1xuICAgICAgdmFyIEN0b3IgPSBwTG9hZGVyIHx8IHRoaXMuY29uZmlnLmxvYWRlcjtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDbWNkUGxheWxpc3RMb2FkZXIoY29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5sb2FkZXIgPSB2b2lkIDA7XG4gICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgQ3Rvcihjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfcHJvdG8yID0gQ21jZFBsYXlsaXN0TG9hZGVyLnByb3RvdHlwZTtcbiAgICAgICAgX3Byb3RvMi5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgICAgIF9wcm90bzIuYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9O1xuICAgICAgICBfcHJvdG8yLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgICAgICAgYXBwbHkoY29udGV4dCk7XG4gICAgICAgICAgdGhpcy5sb2FkZXIubG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcyk7XG4gICAgICAgIH07XG4gICAgICAgIF9jcmVhdGVDbGFzcyhDbWNkUGxheWxpc3RMb2FkZXIsIFt7XG4gICAgICAgICAga2V5OiBcInN0YXRzXCIsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuc3RhdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAga2V5OiBcImNvbnRleHRcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5jb250ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgICByZXR1cm4gQ21jZFBsYXlsaXN0TG9hZGVyO1xuICAgICAgfSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHBsYXlsaXN0IGxvYWRlclxuICAgICAqLztcbiAgICBfcHJvdG8uY3JlYXRlRnJhZ21lbnRMb2FkZXIgPSBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudExvYWRlcigpIHtcbiAgICAgIHZhciBmTG9hZGVyID0gdGhpcy5jb25maWcuZkxvYWRlcjtcbiAgICAgIHZhciBhcHBseSA9IHRoaXMuYXBwbHlGcmFnbWVudERhdGE7XG4gICAgICB2YXIgQ3RvciA9IGZMb2FkZXIgfHwgdGhpcy5jb25maWcubG9hZGVyO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENtY2RGcmFnbWVudExvYWRlcihjb25maWcpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlciA9IHZvaWQgMDtcbiAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBDdG9yKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9wcm90bzMgPSBDbWNkRnJhZ21lbnRMb2FkZXIucHJvdG90eXBlO1xuICAgICAgICBfcHJvdG8zLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3Byb3RvMy5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgIHRoaXMubG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH07XG4gICAgICAgIF9wcm90bzMubG9hZCA9IGZ1bmN0aW9uIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICAgICAgICBhcHBseShjb250ZXh0KTtcbiAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKTtcbiAgICAgICAgfTtcbiAgICAgICAgX2NyZWF0ZUNsYXNzKENtY2RGcmFnbWVudExvYWRlciwgW3tcbiAgICAgICAgICBrZXk6IFwic3RhdHNcIixcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5zdGF0cztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBrZXk6IFwiY29udGV4dFwiLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLmNvbnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICAgIHJldHVybiBDbWNkRnJhZ21lbnRMb2FkZXI7XG4gICAgICB9KCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ01DRENvbnRyb2xsZXI7XG4gIH0oKTtcblxuICB2YXIgUEFUSFdBWV9QRU5BTFRZX0RVUkFUSU9OX01TID0gMzAwMDAwO1xuICB2YXIgQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlcihobHMpIHtcbiAgICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgICAgdGhpcy5sb2cgPSB2b2lkIDA7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgICB0aGlzLnVyaSA9IG51bGw7XG4gICAgICB0aGlzLnBhdGh3YXlJZCA9ICcuJztcbiAgICAgIHRoaXMucGF0aHdheVByaW9yaXR5ID0gbnVsbDtcbiAgICAgIHRoaXMudGltZVRvTG9hZCA9IDMwMDtcbiAgICAgIHRoaXMucmVsb2FkVGltZXIgPSAtMTtcbiAgICAgIHRoaXMudXBkYXRlZCA9IDA7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLmxldmVscyA9IG51bGw7XG4gICAgICB0aGlzLmF1ZGlvVHJhY2tzID0gbnVsbDtcbiAgICAgIHRoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICAgICAgdGhpcy5wZW5hbGl6ZWRQYXRod2F5cyA9IHt9O1xuICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIFwiW2NvbnRlbnQtc3RlZXJpbmddOlwiKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLnVucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaWYgKCFobHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWQgJiYgdGhpcy51cmkpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlZCkge1xuICAgICAgICAgIHZhciB0dGwgPSB0aGlzLnRpbWVUb0xvYWQgKiAxMDAwIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy51cGRhdGVkKTtcbiAgICAgICAgICBpZiAodHRsID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2godGhpcy51cmksIHR0bCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZFN0ZWVyaW5nTWFuaWZlc3QodGhpcy51cmkpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnN0b3BMb2FkID0gZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gY2xlYXJUaW1lb3V0KCkge1xuICAgICAgaWYgKHRoaXMucmVsb2FkVGltZXIgIT09IC0xKSB7XG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVsb2FkVGltZXIpO1xuICAgICAgICB0aGlzLnJlbG9hZFRpbWVyID0gLTE7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgICAgIHRoaXMubGV2ZWxzID0gdGhpcy5hdWRpb1RyYWNrcyA9IHRoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZUxldmVsID0gZnVuY3Rpb24gcmVtb3ZlTGV2ZWwobGV2ZWxUb1JlbW92ZSkge1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgICAgaWYgKGxldmVscykge1xuICAgICAgICB0aGlzLmxldmVscyA9IGxldmVscy5maWx0ZXIoZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgcmV0dXJuIGxldmVsICE9PSBsZXZlbFRvUmVtb3ZlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudGltZVRvTG9hZCA9IDMwMDtcbiAgICAgIHRoaXMudXBkYXRlZCA9IDA7XG4gICAgICB0aGlzLnVyaSA9IG51bGw7XG4gICAgICB0aGlzLnBhdGh3YXlJZCA9ICcuJztcbiAgICAgIHRoaXMubGV2ZWxzID0gdGhpcy5hdWRpb1RyYWNrcyA9IHRoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkZWQgPSBmdW5jdGlvbiBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgY29udGVudFN0ZWVyaW5nID0gZGF0YS5jb250ZW50U3RlZXJpbmc7XG4gICAgICBpZiAoY29udGVudFN0ZWVyaW5nID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGF0aHdheUlkID0gY29udGVudFN0ZWVyaW5nLnBhdGh3YXlJZDtcbiAgICAgIHRoaXMudXJpID0gY29udGVudFN0ZWVyaW5nLnVyaTtcbiAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5zdGFydExvYWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0UGFyc2VkID0gZnVuY3Rpb24gb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgICAgdGhpcy5hdWRpb1RyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3M7XG4gICAgICB0aGlzLnN1YnRpdGxlVHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcztcbiAgICB9O1xuICAgIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgICAgdmFyIGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbjtcbiAgICAgIGlmICgoZXJyb3JBY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yQWN0aW9uLmFjdGlvbikgPT09IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94ICYmIGVycm9yQWN0aW9uLmZsYWdzID09PSBFcnJvckFjdGlvbkZsYWdzLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0KSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcbiAgICAgICAgdmFyIHBhdGh3YXlQcmlvcml0eSA9IHRoaXMucGF0aHdheVByaW9yaXR5O1xuICAgICAgICB2YXIgZXJyb3JQYXRod2F5ID0gdGhpcy5wYXRod2F5SWQ7XG4gICAgICAgIGlmIChkYXRhLmNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX2RhdGEkY29udGV4dCA9IGRhdGEuY29udGV4dCxcbiAgICAgICAgICAgIGdyb3VwSWQgPSBfZGF0YSRjb250ZXh0Lmdyb3VwSWQsXG4gICAgICAgICAgICBfcGF0aHdheUlkID0gX2RhdGEkY29udGV4dC5wYXRod2F5SWQsXG4gICAgICAgICAgICB0eXBlID0gX2RhdGEkY29udGV4dC50eXBlO1xuICAgICAgICAgIGlmIChncm91cElkICYmIGxldmVscykge1xuICAgICAgICAgICAgZXJyb3JQYXRod2F5ID0gdGhpcy5nZXRQYXRod2F5Rm9yR3JvdXBJZChncm91cElkLCB0eXBlLCBlcnJvclBhdGh3YXkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3BhdGh3YXlJZCkge1xuICAgICAgICAgICAgZXJyb3JQYXRod2F5ID0gX3BhdGh3YXlJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZXJyb3JQYXRod2F5IGluIHRoaXMucGVuYWxpemVkUGF0aHdheXMpKSB7XG4gICAgICAgICAgdGhpcy5wZW5hbGl6ZWRQYXRod2F5c1tlcnJvclBhdGh3YXldID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXRod2F5UHJpb3JpdHkgJiYgbGV2ZWxzKSB7XG4gICAgICAgICAgLy8gSWYgUEFUSFdBWS1QUklPUklUWSB3YXMgbm90IHByb3ZpZGVkLCBsaXN0IHBhdGh3YXlzIGZvciBlcnJvciBoYW5kbGluZ1xuICAgICAgICAgIHBhdGh3YXlQcmlvcml0eSA9IGxldmVscy5yZWR1Y2UoZnVuY3Rpb24gKHBhdGh3YXlzLCBsZXZlbCkge1xuICAgICAgICAgICAgaWYgKHBhdGh3YXlzLmluZGV4T2YobGV2ZWwucGF0aHdheUlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcGF0aHdheXMucHVzaChsZXZlbC5wYXRod2F5SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdGh3YXlzO1xuICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aHdheVByaW9yaXR5ICYmIHBhdGh3YXlQcmlvcml0eS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVQYXRod2F5UHJpb3JpdHkocGF0aHdheVByaW9yaXR5KTtcbiAgICAgICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRoaXMucGF0aHdheUlkICE9PSBlcnJvclBhdGh3YXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlcnJvckFjdGlvbi5yZXNvbHZlZCkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFwiQ291bGQgbm90IHJlc29sdmUgXCIgKyBkYXRhLmRldGFpbHMgKyBcIiAoXFxcIlwiICsgZGF0YS5lcnJvci5tZXNzYWdlICsgXCJcXFwiKSB3aXRoIGNvbnRlbnQtc3RlZXJpbmcgZm9yIFBhdGh3YXk6IFwiICsgZXJyb3JQYXRod2F5ICsgXCIgbGV2ZWxzOiBcIiArIChsZXZlbHMgPyBsZXZlbHMubGVuZ3RoIDogbGV2ZWxzKSArIFwiIHByaW9yaXRpZXM6IFwiICsgSlNPTi5zdHJpbmdpZnkocGF0aHdheVByaW9yaXR5KSArIFwiIHBlbmFsaXplZDogXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnBlbmFsaXplZFBhdGh3YXlzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5maWx0ZXJQYXJzZWRMZXZlbHMgPSBmdW5jdGlvbiBmaWx0ZXJQYXJzZWRMZXZlbHMobGV2ZWxzKSB7XG4gICAgICAvLyBGaWx0ZXIgbGV2ZWxzIHRvIG9ubHkgaW5jbHVkZSB0aG9zZSB0aGF0IGFyZSBpbiB0aGUgaW5pdGlhbCBwYXRod2F5XG4gICAgICB0aGlzLmxldmVscyA9IGxldmVscztcbiAgICAgIHZhciBwYXRod2F5TGV2ZWxzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KHRoaXMucGF0aHdheUlkKTtcbiAgICAgIGlmIChwYXRod2F5TGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgX3BhdGh3YXlJZDIgPSBsZXZlbHNbMF0ucGF0aHdheUlkO1xuICAgICAgICB0aGlzLmxvZyhcIk5vIGxldmVscyBmb3VuZCBpbiBQYXRod2F5IFwiICsgdGhpcy5wYXRod2F5SWQgKyBcIi4gU2V0dGluZyBpbml0aWFsIFBhdGh3YXkgdG8gXFxcIlwiICsgX3BhdGh3YXlJZDIgKyBcIlxcXCJcIik7XG4gICAgICAgIHBhdGh3YXlMZXZlbHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkoX3BhdGh3YXlJZDIpO1xuICAgICAgICB0aGlzLnBhdGh3YXlJZCA9IF9wYXRod2F5SWQyO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGh3YXlMZXZlbHMubGVuZ3RoICE9PSBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubG9nKFwiRm91bmQgXCIgKyBwYXRod2F5TGV2ZWxzLmxlbmd0aCArIFwiL1wiICsgbGV2ZWxzLmxlbmd0aCArIFwiIGxldmVscyBpbiBQYXRod2F5IFxcXCJcIiArIHRoaXMucGF0aHdheUlkICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGh3YXlMZXZlbHM7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TGV2ZWxzRm9yUGF0aHdheSA9IGZ1bmN0aW9uIGdldExldmVsc0ZvclBhdGh3YXkocGF0aHdheUlkKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHBhdGh3YXlJZCA9PT0gbGV2ZWwucGF0aHdheUlkO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8udXBkYXRlUGF0aHdheVByaW9yaXR5ID0gZnVuY3Rpb24gdXBkYXRlUGF0aHdheVByaW9yaXR5KHBhdGh3YXlQcmlvcml0eSkge1xuICAgICAgdGhpcy5wYXRod2F5UHJpb3JpdHkgPSBwYXRod2F5UHJpb3JpdHk7XG4gICAgICB2YXIgbGV2ZWxzO1xuXG4gICAgICAvLyBFdmFsdWF0ZSBpZiB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwYXRod2F5IGZyb20gdGhlIHBlbmFsaXplZCBsaXN0XG4gICAgICB2YXIgcGVuYWxpemVkUGF0aHdheXMgPSB0aGlzLnBlbmFsaXplZFBhdGh3YXlzO1xuICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgT2JqZWN0LmtleXMocGVuYWxpemVkUGF0aHdheXMpLmZvckVhY2goZnVuY3Rpb24gKHBhdGh3YXlJZCkge1xuICAgICAgICBpZiAobm93IC0gcGVuYWxpemVkUGF0aHdheXNbcGF0aHdheUlkXSA+IFBBVEhXQVlfUEVOQUxUWV9EVVJBVElPTl9NUykge1xuICAgICAgICAgIGRlbGV0ZSBwZW5hbGl6ZWRQYXRod2F5c1twYXRod2F5SWRdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHdheVByaW9yaXR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfcGF0aHdheUlkMyA9IHBhdGh3YXlQcmlvcml0eVtpXTtcbiAgICAgICAgaWYgKF9wYXRod2F5SWQzIGluIHBlbmFsaXplZFBhdGh3YXlzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9wYXRod2F5SWQzID09PSB0aGlzLnBhdGh3YXlJZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IHRoaXMuaGxzLm5leHRMb2FkTGV2ZWw7XG4gICAgICAgIHZhciBzZWxlY3RlZExldmVsID0gdGhpcy5obHMubGV2ZWxzW3NlbGVjdGVkSW5kZXhdO1xuICAgICAgICBsZXZlbHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkoX3BhdGh3YXlJZDMpO1xuICAgICAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmxvZyhcIlNldHRpbmcgUGF0aHdheSB0byBcXFwiXCIgKyBfcGF0aHdheUlkMyArIFwiXFxcIlwiKTtcbiAgICAgICAgICB0aGlzLnBhdGh3YXlJZCA9IF9wYXRod2F5SWQzO1xuICAgICAgICAgIHJlYXNzaWduRnJhZ21lbnRMZXZlbEluZGV4ZXMobGV2ZWxzKTtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwge1xuICAgICAgICAgICAgbGV2ZWxzOiBsZXZlbHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBTZXQgTGV2ZWxDb250cm9sbGVyJ3MgbGV2ZWwgdG8gdHJpZ2dlciBMRVZFTF9TV0lUQ0hJTkcgd2hpY2ggbG9hZHMgcGxheWxpc3QgaWYgbmVlZGVkXG4gICAgICAgICAgdmFyIGxldmVsQWZ0ZXJDaGFuZ2UgPSB0aGlzLmhscy5sZXZlbHNbc2VsZWN0ZWRJbmRleF07XG4gICAgICAgICAgaWYgKHNlbGVjdGVkTGV2ZWwgJiYgbGV2ZWxBZnRlckNoYW5nZSAmJiB0aGlzLmxldmVscykge1xuICAgICAgICAgICAgaWYgKGxldmVsQWZ0ZXJDaGFuZ2UuYXR0cnNbJ1NUQUJMRS1WQVJJQU5ULUlEJ10gIT09IHNlbGVjdGVkTGV2ZWwuYXR0cnNbJ1NUQUJMRS1WQVJJQU5ULUlEJ10gJiYgbGV2ZWxBZnRlckNoYW5nZS5iaXRyYXRlICE9PSBzZWxlY3RlZExldmVsLmJpdHJhdGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2coXCJVbnN0YWJsZSBQYXRod2F5cyBjaGFuZ2UgZnJvbSBiaXRyYXRlIFwiICsgc2VsZWN0ZWRMZXZlbC5iaXRyYXRlICsgXCIgdG8gXCIgKyBsZXZlbEFmdGVyQ2hhbmdlLmJpdHJhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5obHMubmV4dExvYWRMZXZlbCA9IHNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UGF0aHdheUZvckdyb3VwSWQgPSBmdW5jdGlvbiBnZXRQYXRod2F5Rm9yR3JvdXBJZChncm91cElkLCB0eXBlLCBkZWZhdWx0UGF0aHdheSkge1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheShkZWZhdWx0UGF0aHdheSkuY29uY2F0KHRoaXMubGV2ZWxzIHx8IFtdKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIGxldmVsc1tpXS5oYXNBdWRpb0dyb3VwKGdyb3VwSWQpIHx8IHR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiYgbGV2ZWxzW2ldLmhhc1N1YnRpdGxlR3JvdXAoZ3JvdXBJZCkpIHtcbiAgICAgICAgICByZXR1cm4gbGV2ZWxzW2ldLnBhdGh3YXlJZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmF1bHRQYXRod2F5O1xuICAgIH07XG4gICAgX3Byb3RvLmNsb25lUGF0aHdheXMgPSBmdW5jdGlvbiBjbG9uZVBhdGh3YXlzKHBhdGh3YXlDbG9uZXMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgICBpZiAoIWxldmVscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYXVkaW9Hcm91cENsb25lTWFwID0ge307XG4gICAgICB2YXIgc3VidGl0bGVHcm91cENsb25lTWFwID0ge307XG4gICAgICBwYXRod2F5Q2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKHBhdGh3YXlDbG9uZSkge1xuICAgICAgICB2YXIgY2xvbmVJZCA9IHBhdGh3YXlDbG9uZS5JRCxcbiAgICAgICAgICBiYXNlSWQgPSBwYXRod2F5Q2xvbmVbJ0JBU0UtSUQnXSxcbiAgICAgICAgICB1cmlSZXBsYWNlbWVudCA9IHBhdGh3YXlDbG9uZVsnVVJJLVJFUExBQ0VNRU5UJ107XG4gICAgICAgIGlmIChsZXZlbHMuc29tZShmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICByZXR1cm4gbGV2ZWwucGF0aHdheUlkID09PSBjbG9uZUlkO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xvbmVkVmFyaWFudHMgPSBfdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KGJhc2VJZCkubWFwKGZ1bmN0aW9uIChiYXNlTGV2ZWwpIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IG5ldyBBdHRyTGlzdChiYXNlTGV2ZWwuYXR0cnMpO1xuICAgICAgICAgIGF0dHJpYnV0ZXNbJ1BBVEhXQVktSUQnXSA9IGNsb25lSWQ7XG4gICAgICAgICAgdmFyIGNsb25lZEF1ZGlvR3JvdXBJZCA9IGF0dHJpYnV0ZXMuQVVESU8gJiYgYXR0cmlidXRlcy5BVURJTyArIFwiX2Nsb25lX1wiICsgY2xvbmVJZDtcbiAgICAgICAgICB2YXIgY2xvbmVkU3VidGl0bGVHcm91cElkID0gYXR0cmlidXRlcy5TVUJUSVRMRVMgJiYgYXR0cmlidXRlcy5TVUJUSVRMRVMgKyBcIl9jbG9uZV9cIiArIGNsb25lSWQ7XG4gICAgICAgICAgaWYgKGNsb25lZEF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgICAgYXVkaW9Hcm91cENsb25lTWFwW2F0dHJpYnV0ZXMuQVVESU9dID0gY2xvbmVkQXVkaW9Hcm91cElkO1xuICAgICAgICAgICAgYXR0cmlidXRlcy5BVURJTyA9IGNsb25lZEF1ZGlvR3JvdXBJZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNsb25lZFN1YnRpdGxlR3JvdXBJZCkge1xuICAgICAgICAgICAgc3VidGl0bGVHcm91cENsb25lTWFwW2F0dHJpYnV0ZXMuU1VCVElUTEVTXSA9IGNsb25lZFN1YnRpdGxlR3JvdXBJZDtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuU1VCVElUTEVTID0gY2xvbmVkU3VidGl0bGVHcm91cElkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXJsID0gcGVyZm9ybVVyaVJlcGxhY2VtZW50KGJhc2VMZXZlbC51cmksIGF0dHJpYnV0ZXNbJ1NUQUJMRS1WQVJJQU5ULUlEJ10sICdQRVItVkFSSUFOVC1VUklTJywgdXJpUmVwbGFjZW1lbnQpO1xuICAgICAgICAgIHZhciBjbG9uZWRMZXZlbCA9IG5ldyBMZXZlbCh7XG4gICAgICAgICAgICBhdHRyczogYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGF1ZGlvQ29kZWM6IGJhc2VMZXZlbC5hdWRpb0NvZGVjLFxuICAgICAgICAgICAgYml0cmF0ZTogYmFzZUxldmVsLmJpdHJhdGUsXG4gICAgICAgICAgICBoZWlnaHQ6IGJhc2VMZXZlbC5oZWlnaHQsXG4gICAgICAgICAgICBuYW1lOiBiYXNlTGV2ZWwubmFtZSxcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgdmlkZW9Db2RlYzogYmFzZUxldmVsLnZpZGVvQ29kZWMsXG4gICAgICAgICAgICB3aWR0aDogYmFzZUxldmVsLndpZHRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGJhc2VMZXZlbC5hdWRpb0dyb3Vwcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiYXNlTGV2ZWwuYXVkaW9Hcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY2xvbmVkTGV2ZWwuYWRkR3JvdXBJZCgnYXVkaW8nLCBiYXNlTGV2ZWwuYXVkaW9Hcm91cHNbaV0gKyBcIl9jbG9uZV9cIiArIGNsb25lSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmFzZUxldmVsLnN1YnRpdGxlR3JvdXBzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYmFzZUxldmVsLnN1YnRpdGxlR3JvdXBzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICBjbG9uZWRMZXZlbC5hZGRHcm91cElkKCd0ZXh0JywgYmFzZUxldmVsLnN1YnRpdGxlR3JvdXBzW19pXSArIFwiX2Nsb25lX1wiICsgY2xvbmVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjbG9uZWRMZXZlbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldmVscy5wdXNoLmFwcGx5KGxldmVscywgY2xvbmVkVmFyaWFudHMpO1xuICAgICAgICBjbG9uZVJlbmRpdGlvbkdyb3VwcyhfdGhpcy5hdWRpb1RyYWNrcywgYXVkaW9Hcm91cENsb25lTWFwLCB1cmlSZXBsYWNlbWVudCwgY2xvbmVJZCk7XG4gICAgICAgIGNsb25lUmVuZGl0aW9uR3JvdXBzKF90aGlzLnN1YnRpdGxlVHJhY2tzLCBzdWJ0aXRsZUdyb3VwQ2xvbmVNYXAsIHVyaVJlcGxhY2VtZW50LCBjbG9uZUlkKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRTdGVlcmluZ01hbmlmZXN0ID0gZnVuY3Rpb24gbG9hZFN0ZWVyaW5nTWFuaWZlc3QodXJpKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgICB2YXIgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRlciA9IG5ldyBMb2FkZXIoY29uZmlnKTtcbiAgICAgIHZhciB1cmw7XG4gICAgICB0cnkge1xuICAgICAgICB1cmwgPSBuZXcgc2VsZi5VUkwodXJpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBTdGVlcmluZyBNYW5pZmVzdCBVUkk6IFwiICsgdXJpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHVybC5wcm90b2NvbCAhPT0gJ2RhdGE6Jykge1xuICAgICAgICB2YXIgdGhyb3VnaHB1dCA9ICh0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZSB8fCBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkgfCAwO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19wYXRod2F5JywgdGhpcy5wYXRod2F5SWQpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU190aHJvdWdocHV0JywgJycgKyB0aHJvdWdocHV0KTtcbiAgICAgIH1cbiAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgdXJsOiB1cmwuaHJlZlxuICAgICAgfTtcbiAgICAgIHZhciBsb2FkUG9saWN5ID0gY29uZmlnLnN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgICB2YXIgbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5ID0gbG9hZFBvbGljeS5lcnJvclJldHJ5IHx8IGxvYWRQb2xpY3kudGltZW91dFJldHJ5IHx8IHt9O1xuICAgICAgdmFyIGxvYWRlckNvbmZpZyA9IHtcbiAgICAgICAgbG9hZFBvbGljeTogbG9hZFBvbGljeSxcbiAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heE51bVJldHJ5IHx8IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5yZXRyeURlbGF5TXMgfHwgMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heFJldHJ5RGVsYXlNcyB8fCAwXG4gICAgICB9O1xuICAgICAgdmFyIGNhbGxiYWNrcyA9IHtcbiAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykge1xuICAgICAgICAgIF90aGlzMi5sb2coXCJMb2FkZWQgc3RlZXJpbmcgbWFuaWZlc3Q6IFxcXCJcIiArIHVybCArIFwiXFxcIlwiKTtcbiAgICAgICAgICB2YXIgc3RlZXJpbmdEYXRhID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICBpZiAoc3RlZXJpbmdEYXRhLlZFUlNJT04gIT09IDEpIHtcbiAgICAgICAgICAgIF90aGlzMi5sb2coXCJTdGVlcmluZyBWRVJTSU9OIFwiICsgc3RlZXJpbmdEYXRhLlZFUlNJT04gKyBcIiBub3Qgc3VwcG9ydGVkIVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMyLnVwZGF0ZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBfdGhpczIudGltZVRvTG9hZCA9IHN0ZWVyaW5nRGF0YS5UVEw7XG4gICAgICAgICAgdmFyIHJlbG9hZFVyaSA9IHN0ZWVyaW5nRGF0YVsnUkVMT0FELVVSSSddLFxuICAgICAgICAgICAgcGF0aHdheUNsb25lcyA9IHN0ZWVyaW5nRGF0YVsnUEFUSFdBWS1DTE9ORVMnXSxcbiAgICAgICAgICAgIHBhdGh3YXlQcmlvcml0eSA9IHN0ZWVyaW5nRGF0YVsnUEFUSFdBWS1QUklPUklUWSddO1xuICAgICAgICAgIGlmIChyZWxvYWRVcmkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIF90aGlzMi51cmkgPSBuZXcgc2VsZi5VUkwocmVsb2FkVXJpLCB1cmwpLmhyZWY7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBfdGhpczIuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBfdGhpczIubG9nKFwiRmFpbGVkIHRvIHBhcnNlIFN0ZWVyaW5nIE1hbmlmZXN0IFJFTE9BRC1VUkk6IFwiICsgcmVsb2FkVXJpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpczIuc2NoZWR1bGVSZWZyZXNoKF90aGlzMi51cmkgfHwgY29udGV4dC51cmwpO1xuICAgICAgICAgIGlmIChwYXRod2F5Q2xvbmVzKSB7XG4gICAgICAgICAgICBfdGhpczIuY2xvbmVQYXRod2F5cyhwYXRod2F5Q2xvbmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxvYWRlZFN0ZWVyaW5nRGF0YSA9IHtcbiAgICAgICAgICAgIHN0ZWVyaW5nTWFuaWZlc3Q6IHN0ZWVyaW5nRGF0YSxcbiAgICAgICAgICAgIHVybDogdXJsLnRvU3RyaW5nKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIF90aGlzMi5obHMudHJpZ2dlcihFdmVudHMuU1RFRVJJTkdfTUFOSUZFU1RfTE9BREVELCBsb2FkZWRTdGVlcmluZ0RhdGEpO1xuICAgICAgICAgIGlmIChwYXRod2F5UHJpb3JpdHkpIHtcbiAgICAgICAgICAgIF90aGlzMi51cGRhdGVQYXRod2F5UHJpb3JpdHkocGF0aHdheVByaW9yaXR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykge1xuICAgICAgICAgIF90aGlzMi5sb2coXCJFcnJvciBsb2FkaW5nIHN0ZWVyaW5nIG1hbmlmZXN0OiBcIiArIGVycm9yLmNvZGUgKyBcIiBcIiArIGVycm9yLnRleHQgKyBcIiAoXCIgKyBjb250ZXh0LnVybCArIFwiKVwiKTtcbiAgICAgICAgICBfdGhpczIuc3RvcExvYWQoKTtcbiAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gNDEwKSB7XG4gICAgICAgICAgICBfdGhpczIuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMyLmxvZyhcIlN0ZWVyaW5nIG1hbmlmZXN0IFwiICsgY29udGV4dC51cmwgKyBcIiBubyBsb25nZXIgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdHRsID0gX3RoaXMyLnRpbWVUb0xvYWQgKiAxMDAwO1xuICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSA0MjkpIHtcbiAgICAgICAgICAgIHZhciBsb2FkZXIgPSBfdGhpczIubG9hZGVyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAobG9hZGVyID09IG51bGwgPyB2b2lkIDAgOiBsb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHZhciByZXRyeUFmdGVyID0gbG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKCdSZXRyeS1BZnRlcicpO1xuICAgICAgICAgICAgICBpZiAocmV0cnlBZnRlcikge1xuICAgICAgICAgICAgICAgIHR0bCA9IHBhcnNlRmxvYXQocmV0cnlBZnRlcikgKiAxMDAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpczIubG9nKFwiU3RlZXJpbmcgbWFuaWZlc3QgXCIgKyBjb250ZXh0LnVybCArIFwiIHJhdGUgbGltaXRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMyLnNjaGVkdWxlUmVmcmVzaChfdGhpczIudXJpIHx8IGNvbnRleHQudXJsLCB0dGwpO1xuICAgICAgICB9LFxuICAgICAgICBvblRpbWVvdXQ6IGZ1bmN0aW9uIG9uVGltZW91dChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICBfdGhpczIubG9nKFwiVGltZW91dCBsb2FkaW5nIHN0ZWVyaW5nIG1hbmlmZXN0IChcIiArIGNvbnRleHQudXJsICsgXCIpXCIpO1xuICAgICAgICAgIF90aGlzMi5zY2hlZHVsZVJlZnJlc2goX3RoaXMyLnVyaSB8fCBjb250ZXh0LnVybCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmxvZyhcIlJlcXVlc3Rpbmcgc3RlZXJpbmcgbWFuaWZlc3Q6IFwiICsgdXJsKTtcbiAgICAgIHRoaXMubG9hZGVyLmxvYWQoY29udGV4dCwgbG9hZGVyQ29uZmlnLCBjYWxsYmFja3MpO1xuICAgIH07XG4gICAgX3Byb3RvLnNjaGVkdWxlUmVmcmVzaCA9IGZ1bmN0aW9uIHNjaGVkdWxlUmVmcmVzaCh1cmksIHR0bE1zKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGlmICh0dGxNcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHR0bE1zID0gdGhpcy50aW1lVG9Mb2FkICogMTAwMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICB0aGlzLnJlbG9hZFRpbWVyID0gc2VsZi5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzMyRobHM7XG4gICAgICAgIHZhciBtZWRpYSA9IChfdGhpczMkaGxzID0gX3RoaXMzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzMyRobHMubWVkaWE7XG4gICAgICAgIGlmIChtZWRpYSAmJiAhbWVkaWEuZW5kZWQpIHtcbiAgICAgICAgICBfdGhpczMubG9hZFN0ZWVyaW5nTWFuaWZlc3QodXJpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMzLnNjaGVkdWxlUmVmcmVzaCh1cmksIF90aGlzMy50aW1lVG9Mb2FkICogMTAwMCk7XG4gICAgICB9LCB0dGxNcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjtcbiAgfSgpO1xuICBmdW5jdGlvbiBjbG9uZVJlbmRpdGlvbkdyb3Vwcyh0cmFja3MsIGdyb3VwQ2xvbmVNYXAsIHVyaVJlcGxhY2VtZW50LCBjbG9uZUlkKSB7XG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoZ3JvdXBDbG9uZU1hcCkuZm9yRWFjaChmdW5jdGlvbiAoYXVkaW9Hcm91cElkKSB7XG4gICAgICB2YXIgY2xvbmVkVHJhY2tzID0gdHJhY2tzLmZpbHRlcihmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrLmdyb3VwSWQgPT09IGF1ZGlvR3JvdXBJZDtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFyIGNsb25lZFRyYWNrID0gX2V4dGVuZHMoe30sIHRyYWNrKTtcbiAgICAgICAgY2xvbmVkVHJhY2suZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgY2xvbmVkVHJhY2suYXR0cnMgPSBuZXcgQXR0ckxpc3QoY2xvbmVkVHJhY2suYXR0cnMpO1xuICAgICAgICBjbG9uZWRUcmFjay51cmwgPSBjbG9uZWRUcmFjay5hdHRycy5VUkkgPSBwZXJmb3JtVXJpUmVwbGFjZW1lbnQodHJhY2sudXJsLCB0cmFjay5hdHRyc1snU1RBQkxFLVJFTkRJVElPTi1JRCddLCAnUEVSLVJFTkRJVElPTi1VUklTJywgdXJpUmVwbGFjZW1lbnQpO1xuICAgICAgICBjbG9uZWRUcmFjay5ncm91cElkID0gY2xvbmVkVHJhY2suYXR0cnNbJ0dST1VQLUlEJ10gPSBncm91cENsb25lTWFwW2F1ZGlvR3JvdXBJZF07XG4gICAgICAgIGNsb25lZFRyYWNrLmF0dHJzWydQQVRIV0FZLUlEJ10gPSBjbG9uZUlkO1xuICAgICAgICByZXR1cm4gY2xvbmVkVHJhY2s7XG4gICAgICB9KTtcbiAgICAgIHRyYWNrcy5wdXNoLmFwcGx5KHRyYWNrcywgY2xvbmVkVHJhY2tzKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBwZXJmb3JtVXJpUmVwbGFjZW1lbnQodXJpLCBzdGFibGVJZCwgcGVyT3B0aW9uS2V5LCB1cmlSZXBsYWNlbWVudCkge1xuICAgIHZhciBob3N0ID0gdXJpUmVwbGFjZW1lbnQuSE9TVCxcbiAgICAgIHBhcmFtcyA9IHVyaVJlcGxhY2VtZW50LlBBUkFNUyxcbiAgICAgIHBlck9wdGlvblVyaXMgPSB1cmlSZXBsYWNlbWVudFtwZXJPcHRpb25LZXldO1xuICAgIHZhciBwZXJWYXJpYW50VXJpO1xuICAgIGlmIChzdGFibGVJZCkge1xuICAgICAgcGVyVmFyaWFudFVyaSA9IHBlck9wdGlvblVyaXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBlck9wdGlvblVyaXNbc3RhYmxlSWRdO1xuICAgICAgaWYgKHBlclZhcmlhbnRVcmkpIHtcbiAgICAgICAgdXJpID0gcGVyVmFyaWFudFVyaTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVybCA9IG5ldyBzZWxmLlVSTCh1cmkpO1xuICAgIGlmIChob3N0ICYmICFwZXJWYXJpYW50VXJpKSB7XG4gICAgICB1cmwuaG9zdCA9IGhvc3Q7XG4gICAgfVxuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuc29ydCgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBwYXJhbXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLmhyZWY7XG4gIH1cblxuICB2YXIgQUdFX0hFQURFUl9MSU5FX1JFR0VYID0gL15hZ2U6XFxzKltcXGQuXStcXHMqJC9pbTtcbiAgdmFyIFhockxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWGhyTG9hZGVyKGNvbmZpZykge1xuICAgICAgdGhpcy54aHJTZXR1cCA9IHZvaWQgMDtcbiAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICB0aGlzLnJldHJ5VGltZW91dCA9IHZvaWQgMDtcbiAgICAgIHRoaXMucmV0cnlEZWxheSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgICB0aGlzLnN0YXRzID0gdm9pZCAwO1xuICAgICAgdGhpcy54aHJTZXR1cCA9IGNvbmZpZyA/IGNvbmZpZy54aHJTZXR1cCB8fCBudWxsIDogbnVsbDtcbiAgICAgIHRoaXMuc3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG4gICAgICB0aGlzLnJldHJ5RGVsYXkgPSAwO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gWGhyTG9hZGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLnhoclNldHVwID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5hYm9ydEludGVybmFsID0gZnVuY3Rpb24gYWJvcnRJbnRlcm5hbCgpIHtcbiAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcjtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgbG9hZGVyLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICBpZiAobG9hZGVyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIHZhciBfdGhpcyRjYWxsYmFja3M7XG4gICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgIGlmICgoX3RoaXMkY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MpICE9IG51bGwgJiYgX3RoaXMkY2FsbGJhY2tzLm9uQWJvcnQpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMubG9hZGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5sb2FkID0gZnVuY3Rpb24gbG9hZChjb250ZXh0LCBjb25maWcsIGNhbGxiYWNrcykge1xuICAgICAgaWYgKHRoaXMuc3RhdHMubG9hZGluZy5zdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWRlciBjYW4gb25seSBiZSB1c2VkIG9uY2UuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICB0aGlzLmxvYWRJbnRlcm5hbCgpO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRJbnRlcm5hbCA9IGZ1bmN0aW9uIGxvYWRJbnRlcm5hbCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG4gICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICBpZiAoIWNvbmZpZyB8fCAhY29udGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgeGhyID0gdGhpcy5sb2FkZXIgPSBuZXcgc2VsZi5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSAwO1xuICAgICAgc3RhdHMubG9hZGVkID0gMDtcbiAgICAgIHN0YXRzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICAgIHZhciB4aHJTZXR1cCA9IHRoaXMueGhyU2V0dXA7XG4gICAgICBpZiAoeGhyU2V0dXApIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzLmxvYWRlciAhPT0geGhyIHx8IF90aGlzLnN0YXRzLmFib3J0ZWQpIHJldHVybjtcbiAgICAgICAgICByZXR1cm4geGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGlmIChfdGhpcy5sb2FkZXIgIT09IHhociB8fCBfdGhpcy5zdGF0cy5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4geGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5sb2FkZXIgIT09IHhociB8fCBfdGhpcy5zdGF0cy5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgICAgX3RoaXMub3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBJRTExIHRocm93cyBhbiBleGNlcHRpb24gb24geGhyLm9wZW4gaWYgYXR0ZW1wdGluZyB0byBhY2Nlc3MgYW4gSFRUUCByZXNvdXJjZSBvdmVyIEhUVFBTXG4gICAgICAgICAgX3RoaXMuY2FsbGJhY2tzLm9uRXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogeGhyLnN0YXR1cyxcbiAgICAgICAgICAgIHRleHQ6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9LCBjb250ZXh0LCB4aHIsIHN0YXRzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcGVuQW5kU2VuZFhocih4aHIsIGNvbnRleHQsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub3BlbkFuZFNlbmRYaHIgPSBmdW5jdGlvbiBvcGVuQW5kU2VuZFhocih4aHIsIGNvbnRleHQsIGNvbmZpZykge1xuICAgICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhlYWRlcnMgPSBjb250ZXh0LmhlYWRlcnM7XG4gICAgICB2YXIgX2NvbmZpZyRsb2FkUG9saWN5ID0gY29uZmlnLmxvYWRQb2xpY3ksXG4gICAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zID0gX2NvbmZpZyRsb2FkUG9saWN5Lm1heFRpbWVUb0ZpcnN0Qnl0ZU1zLFxuICAgICAgICBtYXhMb2FkVGltZU1zID0gX2NvbmZpZyRsb2FkUG9saWN5Lm1heExvYWRUaW1lTXM7XG4gICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICBmb3IgKHZhciBoZWFkZXIgaW4gaGVhZGVycykge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyAoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcbiAgICAgIH1cbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLnJlYWR5c3RhdGVjaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKTtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBjb250ZXh0LnJlc3BvbnNlVHlwZTtcbiAgICAgIC8vIHNldHVwIHRpbWVvdXQgYmVmb3JlIHdlIHBlcmZvcm0gcmVxdWVzdFxuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICBjb25maWcudGltZW91dCA9IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zICYmIGlzRmluaXRlTnVtYmVyKG1heFRpbWVUb0ZpcnN0Qnl0ZU1zKSA/IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zIDogbWF4TG9hZFRpbWVNcztcbiAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCBjb25maWcudGltZW91dCk7XG4gICAgICB4aHIuc2VuZCgpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG4gICAgICAgIHhociA9IHRoaXMubG9hZGVyLFxuICAgICAgICBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgICBpZiAoIWNvbnRleHQgfHwgIXhocikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAvLyBkb24ndCBwcm9jZWVkIGlmIHhociBoYXMgYmVlbiBhYm9ydGVkXG4gICAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vID49IEhFQURFUlNfUkVDRUlWRURcbiAgICAgIGlmIChyZWFkeVN0YXRlID49IDIpIHtcbiAgICAgICAgaWYgKHN0YXRzLmxvYWRpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgICAgICAgLy8gcmVhZHlTdGF0ZSA+PSAyIEFORCByZWFkeVN0YXRlICE9PTQgKHJlYWR5U3RhdGUgPSBIRUFERVJTX1JFQ0VJVkVEIHx8IExPQURJTkcpIHJlYXJtIHRpbWVvdXQgYXMgeGhyIG5vdCBmaW5pc2hlZCB5ZXRcbiAgICAgICAgICBpZiAoY29uZmlnLnRpbWVvdXQgIT09IGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXMpIHtcbiAgICAgICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICAgICAgY29uZmlnLnRpbWVvdXQgPSBjb25maWcubG9hZFBvbGljeS5tYXhMb2FkVGltZU1zO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXMgLSAoc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICB4aHIub25wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgdmFyIF9zdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgICAgIC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcbiAgICAgICAgICB2YXIgdXNlUmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUeXBlICE9PSAndGV4dCc7XG4gICAgICAgICAgaWYgKF9zdGF0dXMgPj0gMjAwICYmIF9zdGF0dXMgPCAzMDAgJiYgKHVzZVJlc3BvbnNlICYmIHhoci5yZXNwb25zZSB8fCB4aHIucmVzcG9uc2VUZXh0ICE9PSBudWxsKSkge1xuICAgICAgICAgICAgc3RhdHMubG9hZGluZy5lbmQgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLmZpcnN0KTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdXNlUmVzcG9uc2UgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgdmFyIGxlbiA9IHhoci5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicgPyBkYXRhLmJ5dGVMZW5ndGggOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gbGVuO1xuICAgICAgICAgICAgc3RhdHMuYndFc3RpbWF0ZSA9IHN0YXRzLnRvdGFsICogODAwMCAvIChzdGF0cy5sb2FkaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb25Qcm9ncmVzcyA9IHRoaXMuY2FsbGJhY2tzLm9uUHJvZ3Jlc3M7XG4gICAgICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBkYXRhLCB4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgIHVybDogeGhyLnJlc3BvbnNlVVJMLFxuICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICBjb2RlOiBfc3RhdHVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgeGhyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJldHJ5Q29uZmlnID0gY29uZmlnLmxvYWRQb2xpY3kuZXJyb3JSZXRyeTtcbiAgICAgICAgICAgIHZhciByZXRyeUNvdW50ID0gc3RhdHMucmV0cnk7XG4gICAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgICAgdmFyIF9yZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgdXJsOiBjb250ZXh0LnVybCxcbiAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBjb2RlOiBfc3RhdHVzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCBmYWxzZSwgX3Jlc3BvbnNlKSkge1xuICAgICAgICAgICAgICB0aGlzLnJldHJ5KHJldHJ5Q29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihfc3RhdHVzICsgXCIgd2hpbGUgbG9hZGluZyBcIiArIGNvbnRleHQudXJsKTtcbiAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogX3N0YXR1cyxcbiAgICAgICAgICAgICAgICB0ZXh0OiB4aHIuc3RhdHVzVGV4dFxuICAgICAgICAgICAgICB9LCBjb250ZXh0LCB4aHIsIHN0YXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5sb2FkdGltZW91dCA9IGZ1bmN0aW9uIGxvYWR0aW1lb3V0KCkge1xuICAgICAgaWYgKCF0aGlzLmNvbmZpZykgcmV0dXJuO1xuICAgICAgdmFyIHJldHJ5Q29uZmlnID0gdGhpcy5jb25maWcubG9hZFBvbGljeS50aW1lb3V0UmV0cnk7XG4gICAgICB2YXIgcmV0cnlDb3VudCA9IHRoaXMuc3RhdHMucmV0cnk7XG4gICAgICBpZiAoc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIHJldHJ5Q291bnQsIHRydWUpKSB7XG4gICAgICAgIHRoaXMucmV0cnkocmV0cnlDb25maWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF90aGlzJGNvbnRleHQ7XG4gICAgICAgIGxvZ2dlci53YXJuKFwidGltZW91dCB3aGlsZSBsb2FkaW5nIFwiICsgKChfdGhpcyRjb250ZXh0ID0gdGhpcy5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY29udGV4dC51cmwpKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzO1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICAgICAgY2FsbGJhY2tzLm9uVGltZW91dCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMubG9hZGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnJldHJ5ID0gZnVuY3Rpb24gcmV0cnkocmV0cnlDb25maWcpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgICB0aGlzLnJldHJ5RGVsYXkgPSBnZXRSZXRyeURlbGF5KHJldHJ5Q29uZmlnLCBzdGF0cy5yZXRyeSk7XG4gICAgICBzdGF0cy5yZXRyeSsrO1xuICAgICAgbG9nZ2VyLndhcm4oKHN0YXR1cyA/ICdIVFRQIFN0YXR1cyAnICsgc3RhdHVzIDogJ1RpbWVvdXQnKSArIFwiIHdoaWxlIGxvYWRpbmcgXCIgKyAoY29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC51cmwpICsgXCIsIHJldHJ5aW5nIFwiICsgc3RhdHMucmV0cnkgKyBcIi9cIiArIHJldHJ5Q29uZmlnLm1heE51bVJldHJ5ICsgXCIgaW4gXCIgKyB0aGlzLnJldHJ5RGVsYXkgKyBcIm1zXCIpO1xuICAgICAgLy8gYWJvcnQgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlXG4gICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICAgIC8vIHNjaGVkdWxlIHJldHJ5XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgICB0aGlzLnJldHJ5VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRwcm9ncmVzcyA9IGZ1bmN0aW9uIGxvYWRwcm9ncmVzcyhldmVudCkge1xuICAgICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICAgIHN0YXRzLmxvYWRlZCA9IGV2ZW50LmxvYWRlZDtcbiAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0Q2FjaGVBZ2UgPSBmdW5jdGlvbiBnZXRDYWNoZUFnZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgaWYgKHRoaXMubG9hZGVyICYmIEFHRV9IRUFERVJfTElORV9SRUdFWC50ZXN0KHRoaXMubG9hZGVyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgICB2YXIgYWdlSGVhZGVyID0gdGhpcy5sb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2FnZScpO1xuICAgICAgICByZXN1bHQgPSBhZ2VIZWFkZXIgPyBwYXJzZUZsb2F0KGFnZUhlYWRlcikgOiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIGdldFJlc3BvbnNlSGVhZGVyKG5hbWUpIHtcbiAgICAgIGlmICh0aGlzLmxvYWRlciAmJiBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZSArIFwiOlxcXFxzKltcXFxcZC5dK1xcXFxzKiRcIiwgJ2ltJykudGVzdCh0aGlzLmxvYWRlci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKG5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gWGhyTG9hZGVyO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gZmV0Y2hTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzZWxmLmZldGNoICYmIHNlbGYuQWJvcnRDb250cm9sbGVyICYmIHNlbGYuUmVhZGFibGVTdHJlYW0gJiYgc2VsZi5SZXF1ZXN0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgc2VsZi5SZWFkYWJsZVN0cmVhbSh7fSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBub29wICovXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgQllURVJBTkdFID0gLyhcXGQrKS0oXFxkKylcXC8oXFxkKykvO1xuICB2YXIgRmV0Y2hMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZldGNoTG9hZGVyKGNvbmZpZyAvKiBIbHNDb25maWcgKi8pIHtcbiAgICAgIHRoaXMuZmV0Y2hTZXR1cCA9IHZvaWQgMDtcbiAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICB0aGlzLnJlcXVlc3QgPSBudWxsO1xuICAgICAgdGhpcy5yZXNwb25zZSA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgICAgdGhpcy5zdGF0cyA9IHZvaWQgMDtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICAgIHRoaXMuZmV0Y2hTZXR1cCA9IGNvbmZpZy5mZXRjaFNldHVwIHx8IGdldFJlcXVlc3Q7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgc2VsZi5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHRoaXMuc3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBGZXRjaExvYWRlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5sb2FkZXIgPSB0aGlzLmNhbGxiYWNrcyA9IHRoaXMuY29udGV4dCA9IHRoaXMuY29uZmlnID0gdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgdGhpcy5yZXNwb25zZSA9IG51bGw7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLmZldGNoU2V0dXAgPSB0aGlzLmNvbnRyb2xsZXIgPSB0aGlzLnN0YXRzID0gbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5hYm9ydEludGVybmFsID0gZnVuY3Rpb24gYWJvcnRJbnRlcm5hbCgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRyb2xsZXIgJiYgIXRoaXMuc3RhdHMubG9hZGluZy5lbmQpIHtcbiAgICAgICAgdGhpcy5zdGF0cy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIHZhciBfdGhpcyRjYWxsYmFja3M7XG4gICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgIGlmICgoX3RoaXMkY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MpICE9IG51bGwgJiYgX3RoaXMkY2FsbGJhY2tzLm9uQWJvcnQpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMucmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICAgIGlmIChzdGF0cy5sb2FkaW5nLnN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS4nKTtcbiAgICAgIH1cbiAgICAgIHN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdmFyIGluaXRQYXJhbXMgPSBnZXRSZXF1ZXN0UGFyYW1ldGVycyhjb250ZXh0LCB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIHZhciBvblByb2dyZXNzID0gY2FsbGJhY2tzLm9uUHJvZ3Jlc3M7XG4gICAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInO1xuICAgICAgdmFyIExFTkdUSCA9IGlzQXJyYXlCdWZmZXIgPyAnYnl0ZUxlbmd0aCcgOiAnbGVuZ3RoJztcbiAgICAgIHZhciBfY29uZmlnJGxvYWRQb2xpY3kgPSBjb25maWcubG9hZFBvbGljeSxcbiAgICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXMgPSBfY29uZmlnJGxvYWRQb2xpY3kubWF4VGltZVRvRmlyc3RCeXRlTXMsXG4gICAgICAgIG1heExvYWRUaW1lTXMgPSBfY29uZmlnJGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5mZXRjaFNldHVwKGNvbnRleHQsIGluaXRQYXJhbXMpO1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICBjb25maWcudGltZW91dCA9IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zICYmIGlzRmluaXRlTnVtYmVyKG1heFRpbWVUb0ZpcnN0Qnl0ZU1zKSA/IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zIDogbWF4TG9hZFRpbWVNcztcbiAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICAgIGNhbGxiYWNrcy5vblRpbWVvdXQoc3RhdHMsIGNvbnRleHQsIF90aGlzLnJlc3BvbnNlKTtcbiAgICAgIH0sIGNvbmZpZy50aW1lb3V0KTtcbiAgICAgIHNlbGYuZmV0Y2godGhpcy5yZXF1ZXN0KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBfdGhpcy5yZXNwb25zZSA9IF90aGlzLmxvYWRlciA9IHJlc3BvbnNlO1xuICAgICAgICB2YXIgZmlyc3QgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLnN0YXJ0KTtcbiAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQoX3RoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICBjb25maWcudGltZW91dCA9IG1heExvYWRUaW1lTXM7XG4gICAgICAgIF90aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICAgICAgY2FsbGJhY2tzLm9uVGltZW91dChzdGF0cywgY29udGV4dCwgX3RoaXMucmVzcG9uc2UpO1xuICAgICAgICB9LCBtYXhMb2FkVGltZU1zIC0gKGZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCkpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdmFyIHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0dXNUZXh0O1xuICAgICAgICAgIHRocm93IG5ldyBGZXRjaEVycm9yKHN0YXR1c1RleHQgfHwgJ2ZldGNoLCBiYWQgbmV0d29yayByZXNwb25zZScsIHN0YXR1cywgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSBmaXJzdDtcbiAgICAgICAgc3RhdHMudG90YWwgPSBnZXRDb250ZW50TGVuZ3RoKHJlc3BvbnNlLmhlYWRlcnMpIHx8IHN0YXRzLnRvdGFsO1xuICAgICAgICBpZiAob25Qcm9ncmVzcyAmJiBpc0Zpbml0ZU51bWJlcihjb25maWcuaGlnaFdhdGVyTWFyaykpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMubG9hZFByb2dyZXNzaXZlbHkocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBjb25maWcuaGlnaFdhdGVyTWFyaywgb25Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdqc29uJykge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlRGF0YSkge1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSBfdGhpcy5yZXNwb25zZTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbG9hZGVyIGRlc3Ryb3llZCcpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KF90aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgc3RhdHMubG9hZGluZy5lbmQgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLmZpcnN0KTtcbiAgICAgICAgdmFyIHRvdGFsID0gcmVzcG9uc2VEYXRhW0xFTkdUSF07XG4gICAgICAgIGlmICh0b3RhbCkge1xuICAgICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvYWRlclJlc3BvbnNlID0ge1xuICAgICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgICBjb2RlOiByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgIWlzRmluaXRlTnVtYmVyKGNvbmZpZy5oaWdoV2F0ZXJNYXJrKSkge1xuICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIHJlc3BvbnNlRGF0YSwgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrcy5vblN1Y2Nlc3MobG9hZGVyUmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCByZXNwb25zZSk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQoX3RoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDT1JTIGVycm9ycyByZXN1bHQgaW4gYW4gdW5kZWZpbmVkIGNvZGUuIFNldCBpdCB0byAwIGhlcmUgdG8gYWxpZ24gd2l0aCBYSFIncyBiZWhhdmlvclxuICAgICAgICAvLyB3aGVuIGRlc3Ryb3lpbmcsICdlcnJvcicgaXRzZWxmIGNhbiBiZSB1bmRlZmluZWRcbiAgICAgICAgdmFyIGNvZGUgPSAhZXJyb3IgPyAwIDogZXJyb3IuY29kZSB8fCAwO1xuICAgICAgICB2YXIgdGV4dCA9ICFlcnJvciA/IG51bGwgOiBlcnJvci5tZXNzYWdlO1xuICAgICAgICBjYWxsYmFja3Mub25FcnJvcih7XG4gICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH0sIGNvbnRleHQsIGVycm9yID8gZXJyb3IuZGV0YWlscyA6IG51bGwsIHN0YXRzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmdldENhY2hlQWdlID0gZnVuY3Rpb24gZ2V0Q2FjaGVBZ2UoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBhZ2VIZWFkZXIgPSB0aGlzLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdhZ2UnKTtcbiAgICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbiBnZXRSZXNwb25zZUhlYWRlcihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNwb25zZSA/IHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQobmFtZSkgOiBudWxsO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRQcm9ncmVzc2l2ZWx5ID0gZnVuY3Rpb24gbG9hZFByb2dyZXNzaXZlbHkocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBoaWdoV2F0ZXJNYXJrLCBvblByb2dyZXNzKSB7XG4gICAgICBpZiAoaGlnaFdhdGVyTWFyayA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGhpZ2hXYXRlck1hcmsgPSAwO1xuICAgICAgfVxuICAgICAgdmFyIGNodW5rQ2FjaGUgPSBuZXcgQ2h1bmtDYWNoZSgpO1xuICAgICAgdmFyIHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICB2YXIgcHVtcCA9IGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmtDYWNoZS5kYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGNodW5rQ2FjaGUuZmx1c2goKSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2h1bmsgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgIHZhciBsZW4gPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgc3RhdHMubG9hZGVkICs9IGxlbjtcbiAgICAgICAgICBpZiAobGVuIDwgaGlnaFdhdGVyTWFyayB8fCBjaHVua0NhY2hlLmRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGNodW5rIGlzIHRvbyBzbWFsbCB0byB0byBiZSBlbWl0dGVkIG9yIHRoZSBjYWNoZSBhbHJlYWR5IGhhcyBkYXRhXG4gICAgICAgICAgICAvLyBQdXNoIGl0IHRvIHRoZSBjYWNoZVxuICAgICAgICAgICAgY2h1bmtDYWNoZS5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIGlmIChjaHVua0NhY2hlLmRhdGFMZW5ndGggPj0gaGlnaFdhdGVyTWFyaykge1xuICAgICAgICAgICAgICAvLyBmbHVzaCBpbiBvcmRlciB0byBqb2luIHRoZSB0eXBlZCBhcnJheXNcbiAgICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmtDYWNoZS5mbHVzaCgpLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm90aGluZyBjYWNoZWQgYWxyZWFkeSwgYW5kIHRoZSBjaGFjaGUgaXMgbGFyZ2UgZW5vdWdoXG4gICAgICAgICAgICAvLyBqdXN0IGVtaXQgdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVuaywgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLyogYWJvcnRlZCAqL1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcHVtcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIEZldGNoTG9hZGVyO1xuICB9KCk7XG4gIGZ1bmN0aW9uIGdldFJlcXVlc3RQYXJhbWV0ZXJzKGNvbnRleHQsIHNpZ25hbCkge1xuICAgIHZhciBpbml0UGFyYW1zID0ge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgc2lnbmFsOiBzaWduYWwsXG4gICAgICBoZWFkZXJzOiBuZXcgc2VsZi5IZWFkZXJzKF9leHRlbmRzKHt9LCBjb250ZXh0LmhlYWRlcnMpKVxuICAgIH07XG4gICAgaWYgKGNvbnRleHQucmFuZ2VFbmQpIHtcbiAgICAgIGluaXRQYXJhbXMuaGVhZGVycy5zZXQoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyBTdHJpbmcoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRQYXJhbXM7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Qnl0ZVJhbmdlTGVuZ3RoKGJ5dGVSYW5nZUhlYWRlcikge1xuICAgIHZhciByZXN1bHQgPSBCWVRFUkFOR0UuZXhlYyhieXRlUmFuZ2VIZWFkZXIpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChyZXN1bHRbMl0pIC0gcGFyc2VJbnQocmVzdWx0WzFdKSArIDE7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldENvbnRlbnRMZW5ndGgoaGVhZGVycykge1xuICAgIHZhciBjb250ZW50UmFuZ2UgPSBoZWFkZXJzLmdldCgnQ29udGVudC1SYW5nZScpO1xuICAgIGlmIChjb250ZW50UmFuZ2UpIHtcbiAgICAgIHZhciBieXRlUmFuZ2VMZW5ndGggPSBnZXRCeXRlUmFuZ2VMZW5ndGgoY29udGVudFJhbmdlKTtcbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihieXRlUmFuZ2VMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBieXRlUmFuZ2VMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjb250ZW50TGVuZ3RoID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChjb250ZW50TGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmVxdWVzdChjb250ZXh0LCBpbml0UGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBzZWxmLlJlcXVlc3QoY29udGV4dC51cmwsIGluaXRQYXJhbXMpO1xuICB9XG4gIHZhciBGZXRjaEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgICBfaW5oZXJpdHNMb29zZShGZXRjaEVycm9yLCBfRXJyb3IpO1xuICAgIGZ1bmN0aW9uIEZldGNoRXJyb3IobWVzc2FnZSwgY29kZSwgZGV0YWlscykge1xuICAgICAgdmFyIF90aGlzMjtcbiAgICAgIF90aGlzMiA9IF9FcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICBfdGhpczIuY29kZSA9IHZvaWQgMDtcbiAgICAgIF90aGlzMi5kZXRhaWxzID0gdm9pZCAwO1xuICAgICAgX3RoaXMyLmNvZGUgPSBjb2RlO1xuICAgICAgX3RoaXMyLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgcmV0dXJuIF90aGlzMjtcbiAgICB9XG4gICAgcmV0dXJuIEZldGNoRXJyb3I7XG4gIH0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbiAgdmFyIFdISVRFU1BBQ0VfQ0hBUiA9IC9cXHMvO1xuICB2YXIgQ3VlcyA9IHtcbiAgICBuZXdDdWU6IGZ1bmN0aW9uIG5ld0N1ZSh0cmFjaywgc3RhcnRUaW1lLCBlbmRUaW1lLCBjYXB0aW9uU2NyZWVuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgcm93O1xuICAgICAgLy8gdGhlIHR5cGUgZGF0YSBzdGF0ZXMgdGhpcyBpcyBWVFRDdWUsIGJ1dCBpdCBjYW4gcG90ZW50aWFsbHkgYmUgYSBUZXh0VHJhY2tDdWUgb24gb2xkIGJyb3dzZXJzXG4gICAgICB2YXIgY3VlO1xuICAgICAgdmFyIGluZGVudGluZztcbiAgICAgIHZhciBpbmRlbnQ7XG4gICAgICB2YXIgdGV4dDtcbiAgICAgIHZhciBDdWUgPSBzZWxmLlZUVEN1ZSB8fCBzZWxmLlRleHRUcmFja0N1ZTtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgY2FwdGlvblNjcmVlbi5yb3dzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHJvdyA9IGNhcHRpb25TY3JlZW4ucm93c1tyXTtcbiAgICAgICAgaW5kZW50aW5nID0gdHJ1ZTtcbiAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICBpZiAoIXJvdy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICB2YXIgX3RyYWNrJGN1ZXM7XG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCByb3cuY2hhcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGlmIChXSElURVNQQUNFX0NIQVIudGVzdChyb3cuY2hhcnNbY10udWNoYXIpICYmIGluZGVudGluZykge1xuICAgICAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRleHQgKz0gcm93LmNoYXJzW2NdLnVjaGFyO1xuICAgICAgICAgICAgICBpbmRlbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVG8gYmUgdXNlZCBmb3IgY2xlYW5pbmctdXAgb3JwaGFuZWQgcm9sbC11cCBjYXB0aW9uc1xuICAgICAgICAgIHJvdy5jdWVTdGFydFRpbWUgPSBzdGFydFRpbWU7XG5cbiAgICAgICAgICAvLyBHaXZlIGEgc2xpZ2h0IGJ1bXAgdG8gdGhlIGVuZFRpbWUgaWYgaXQncyBlcXVhbCB0byBzdGFydFRpbWUgdG8gYXZvaWQgYSBTeW50YXhFcnJvciBpbiBJRVxuICAgICAgICAgIGlmIChzdGFydFRpbWUgPT09IGVuZFRpbWUpIHtcbiAgICAgICAgICAgIGVuZFRpbWUgKz0gMC4wMDAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5kZW50ID49IDE2KSB7XG4gICAgICAgICAgICBpbmRlbnQtLTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjdWVUZXh0ID0gZml4TGluZUJyZWFrcyh0ZXh0LnRyaW0oKSk7XG4gICAgICAgICAgdmFyIGlkID0gZ2VuZXJhdGVDdWVJZChzdGFydFRpbWUsIGVuZFRpbWUsIGN1ZVRleHQpO1xuXG4gICAgICAgICAgLy8gSWYgdGhpcyBjdWUgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHRyYWNrIGRvIG5vdCBwdXNoIGl0XG4gICAgICAgICAgaWYgKCEodHJhY2sgIT0gbnVsbCAmJiAoX3RyYWNrJGN1ZXMgPSB0cmFjay5jdWVzKSAhPSBudWxsICYmIF90cmFjayRjdWVzLmdldEN1ZUJ5SWQoaWQpKSkge1xuICAgICAgICAgICAgY3VlID0gbmV3IEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIGN1ZVRleHQpO1xuICAgICAgICAgICAgY3VlLmlkID0gaWQ7XG4gICAgICAgICAgICBjdWUubGluZSA9IHIgKyAxO1xuICAgICAgICAgICAgY3VlLmFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgLy8gQ2xhbXAgdGhlIHBvc2l0aW9uIGJldHdlZW4gMTAgYW5kIDgwIHBlcmNlbnQgKENFQS02MDggUEFDIGluZGVudCBjb2RlKVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kdmNzLnczLm9yZy9oZy90ZXh0LXRyYWNrcy9yYXctZmlsZS9kZWZhdWx0LzYwOHRvVlRULzYwOHRvVlRULmh0bWwjcG9zaXRpb25pbmctaW4tY2VhLTYwOFxuICAgICAgICAgICAgLy8gRmlyZWZveCB0aHJvd3MgYW4gZXhjZXB0aW9uIGFuZCBjYXB0aW9ucyBicmVhayB3aXRoIG91dCBvZiBib3VuZHMgMC0xMDAgdmFsdWVzXG4gICAgICAgICAgICBjdWUucG9zaXRpb24gPSAxMCArIE1hdGgubWluKDgwLCBNYXRoLmZsb29yKGluZGVudCAqIDggLyAzMikgKiAxMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRyYWNrICYmIHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgLy8gU29ydCBib3R0b20gY3VlcyBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgdGhleSByZW5kZXIgaW4gbGluZSBvcmRlciB3aGVuIG92ZXJsYXBwaW5nIGluIENocm9tZVxuICAgICAgICByZXN1bHQuc29ydChmdW5jdGlvbiAoY3VlQSwgY3VlQikge1xuICAgICAgICAgIGlmIChjdWVBLmxpbmUgPT09ICdhdXRvJyB8fCBjdWVCLmxpbmUgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdWVBLmxpbmUgPiA4ICYmIGN1ZUIubGluZSA+IDgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdWVCLmxpbmUgLSBjdWVBLmxpbmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjdWVBLmxpbmUgLSBjdWVCLmxpbmU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAoY3VlKSB7XG4gICAgICAgICAgcmV0dXJuIGFkZEN1ZVRvVHJhY2sodHJhY2ssIGN1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBmcmFnTG9hZFBvbGljeS5kZWZhdWx0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgbWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQgYW5kIHBsYXlsaXN0TG9hZFBvbGljeS5kZWZhdWx0XG4gICAqL1xuXG4gIHZhciBkZWZhdWx0TG9hZFBvbGljeSA9IHtcbiAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogODAwMCxcbiAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICB0aW1lb3V0UmV0cnk6IG51bGwsXG4gICAgZXJyb3JSZXRyeTogbnVsbFxuICB9O1xuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqIElmIHBvc3NpYmxlLCBrZWVwIGhsc0RlZmF1bHRDb25maWcgc2hhbGxvd1xuICAgKiBJdCBpcyBjbG9uZWQgd2hlbmV2ZXIgYSBuZXcgSGxzIGluc3RhbmNlIGlzIGNyZWF0ZWQsIGJ5IGtlZXBpbmcgdGhlIGNvbmZpZ1xuICAgKiBzaGFsbG93IHRoZSBwcm9wZXJ0aWVzIGFyZSBjbG9uZWQsIGFuZCB3ZSBkb24ndCBlbmQgdXAgbWFuaXB1bGF0aW5nIHRoZSBkZWZhdWx0XG4gICAqL1xuICB2YXIgaGxzRGVmYXVsdENvbmZpZyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICBhdXRvU3RhcnRMb2FkOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICBzdGFydFBvc2l0aW9uOiAtMSxcbiAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgZGVmYXVsdEF1ZGlvQ29kZWM6IHVuZGVmaW5lZCxcbiAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgZGVidWc6IGZhbHNlLFxuICAgIC8vIHVzZWQgYnkgbG9nZ2VyXG4gICAgY2FwTGV2ZWxPbkZQU0Ryb3A6IGZhbHNlLFxuICAgIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgICBjYXBMZXZlbFRvUGxheWVyU2l6ZTogZmFsc2UsXG4gICAgLy8gdXNlZCBieSBjYXAtbGV2ZWwtY29udHJvbGxlclxuICAgIGlnbm9yZURldmljZVBpeGVsUmF0aW86IGZhbHNlLFxuICAgIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgICBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2U6IHRydWUsXG4gICAgaW5pdGlhbExpdmVNYW5pZmVzdFNpemU6IDEsXG4gICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgIG1heEJ1ZmZlckxlbmd0aDogMzAsXG4gICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgIGJhY2tCdWZmZXJMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgICBmcm9udEJ1ZmZlckZsdXNoVGhyZXNob2xkOiBJbmZpbml0eSxcbiAgICBtYXhCdWZmZXJTaXplOiA2MCAqIDEwMDAgKiAxMDAwLFxuICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICBtYXhCdWZmZXJIb2xlOiAwLjEsXG4gICAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICAgIGhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMixcbiAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgbnVkZ2VPZmZzZXQ6IDAuMSxcbiAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgbnVkZ2VNYXhSZXRyeTogMyxcbiAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogMC4yNSxcbiAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50OiAzLFxuICAgIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gICAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50OiBJbmZpbml0eSxcbiAgICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICAgIGxpdmVTeW5jRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICAgIGxpdmVNYXhMYXRlbmN5RHVyYXRpb246IHVuZGVmaW5lZCxcbiAgICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICAgIG1heExpdmVTeW5jUGxheWJhY2tSYXRlOiAxLFxuICAgIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gICAgbGl2ZUR1cmF0aW9uSW5maW5pdHk6IGZhbHNlLFxuICAgIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2UgYmFja0J1ZmZlckxlbmd0aFxuICAgICAqL1xuICAgIGxpdmVCYWNrQnVmZmVyTGVuZ3RoOiBudWxsLFxuICAgIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgICBtYXhNYXhCdWZmZXJMZW5ndGg6IDYwMCxcbiAgICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gICAgZW5hYmxlV29ya2VyOiB0cnVlLFxuICAgIC8vIHVzZWQgYnkgdHJhbnNtdXhlclxuICAgIHdvcmtlclBhdGg6IG51bGwsXG4gICAgLy8gdXNlZCBieSB0cmFuc211eGVyXG4gICAgZW5hYmxlU29mdHdhcmVBRVM6IHRydWUsXG4gICAgLy8gdXNlZCBieSBkZWNyeXB0ZXJcbiAgICBzdGFydExldmVsOiB1bmRlZmluZWQsXG4gICAgLy8gdXNlZCBieSBsZXZlbC1jb250cm9sbGVyXG4gICAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLFxuICAgIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgICBmcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZDogNTAwMCxcbiAgICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gICAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IDAuMixcbiAgICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gICAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMyxcbiAgICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gICAgbG9hZGVyOiBYaHJMb2FkZXIsXG4gICAgLy8gbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgICBmTG9hZGVyOiB1bmRlZmluZWQsXG4gICAgLy8gdXNlZCBieSBmcmFnbWVudC1sb2FkZXJcbiAgICBwTG9hZGVyOiB1bmRlZmluZWQsXG4gICAgLy8gdXNlZCBieSBwbGF5bGlzdC1sb2FkZXJcbiAgICB4aHJTZXR1cDogdW5kZWZpbmVkLFxuICAgIC8vIHVzZWQgYnkgeGhyLWxvYWRlclxuICAgIGxpY2Vuc2VYaHJTZXR1cDogdW5kZWZpbmVkLFxuICAgIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgICBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjazogdW5kZWZpbmVkLFxuICAgIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgICBhYnJDb250cm9sbGVyOiBBYnJDb250cm9sbGVyLFxuICAgIGJ1ZmZlckNvbnRyb2xsZXI6IEJ1ZmZlckNvbnRyb2xsZXIsXG4gICAgY2FwTGV2ZWxDb250cm9sbGVyOiBDYXBMZXZlbENvbnRyb2xsZXIsXG4gICAgZXJyb3JDb250cm9sbGVyOiBFcnJvckNvbnRyb2xsZXIsXG4gICAgZnBzQ29udHJvbGxlcjogRlBTQ29udHJvbGxlcixcbiAgICBzdHJldGNoU2hvcnRWaWRlb1RyYWNrOiBmYWxzZSxcbiAgICAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gICAgbWF4QXVkaW9GcmFtZXNEcmlmdDogMSxcbiAgICAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gICAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogdHJ1ZSxcbiAgICAvLyB1c2VkIGJ5IHRzLWRlbXV4ZXJcbiAgICBhYnJFd21hRmFzdExpdmU6IDMsXG4gICAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgIGFickV3bWFTbG93TGl2ZTogOSxcbiAgICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gICAgYWJyRXdtYUZhc3RWb0Q6IDMsXG4gICAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgIGFickV3bWFTbG93Vm9EOiA5LFxuICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiA1ZTUsXG4gICAgLy8gNTAwIGticHMgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICBhYnJFd21hRGVmYXVsdEVzdGltYXRlTWF4OiA1ZTYsXG4gICAgLy8gNSBtYnBzXG4gICAgYWJyQmFuZFdpZHRoRmFjdG9yOiAwLjk1LFxuICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICBhYnJCYW5kV2lkdGhVcEZhY3RvcjogMC43LFxuICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICBhYnJNYXhXaXRoUmVhbEJpdHJhdGU6IGZhbHNlLFxuICAgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgICBtYXhTdGFydmF0aW9uRGVsYXk6IDQsXG4gICAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICAgIG1heExvYWRpbmdEZWxheTogNCxcbiAgICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gICAgbWluQXV0b0JpdHJhdGU6IDAsXG4gICAgLy8gdXNlZCBieSBobHNcbiAgICBlbWVFbmFibGVkOiBmYWxzZSxcbiAgICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gICAgd2lkZXZpbmVMaWNlbnNlVXJsOiB1bmRlZmluZWQsXG4gICAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICAgIGRybVN5c3RlbXM6IHt9LFxuICAgIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgICBkcm1TeXN0ZW1PcHRpb25zOiB7fSxcbiAgICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gICAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYzogcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzICxcbiAgICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gICAgdGVzdEJhbmR3aWR0aDogdHJ1ZSxcbiAgICBwcm9ncmVzc2l2ZTogZmFsc2UsXG4gICAgbG93TGF0ZW5jeU1vZGU6IHRydWUsXG4gICAgY21jZDogdW5kZWZpbmVkLFxuICAgIGVuYWJsZURhdGVSYW5nZU1ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzOiB0cnVlLFxuICAgIGVuYWJsZUlEM01ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgICB1c2VNZWRpYUNhcGFiaWxpdGllczogdHJ1ZSxcbiAgICBjZXJ0TG9hZFBvbGljeToge1xuICAgICAgZGVmYXVsdDogZGVmYXVsdExvYWRQb2xpY3lcbiAgICB9LFxuICAgIGtleUxvYWRQb2xpY3k6IHtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDgwMDAsXG4gICAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAyMDAwMCxcbiAgICAgICAgICBiYWNrb2ZmOiAnbGluZWFyJ1xuICAgICAgICB9LFxuICAgICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgICAgbWF4TnVtUmV0cnk6IDgsXG4gICAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICAgIG1heFJldHJ5RGVsYXlNczogMjAwMDAsXG4gICAgICAgICAgYmFja29mZjogJ2xpbmVhcidcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbWFuaWZlc3RMb2FkUG9saWN5OiB7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiBJbmZpbml0eSxcbiAgICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICAgIG1heE51bVJldHJ5OiAxLFxuICAgICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcGxheWxpc3RMb2FkUG9saWN5OiB7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiAxMDAwMCxcbiAgICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZnJhZ0xvYWRQb2xpY3k6IHtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEwMDAwLFxuICAgICAgICBtYXhMb2FkVGltZU1zOiAxMjAwMDAsXG4gICAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICAgIG1heE51bVJldHJ5OiA0LFxuICAgICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICAgIG1heE51bVJldHJ5OiA2LFxuICAgICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc3RlZXJpbmdNYW5pZmVzdExvYWRQb2xpY3k6IHtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEwMDAwLFxuICAgICAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICAgIG1heFJldHJ5RGVsYXlNczogMFxuICAgICAgICB9LFxuICAgICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgICAgbWF4TnVtUmV0cnk6IDEsXG4gICAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMFxuICAgICAgICB9XG4gICAgICB9IFxuICAgIH0sXG4gICAgLy8gVGhlc2UgZGVmYXVsdCBzZXR0aW5ncyBhcmUgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB0aGUgYWJvdmUgcG9saWNpZXNcbiAgICAvLyBhbmQgYXJlIG1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgbWFuaWZlc3RMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gICAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk6IDEsXG4gICAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICAgIGxldmVsTG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICAgIGxldmVsTG9hZGluZ01heFJldHJ5OiA0LFxuICAgIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gICAgbGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgICBmcmFnTG9hZGluZ1RpbWVPdXQ6IDIwMDAwLFxuICAgIGZyYWdMb2FkaW5nTWF4UmV0cnk6IDYsXG4gICAgZnJhZ0xvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICAgIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMFxuICB9LCB0aW1lbGluZUNvbmZpZygpKSwge30sIHtcbiAgICBzdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI6IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciAsXG4gICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXI6IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyICxcbiAgICB0aW1lbGluZUNvbnRyb2xsZXI6IFRpbWVsaW5lQ29udHJvbGxlciAsXG4gICAgYXVkaW9TdHJlYW1Db250cm9sbGVyOiBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgLFxuICAgIGF1ZGlvVHJhY2tDb250cm9sbGVyOiBBdWRpb1RyYWNrQ29udHJvbGxlciAsXG4gICAgZW1lQ29udHJvbGxlcjogRU1FQ29udHJvbGxlciAsXG4gICAgY21jZENvbnRyb2xsZXI6IENNQ0RDb250cm9sbGVyICxcbiAgICBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyOiBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyIFxuICB9KTtcbiAgZnVuY3Rpb24gdGltZWxpbmVDb25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1ZUhhbmRsZXI6IEN1ZXMsXG4gICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICAgIGVuYWJsZVdlYlZUVDogdHJ1ZSxcbiAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgICAgZW5hYmxlSU1TQzE6IHRydWUsXG4gICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICAgIGVuYWJsZUNFQTcwOENhcHRpb25zOiB0cnVlLFxuICAgICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgICBjYXB0aW9uc1RleHRUcmFjazFMYWJlbDogJ0VuZ2xpc2gnLFxuICAgICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgICBjYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGU6ICdlbicsXG4gICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICAgIGNhcHRpb25zVGV4dFRyYWNrMkxhYmVsOiAnU3BhbmlzaCcsXG4gICAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICAgIGNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZTogJ2VzJyxcbiAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgICAgY2FwdGlvbnNUZXh0VHJhY2szTGFiZWw6ICdVbmtub3duIENDJyxcbiAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgICAgY2FwdGlvbnNUZXh0VHJhY2szTGFuZ3VhZ2VDb2RlOiAnJyxcbiAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgICAgY2FwdGlvbnNUZXh0VHJhY2s0TGFiZWw6ICdVbmtub3duIENDJyxcbiAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgICAgY2FwdGlvbnNUZXh0VHJhY2s0TGFuZ3VhZ2VDb2RlOiAnJyxcbiAgICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgICAgcmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5OiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCB1c2VyQ29uZmlnKSB7XG4gICAgaWYgKCh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCkgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fCB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGhscy5qcyBjb25maWc6IGRvbid0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb25cIik7XG4gICAgfVxuICAgIGlmICh1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAhPT0gdW5kZWZpbmVkICYmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb25Db3VudCA9PT0gdW5kZWZpbmVkIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IDw9IHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50XCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicpO1xuICAgIH1cbiAgICBpZiAodXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA8PSB1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uXCInKTtcbiAgICB9XG4gICAgdmFyIGRlZmF1bHRzQ29weSA9IGRlZXBDcHkoZGVmYXVsdENvbmZpZyk7XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGRlcHJlY2F0ZWQgY29uZmlnIHZhbHVlc1xuICAgIHZhciBkZXByZWNhdGVkU2V0dGluZ1R5cGVzID0gWydtYW5pZmVzdCcsICdsZXZlbCcsICdmcmFnJ107XG4gICAgdmFyIGRlcHJlY2F0ZWRTZXR0aW5ncyA9IFsnVGltZU91dCcsICdNYXhSZXRyeScsICdSZXRyeURlbGF5JywgJ01heFJldHJ5VGltZW91dCddO1xuICAgIGRlcHJlY2F0ZWRTZXR0aW5nVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIHBvbGljeU5hbWUgPSAodHlwZSA9PT0gJ2xldmVsJyA/ICdwbGF5bGlzdCcgOiB0eXBlKSArIFwiTG9hZFBvbGljeVwiO1xuICAgICAgdmFyIHBvbGljeU5vdFNldCA9IHVzZXJDb25maWdbcG9saWN5TmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXBvcnQgPSBbXTtcbiAgICAgIGRlcHJlY2F0ZWRTZXR0aW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChzZXR0aW5nKSB7XG4gICAgICAgIHZhciBkZXByZWNhdGVkU2V0dGluZyA9IHR5cGUgKyBcIkxvYWRpbmdcIiArIHNldHRpbmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHVzZXJDb25maWdbZGVwcmVjYXRlZFNldHRpbmddO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwb2xpY3lOb3RTZXQpIHtcbiAgICAgICAgICByZXBvcnQucHVzaChkZXByZWNhdGVkU2V0dGluZyk7XG4gICAgICAgICAgdmFyIHNldHRpbmdzID0gZGVmYXVsdHNDb3B5W3BvbGljeU5hbWVdLmRlZmF1bHQ7XG4gICAgICAgICAgdXNlckNvbmZpZ1twb2xpY3lOYW1lXSA9IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHNldHRpbmdzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzd2l0Y2ggKHNldHRpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgJ1RpbWVPdXQnOlxuICAgICAgICAgICAgICBzZXR0aW5ncy5tYXhMb2FkVGltZU1zID0gdmFsdWU7XG4gICAgICAgICAgICAgIHNldHRpbmdzLm1heFRpbWVUb0ZpcnN0Qnl0ZU1zID0gdmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTWF4UmV0cnknOlxuICAgICAgICAgICAgICBzZXR0aW5ncy5lcnJvclJldHJ5Lm1heE51bVJldHJ5ID0gdmFsdWU7XG4gICAgICAgICAgICAgIHNldHRpbmdzLnRpbWVvdXRSZXRyeS5tYXhOdW1SZXRyeSA9IHZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1JldHJ5RGVsYXknOlxuICAgICAgICAgICAgICBzZXR0aW5ncy5lcnJvclJldHJ5LnJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgICBzZXR0aW5ncy50aW1lb3V0UmV0cnkucmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTWF4UmV0cnlUaW1lb3V0JzpcbiAgICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3JSZXRyeS5tYXhSZXRyeURlbGF5TXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc2V0dGluZ3MudGltZW91dFJldHJ5Lm1heFJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHJlcG9ydC5sZW5ndGgpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJobHMuanMgY29uZmlnOiBcXFwiXCIgKyByZXBvcnQuam9pbignXCIsIFwiJykgKyBcIlxcXCIgc2V0dGluZyhzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIFxcXCJcIiArIHBvbGljeU5hbWUgKyBcIlxcXCI6IFwiICsgSlNPTi5zdHJpbmdpZnkodXNlckNvbmZpZ1twb2xpY3lOYW1lXSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdHNDb3B5KSwgdXNlckNvbmZpZyk7XG4gIH1cbiAgZnVuY3Rpb24gZGVlcENweShvYmopIHtcbiAgICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBvYmoubWFwKGRlZXBDcHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGRlZXBDcHkob2JqW2tleV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIGVuYWJsZVN0cmVhbWluZ01vZGUoY29uZmlnKSB7XG4gICAgdmFyIGN1cnJlbnRMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGlmIChjdXJyZW50TG9hZGVyICE9PSBGZXRjaExvYWRlciAmJiBjdXJyZW50TG9hZGVyICE9PSBYaHJMb2FkZXIpIHtcbiAgICAgIC8vIElmIGEgZGV2ZWxvcGVyIGhhcyBjb25maWd1cmVkIHRoZWlyIG93biBsb2FkZXIsIHJlc3BlY3QgdGhhdCBjaG9pY2VcbiAgICAgIGxvZ2dlci5sb2coJ1tjb25maWddOiBDdXN0b20gbG9hZGVyIGRldGVjdGVkLCBjYW5ub3QgZW5hYmxlIHByb2dyZXNzaXZlIHN0cmVhbWluZycpO1xuICAgICAgY29uZmlnLnByb2dyZXNzaXZlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjYW5TdHJlYW1Qcm9ncmVzc2l2ZWx5ID0gZmV0Y2hTdXBwb3J0ZWQoKTtcbiAgICAgIGlmIChjYW5TdHJlYW1Qcm9ncmVzc2l2ZWx5KSB7XG4gICAgICAgIGNvbmZpZy5sb2FkZXIgPSBGZXRjaExvYWRlcjtcbiAgICAgICAgY29uZmlnLnByb2dyZXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTID0gdHJ1ZTtcbiAgICAgICAgbG9nZ2VyLmxvZygnW2NvbmZpZ106IFByb2dyZXNzaXZlIHN0cmVhbWluZyBlbmFibGVkLCB1c2luZyBGZXRjaExvYWRlcicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjaHJvbWVPckZpcmVmb3g7XG4gIHZhciBMZXZlbENvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlUGxheWxpc3RDb250cm9sbCkge1xuICAgIF9pbmhlcml0c0xvb3NlKExldmVsQ29udHJvbGxlciwgX0Jhc2VQbGF5bGlzdENvbnRyb2xsKTtcbiAgICBmdW5jdGlvbiBMZXZlbENvbnRyb2xsZXIoaGxzLCBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyKSB7XG4gICAgICB2YXIgX3RoaXM7XG4gICAgICBfdGhpcyA9IF9CYXNlUGxheWxpc3RDb250cm9sbC5jYWxsKHRoaXMsIGhscywgJ1tsZXZlbC1jb250cm9sbGVyXScpIHx8IHRoaXM7XG4gICAgICBfdGhpcy5fbGV2ZWxzID0gW107XG4gICAgICBfdGhpcy5fZmlyc3RMZXZlbCA9IC0xO1xuICAgICAgX3RoaXMuX21heEF1dG9MZXZlbCA9IC0xO1xuICAgICAgX3RoaXMuX3N0YXJ0TGV2ZWwgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgICAgX3RoaXMuY3VycmVudExldmVsSW5kZXggPSAtMTtcbiAgICAgIF90aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgICAgIF90aGlzLnN0ZWVyaW5nID0gdm9pZCAwO1xuICAgICAgX3RoaXMub25QYXJzZWRDb21wbGV0ZSA9IHZvaWQgMDtcbiAgICAgIF90aGlzLnN0ZWVyaW5nID0gY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjtcbiAgICAgIF90aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTGV2ZWxDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uX3JlZ2lzdGVyTGlzdGVuZXJzID0gZnVuY3Rpb24gX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5fdW5yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGhscyA9IHRoaXMuaGxzO1xuICAgICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuc3RlZXJpbmcgPSBudWxsO1xuICAgICAgdGhpcy5yZXNldExldmVscygpO1xuICAgICAgX0Jhc2VQbGF5bGlzdENvbnRyb2xsLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3RvcExvYWQgPSBmdW5jdGlvbiBzdG9wTG9hZCgpIHtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG5cbiAgICAgIC8vIGNsZWFuIHVwIGxpdmUgbGV2ZWwgZGV0YWlscyB0byBmb3JjZSByZWxvYWQgdGhlbSwgYW5kIHJlc2V0IGxvYWQgZXJyb3JzXG4gICAgICBsZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICB9KTtcbiAgICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUuc3RvcExvYWQuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldExldmVscyA9IGZ1bmN0aW9uIHJlc2V0TGV2ZWxzKCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IC0xO1xuICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IC0xO1xuICAgICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgICAgdGhpcy5fbGV2ZWxzID0gW107XG4gICAgICB0aGlzLl9tYXhBdXRvTGV2ZWwgPSAtMTtcbiAgICB9O1xuICAgIF9wcm90by5vbk1hbmlmZXN0TG9hZGluZyA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLnJlc2V0TGV2ZWxzKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdExvYWRlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSB0aGlzLmhscy5jb25maWcucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlO1xuICAgICAgdmFyIGxldmVscyA9IFtdO1xuICAgICAgdmFyIHJlZHVuZGFudFNldCA9IHt9O1xuICAgICAgdmFyIGdlbmVyYXRlUGF0aHdheVNldCA9IHt9O1xuICAgICAgdmFyIHJlc29sdXRpb25Gb3VuZCA9IGZhbHNlO1xuICAgICAgdmFyIHZpZGVvQ29kZWNGb3VuZCA9IGZhbHNlO1xuICAgICAgdmFyIGF1ZGlvQ29kZWNGb3VuZCA9IGZhbHNlO1xuICAgICAgZGF0YS5sZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWxQYXJzZWQpIHtcbiAgICAgICAgdmFyIF9hdWRpb0NvZGVjLCBfdmlkZW9Db2RlYztcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBsZXZlbFBhcnNlZC5hdHRycztcblxuICAgICAgICAvLyBlcmFzZSBhdWRpbyBjb2RlYyBpbmZvIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtcDRhLjQwLjM0LlxuICAgICAgICAvLyBkZW11eGVyIHdpbGwgYXV0b2RldGVjdCBjb2RlYyBhbmQgZmFsbGJhY2sgdG8gbXBlZy9hdWRpb1xuICAgICAgICB2YXIgYXVkaW9Db2RlYyA9IGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMsXG4gICAgICAgICAgdmlkZW9Db2RlYyA9IGxldmVsUGFyc2VkLnZpZGVvQ29kZWM7XG4gICAgICAgIGlmICgoKF9hdWRpb0NvZGVjID0gYXVkaW9Db2RlYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuMzQnKSkgIT09IC0xKSB7XG4gICAgICAgICAgY2hyb21lT3JGaXJlZm94IHx8IChjaHJvbWVPckZpcmVmb3ggPSAvY2hyb21lfGZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKTtcbiAgICAgICAgICBpZiAoY2hyb21lT3JGaXJlZm94KSB7XG4gICAgICAgICAgICBsZXZlbFBhcnNlZC5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICBsZXZlbFBhcnNlZC5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYyA9IGdldENvZGVjQ29tcGF0aWJsZU5hbWUoYXVkaW9Db2RlYywgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfdmlkZW9Db2RlYyA9IHZpZGVvQ29kZWMpID09IG51bGwgPyB2b2lkIDAgOiBfdmlkZW9Db2RlYy5pbmRleE9mKCdhdmMxJykpID09PSAwKSB7XG4gICAgICAgICAgdmlkZW9Db2RlYyA9IGxldmVsUGFyc2VkLnZpZGVvQ29kZWMgPSBjb252ZXJ0QVZDMVRvQVZDT1RJKHZpZGVvQ29kZWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBrZWVwIGxldmVscyB3aXRoIHN1cHBvcnRlZCBhdWRpby92aWRlbyBjb2RlY3NcbiAgICAgICAgdmFyIHdpZHRoID0gbGV2ZWxQYXJzZWQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gbGV2ZWxQYXJzZWQuaGVpZ2h0LFxuICAgICAgICAgIHVua25vd25Db2RlY3MgPSBsZXZlbFBhcnNlZC51bmtub3duQ29kZWNzO1xuICAgICAgICByZXNvbHV0aW9uRm91bmQgfHwgKHJlc29sdXRpb25Gb3VuZCA9ICEhKHdpZHRoICYmIGhlaWdodCkpO1xuICAgICAgICB2aWRlb0NvZGVjRm91bmQgfHwgKHZpZGVvQ29kZWNGb3VuZCA9ICEhdmlkZW9Db2RlYyk7XG4gICAgICAgIGF1ZGlvQ29kZWNGb3VuZCB8fCAoYXVkaW9Db2RlY0ZvdW5kID0gISFhdWRpb0NvZGVjKTtcbiAgICAgICAgaWYgKHVua25vd25Db2RlY3MgIT0gbnVsbCAmJiB1bmtub3duQ29kZWNzLmxlbmd0aCB8fCBhdWRpb0NvZGVjICYmICFhcmVDb2RlY3NNZWRpYVNvdXJjZVN1cHBvcnRlZChhdWRpb0NvZGVjLCAnYXVkaW8nLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpIHx8IHZpZGVvQ29kZWMgJiYgIWFyZUNvZGVjc01lZGlhU291cmNlU3VwcG9ydGVkKHZpZGVvQ29kZWMsICd2aWRlbycsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIENPREVDUyA9IGF0dHJpYnV0ZXMuQ09ERUNTLFxuICAgICAgICAgIEZSQU1FUkFURSA9IGF0dHJpYnV0ZXNbJ0ZSQU1FLVJBVEUnXSxcbiAgICAgICAgICBIRENQID0gYXR0cmlidXRlc1snSERDUC1MRVZFTCddLFxuICAgICAgICAgIFBBVEhXQVkgPSBhdHRyaWJ1dGVzWydQQVRIV0FZLUlEJ10sXG4gICAgICAgICAgUkVTT0xVVElPTiA9IGF0dHJpYnV0ZXMuUkVTT0xVVElPTixcbiAgICAgICAgICBWSURFT19SQU5HRSA9IGF0dHJpYnV0ZXNbJ1ZJREVPLVJBTkdFJ107XG4gICAgICAgIHZhciBjb250ZW50U3RlZXJpbmdQcmVmaXggPSAoUEFUSFdBWSB8fCAnLicpICsgXCItXCI7XG4gICAgICAgIHZhciBsZXZlbEtleSA9IFwiXCIgKyBjb250ZW50U3RlZXJpbmdQcmVmaXggKyBsZXZlbFBhcnNlZC5iaXRyYXRlICsgXCItXCIgKyBSRVNPTFVUSU9OICsgXCItXCIgKyBGUkFNRVJBVEUgKyBcIi1cIiArIENPREVDUyArIFwiLVwiICsgVklERU9fUkFOR0UgKyBcIi1cIiArIEhEQ1A7XG4gICAgICAgIGlmICghcmVkdW5kYW50U2V0W2xldmVsS2V5XSkge1xuICAgICAgICAgIHZhciBsZXZlbCA9IG5ldyBMZXZlbChsZXZlbFBhcnNlZCk7XG4gICAgICAgICAgcmVkdW5kYW50U2V0W2xldmVsS2V5XSA9IGxldmVsO1xuICAgICAgICAgIGdlbmVyYXRlUGF0aHdheVNldFtsZXZlbEtleV0gPSAxO1xuICAgICAgICAgIGxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWR1bmRhbnRTZXRbbGV2ZWxLZXldLnVyaSAhPT0gbGV2ZWxQYXJzZWQudXJsICYmICFsZXZlbFBhcnNlZC5hdHRyc1snUEFUSFdBWS1JRCddKSB7XG4gICAgICAgICAgLy8gQXNzaWduIFBhdGh3YXkgSURzIHRvIFJlZHVuZGFudCBTdHJlYW1zIChkZWZhdWx0IFBhdGh3YXlzIGlzIFwiLlwiLiBSZWR1bmRhbnQgU3RyZWFtcyBcIi4uXCIsIFwiLi4uXCIsIGFuZCBzbyBvbi4pXG4gICAgICAgICAgLy8gQ29udGVudCBTdGVlcmluZyBjb250cm9sbGVyIHRvIGhhbmRsZXMgUGF0aHdheSBmYWxsYmFjayBvbiBlcnJvclxuICAgICAgICAgIHZhciBwYXRod2F5Q291bnQgPSBnZW5lcmF0ZVBhdGh3YXlTZXRbbGV2ZWxLZXldICs9IDE7XG4gICAgICAgICAgbGV2ZWxQYXJzZWQuYXR0cnNbJ1BBVEhXQVktSUQnXSA9IG5ldyBBcnJheShwYXRod2F5Q291bnQgKyAxKS5qb2luKCcuJyk7XG4gICAgICAgICAgdmFyIF9sZXZlbCA9IG5ldyBMZXZlbChsZXZlbFBhcnNlZCk7XG4gICAgICAgICAgcmVkdW5kYW50U2V0W2xldmVsS2V5XSA9IF9sZXZlbDtcbiAgICAgICAgICBsZXZlbHMucHVzaChfbGV2ZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZHVuZGFudFNldFtsZXZlbEtleV0uYWRkR3JvdXBJZCgnYXVkaW8nLCBhdHRyaWJ1dGVzLkFVRElPKTtcbiAgICAgICAgICByZWR1bmRhbnRTZXRbbGV2ZWxLZXldLmFkZEdyb3VwSWQoJ3RleHQnLCBhdHRyaWJ1dGVzLlNVQlRJVExFUyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5maWx0ZXJBbmRTb3J0TWVkaWFPcHRpb25zKGxldmVscywgZGF0YSwgcmVzb2x1dGlvbkZvdW5kLCB2aWRlb0NvZGVjRm91bmQsIGF1ZGlvQ29kZWNGb3VuZCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZmlsdGVyQW5kU29ydE1lZGlhT3B0aW9ucyA9IGZ1bmN0aW9uIGZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnMoZmlsdGVyZWRMZXZlbHMsIGRhdGEsIHJlc29sdXRpb25Gb3VuZCwgdmlkZW9Db2RlY0ZvdW5kLCBhdWRpb0NvZGVjRm91bmQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIGF1ZGlvVHJhY2tzID0gW107XG4gICAgICB2YXIgc3VidGl0bGVUcmFja3MgPSBbXTtcbiAgICAgIHZhciBsZXZlbHMgPSBmaWx0ZXJlZExldmVscztcblxuICAgICAgLy8gcmVtb3ZlIGF1ZGlvLW9ubHkgYW5kIGludmFsaWQgdmlkZW8tcmFuZ2UgbGV2ZWxzIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCB2aWRlbyBjb2RlY3Mgb3IgUkVTT0xVVElPTiBzaWduYWxsZWRcbiAgICAgIGlmICgocmVzb2x1dGlvbkZvdW5kIHx8IHZpZGVvQ29kZWNGb3VuZCkgJiYgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgICAgIGxldmVscyA9IGxldmVscy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgdmlkZW9Db2RlYyA9IF9yZWYudmlkZW9Db2RlYyxcbiAgICAgICAgICAgIHZpZGVvUmFuZ2UgPSBfcmVmLnZpZGVvUmFuZ2UsXG4gICAgICAgICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcbiAgICAgICAgICByZXR1cm4gKCEhdmlkZW9Db2RlYyB8fCAhISh3aWR0aCAmJiBoZWlnaHQpKSAmJiBpc1ZpZGVvUmFuZ2UodmlkZW9SYW5nZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gRGlzcGF0Y2ggZXJyb3IgYWZ0ZXIgTUFOSUZFU1RfTE9BREVEIGlzIGRvbmUgcHJvcGFnYXRpbmdcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5obHMpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLndhcm4oXCJPbmUgb3IgbW9yZSBDT0RFQ1MgaW4gdmFyaWFudCBub3Qgc3VwcG9ydGVkOiBcIiArIEpTT04uc3RyaW5naWZ5KGRhdGEubGV2ZWxzWzBdLmF0dHJzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ25vIGxldmVsIHdpdGggY29tcGF0aWJsZSBjb2RlY3MgZm91bmQgaW4gbWFuaWZlc3QnKTtcbiAgICAgICAgICAgIF90aGlzMi5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgICAgICB1cmw6IGRhdGEudXJsLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuYXVkaW9UcmFja3MpIHtcbiAgICAgICAgdmFyIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRoaXMuaGxzLmNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2U7XG4gICAgICAgIGF1ZGlvVHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcy5maWx0ZXIoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgcmV0dXJuICF0cmFjay5hdWRpb0NvZGVjIHx8IGFyZUNvZGVjc01lZGlhU291cmNlU3VwcG9ydGVkKHRyYWNrLmF1ZGlvQ29kZWMsICdhdWRpbycsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBc3NpZ24gaWRzIGFmdGVyIGZpbHRlcmluZyBhcyBhcnJheSBpbmRpY2VzIGJ5IGdyb3VwLWlkXG4gICAgICAgIGFzc2lnblRyYWNrSWRzQnlHcm91cChhdWRpb1RyYWNrcyk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5zdWJ0aXRsZXMpIHtcbiAgICAgICAgc3VidGl0bGVUcmFja3MgPSBkYXRhLnN1YnRpdGxlcztcbiAgICAgICAgYXNzaWduVHJhY2tJZHNCeUdyb3VwKHN1YnRpdGxlVHJhY2tzKTtcbiAgICAgIH1cbiAgICAgIC8vIHN0YXJ0IGJpdHJhdGUgaXMgdGhlIGZpcnN0IGJpdHJhdGUgb2YgdGhlIG1hbmlmZXN0XG4gICAgICB2YXIgdW5zb3J0ZWRMZXZlbHMgPSBsZXZlbHMuc2xpY2UoMCk7XG4gICAgICAvLyBzb3J0IGxldmVscyBmcm9tIGxvd2VzdCB0byBoaWdoZXN0XG4gICAgICBsZXZlbHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoYS5hdHRyc1snSERDUC1MRVZFTCddICE9PSBiLmF0dHJzWydIRENQLUxFVkVMJ10pIHtcbiAgICAgICAgICByZXR1cm4gKGEuYXR0cnNbJ0hEQ1AtTEVWRUwnXSB8fCAnJykgPiAoYi5hdHRyc1snSERDUC1MRVZFTCddIHx8ICcnKSA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzb3J0IG9uIGhlaWdodCBiZWZvcmUgYml0cmF0ZSBmb3IgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgICAgICAgaWYgKHJlc29sdXRpb25Gb3VuZCAmJiBhLmhlaWdodCAhPT0gYi5oZWlnaHQpIHtcbiAgICAgICAgICByZXR1cm4gYS5oZWlnaHQgLSBiLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5mcmFtZVJhdGUgIT09IGIuZnJhbWVSYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGEuZnJhbWVSYXRlIC0gYi5mcmFtZVJhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEudmlkZW9SYW5nZSAhPT0gYi52aWRlb1JhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIFZpZGVvUmFuZ2VWYWx1ZXMuaW5kZXhPZihhLnZpZGVvUmFuZ2UpIC0gVmlkZW9SYW5nZVZhbHVlcy5pbmRleE9mKGIudmlkZW9SYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEudmlkZW9Db2RlYyAhPT0gYi52aWRlb0NvZGVjKSB7XG4gICAgICAgICAgdmFyIHZhbHVlQSA9IHZpZGVvQ29kZWNQcmVmZXJlbmNlVmFsdWUoYS52aWRlb0NvZGVjKTtcbiAgICAgICAgICB2YXIgdmFsdWVCID0gdmlkZW9Db2RlY1ByZWZlcmVuY2VWYWx1ZShiLnZpZGVvQ29kZWMpO1xuICAgICAgICAgIGlmICh2YWx1ZUEgIT09IHZhbHVlQikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlQiAtIHZhbHVlQTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEudXJpID09PSBiLnVyaSAmJiBhLmNvZGVjU2V0ICE9PSBiLmNvZGVjU2V0KSB7XG4gICAgICAgICAgdmFyIF92YWx1ZUEgPSBjb2RlY3NTZXRTZWxlY3Rpb25QcmVmZXJlbmNlVmFsdWUoYS5jb2RlY1NldCk7XG4gICAgICAgICAgdmFyIF92YWx1ZUIgPSBjb2RlY3NTZXRTZWxlY3Rpb25QcmVmZXJlbmNlVmFsdWUoYi5jb2RlY1NldCk7XG4gICAgICAgICAgaWYgKF92YWx1ZUEgIT09IF92YWx1ZUIpIHtcbiAgICAgICAgICAgIHJldHVybiBfdmFsdWVCIC0gX3ZhbHVlQTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuYXZlcmFnZUJpdHJhdGUgIT09IGIuYXZlcmFnZUJpdHJhdGUpIHtcbiAgICAgICAgICByZXR1cm4gYS5hdmVyYWdlQml0cmF0ZSAtIGIuYXZlcmFnZUJpdHJhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9KTtcbiAgICAgIHZhciBmaXJzdExldmVsSW5QbGF5bGlzdCA9IHVuc29ydGVkTGV2ZWxzWzBdO1xuICAgICAgaWYgKHRoaXMuc3RlZXJpbmcpIHtcbiAgICAgICAgbGV2ZWxzID0gdGhpcy5zdGVlcmluZy5maWx0ZXJQYXJzZWRMZXZlbHMobGV2ZWxzKTtcbiAgICAgICAgaWYgKGxldmVscy5sZW5ndGggIT09IHVuc29ydGVkTGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5zb3J0ZWRMZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh1bnNvcnRlZExldmVsc1tpXS5wYXRod2F5SWQgPT09IGxldmVsc1swXS5wYXRod2F5SWQpIHtcbiAgICAgICAgICAgICAgZmlyc3RMZXZlbEluUGxheWxpc3QgPSB1bnNvcnRlZExldmVsc1tpXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7XG5cbiAgICAgIC8vIGZpbmQgaW5kZXggb2YgZmlyc3QgbGV2ZWwgaW4gc29ydGVkIGxldmVsc1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxldmVscy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgaWYgKGxldmVsc1tfaV0gPT09IGZpcnN0TGV2ZWxJblBsYXlsaXN0KSB7XG4gICAgICAgICAgdmFyIF90aGlzJGhscyR1c2VyQ29uZmlnO1xuICAgICAgICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBfaTtcbiAgICAgICAgICB2YXIgZmlyc3RMZXZlbEJpdHJhdGUgPSBmaXJzdExldmVsSW5QbGF5bGlzdC5iaXRyYXRlO1xuICAgICAgICAgIHZhciBiYW5kd2lkdGhFc3RpbWF0ZSA9IHRoaXMuaGxzLmJhbmR3aWR0aEVzdGltYXRlO1xuICAgICAgICAgIHRoaXMubG9nKFwibWFuaWZlc3QgbG9hZGVkLCBcIiArIGxldmVscy5sZW5ndGggKyBcIiBsZXZlbChzKSBmb3VuZCwgZmlyc3QgYml0cmF0ZTogXCIgKyBmaXJzdExldmVsQml0cmF0ZSk7XG4gICAgICAgICAgLy8gVXBkYXRlIGRlZmF1bHQgYndlIHRvIGZpcnN0IHZhcmlhbnQgYml0cmF0ZSBhcyBsb25nIGl0IGhhcyBub3QgYmVlbiBjb25maWd1cmVkIG9yIHNldFxuICAgICAgICAgIGlmICgoKF90aGlzJGhscyR1c2VyQ29uZmlnID0gdGhpcy5obHMudXNlckNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhscyR1c2VyQ29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydGluZ0J3RXN0aW1hdGUgPSBNYXRoLm1pbihmaXJzdExldmVsQml0cmF0ZSwgdGhpcy5obHMuY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGVNYXgpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nQndFc3RpbWF0ZSA+IGJhbmR3aWR0aEVzdGltYXRlICYmIGJhbmR3aWR0aEVzdGltYXRlID09PSBobHNEZWZhdWx0Q29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5obHMuYmFuZHdpZHRoRXN0aW1hdGUgPSBzdGFydGluZ0J3RXN0aW1hdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEF1ZGlvIGlzIG9ubHkgYWx0ZXJuYXRlIGlmIG1hbmlmZXN0IGluY2x1ZGUgYSBVUkkgYWxvbmcgd2l0aCB0aGUgYXVkaW8gZ3JvdXAgdGFnLFxuICAgICAgLy8gYW5kIHRoaXMgaXMgbm90IGFuIGF1ZGlvLW9ubHkgc3RyZWFtIHdoZXJlIGxldmVscyBjb250YWluIGF1ZGlvLW9ubHlcbiAgICAgIHZhciBhdWRpb09ubHkgPSBhdWRpb0NvZGVjRm91bmQgJiYgIXZpZGVvQ29kZWNGb3VuZDtcbiAgICAgIHZhciBlZGF0YSA9IHtcbiAgICAgICAgbGV2ZWxzOiBsZXZlbHMsXG4gICAgICAgIGF1ZGlvVHJhY2tzOiBhdWRpb1RyYWNrcyxcbiAgICAgICAgc3VidGl0bGVUcmFja3M6IHN1YnRpdGxlVHJhY2tzLFxuICAgICAgICBzZXNzaW9uRGF0YTogZGF0YS5zZXNzaW9uRGF0YSxcbiAgICAgICAgc2Vzc2lvbktleXM6IGRhdGEuc2Vzc2lvbktleXMsXG4gICAgICAgIGZpcnN0TGV2ZWw6IHRoaXMuX2ZpcnN0TGV2ZWwsXG4gICAgICAgIHN0YXRzOiBkYXRhLnN0YXRzLFxuICAgICAgICBhdWRpbzogYXVkaW9Db2RlY0ZvdW5kLFxuICAgICAgICB2aWRlbzogdmlkZW9Db2RlY0ZvdW5kLFxuICAgICAgICBhbHRBdWRpbzogIWF1ZGlvT25seSAmJiBhdWRpb1RyYWNrcy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuICEhdC51cmw7XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCBlZGF0YSk7XG5cbiAgICAgIC8vIEluaXRpYXRlIGxvYWRpbmcgYWZ0ZXIgYWxsIGNvbnRyb2xsZXJzIGhhdmUgcmVjZWl2ZWQgTUFOSUZFU1RfUEFSU0VEXG4gICAgICBpZiAodGhpcy5obHMuY29uZmlnLmF1dG9TdGFydExvYWQgfHwgdGhpcy5obHMuZm9yY2VTdGFydExvYWQpIHtcbiAgICAgICAgdGhpcy5obHMuc3RhcnRMb2FkKHRoaXMuaGxzLmNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgICAgaWYgKGRhdGEuZmF0YWwgfHwgIWRhdGEuY29udGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5jb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwgJiYgZGF0YS5jb250ZXh0LmxldmVsID09PSB0aGlzLmxldmVsKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXRyeShkYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXNldCBlcnJvcnMgb24gdGhlIHN1Y2Nlc3NmdWwgbG9hZCBvZiBhIGZyYWdtZW50XG4gICAgO1xuICAgIF9wcm90by5vbkZyYWdCdWZmZXJlZCA9IGZ1bmN0aW9uIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBfcmVmMikge1xuICAgICAgdmFyIGZyYWcgPSBfcmVmMi5mcmFnO1xuICAgICAgaWYgKGZyYWcgIT09IHVuZGVmaW5lZCAmJiBmcmFnLnR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICAgICAgdmFyIGVsID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhlbCkuc29tZShmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIHJldHVybiAhIWVsW3R5cGVdO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICAgIGlmIChsZXZlbCAhPSBudWxsICYmIGxldmVsLmxvYWRFcnJvcikge1xuICAgICAgICAgIHRoaXMubG9nKFwiUmVzZXR0aW5nIGxldmVsIGVycm9yIGNvdW50IG9mIFwiICsgbGV2ZWwubG9hZEVycm9yICsgXCIgb24gZnJhZyBidWZmZXJlZFwiKTtcbiAgICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbExvYWRlZCA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfZGF0YSRkZWxpdmVyeURpcmVjdGkyO1xuICAgICAgdmFyIGxldmVsID0gZGF0YS5sZXZlbCxcbiAgICAgICAgZGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgICAgIHZhciBjdXJMZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbF07XG4gICAgICBpZiAoIWN1ckxldmVsKSB7XG4gICAgICAgIHZhciBfZGF0YSRkZWxpdmVyeURpcmVjdGk7XG4gICAgICAgIHRoaXMud2FybihcIkludmFsaWQgbGV2ZWwgaW5kZXggXCIgKyBsZXZlbCk7XG4gICAgICAgIGlmICgoX2RhdGEkZGVsaXZlcnlEaXJlY3RpID0gZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMpICE9IG51bGwgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpLnNraXApIHtcbiAgICAgICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgcHJvY2VzcyBsZXZlbCBsb2FkZWQgZXZlbnRzIG1hdGNoaW5nIHdpdGggZXhwZWN0ZWQgbGV2ZWxcbiAgICAgIGlmIChsZXZlbCA9PT0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleCkge1xuICAgICAgICAvLyByZXNldCBsZXZlbCBsb2FkIGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCBsZXZlbCBsb2FkZWQgb25seSBpZiB0aGVyZSBpcyBubyBpc3N1ZXMgd2l0aCBmcmFnbWVudHNcbiAgICAgICAgaWYgKGN1ckxldmVsLmZyYWdtZW50RXJyb3IgPT09IDApIHtcbiAgICAgICAgICBjdXJMZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxheWxpc3RMb2FkZWQobGV2ZWwsIGRhdGEsIGN1ckxldmVsLmRldGFpbHMpO1xuICAgICAgfSBlbHNlIGlmICgoX2RhdGEkZGVsaXZlcnlEaXJlY3RpMiA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzKSAhPSBudWxsICYmIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTIuc2tpcCkge1xuICAgICAgICAvLyByZWNlaXZlZCBhIGRlbHRhIHBsYXlsaXN0IHVwZGF0ZSB0aGF0IGNhbm5vdCBiZSBtZXJnZWRcbiAgICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZFBsYXlsaXN0ID0gZnVuY3Rpb24gbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgIF9CYXNlUGxheWxpc3RDb250cm9sbC5wcm90b3R5cGUubG9hZFBsYXlsaXN0LmNhbGwodGhpcyk7XG4gICAgICB2YXIgY3VycmVudExldmVsSW5kZXggPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbCA9IHRoaXMuY3VycmVudExldmVsO1xuICAgICAgaWYgKGN1cnJlbnRMZXZlbCAmJiB0aGlzLnNob3VsZExvYWRQbGF5bGlzdChjdXJyZW50TGV2ZWwpKSB7XG4gICAgICAgIHZhciB1cmwgPSBjdXJyZW50TGV2ZWwudXJpO1xuICAgICAgICBpZiAoaGxzVXJsUGFyYW1ldGVycykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cmwgPSBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJsKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy53YXJuKFwiQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIHdpdGggSExTIERlbGl2ZXJ5IERpcmVjdGl2ZXM6IFwiICsgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aHdheUlkID0gY3VycmVudExldmVsLmF0dHJzWydQQVRIV0FZLUlEJ107XG4gICAgICAgIHRoaXMubG9nKFwiTG9hZGluZyBsZXZlbCBpbmRleCBcIiArIGN1cnJlbnRMZXZlbEluZGV4ICsgKChobHNVcmxQYXJhbWV0ZXJzID09IG51bGwgPyB2b2lkIDAgOiBobHNVcmxQYXJhbWV0ZXJzLm1zbikgIT09IHVuZGVmaW5lZCA/ICcgYXQgc24gJyArIGhsc1VybFBhcmFtZXRlcnMubXNuICsgJyBwYXJ0ICcgKyBobHNVcmxQYXJhbWV0ZXJzLnBhcnQgOiAnJykgKyBcIiB3aXRoXCIgKyAocGF0aHdheUlkID8gJyBQYXRod2F5ICcgKyBwYXRod2F5SWQgOiAnJykgKyBcIiBcIiArIHVybCk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0N1cnJlbnQgYXVkaW8gdHJhY2sgZ3JvdXAgSUQ6JywgdGhpcy5obHMuYXVkaW9UcmFja3NbdGhpcy5obHMuYXVkaW9UcmFja10uZ3JvdXBJZCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdOZXcgdmlkZW8gcXVhbGl0eSBsZXZlbCBhdWRpbyBncm91cCBpZDonLCBsZXZlbE9iamVjdC5hdHRycy5BVURJTywgbGV2ZWwpO1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfTE9BRElORywge1xuICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgIGxldmVsOiBjdXJyZW50TGV2ZWxJbmRleCxcbiAgICAgICAgICBwYXRod2F5SWQ6IGN1cnJlbnRMZXZlbC5hdHRyc1snUEFUSFdBWS1JRCddLFxuICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgIC8vIERlcHJlY2F0ZWQgTGV2ZWwgdXJsSWRcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGhsc1VybFBhcmFtZXRlcnMgfHwgbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVMZXZlbCA9IGZ1bmN0aW9uIHJlbW92ZUxldmVsKGxldmVsSW5kZXgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzLFxuICAgICAgICBfdGhpcyRjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzLmZpbHRlcihmdW5jdGlvbiAobGV2ZWwsIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCAhPT0gbGV2ZWxJbmRleCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczMuc3RlZXJpbmcpIHtcbiAgICAgICAgICBfdGhpczMuc3RlZXJpbmcucmVtb3ZlTGV2ZWwobGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbCA9PT0gX3RoaXMzLmN1cnJlbnRMZXZlbCkge1xuICAgICAgICAgIF90aGlzMy5jdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgICAgICAgIF90aGlzMy5jdXJyZW50TGV2ZWxJbmRleCA9IC0xO1xuICAgICAgICAgIGlmIChsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgICBsZXZlbC5kZXRhaWxzLmZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmLmxldmVsID0gLTE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgICByZWFzc2lnbkZyYWdtZW50TGV2ZWxJbmRleGVzKGxldmVscyk7XG4gICAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7XG4gICAgICBpZiAodGhpcy5jdXJyZW50TGV2ZWxJbmRleCA+IC0xICYmIChfdGhpcyRjdXJyZW50TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbCkgIT0gbnVsbCAmJiBfdGhpcyRjdXJyZW50TGV2ZWwuZGV0YWlscykge1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWwuZGV0YWlscy5mcmFnbWVudHNbMF0ubGV2ZWw7XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwge1xuICAgICAgICBsZXZlbHM6IGxldmVsc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbHNVcGRhdGVkID0gZnVuY3Rpb24gb25MZXZlbHNVcGRhdGVkKGV2ZW50LCBfcmVmMykge1xuICAgICAgdmFyIGxldmVscyA9IF9yZWYzLmxldmVscztcbiAgICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgICB9O1xuICAgIF9wcm90by5jaGVja01heEF1dG9VcGRhdGVkID0gZnVuY3Rpb24gY2hlY2tNYXhBdXRvVXBkYXRlZCgpIHtcbiAgICAgIHZhciBfdGhpcyRobHMgPSB0aGlzLmhscyxcbiAgICAgICAgYXV0b0xldmVsQ2FwcGluZyA9IF90aGlzJGhscy5hdXRvTGV2ZWxDYXBwaW5nLFxuICAgICAgICBtYXhBdXRvTGV2ZWwgPSBfdGhpcyRobHMubWF4QXV0b0xldmVsLFxuICAgICAgICBtYXhIZGNwTGV2ZWwgPSBfdGhpcyRobHMubWF4SGRjcExldmVsO1xuICAgICAgaWYgKHRoaXMuX21heEF1dG9MZXZlbCAhPT0gbWF4QXV0b0xldmVsKSB7XG4gICAgICAgIHRoaXMuX21heEF1dG9MZXZlbCA9IG1heEF1dG9MZXZlbDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUFYX0FVVE9fTEVWRUxfVVBEQVRFRCwge1xuICAgICAgICAgIGF1dG9MZXZlbENhcHBpbmc6IGF1dG9MZXZlbENhcHBpbmcsXG4gICAgICAgICAgbGV2ZWxzOiB0aGlzLmxldmVscyxcbiAgICAgICAgICBtYXhBdXRvTGV2ZWw6IG1heEF1dG9MZXZlbCxcbiAgICAgICAgICBtaW5BdXRvTGV2ZWw6IHRoaXMuaGxzLm1pbkF1dG9MZXZlbCxcbiAgICAgICAgICBtYXhIZGNwTGV2ZWw6IG1heEhkY3BMZXZlbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9jcmVhdGVDbGFzcyhMZXZlbENvbnRyb2xsZXIsIFt7XG4gICAgICBrZXk6IFwibGV2ZWxzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJsZXZlbFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRMZXZlbEluZGV4O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgICAgIGlmIChsZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIGxldmVsIGlkeCBpcyB2YWxpZFxuICAgICAgICBpZiAobmV3TGV2ZWwgPCAwIHx8IG5ld0xldmVsID49IGxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBpbnZhbGlkIGxldmVsIGlkIGdpdmVuLCB0cmlnZ2VyIGVycm9yXG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIGxldmVsIGlkeCcpO1xuICAgICAgICAgIHZhciBmYXRhbCA9IG5ld0xldmVsIDwgMDtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9TV0lUQ0hfRVJST1IsXG4gICAgICAgICAgICBsZXZlbDogbmV3TGV2ZWwsXG4gICAgICAgICAgICBmYXRhbDogZmF0YWwsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZmF0YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1pbihuZXdMZXZlbCwgbGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0TGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgICAgIHZhciBsYXN0TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbDtcbiAgICAgICAgdmFyIGxhc3RQYXRod2F5SWQgPSBsYXN0TGV2ZWwgPyBsYXN0TGV2ZWwuYXR0cnNbJ1BBVEhXQVktSUQnXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGxldmVsID0gbGV2ZWxzW25ld0xldmVsXTtcbiAgICAgICAgdmFyIHBhdGh3YXlJZCA9IGxldmVsLmF0dHJzWydQQVRIV0FZLUlEJ107XG4gICAgICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBuZXdMZXZlbDtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgaWYgKGxhc3RMZXZlbEluZGV4ID09PSBuZXdMZXZlbCAmJiBsZXZlbC5kZXRhaWxzICYmIGxhc3RMZXZlbCAmJiBsYXN0UGF0aHdheUlkID09PSBwYXRod2F5SWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2coXCJTd2l0Y2hpbmcgdG8gbGV2ZWwgXCIgKyBuZXdMZXZlbCArIFwiIChcIiArIChsZXZlbC5oZWlnaHQgPyBsZXZlbC5oZWlnaHQgKyAncCAnIDogJycpICsgKGxldmVsLnZpZGVvUmFuZ2UgPyBsZXZlbC52aWRlb1JhbmdlICsgJyAnIDogJycpICsgKGxldmVsLmNvZGVjU2V0ID8gbGV2ZWwuY29kZWNTZXQgKyAnICcgOiAnJykgKyBcIkBcIiArIGxldmVsLmJpdHJhdGUgKyBcIilcIiArIChwYXRod2F5SWQgPyAnIHdpdGggUGF0aHdheSAnICsgcGF0aHdheUlkIDogJycpICsgXCIgZnJvbSBsZXZlbCBcIiArIGxhc3RMZXZlbEluZGV4ICsgKGxhc3RQYXRod2F5SWQgPyAnIHdpdGggUGF0aHdheSAnICsgbGFzdFBhdGh3YXlJZCA6ICcnKSk7XG4gICAgICAgIHZhciBsZXZlbFN3aXRjaGluZ0RhdGEgPSB7XG4gICAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgICAgIGF0dHJzOiBsZXZlbC5hdHRycyxcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbC5kZXRhaWxzLFxuICAgICAgICAgIGJpdHJhdGU6IGxldmVsLmJpdHJhdGUsXG4gICAgICAgICAgYXZlcmFnZUJpdHJhdGU6IGxldmVsLmF2ZXJhZ2VCaXRyYXRlLFxuICAgICAgICAgIG1heEJpdHJhdGU6IGxldmVsLm1heEJpdHJhdGUsXG4gICAgICAgICAgcmVhbEJpdHJhdGU6IGxldmVsLnJlYWxCaXRyYXRlLFxuICAgICAgICAgIHdpZHRoOiBsZXZlbC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGxldmVsLmhlaWdodCxcbiAgICAgICAgICBjb2RlY1NldDogbGV2ZWwuY29kZWNTZXQsXG4gICAgICAgICAgYXVkaW9Db2RlYzogbGV2ZWwuYXVkaW9Db2RlYyxcbiAgICAgICAgICB2aWRlb0NvZGVjOiBsZXZlbC52aWRlb0NvZGVjLFxuICAgICAgICAgIGF1ZGlvR3JvdXBzOiBsZXZlbC5hdWRpb0dyb3VwcyxcbiAgICAgICAgICBzdWJ0aXRsZUdyb3VwczogbGV2ZWwuc3VidGl0bGVHcm91cHMsXG4gICAgICAgICAgbG9hZGVkOiBsZXZlbC5sb2FkZWQsXG4gICAgICAgICAgbG9hZEVycm9yOiBsZXZlbC5sb2FkRXJyb3IsXG4gICAgICAgICAgZnJhZ21lbnRFcnJvcjogbGV2ZWwuZnJhZ21lbnRFcnJvcixcbiAgICAgICAgICBuYW1lOiBsZXZlbC5uYW1lLFxuICAgICAgICAgIGlkOiBsZXZlbC5pZCxcbiAgICAgICAgICB1cmk6IGxldmVsLnVyaSxcbiAgICAgICAgICB1cmw6IGxldmVsLnVybCxcbiAgICAgICAgICB1cmxJZDogMCxcbiAgICAgICAgICBhdWRpb0dyb3VwSWRzOiBsZXZlbC5hdWRpb0dyb3VwSWRzLFxuICAgICAgICAgIHRleHRHcm91cElkczogbGV2ZWwudGV4dEdyb3VwSWRzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgbGV2ZWxTd2l0Y2hpbmdEYXRhKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBsb2FkIHBsYXlsaXN0IGZvciB0aGlzIGxldmVsXG4gICAgICAgIHZhciBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgICAgICBpZiAoIWxldmVsRGV0YWlscyB8fCBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICAgIC8vIGxldmVsIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgICAgICB2YXIgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKGxldmVsLnVyaSwgbGFzdExldmVsID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TGV2ZWwuZGV0YWlscywgbGV2ZWxEZXRhaWxzKTtcbiAgICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYW51YWxMZXZlbFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG4gICAgICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmaXJzdExldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdGFydExldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgLy8gU2V0dGluZyBobHMuc3RhcnRMZXZlbCAodGhpcy5fc3RhcnRMZXZlbCkgb3ZlcnJpZGVzIGNvbmZpZy5zdGFydExldmVsXG4gICAgICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgY29uZmlnU3RhcnRMZXZlbCA9IHRoaXMuaGxzLmNvbmZpZy5zdGFydExldmVsO1xuICAgICAgICAgIGlmIChjb25maWdTdGFydExldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWdTdGFydExldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5obHMuZmlyc3RBdXRvTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0TGV2ZWw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJuZXh0TG9hZExldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhscy5uZXh0QXV0b0xldmVsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV4dExldmVsKSB7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgICAgIGlmICh0aGlzLm1hbnVhbExldmVsSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5obHMubmV4dEF1dG9MZXZlbCA9IG5leHRMZXZlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gTGV2ZWxDb250cm9sbGVyO1xuICB9KEJhc2VQbGF5bGlzdENvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBhc3NpZ25UcmFja0lkc0J5R3JvdXAodHJhY2tzKSB7XG4gICAgdmFyIGdyb3VwcyA9IHt9O1xuICAgIHRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgdmFyIGdyb3VwSWQgPSB0cmFjay5ncm91cElkIHx8ICcnO1xuICAgICAgdHJhY2suaWQgPSBncm91cHNbZ3JvdXBJZF0gPSBncm91cHNbZ3JvdXBJZF0gfHwgMDtcbiAgICAgIGdyb3Vwc1tncm91cElkXSsrO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIEtleUxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gS2V5TG9hZGVyKGNvbmZpZykge1xuICAgICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgICB0aGlzLmtleVVyaVRvS2V5SW5mbyA9IHt9O1xuICAgICAgdGhpcy5lbWVDb250cm9sbGVyID0gbnVsbDtcbiAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gS2V5TG9hZGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCh0eXBlKSB7XG4gICAgICBmb3IgKHZhciB1cmkgaW4gdGhpcy5rZXlVcmlUb0tleUluZm8pIHtcbiAgICAgICAgdmFyIGxvYWRlciA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0ubG9hZGVyO1xuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgdmFyIF9sb2FkZXIkY29udGV4dDtcbiAgICAgICAgICBpZiAodHlwZSAmJiB0eXBlICE9PSAoKF9sb2FkZXIkY29udGV4dCA9IGxvYWRlci5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2xvYWRlciRjb250ZXh0LmZyYWcudHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICBmb3IgKHZhciB1cmkgaW4gdGhpcy5rZXlVcmlUb0tleUluZm8pIHtcbiAgICAgICAgdmFyIGtleUluZm8gPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgICAgICAvLyBSZW1vdmUgY2FjaGVkIEVNRSBrZXlzIG9uIGRldGFjaFxuICAgICAgICBpZiAoa2V5SW5mby5tZWRpYUtleVNlc3Npb25Db250ZXh0IHx8IGtleUluZm8uZGVjcnlwdGRhdGEuaXNDb21tb25FbmNyeXB0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICBmb3IgKHZhciB1cmkgaW4gdGhpcy5rZXlVcmlUb0tleUluZm8pIHtcbiAgICAgICAgdmFyIGxvYWRlciA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0ubG9hZGVyO1xuICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXlVcmlUb0tleUluZm8gPSB7fTtcbiAgICB9O1xuICAgIF9wcm90by5jcmVhdGVLZXlMb2FkRXJyb3IgPSBmdW5jdGlvbiBjcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgZGV0YWlscywgZXJyb3IsIG5ldHdvcmtEZXRhaWxzLCByZXNwb25zZSkge1xuICAgICAgaWYgKGRldGFpbHMgPT09IHZvaWQgMCkge1xuICAgICAgICBkZXRhaWxzID0gRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzOiBuZXR3b3JrRGV0YWlsc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZENsZWFyID0gZnVuY3Rpb24gbG9hZENsZWFyKGxvYWRpbmdGcmFnLCBlbmNyeXB0ZWRGcmFnbWVudHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5lbWVDb250cm9sbGVyICYmIHRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgICAgLy8gYWNjZXNzIGtleS1zeXN0ZW0gd2l0aCBuZWFyZXN0IGtleSBvbiBzdGFydCAobG9haWRuZyBmcmFnIGlzIHVuZW5jcnlwdGVkKVxuICAgICAgICB2YXIgc24gPSBsb2FkaW5nRnJhZy5zbixcbiAgICAgICAgICBjYyA9IGxvYWRpbmdGcmFnLmNjO1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICB2YXIgZnJhZyA9IGVuY3J5cHRlZEZyYWdtZW50c1tpXTtcbiAgICAgICAgICBpZiAoY2MgPD0gZnJhZy5jYyAmJiAoc24gPT09ICdpbml0U2VnbWVudCcgfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyB8fCBzbiA8IGZyYWcuc24pKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWVDb250cm9sbGVyLnNlbGVjdEtleVN5c3RlbUZvcm1hdChmcmFnKS50aGVuKGZ1bmN0aW9uIChrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgZnJhZy5zZXRLZXlGb3JtYXQoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIDE7IC8vIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfbG9vcCgpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGZyYWcpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKCFmcmFnLmRlY3J5cHRkYXRhICYmIGZyYWcuZW5jcnlwdGVkICYmIHRoaXMuZW1lQ29udHJvbGxlcikge1xuICAgICAgICAvLyBNdWx0aXBsZSBrZXlzLCBidXQgbm9uZSBzZWxlY3RlZCwgcmVzb2x2ZSBpbiBlbWUtY29udHJvbGxlclxuICAgICAgICByZXR1cm4gdGhpcy5lbWVDb250cm9sbGVyLnNlbGVjdEtleVN5c3RlbUZvcm1hdChmcmFnKS50aGVuKGZ1bmN0aW9uIChrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmxvYWRJbnRlcm5hbChmcmFnLCBrZXlTeXN0ZW1Gb3JtYXQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxvYWRJbnRlcm5hbChmcmFnKTtcbiAgICB9O1xuICAgIF9wcm90by5sb2FkSW50ZXJuYWwgPSBmdW5jdGlvbiBsb2FkSW50ZXJuYWwoZnJhZywga2V5U3lzdGVtRm9ybWF0KSB7XG4gICAgICB2YXIgX2tleUluZm8sIF9rZXlJbmZvMjtcbiAgICAgIGlmIChrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICAgICAgZnJhZy5zZXRLZXlGb3JtYXQoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgIH1cbiAgICAgIHZhciBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgICBpZiAoIWRlY3J5cHRkYXRhKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihrZXlTeXN0ZW1Gb3JtYXQgPyBcIkV4cGVjdGVkIGZyYWcuZGVjcnlwdGRhdGEgdG8gYmUgZGVmaW5lZCBhZnRlciBzZXR0aW5nIGZvcm1hdCBcIiArIGtleVN5c3RlbUZvcm1hdCA6ICdNaXNzaW5nIGRlY3J5cHRpb24gZGF0YSBvbiBmcmFnbWVudCBpbiBvbktleUxvYWRpbmcnKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgZXJyb3IpKTtcbiAgICAgIH1cbiAgICAgIHZhciB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XG4gICAgICBpZiAoIXVyaSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleSBVUkk6IFxcXCJcIiArIHVyaSArIFwiXFxcIlwiKSkpO1xuICAgICAgfVxuICAgICAgdmFyIGtleUluZm8gPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgICAgaWYgKChfa2V5SW5mbyA9IGtleUluZm8pICE9IG51bGwgJiYgX2tleUluZm8uZGVjcnlwdGRhdGEua2V5KSB7XG4gICAgICAgIGRlY3J5cHRkYXRhLmtleSA9IGtleUluZm8uZGVjcnlwdGRhdGEua2V5O1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIGtleUluZm86IGtleUluZm9cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBSZXR1cm4ga2V5IGxvYWQgcHJvbWlzZSBhcyBsb25nIGFzIGl0IGRvZXMgbm90IGhhdmUgYSBtZWRpYWtleSBzZXNzaW9uIHdpdGggYW4gdW51c2FibGUga2V5IHN0YXR1c1xuICAgICAgaWYgKChfa2V5SW5mbzIgPSBrZXlJbmZvKSAhPSBudWxsICYmIF9rZXlJbmZvMi5rZXlMb2FkUHJvbWlzZSkge1xuICAgICAgICB2YXIgX2tleUluZm8kbWVkaWFLZXlTZXNzO1xuICAgICAgICBzd2l0Y2ggKChfa2V5SW5mbyRtZWRpYUtleVNlc3MgPSBrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfa2V5SW5mbyRtZWRpYUtleVNlc3Mua2V5U3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgY2FzZSAnc3RhdHVzLXBlbmRpbmcnOlxuICAgICAgICAgIGNhc2UgJ3VzYWJsZSc6XG4gICAgICAgICAgY2FzZSAndXNhYmxlLWluLWZ1dHVyZSc6XG4gICAgICAgICAgICByZXR1cm4ga2V5SW5mby5rZXlMb2FkUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChrZXlMb2FkZWREYXRhKSB7XG4gICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY29ycmVjdCBmcmFnbWVudCB3aXRoIHVwZGF0ZWQgZGVjcnlwdGRhdGEga2V5IGFuZCBsb2FkZWQga2V5SW5mb1xuICAgICAgICAgICAgICBkZWNyeXB0ZGF0YS5rZXkgPSBrZXlMb2FkZWREYXRhLmtleUluZm8uZGVjcnlwdGRhdGEua2V5O1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICAgICAga2V5SW5mbzoga2V5SW5mb1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGtleSBzZXNzaW9uIGFuZCBzdGF0dXMgYW5kIGl0IGlzIG5vdCBwZW5kaW5nIG9yIHVzYWJsZSwgY29udGludWVcbiAgICAgICAgLy8gVGhpcyB3aWxsIGdvIGJhY2sgdG8gdGhlIGVtZS1jb250cm9sbGVyIGZvciBleHBpcmVkIGtleXMgdG8gZ2V0IGEgbmV3IGtleUxvYWRQcm9taXNlXG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgdGhlIGtleSBvciByZXR1cm4gdGhlIGxvYWRpbmcgcHJvbWlzZVxuICAgICAga2V5SW5mbyA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0gPSB7XG4gICAgICAgIGRlY3J5cHRkYXRhOiBkZWNyeXB0ZGF0YSxcbiAgICAgICAga2V5TG9hZFByb21pc2U6IG51bGwsXG4gICAgICAgIGxvYWRlcjogbnVsbCxcbiAgICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIHN3aXRjaCAoZGVjcnlwdGRhdGEubWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ0lTTy0yMzAwMS03JzpcbiAgICAgICAgY2FzZSAnU0FNUExFLUFFUyc6XG4gICAgICAgIGNhc2UgJ1NBTVBMRS1BRVMtQ0VOQyc6XG4gICAgICAgIGNhc2UgJ1NBTVBMRS1BRVMtQ1RSJzpcbiAgICAgICAgICBpZiAoZGVjcnlwdGRhdGEua2V5Rm9ybWF0ID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgICAvLyBsb2FkS2V5SFRUUCBoYW5kbGVzIGh0dHAocykgYW5kIGRhdGEgVVJMc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEtleUhUVFAoa2V5SW5mbywgZnJhZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRLZXlFTUUoa2V5SW5mbywgZnJhZyk7XG4gICAgICAgIGNhc2UgJ0FFUy0xMjgnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRLZXlIVFRQKGtleUluZm8sIGZyYWcpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIG5ldyBFcnJvcihcIktleSBzdXBwbGllZCB3aXRoIHVuc3VwcG9ydGVkIE1FVEhPRDogXFxcIlwiICsgZGVjcnlwdGRhdGEubWV0aG9kICsgXCJcXFwiXCIpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZEtleUVNRSA9IGZ1bmN0aW9uIGxvYWRLZXlFTUUoa2V5SW5mbywgZnJhZykge1xuICAgICAgdmFyIGtleUxvYWRlZERhdGEgPSB7XG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGtleUluZm86IGtleUluZm9cbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5lbWVDb250cm9sbGVyICYmIHRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgICAgdmFyIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IHRoaXMuZW1lQ29udHJvbGxlci5sb2FkS2V5KGtleUxvYWRlZERhdGEpO1xuICAgICAgICBpZiAoa2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlKSB7XG4gICAgICAgICAgcmV0dXJuIChrZXlJbmZvLmtleUxvYWRQcm9taXNlID0ga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgICAgICAgICBrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgPSBrZXlTZXNzaW9uQ29udGV4dDtcbiAgICAgICAgICAgIHJldHVybiBrZXlMb2FkZWREYXRhO1xuICAgICAgICAgIH0pKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBwcm9taXNlIGZvciBsaWNlbnNlIHJlbmV3YWwgb3IgcmV0cnlcbiAgICAgICAgICAgIGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5TG9hZGVkRGF0YSk7XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZEtleUhUVFAgPSBmdW5jdGlvbiBsb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICAgIHZhciBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgICAgdmFyIGtleUxvYWRlciA9IG5ldyBMb2FkZXIoY29uZmlnKTtcbiAgICAgIGZyYWcua2V5TG9hZGVyID0ga2V5SW5mby5sb2FkZXIgPSBrZXlMb2FkZXI7XG4gICAgICByZXR1cm4ga2V5SW5mby5rZXlMb2FkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGxvYWRlckNvbnRleHQgPSB7XG4gICAgICAgICAga2V5SW5mbzoga2V5SW5mbyxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICAgICAgICB1cmw6IGtleUluZm8uZGVjcnlwdGRhdGEudXJpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWF4UmV0cnkgaXMgMCBzbyB0aGF0IGluc3RlYWQgb2YgcmV0cnlpbmcgdGhlIHNhbWUga2V5IG9uIHRoZSBzYW1lIHZhcmlhbnQgbXVsdGlwbGUgdGltZXMsXG4gICAgICAgIC8vIGtleS1sb2FkZXIgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGFuZCByZWx5IG9uIHN0cmVhbS1jb250cm9sbGVyIHRvIGhhbmRsZSByZXRyeSBsb2dpYy5cbiAgICAgICAgLy8gdGhpcyB3aWxsIGFsc28gYWxpZ24gcmV0cnkgbG9naWMgd2l0aCBmcmFnbWVudC1sb2FkZXJcbiAgICAgICAgdmFyIGxvYWRQb2xpY3kgPSBjb25maWcua2V5TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgICAgICB2YXIgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICAgIGxvYWRQb2xpY3k6IGxvYWRQb2xpY3ksXG4gICAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgICAgbWF4UmV0cnlEZWxheTogMFxuICAgICAgICB9O1xuICAgICAgICB2YXIgbG9hZGVyQ2FsbGJhY2tzID0ge1xuICAgICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gb25TdWNjZXNzKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICAgICAgICBrZXlJbmZvID0gY29udGV4dC5rZXlJbmZvLFxuICAgICAgICAgICAgICB1cmkgPSBjb250ZXh0LnVybDtcbiAgICAgICAgICAgIGlmICghZnJhZy5kZWNyeXB0ZGF0YSB8fCBrZXlJbmZvICE9PSBfdGhpczMua2V5VXJpVG9LZXlJbmZvW3VyaV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChfdGhpczMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgbmV3IEVycm9yKCdhZnRlciBrZXkgbG9hZCwgZGVjcnlwdGRhdGEgdW5zZXQgb3IgY2hhbmdlZCcpLCBuZXR3b3JrRGV0YWlscykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5SW5mby5kZWNyeXB0ZGF0YS5rZXkgPSBmcmFnLmRlY3J5cHRkYXRhLmtleSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmRhdGEpO1xuXG4gICAgICAgICAgICAvLyBkZXRhY2ggZnJhZ21lbnQga2V5IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICAgICAgICAgIGZyYWcua2V5TG9hZGVyID0gbnVsbDtcbiAgICAgICAgICAgIGtleUluZm8ubG9hZGVyID0gbnVsbDtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgICBrZXlJbmZvOiBrZXlJbmZvXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykge1xuICAgICAgICAgICAgX3RoaXMzLnJlc2V0TG9hZGVyKGNvbnRleHQpO1xuICAgICAgICAgICAgcmVqZWN0KF90aGlzMy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBuZXcgRXJyb3IoXCJIVFRQIEVycm9yIFwiICsgcmVzcG9uc2UuY29kZSArIFwiIGxvYWRpbmcga2V5IFwiICsgcmVzcG9uc2UudGV4dCksIG5ldHdvcmtEZXRhaWxzLCBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSwgcmVzcG9uc2UpKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblRpbWVvdXQ6IGZ1bmN0aW9uIG9uVGltZW91dChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICAgIF90aGlzMy5yZXNldExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgICAgIHJlamVjdChfdGhpczMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VULCBuZXcgRXJyb3IoJ2tleSBsb2FkaW5nIHRpbWVkIG91dCcpLCBuZXR3b3JrRGV0YWlscykpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25BYm9ydDogZnVuY3Rpb24gb25BYm9ydChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpIHtcbiAgICAgICAgICAgIF90aGlzMy5yZXNldExvYWRlcihjb250ZXh0KTtcbiAgICAgICAgICAgIHJlamVjdChfdGhpczMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELCBuZXcgRXJyb3IoJ2tleSBsb2FkaW5nIGFib3J0ZWQnKSwgbmV0d29ya0RldGFpbHMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGtleUxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0TG9hZGVyID0gZnVuY3Rpb24gcmVzZXRMb2FkZXIoY29udGV4dCkge1xuICAgICAgdmFyIGZyYWcgPSBjb250ZXh0LmZyYWcsXG4gICAgICAgIGtleUluZm8gPSBjb250ZXh0LmtleUluZm8sXG4gICAgICAgIHVyaSA9IGNvbnRleHQudXJsO1xuICAgICAgdmFyIGxvYWRlciA9IGtleUluZm8ubG9hZGVyO1xuICAgICAgaWYgKGZyYWcua2V5TG9hZGVyID09PSBsb2FkZXIpIHtcbiAgICAgICAgZnJhZy5rZXlMb2FkZXIgPSBudWxsO1xuICAgICAgICBrZXlJbmZvLmxvYWRlciA9IG51bGw7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBLZXlMb2FkZXI7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBnZXRTb3VyY2VCdWZmZXIoKSB7XG4gICAgcmV0dXJuIHNlbGYuU291cmNlQnVmZmVyIHx8IHNlbGYuV2ViS2l0U291cmNlQnVmZmVyO1xuICB9XG4gIGZ1bmN0aW9uIGlzTVNFU3VwcG9ydGVkKCkge1xuICAgIHZhciBtZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKCk7XG4gICAgaWYgKCFtZWRpYVNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGlmIFNvdXJjZUJ1ZmZlciBpcyBleHBvc2VkIGVuc3VyZSBpdHMgQVBJIGlzIHZhbGlkXG4gICAgLy8gT2xkZXIgYnJvd3NlcnMgZG8gbm90IGV4cG9zZSBTb3VyY2VCdWZmZXIgZ2xvYmFsbHkgc28gY2hlY2tpbmcgU291cmNlQnVmZmVyLnByb3RvdHlwZSBpcyBpbXBvc3NpYmxlXG4gICAgdmFyIHNvdXJjZUJ1ZmZlciA9IGdldFNvdXJjZUJ1ZmZlcigpO1xuICAgIHJldHVybiAhc291cmNlQnVmZmVyIHx8IHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUgJiYgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUuYXBwZW5kQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VCdWZmZXIucHJvdG90eXBlLnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuICBmdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgICBpZiAoIWlzTVNFU3VwcG9ydGVkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoKTtcbiAgICByZXR1cm4gdHlwZW9mIChtZWRpYVNvdXJjZSA9PSBudWxsID8gdm9pZCAwIDogbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKSA9PT0gJ2Z1bmN0aW9uJyAmJiAoWydhdmMxLjQyRTAxRSxtcDRhLjQwLjInLCAnYXYwMS4wLjAxTS4wOCcsICd2cDA5LjAwLjUwLjA4J10uc29tZShmdW5jdGlvbiAoY29kZWNzRm9yVmlkZW9Db250YWluZXIpIHtcbiAgICAgIHJldHVybiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQobWltZVR5cGVGb3JDb2RlYyhjb2RlY3NGb3JWaWRlb0NvbnRhaW5lciwgJ3ZpZGVvJykpO1xuICAgIH0pIHx8IFsnbXA0YS40MC4yJywgJ2ZMYUMnXS5zb21lKGZ1bmN0aW9uIChjb2RlY0ZvckF1ZGlvQ29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKG1pbWVUeXBlRm9yQ29kZWMoY29kZWNGb3JBdWRpb0NvbnRhaW5lciwgJ2F1ZGlvJykpO1xuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBjaGFuZ2VUeXBlU3VwcG9ydGVkKCkge1xuICAgIHZhciBfc291cmNlQnVmZmVyJHByb3RvdHk7XG4gICAgdmFyIHNvdXJjZUJ1ZmZlciA9IGdldFNvdXJjZUJ1ZmZlcigpO1xuICAgIHJldHVybiB0eXBlb2YgKHNvdXJjZUJ1ZmZlciA9PSBudWxsID8gdm9pZCAwIDogKF9zb3VyY2VCdWZmZXIkcHJvdG90eSA9IHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfc291cmNlQnVmZmVyJHByb3RvdHkuY2hhbmdlVHlwZSkgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICB2YXIgU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUyA9IDI1MDtcbiAgdmFyIE1BWF9TVEFSVF9HQVBfSlVNUCA9IDIuMDtcbiAgdmFyIFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTID0gMC4xO1xuICB2YXIgU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQgPSAwLjA1O1xuICB2YXIgR2FwQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR2FwQ29udHJvbGxlcihjb25maWcsIG1lZGlhLCBmcmFnbWVudFRyYWNrZXIsIGhscykge1xuICAgICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gdm9pZCAwO1xuICAgICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zZWVraW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gZnJhZ21lbnRUcmFja2VyO1xuICAgICAgdGhpcy5obHMgPSBobHM7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBHYXBDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuaGxzID0gdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcGxheWhlYWQgaXMgc3R1Y2sgd2l0aGluIGEgZ2FwLCBhbmQgaWYgc28sIGF0dGVtcHRzIHRvIGZyZWUgaXQuXG4gICAgICogQSBnYXAgaXMgYW4gdW5idWZmZXJlZCByYW5nZSBiZXR3ZWVuIHR3byBidWZmZXJlZCByYW5nZXMgKG9yIHRoZSBzdGFydCBhbmQgdGhlIGZpcnN0IGJ1ZmZlcmVkIHJhbmdlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXN0Q3VycmVudFRpbWUgLSBQcmV2aW91c2x5IHJlYWQgcGxheWhlYWQgcG9zaXRpb25cbiAgICAgKi87XG4gICAgX3Byb3RvLnBvbGwgPSBmdW5jdGlvbiBwb2xsKGxhc3RDdXJyZW50VGltZSwgYWN0aXZlRnJhZykge1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWEsXG4gICAgICAgIHN0YWxsZWQgPSB0aGlzLnN0YWxsZWQ7XG4gICAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWUsXG4gICAgICAgIHNlZWtpbmcgPSBtZWRpYS5zZWVraW5nO1xuICAgICAgdmFyIHNlZWtlZCA9IHRoaXMuc2Vla2luZyAmJiAhc2Vla2luZztcbiAgICAgIHZhciBiZWdpblNlZWsgPSAhdGhpcy5zZWVraW5nICYmIHNlZWtpbmc7XG4gICAgICB0aGlzLnNlZWtpbmcgPSBzZWVraW5nO1xuXG4gICAgICAvLyBUaGUgcGxheWhlYWQgaXMgbW92aW5nLCBuby1vcFxuICAgICAgaWYgKGN1cnJlbnRUaW1lICE9PSBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XG4gICAgICAgIGlmICghc2Vla2luZykge1xuICAgICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWxsZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGUgcGxheWhlYWQgaXMgbm93IG1vdmluZywgYnV0IHdhcyBwcmV2aW91c2x5IHN0YWxsZWRcbiAgICAgICAgICBpZiAodGhpcy5zdGFsbFJlcG9ydGVkKSB7XG4gICAgICAgICAgICB2YXIgX3N0YWxsZWREdXJhdGlvbiA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgLSBzdGFsbGVkO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJwbGF5YmFjayBub3Qgc3R1Y2sgYW55bW9yZSBAXCIgKyBjdXJyZW50VGltZSArIFwiLCBhZnRlciBcIiArIE1hdGgucm91bmQoX3N0YWxsZWREdXJhdGlvbikgKyBcIm1zXCIpO1xuICAgICAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciBzdGFsbGVkIHN0YXRlIHdoZW4gYmVnaW5uaW5nIG9yIGZpbmlzaGluZyBzZWVraW5nIHNvIHRoYXQgd2UgZG9uJ3QgcmVwb3J0IHN0YWxscyBjb21pbmcgb3V0IG9mIGEgc2Vla1xuICAgICAgaWYgKGJlZ2luU2VlayB8fCBzZWVrZWQpIHtcbiAgICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcGxheWhlYWQgc2hvdWxkIG5vdCBiZSBtb3ZpbmdcbiAgICAgIGlmIChtZWRpYS5wYXVzZWQgJiYgIXNlZWtpbmcgfHwgbWVkaWEuZW5kZWQgfHwgbWVkaWEucGxheWJhY2tSYXRlID09PSAwIHx8ICFCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhLCBjdXJyZW50VGltZSwgMCk7XG4gICAgICB2YXIgbmV4dFN0YXJ0ID0gYnVmZmVySW5mby5uZXh0U3RhcnQgfHwgMDtcbiAgICAgIGlmIChzZWVraW5nKSB7XG4gICAgICAgIC8vIFdhaXRpbmcgZm9yIHNlZWtpbmcgaW4gYSBidWZmZXJlZCByYW5nZSB0byBjb21wbGV0ZVxuICAgICAgICB2YXIgaGFzRW5vdWdoQnVmZmVyID0gYnVmZmVySW5mby5sZW4gPiBNQVhfU1RBUlRfR0FQX0pVTVA7XG4gICAgICAgIC8vIE5leHQgYnVmZmVyZWQgcmFuZ2UgaXMgdG9vIGZhciBhaGVhZCB0byBqdW1wIHRvIHdoaWxlIHN0aWxsIHNlZWtpbmdcbiAgICAgICAgdmFyIG5vQnVmZmVyR2FwID0gIW5leHRTdGFydCB8fCBhY3RpdmVGcmFnICYmIGFjdGl2ZUZyYWcuc3RhcnQgPD0gY3VycmVudFRpbWUgfHwgbmV4dFN0YXJ0IC0gY3VycmVudFRpbWUgPiBNQVhfU1RBUlRfR0FQX0pVTVAgJiYgIXRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG4gICAgICAgIGlmIChoYXNFbm91Z2hCdWZmZXIgfHwgbm9CdWZmZXJHYXApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgbW92ZWQgc3RhdGUgd2hlbiBzZWVraW5nIHRvIGEgcG9pbnQgaW4gb3IgYmVmb3JlIGEgZ2FwXG4gICAgICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBzdGFydCBnYXBzIGlmIHdlIGhhdmVuJ3QgcGxheWVkLCBidXQgdGhlIGxhc3QgcG9sbCBkZXRlY3RlZCB0aGUgc3RhcnQgb2YgYSBzdGFsbFxuICAgICAgLy8gVGhlIGFkZGl0aW9uIHBvbGwgZ2l2ZXMgdGhlIGJyb3dzZXIgYSBjaGFuY2UgdG8ganVtcCB0aGUgZ2FwIGZvciB1c1xuICAgICAgaWYgKCF0aGlzLm1vdmVkICYmIHRoaXMuc3RhbGxlZCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2xldmVsJGRldGFpbHM7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIHBsYXlhYmxlIGJ1ZmZlciAoc2Vla2VkLCB3YWl0aW5nIGZvciBidWZmZXIpXG4gICAgICAgIHZhciBpc0J1ZmZlcmVkID0gYnVmZmVySW5mby5sZW4gPiAwO1xuICAgICAgICBpZiAoIWlzQnVmZmVyZWQgJiYgIW5leHRTdGFydCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBKdW1wIHN0YXJ0IGdhcHMgd2l0aGluIGp1bXAgdGhyZXNob2xkXG4gICAgICAgIHZhciBzdGFydEp1bXAgPSBNYXRoLm1heChuZXh0U3RhcnQsIGJ1ZmZlckluZm8uc3RhcnQgfHwgMCkgLSBjdXJyZW50VGltZTtcblxuICAgICAgICAvLyBXaGVuIGpvaW5pbmcgYSBsaXZlIHN0cmVhbSB3aXRoIGF1ZGlvIHRyYWNrcywgYWNjb3VudCBmb3IgbGl2ZSBwbGF5bGlzdCB3aW5kb3cgc2xpZGluZyBieSBhbGxvd2luZ1xuICAgICAgICAvLyBhIGxhcmdlciBqdW1wIG92ZXIgc3RhcnQgZ2FwcyBjYXVzZWQgYnkgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGJ1ZmZlcmluZyBhIHN0YXJ0IGZyYWdtZW50XG4gICAgICAgIC8vIHRoYXQgYmVnaW5zIG92ZXIgMSB0YXJnZXQgZHVyYXRpb24gYWZ0ZXIgdGhlIHZpZGVvIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHMgPyB0aGlzLmhscy5sZXZlbHNbdGhpcy5obHMuY3VycmVudExldmVsXSA6IG51bGw7XG4gICAgICAgIHZhciBpc0xpdmUgPSBsZXZlbCA9PSBudWxsID8gdm9pZCAwIDogKF9sZXZlbCRkZXRhaWxzID0gbGV2ZWwuZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbCRkZXRhaWxzLmxpdmU7XG4gICAgICAgIHZhciBtYXhTdGFydEdhcEp1bXAgPSBpc0xpdmUgPyBsZXZlbC5kZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMiA6IE1BWF9TVEFSVF9HQVBfSlVNUDtcbiAgICAgICAgdmFyIHBhcnRpYWxPckdhcCA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG4gICAgICAgIGlmIChzdGFydEp1bXAgPiAwICYmIChzdGFydEp1bXAgPD0gbWF4U3RhcnRHYXBKdW1wIHx8IHBhcnRpYWxPckdhcCkpIHtcbiAgICAgICAgICBpZiAoIW1lZGlhLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUocGFydGlhbE9yR2FwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXJ0IHRyYWNraW5nIHN0YWxsIHRpbWVcbiAgICAgIHZhciB0bm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGlmIChzdGFsbGVkID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhbGxlZCA9IHRub3c7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdGFsbGVkRHVyYXRpb24gPSB0bm93IC0gc3RhbGxlZDtcbiAgICAgIGlmICghc2Vla2luZyAmJiBzdGFsbGVkRHVyYXRpb24gPj0gU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUykge1xuICAgICAgICAvLyBSZXBvcnQgc3RhbGxpbmcgYWZ0ZXIgdHJ5aW5nIHRvIGZpeFxuICAgICAgICB0aGlzLl9yZXBvcnRTdGFsbChidWZmZXJJbmZvKTtcbiAgICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYnVmZmVyZWRXaXRoSG9sZXMgPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICAgIHRoaXMuX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlcmVkV2l0aEhvbGVzLCBzdGFsbGVkRHVyYXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVjdHMgYW5kIGF0dGVtcHRzIHRvIGZpeCBrbm93biBidWZmZXIgc3RhbGxpbmcgaXNzdWVzLlxuICAgICAqIEBwYXJhbSBidWZmZXJJbmZvIC0gVGhlIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgYnVmZmVyLlxuICAgICAqIEBwYXJhbSBzdGFsbGVkRHVyYXRpb25NcyAtIFRoZSBhbW91bnQgb2YgdGltZSBIbHMuanMgaGFzIGJlZW4gc3RhbGxpbmcgZm9yLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovO1xuICAgIF9wcm90by5fdHJ5Rml4QnVmZmVyU3RhbGwgPSBmdW5jdGlvbiBfdHJ5Rml4QnVmZmVyU3RhbGwoYnVmZmVySW5mbywgc3RhbGxlZER1cmF0aW9uTXMpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgZnJhZ21lbnRUcmFja2VyID0gdGhpcy5mcmFnbWVudFRyYWNrZXIsXG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIHZhciBwYXJ0aWFsID0gZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG4gICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAvLyBUcnkgdG8gc2tpcCBvdmVyIHRoZSBidWZmZXIgaG9sZSBjYXVzZWQgYnkgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzbid0IGxpbWl0ZWQgYnkgdGhlIHNpemUgb2YgdGhlIGdhcCBiZXR3ZWVuIGJ1ZmZlcmVkIHJhbmdlc1xuICAgICAgICB2YXIgdGFyZ2V0VGltZSA9IHRoaXMuX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWwpO1xuICAgICAgICAvLyB3ZSByZXR1cm4gaGVyZSBpbiB0aGlzIGNhc2UsIG1lYW5pbmdcbiAgICAgICAgLy8gdGhlIGJyYW5jaCBiZWxvdyBvbmx5IGV4ZWN1dGVzIHdoZW4gd2UgaGF2ZW4ndCBzZWVrZWQgdG8gYSBuZXcgcG9zaXRpb25cbiAgICAgICAgaWYgKHRhcmdldFRpbWUgfHwgIXRoaXMubWVkaWEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2UgaGF2ZW4ndCBoYWQgdG8gc2tpcCBvdmVyIGEgYnVmZmVyIGhvbGUgb2YgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgICAvLyB3ZSBtYXkganVzdCBoYXZlIHRvIFwibnVkZ2VcIiB0aGUgcGxheWxpc3QgYXMgdGhlIGJyb3dzZXIgZGVjb2RpbmcvcmVuZGVyaW5nIGVuZ2luZVxuICAgICAgLy8gbmVlZHMgdG8gY3Jvc3Mgc29tZSBzb3J0IG9mIHRocmVzaG9sZCBjb3ZlcmluZyBhbGwgc291cmNlLWJ1ZmZlcnMgY29udGVudFxuICAgICAgLy8gdG8gc3RhcnQgcGxheWluZyBwcm9wZXJseS5cbiAgICAgIGlmICgoYnVmZmVySW5mby5sZW4gPiBjb25maWcubWF4QnVmZmVySG9sZSB8fCBidWZmZXJJbmZvLm5leHRTdGFydCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCAtIGN1cnJlbnRUaW1lIDwgY29uZmlnLm1heEJ1ZmZlckhvbGUpICYmIHN0YWxsZWREdXJhdGlvbk1zID4gY29uZmlnLmhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZCAqIDEwMDApIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1RyeWluZyB0byBudWRnZSBwbGF5aGVhZCBvdmVyIGJ1ZmZlci1ob2xlJyk7XG4gICAgICAgIC8vIFRyeSB0byBudWRnZSBjdXJyZW50VGltZSBvdmVyIGEgYnVmZmVyIGhvbGUgaWYgd2UndmUgYmVlbiBzdGFsbGluZyBmb3IgdGhlIGNvbmZpZ3VyZWQgYW1vdW50IG9mIHNlY29uZHNcbiAgICAgICAgLy8gV2Ugb25seSB0cnkgdG8ganVtcCB0aGUgaG9sZSBpZiBpdCdzIHVuZGVyIHRoZSBjb25maWd1cmVkIHNpemVcbiAgICAgICAgLy8gUmVzZXQgc3RhbGxlZCBzbyB0byByZWFybSB3YXRjaGRvZyB0aW1lclxuICAgICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgICB0aGlzLl90cnlOdWRnZUJ1ZmZlcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGEgQlVGRkVSX1NUQUxMRURfRVJST1IgZXZlbnQsIGJ1dCBvbmx5IG9uY2UgcGVyIHN0YWxsIHBlcmlvZC5cbiAgICAgKiBAcGFyYW0gYnVmZmVyTGVuIC0gVGhlIHBsYXloZWFkIGRpc3RhbmNlIGZyb20gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXIgc2VnbWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqLztcbiAgICBfcHJvdG8uX3JlcG9ydFN0YWxsID0gZnVuY3Rpb24gX3JlcG9ydFN0YWxsKGJ1ZmZlckluZm8pIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBzdGFsbFJlcG9ydGVkID0gdGhpcy5zdGFsbFJlcG9ydGVkO1xuICAgICAgaWYgKCFzdGFsbFJlcG9ydGVkICYmIG1lZGlhKSB7XG4gICAgICAgIC8vIFJlcG9ydCBzdGFsbGVkIGVycm9yIG9uY2VcbiAgICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiUGxheWJhY2sgc3RhbGxpbmcgYXQgQFwiICsgbWVkaWEuY3VycmVudFRpbWUgKyBcIiBkdWUgdG8gbG93IGJ1ZmZlciAoXCIgKyBKU09OLnN0cmluZ2lmeShidWZmZXJJbmZvKSArIFwiKVwiKTtcbiAgICAgICAgbG9nZ2VyLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgYnVmZmVyOiBidWZmZXJJbmZvLmxlblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBqdW1waW5nIG92ZXIga25vd24gZ2FwcyBjYXVzZWQgYnkgcGFydGlhbCBmcmFnbWVudHNcbiAgICAgKiBAcGFyYW0gcGFydGlhbCAtIFRoZSBwYXJ0aWFsIGZyYWdtZW50IGZvdW5kIGF0IHRoZSBjdXJyZW50IHRpbWUgKHdoZXJlIHBsYXliYWNrIGlzIHN0YWxsaW5nKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqLztcbiAgICBfcHJvdG8uX3RyeVNraXBCdWZmZXJIb2xlID0gZnVuY3Rpb24gX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWwpIHtcbiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgICAgaGxzID0gdGhpcy5obHMsXG4gICAgICAgIG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgY3VycmVudFRpbWUgaXMgYmV0d2VlbiB1bmJ1ZmZlcmVkIHJlZ2lvbnMgb2YgcGFydGlhbCBmcmFnbWVudHNcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgdmFyIGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lIDwgYnVmZmVySW5mby5zdGFydCA/IGJ1ZmZlckluZm8uc3RhcnQgOiBidWZmZXJJbmZvLm5leHRTdGFydDtcbiAgICAgIGlmIChzdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIGJ1ZmZlclN0YXJ2ZWQgPSBidWZmZXJJbmZvLmxlbiA8PSBjb25maWcubWF4QnVmZmVySG9sZTtcbiAgICAgICAgdmFyIHdhaXRpbmcgPSBidWZmZXJJbmZvLmxlbiA+IDAgJiYgYnVmZmVySW5mby5sZW4gPCAxICYmIG1lZGlhLnJlYWR5U3RhdGUgPCAzO1xuICAgICAgICB2YXIgZ2FwTGVuZ3RoID0gc3RhcnRUaW1lIC0gY3VycmVudFRpbWU7XG4gICAgICAgIGlmIChnYXBMZW5ndGggPiAwICYmIChidWZmZXJTdGFydmVkIHx8IHdhaXRpbmcpKSB7XG4gICAgICAgICAgLy8gT25seSBhbGxvdyBsYXJnZSBnYXBzIHRvIGJlIHNraXBwZWQgaWYgaXQgaXMgYSBzdGFydCBnYXAsIG9yIGFsbCBmcmFnbWVudHMgaW4gc2tpcCByYW5nZSBhcmUgcGFydGlhbFxuICAgICAgICAgIGlmIChnYXBMZW5ndGggPiBjb25maWcubWF4QnVmZmVySG9sZSkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50VHJhY2tlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyO1xuICAgICAgICAgICAgdmFyIHN0YXJ0R2FwID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPT09IDApIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0RnJhZyA9IGZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcoMCwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgICAgICAgIGlmIChzdGFydEZyYWcgJiYgc3RhcnRUaW1lIDwgc3RhcnRGcmFnLmVuZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0R2FwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGFydEdhcCkge1xuICAgICAgICAgICAgICB2YXIgc3RhcnRQcm92aXNpb25lZCA9IHBhcnRpYWwgfHwgZnJhZ21lbnRUcmFja2VyLmdldEFwcGVuZGVkRnJhZyhjdXJyZW50VGltZSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgICAgICAgIGlmIChzdGFydFByb3Zpc2lvbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vcmVUb0xvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gc3RhcnRQcm92aXNpb25lZC5lbmQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHByb3Zpc2lvbmVkID0gZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChwb3MpO1xuICAgICAgICAgICAgICAgICAgaWYgKHByb3Zpc2lvbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBwcm92aXNpb25lZC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vcmVUb0xvYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vcmVUb0xvYWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGFyZ2V0VGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSArIFNLSVBfQlVGRkVSX1JBTkdFX1NUQVJULCBjdXJyZW50VGltZSArIFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTKTtcbiAgICAgICAgICBsb2dnZXIud2FybihcInNraXBwaW5nIGhvbGUsIGFkanVzdGluZyBjdXJyZW50VGltZSBmcm9tIFwiICsgY3VycmVudFRpbWUgKyBcIiB0byBcIiArIHRhcmdldFRpbWUpO1xuICAgICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xuICAgICAgICAgIGlmIChwYXJ0aWFsICYmICFwYXJ0aWFsLmdhcCkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiZnJhZ21lbnQgbG9hZGVkIHdpdGggYnVmZmVyIGhvbGVzLCBzZWVraW5nIGZyb20gXCIgKyBjdXJyZW50VGltZSArIFwiIHRvIFwiICsgdGFyZ2V0VGltZSk7XG4gICAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRSxcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgZnJhZzogcGFydGlhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0YXJnZXRUaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBhZHZhbmNpbmcgdGhlIG1lZGlhRWxlbWVudCdzIGN1cnJlbnQgdGltZSBieSBhIHNtYWxsIGFtb3VudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqLztcbiAgICBfcHJvdG8uX3RyeU51ZGdlQnVmZmVyID0gZnVuY3Rpb24gX3RyeU51ZGdlQnVmZmVyKCkge1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuICAgICAgICBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhLFxuICAgICAgICBudWRnZVJldHJ5ID0gdGhpcy5udWRnZVJldHJ5O1xuICAgICAgaWYgKG1lZGlhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5udWRnZVJldHJ5Kys7XG4gICAgICBpZiAobnVkZ2VSZXRyeSA8IGNvbmZpZy5udWRnZU1heFJldHJ5KSB7XG4gICAgICAgIHZhciB0YXJnZXRUaW1lID0gY3VycmVudFRpbWUgKyAobnVkZ2VSZXRyeSArIDEpICogY29uZmlnLm51ZGdlT2Zmc2V0O1xuICAgICAgICAvLyBwbGF5YmFjayBzdGFsbGVkIGluIGJ1ZmZlcmVkIGFyZWEgLi4uIGxldCdzIG51ZGdlIGN1cnJlbnRUaW1lIHRvIHRyeSB0byBvdmVyY29tZSB0aGlzXG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIk51ZGdpbmcgJ2N1cnJlbnRUaW1lJyBmcm9tIFwiICsgY3VycmVudFRpbWUgKyBcIiB0byBcIiArIHRhcmdldFRpbWUpO1xuICAgICAgICBsb2dnZXIud2FybihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEwsXG4gICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfZXJyb3IgPSBuZXcgRXJyb3IoXCJQbGF5aGVhZCBzdGlsbCBub3QgbW92aW5nIHdoaWxlIGVub3VnaCBkYXRhIGJ1ZmZlcmVkIEBcIiArIGN1cnJlbnRUaW1lICsgXCIgYWZ0ZXIgXCIgKyBjb25maWcubnVkZ2VNYXhSZXRyeSArIFwiIG51ZGdlc1wiKTtcbiAgICAgICAgbG9nZ2VyLmVycm9yKF9lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgICAgZXJyb3I6IF9lcnJvcixcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHYXBDb250cm9sbGVyO1xuICB9KCk7XG5cbiAgdmFyIFRJQ0tfSU5URVJWQUwgPSAxMDA7IC8vIGhvdyBvZnRlbiB0byB0aWNrIGluIG1zXG4gIHZhciBTdHJlYW1Db250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICBfaW5oZXJpdHNMb29zZShTdHJlYW1Db250cm9sbGVyLCBfQmFzZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIGZ1bmN0aW9uIFN0cmVhbUNvbnRyb2xsZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX3RoaXMgPSBfQmFzZVN0cmVhbUNvbnRyb2xsZXIuY2FsbCh0aGlzLCBobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCAnW3N0cmVhbS1jb250cm9sbGVyXScsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHx8IHRoaXM7XG4gICAgICBfdGhpcy5hdWRpb0NvZGVjU3dhcCA9IGZhbHNlO1xuICAgICAgX3RoaXMuZ2FwQ29udHJvbGxlciA9IG51bGw7XG4gICAgICBfdGhpcy5sZXZlbCA9IC0xO1xuICAgICAgX3RoaXMuX2ZvcmNlU3RhcnRMb2FkID0gZmFsc2U7XG4gICAgICBfdGhpcy5hbHRBdWRpbyA9IGZhbHNlO1xuICAgICAgX3RoaXMuYXVkaW9Pbmx5ID0gZmFsc2U7XG4gICAgICBfdGhpcy5mcmFnUGxheWluZyA9IG51bGw7XG4gICAgICBfdGhpcy5vbnZwbGF5aW5nID0gbnVsbDtcbiAgICAgIF90aGlzLm9udnNlZWtlZCA9IG51bGw7XG4gICAgICBfdGhpcy5mcmFnTGFzdEticHMgPSAwO1xuICAgICAgX3RoaXMuY291bGRCYWNrdHJhY2sgPSBmYWxzZTtcbiAgICAgIF90aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgIF90aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggPSBmYWxzZTtcbiAgICAgIF90aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICAgIF90aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLl9yZWdpc3Rlckxpc3RlbmVycyA9IGZ1bmN0aW9uIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHRoaXMub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8uX3VucmVnaXN0ZXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwgdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25IYW5kbGVyRGVzdHJveWluZyA9IGZ1bmN0aW9uIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3lpbmcuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5zdGFydExvYWQgPSBmdW5jdGlvbiBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgICAgaWYgKHRoaXMubGV2ZWxzKSB7XG4gICAgICAgIHZhciBsYXN0Q3VycmVudFRpbWUgPSB0aGlzLmxhc3RDdXJyZW50VGltZSxcbiAgICAgICAgICBobHMgPSB0aGlzLmhscztcbiAgICAgICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwpO1xuICAgICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAvLyBkZXRlcm1pbmUgbG9hZCBsZXZlbFxuICAgICAgICAgIHZhciBzdGFydExldmVsID0gaGxzLnN0YXJ0TGV2ZWw7XG4gICAgICAgICAgaWYgKHN0YXJ0TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoaGxzLmNvbmZpZy50ZXN0QmFuZHdpZHRoICYmIHRoaXMubGV2ZWxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgLy8gLTEgOiBndWVzcyBzdGFydCBMZXZlbCBieSBkb2luZyBhIGJpdHJhdGUgdGVzdCBieSBsb2FkaW5nIGZpcnN0IGZyYWdtZW50IG9mIGxvd2VzdCBxdWFsaXR5IGxldmVsXG4gICAgICAgICAgICAgIHN0YXJ0TGV2ZWwgPSAwO1xuICAgICAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXJ0TGV2ZWwgPSBobHMuZmlyc3RBdXRvTGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNldCBuZXcgbGV2ZWwgdG8gcGxheWxpc3QgbG9hZGVyIDogdGhpcyB3aWxsIHRyaWdnZXIgc3RhcnQgbGV2ZWwgbG9hZFxuICAgICAgICAgIC8vIGhscy5uZXh0TG9hZExldmVsIHJlbWFpbnMgdW50aWwgaXQgaXMgc2V0IHRvIGEgbmV3IHZhbHVlIG9yIHVudGlsIGEgbmV3IGZyYWcgaXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZFxuICAgICAgICAgIGhscy5uZXh0TG9hZExldmVsID0gc3RhcnRMZXZlbDtcbiAgICAgICAgICB0aGlzLmxldmVsID0gaGxzLmxvYWRMZXZlbDtcbiAgICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgc3RhcnRQb3NpdGlvbiB1bmRlZmluZWQgYnV0IGxhc3RDdXJyZW50VGltZSBzZXQsIHNldCBzdGFydFBvc2l0aW9uIHRvIGxhc3QgY3VycmVudFRpbWVcbiAgICAgICAgaWYgKGxhc3RDdXJyZW50VGltZSA+IDAgJiYgc3RhcnRQb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICB0aGlzLmxvZyhcIk92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQFwiICsgbGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMykpO1xuICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSBsYXN0Q3VycmVudFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnN0b3BMb2FkID0gZnVuY3Rpb24gc3RvcExvYWQoKSB7XG4gICAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5zdG9wTG9hZC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgX3Byb3RvLmRvVGljayA9IGZ1bmN0aW9uIGRvVGljaygpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlIFN0YXRlLldBSVRJTkdfTEVWRUw6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWw7XG4gICAgICAgICAgICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbHNbbGV2ZWxdO1xuICAgICAgICAgICAgdmFyIGRldGFpbHMgPSBjdXJyZW50TGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRMZXZlbC5kZXRhaWxzO1xuICAgICAgICAgICAgaWYgKGRldGFpbHMgJiYgKCFkZXRhaWxzLmxpdmUgfHwgdGhpcy5sZXZlbExhc3RMb2FkZWQgPT09IGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihkZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5obHMubmV4dExvYWRMZXZlbCAhPT0gdGhpcy5sZXZlbCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF90aGlzJG1lZGlhO1xuICAgICAgICAgICAgdmFyIG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICB2YXIgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICAgICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgICAgaWYgKCFyZXRyeURhdGUgfHwgbm93ID49IHJldHJ5RGF0ZSB8fCAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSAhPSBudWxsICYmIF90aGlzJG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICAgICAgdmFyIF9sZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgICAgICAgICBfbGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgICAgICAgICB2YXIgX2N1cnJlbnRMZXZlbCA9IF9sZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbHNbX2xldmVsXTtcbiAgICAgICAgICAgICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZChfY3VycmVudExldmVsIHx8IG51bGwpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuSURMRSkge1xuICAgICAgICB0aGlzLmRvVGlja0lkbGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub25UaWNrRW5kKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25UaWNrRW5kID0gZnVuY3Rpb24gb25UaWNrRW5kKCkge1xuICAgICAgX0Jhc2VTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5vblRpY2tFbmQuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgICAgIHRoaXMuY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgICB9O1xuICAgIF9wcm90by5kb1RpY2tJZGxlID0gZnVuY3Rpb24gZG9UaWNrSWRsZSgpIHtcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscyxcbiAgICAgICAgbGV2ZWxMYXN0TG9hZGVkID0gdGhpcy5sZXZlbExhc3RMb2FkZWQsXG4gICAgICAgIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgICBtZWRpYSA9IHRoaXMubWVkaWE7XG5cbiAgICAgIC8vIGlmIHN0YXJ0IGxldmVsIG5vdCBwYXJzZWQgeWV0IE9SXG4gICAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggbm90IGVuYWJsZWRcbiAgICAgIC8vIGV4aXQgbG9vcCwgYXMgd2UgZWl0aGVyIG5lZWQgbW9yZSBpbmZvIChsZXZlbCBub3QgcGFyc2VkKSBvciB3ZSBuZWVkIG1lZGlhIHRvIGJlIGF0dGFjaGVkIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICBpZiAobGV2ZWxMYXN0TG9hZGVkID09PSBudWxsIHx8ICFtZWRpYSAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWhscy5jb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIFwibWFpblwiIGxldmVsIGlzIGF1ZGlvLW9ubHkgYnV0IHdlIGFyZSBsb2FkaW5nIGFuIGFsdGVybmF0ZSB0cmFjayBpbiB0aGUgc2FtZSBncm91cCwgZG8gbm90IGxvYWQgYW55dGhpbmdcbiAgICAgIGlmICh0aGlzLmFsdEF1ZGlvICYmIHRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsZXZlbCA9IGhscy5uZXh0TG9hZExldmVsO1xuICAgICAgaWYgKCEobGV2ZWxzICE9IG51bGwgJiYgbGV2ZWxzW2xldmVsXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGxldmVsSW5mbyA9IGxldmVsc1tsZXZlbF07XG5cbiAgICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuXG4gICAgICB2YXIgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0RGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgICBpZiAobGFzdERldGFpbHMgJiYgdGhpcy5fc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgbGFzdERldGFpbHMpKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIGlmICh0aGlzLmFsdEF1ZGlvKSB7XG4gICAgICAgICAgZGF0YS50eXBlID0gJ3ZpZGVvJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRU9TLCBkYXRhKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXG4gICAgICBpZiAoaGxzLmxvYWRMZXZlbCAhPT0gbGV2ZWwgJiYgaGxzLm1hbnVhbExldmVsID09PSAtMSkge1xuICAgICAgICB0aGlzLmxvZyhcIkFkYXB0aW5nIHRvIGxldmVsIFwiICsgbGV2ZWwgKyBcIiBmcm9tIGxldmVsIFwiICsgdGhpcy5sZXZlbCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxldmVsID0gaGxzLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgICAgIHZhciBsZXZlbERldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICAgIC8vIGlmIGxldmVsIGluZm8gbm90IHJldHJpZXZlZCB5ZXQsIHN3aXRjaCBzdGF0ZSBhbmQgd2FpdCBmb3IgbGV2ZWwgcmV0cmlldmFsXG4gICAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcbiAgICAgIC8vIGEgdXNlbGVzcyBhbmQgb3V0ZGF0ZWQgZnJhZ21lbnQgKHRoYXQgbWlnaHQgZXZlbiBpbnRyb2R1Y2UgbG9hZCBlcnJvciBpZiBpdCBpcyBhbHJlYWR5IG91dCBvZiB0aGUgbGl2ZSBwbGF5bGlzdClcbiAgICAgIGlmICghbGV2ZWxEZXRhaWxzIHx8IHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwgfHwgbGV2ZWxEZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsSW5mbykge1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG5cbiAgICAgIC8vIGNvbXB1dGUgbWF4IEJ1ZmZlciBMZW5ndGggdGhhdCB3ZSBjb3VsZCBnZXQgZnJvbSB0aGlzIGxvYWQgbGV2ZWwsIGJhc2VkIG9uIGxldmVsIGJpdHJhdGUuIGRvbid0IGJ1ZmZlciBtb3JlIHRoYW4gNjAgTUIgYW5kIG1vcmUgdGhhbiAzMHNcbiAgICAgIHZhciBtYXhCdWZMZW4gPSB0aGlzLmdldE1heEJ1ZmZlckxlbmd0aChsZXZlbEluZm8ubWF4Qml0cmF0ZSk7XG5cbiAgICAgIC8vIFN0YXkgaWRsZSBpZiB3ZSBhcmUgc3RpbGwgd2l0aCBidWZmZXIgbWFyZ2luc1xuICAgICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgJiYgdGhpcy5iYWNrdHJhY2tGcmFnbWVudC5zdGFydCA+IGJ1ZmZlckluZm8uZW5kKSB7XG4gICAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHRhcmdldEJ1ZmZlclRpbWUgPSB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID8gdGhpcy5iYWNrdHJhY2tGcmFnbWVudC5zdGFydCA6IGJ1ZmZlckluZm8uZW5kO1xuICAgICAgdmFyIGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0YXJnZXRCdWZmZXJUaW1lLCBsZXZlbERldGFpbHMpO1xuICAgICAgLy8gQXZvaWQgYmFja3RyYWNraW5nIGJ5IGxvYWRpbmcgYW4gZWFybGllciBzZWdtZW50IGluIHN0cmVhbXMgd2l0aCBzZWdtZW50cyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIGEga2V5IGZyYW1lIChmbGFnZ2VkIGJ5IGBjb3VsZEJhY2t0cmFja2ApXG4gICAgICBpZiAodGhpcy5jb3VsZEJhY2t0cmFjayAmJiAhdGhpcy5mcmFnUHJldmlvdXMgJiYgZnJhZyAmJiBmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnICYmIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpICE9PSBGcmFnbWVudFN0YXRlLk9LKSB7XG4gICAgICAgIHZhciBfdGhpcyRiYWNrdHJhY2tGcmFnbWU7XG4gICAgICAgIHZhciBiYWNrdHJhY2tTbiA9ICgoX3RoaXMkYmFja3RyYWNrRnJhZ21lID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudCkgIT0gbnVsbCA/IF90aGlzJGJhY2t0cmFja0ZyYWdtZSA6IGZyYWcpLnNuO1xuICAgICAgICB2YXIgZnJhZ0lkeCA9IGJhY2t0cmFja1NuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICAgIHZhciBiYWNrdHJhY2tGcmFnID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tmcmFnSWR4IC0gMV07XG4gICAgICAgIGlmIChiYWNrdHJhY2tGcmFnICYmIGZyYWcuY2MgPT09IGJhY2t0cmFja0ZyYWcuY2MpIHtcbiAgICAgICAgICBmcmFnID0gYmFja3RyYWNrRnJhZztcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChiYWNrdHJhY2tGcmFnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50ICYmIGJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gQXZvaWQgbG9vcCBsb2FkaW5nIGJ5IHVzaW5nIG5leHRMb2FkUG9zaXRpb24gc2V0IGZvciBiYWNrdHJhY2tpbmcgYW5kIHNraXBwaW5nIGNvbnNlY3V0aXZlIEdBUCB0YWdzXG4gICAgICBpZiAoZnJhZyAmJiB0aGlzLmlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgICAgdmFyIGdhcFN0YXJ0ID0gZnJhZy5nYXA7XG4gICAgICAgIGlmICghZ2FwU3RhcnQpIHtcbiAgICAgICAgICAvLyBDbGVhbnVwIHRoZSBmcmFnbWVudCB0cmFja2VyIGJlZm9yZSB0cnlpbmcgdG8gZmluZCB0aGUgbmV4dCB1bmJ1ZmZlcmVkIGZyYWdtZW50XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmF1ZGlvT25seSAmJiAhdGhpcy5hbHRBdWRpbyA/IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyA6IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTztcbiAgICAgICAgICB2YXIgbWVkaWFCdWZmZXIgPSAodHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPID8gdGhpcy52aWRlb0J1ZmZlciA6IHRoaXMubWVkaWFCdWZmZXIpIHx8IHRoaXMubWVkaWE7XG4gICAgICAgICAgaWYgKG1lZGlhQnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYUJ1ZmZlciwgdHlwZSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKGZyYWcsIGxldmVsRGV0YWlscywgYnVmZmVySW5mbywgUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgbWF4QnVmTGVuKTtcbiAgICAgIH1cbiAgICAgIGlmICghZnJhZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5pbml0U2VnbWVudCAmJiAhZnJhZy5pbml0U2VnbWVudC5kYXRhICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIGZyYWcgPSBmcmFnLmluaXRTZWdtZW50O1xuICAgICAgfVxuICAgICAgdGhpcy5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxJbmZvLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICB9O1xuICAgIF9wcm90by5sb2FkRnJhZ21lbnQgPSBmdW5jdGlvbiBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAgIC8vIENoZWNrIGlmIGZyYWdtZW50IGlzIG5vdCBsb2FkZWRcbiAgICAgIHZhciBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgaWYgKGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XG4gICAgICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgICAgdGhpcy5fbG9hZEluaXRTZWdtZW50KGZyYWcsIGxldmVsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJGcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiBpcyBiZWluZyBkb3dubG9hZGVkIHRvIHRlc3QgYml0cmF0ZSBhbmQgd2lsbCBub3QgYmUgYnVmZmVyZWRcIik7XG4gICAgICAgICAgdGhpcy5fbG9hZEJpdHJhdGVUZXN0RnJhZyhmcmFnLCBsZXZlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgIF9CYXNlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUubG9hZEZyYWdtZW50LmNhbGwodGhpcywgZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdldEJ1ZmZlcmVkRnJhZyA9IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhwb3NpdGlvbiwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgfTtcbiAgICBfcHJvdG8uZm9sbG93aW5nQnVmZmVyZWRGcmFnID0gZnVuY3Rpb24gZm9sbG93aW5nQnVmZmVyZWRGcmFnKGZyYWcpIHtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIC8vIHRyeSB0byBnZXQgcmFuZ2Ugb2YgbmV4dCBmcmFnbWVudCAoNTAwbXMgYWZ0ZXIgdGhpcyByYW5nZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGZyYWcuZW5kICsgMC41KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qXG4gICAgICBvbiBpbW1lZGlhdGUgbGV2ZWwgc3dpdGNoIDpcbiAgICAgICAtIHBhdXNlIHBsYXliYWNrIGlmIHBsYXlpbmdcbiAgICAgICAtIGNhbmNlbCBhbnkgcGVuZGluZyBsb2FkIHJlcXVlc3RcbiAgICAgICAtIGFuZCB0cmlnZ2VyIGEgYnVmZmVyIGZsdXNoXG4gICAgKi87XG4gICAgX3Byb3RvLmltbWVkaWF0ZUxldmVsU3dpdGNoID0gZnVuY3Rpb24gaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKSB7XG4gICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJ5IHRvIHN3aXRjaCBBU0FQIHdpdGhvdXQgYnJlYWtpbmcgdmlkZW8gcGxheWJhY2s6XG4gICAgICogaW4gb3JkZXIgdG8gZW5zdXJlIHNtb290aCBidXQgcXVpY2sgbGV2ZWwgc3dpdGNoaW5nLFxuICAgICAqIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAgICogd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcbiAgICAgKi87XG4gICAgX3Byb3RvLm5leHRMZXZlbFN3aXRjaCA9IGZ1bmN0aW9uIG5leHRMZXZlbFN3aXRjaCgpIHtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgLy8gZW5zdXJlIHRoYXQgbWVkaWEgaXMgZGVmaW5lZCBhbmQgdGhhdCBtZXRhZGF0YSBhcmUgYXZhaWxhYmxlICh0byByZXRyaWV2ZSBjdXJyZW50VGltZSlcbiAgICAgIGlmIChtZWRpYSAhPSBudWxsICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgdmFyIGZldGNoZGVsYXk7XG4gICAgICAgIHZhciBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQgJiYgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0ID4gMSkge1xuICAgICAgICAgIC8vIGZsdXNoIGJ1ZmZlciBwcmVjZWRpbmcgY3VycmVudCBmcmFnbWVudCAoZmx1c2ggdW50aWwgY3VycmVudCBmcmFnbWVudCBzdGFydCBvZmZzZXQpXG4gICAgICAgICAgLy8gbWludXMgMXMgdG8gYXZvaWQgdmlkZW8gZnJlZXppbmcsIHRoYXQgY291bGQgaGFwcGVuIGlmIHdlIGZsdXNoIGtleWZyYW1lIG9mIGN1cnJlbnQgdmlkZW8gLi4uXG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxldmVsRGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgICAgIGlmIChsZXZlbERldGFpbHMgIT0gbnVsbCAmJiBsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgICAgIHZhciBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgICAgIC8vIERvIG5vdCBmbHVzaCBpbiBsaXZlIHN0cmVhbSB3aXRoIGxvdyBidWZmZXJcbiAgICAgICAgICBpZiAoIWJ1ZmZlckluZm8gfHwgYnVmZmVySW5mby5sZW4gPCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbWVkaWEucGF1c2VkICYmIGxldmVscykge1xuICAgICAgICAgIC8vIGFkZCBhIHNhZmV0eSBkZWxheSBvZiAxc1xuICAgICAgICAgIHZhciBuZXh0TGV2ZWxJZCA9IHRoaXMuaGxzLm5leHRMb2FkTGV2ZWw7XG4gICAgICAgICAgdmFyIG5leHRMZXZlbCA9IGxldmVsc1tuZXh0TGV2ZWxJZF07XG4gICAgICAgICAgdmFyIGZyYWdMYXN0S2JwcyA9IHRoaXMuZnJhZ0xhc3RLYnBzO1xuICAgICAgICAgIGlmIChmcmFnTGFzdEticHMgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICAgICAgZmV0Y2hkZWxheSA9IHRoaXMuZnJhZ0N1cnJlbnQuZHVyYXRpb24gKiBuZXh0TGV2ZWwubWF4Qml0cmF0ZSAvICgxMDAwICogZnJhZ0xhc3RLYnBzKSArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLmxvZygnZmV0Y2hkZWxheTonK2ZldGNoZGVsYXkpO1xuICAgICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcbiAgICAgICAgdmFyIGJ1ZmZlcmVkRnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XG4gICAgICAgIGlmIChidWZmZXJlZEZyYWcpIHtcbiAgICAgICAgICAvLyB3ZSBjYW4gZmx1c2ggYnVmZmVyIHJhbmdlIGZvbGxvd2luZyB0aGlzIG9uZSB3aXRob3V0IHN0YWxsaW5nIHBsYXliYWNrXG4gICAgICAgICAgdmFyIG5leHRCdWZmZXJlZEZyYWcgPSB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhidWZmZXJlZEZyYWcpO1xuICAgICAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgd2UgY2FuIGFsc28gY2FuY2VsIGFueSBsb2FkaW5nL2RlbXV4aW5nIGluIHByb2dyZXNzLCBhcyB0aGV5IGFyZSB1c2VsZXNzXG4gICAgICAgICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoIHBvc2l0aW9uIGlzIGluIG5leHQgYnVmZmVyZWQgZnJhZy4gTGVhdmUgc29tZSBwYWRkaW5nIGZvciBub24taW5kZXBlbmRlbnQgc2VnbWVudHMgYW5kIHNtb290aGVyIHBsYXliYWNrLlxuICAgICAgICAgICAgdmFyIG1heFN0YXJ0ID0gbmV4dEJ1ZmZlcmVkRnJhZy5tYXhTdGFydFBUUyA/IG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFMgOiBuZXh0QnVmZmVyZWRGcmFnLnN0YXJ0O1xuICAgICAgICAgICAgdmFyIGZyYWdEdXJhdGlvbiA9IG5leHRCdWZmZXJlZEZyYWcuZHVyYXRpb247XG4gICAgICAgICAgICB2YXIgc3RhcnRQdHMgPSBNYXRoLm1heChidWZmZXJlZEZyYWcuZW5kLCBtYXhTdGFydCArIE1hdGgubWluKE1hdGgubWF4KGZyYWdEdXJhdGlvbiAtIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdEdXJhdGlvbiAqICh0aGlzLmNvdWxkQmFja3RyYWNrID8gMC41IDogMC4xMjUpKSwgZnJhZ0R1cmF0aW9uICogKHRoaXMuY291bGRCYWNrdHJhY2sgPyAwLjc1IDogMC4yNSkpKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKHN0YXJ0UHRzLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmFib3J0Q3VycmVudEZyYWcgPSBmdW5jdGlvbiBhYm9ydEN1cnJlbnRGcmFnKCkge1xuICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgICBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnQ3VycmVudCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTdGF0ZS5LRVlfTE9BRElORzpcbiAgICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkc6XG4gICAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIGNhc2UgU3RhdGUuUEFSU0lORzpcbiAgICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoTWFpbkJ1ZmZlciA9IGZ1bmN0aW9uIGZsdXNoTWFpbkJ1ZmZlcihzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmZsdXNoTWFpbkJ1ZmZlci5jYWxsKHRoaXMsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHRoaXMuYWx0QXVkaW8gPyAndmlkZW8nIDogbnVsbCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYUF0dGFjaGVkID0gZnVuY3Rpb24gb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFBdHRhY2hlZC5jYWxsKHRoaXMsIGV2ZW50LCBkYXRhKTtcbiAgICAgIHZhciBtZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgICB0aGlzLm9udnBsYXlpbmcgPSB0aGlzLm9uTWVkaWFQbGF5aW5nLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLm9udnNlZWtlZCA9IHRoaXMub25NZWRpYVNlZWtlZC5iaW5kKHRoaXMpO1xuICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub252cGxheWluZyk7XG4gICAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSBuZXcgR2FwQ29udHJvbGxlcih0aGlzLmNvbmZpZywgbWVkaWEsIHRoaXMuZnJhZ21lbnRUcmFja2VyLCB0aGlzLmhscyk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYURldGFjaGluZyA9IGZ1bmN0aW9uIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgaWYgKG1lZGlhICYmIHRoaXMub252cGxheWluZyAmJiB0aGlzLm9udnNlZWtlZCkge1xuICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy5vbnZwbGF5aW5nKTtcbiAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgICAgICB0aGlzLm9udnBsYXlpbmcgPSB0aGlzLm9udnNlZWtlZCA9IG51bGw7XG4gICAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5mcmFnUGxheWluZyA9IG51bGw7XG4gICAgICBpZiAodGhpcy5nYXBDb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuZ2FwQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG51bGw7XG4gICAgICB9XG4gICAgICBfQmFzZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLm9uTWVkaWFEZXRhY2hpbmcuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIF9wcm90by5vbk1lZGlhUGxheWluZyA9IGZ1bmN0aW9uIG9uTWVkaWFQbGF5aW5nKCkge1xuICAgICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHX0NIQU5HRUQgdHJpZ2dlcmluZ1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NZWRpYVNlZWtlZCA9IGZ1bmN0aW9uIG9uTWVkaWFTZWVrZWQoKSB7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IG51bGw7XG4gICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoY3VycmVudFRpbWUpKSB7XG4gICAgICAgIHRoaXMubG9nKFwiTWVkaWEgc2Vla2VkIHRvIFwiICsgY3VycmVudFRpbWUudG9GaXhlZCgzKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHNlZWtlZCB3YXMgaXNzdWVkIGJlZm9yZSBidWZmZXIgd2FzIGFwcGVuZGVkIGRvIG5vdCB0aWNrIGltbWVkaWF0ZWx5XG4gICAgICB2YXIgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsIHx8IGJ1ZmZlckluZm8ubGVuID09PSAwKSB7XG4gICAgICAgIHRoaXMud2FybihcIk1haW4gZm9yd2FyZCBidWZmZXIgbGVuZ3RoIG9uIFxcXCJzZWVrZWRcXFwiIGV2ZW50IFwiICsgKGJ1ZmZlckluZm8gPyBidWZmZXJJbmZvLmxlbiA6ICdlbXB0eScpICsgXCIpXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHRpY2sgdG8gc3BlZWQgdXAgRlJBR19DSEFOR0VEIHRyaWdnZXJpbmdcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uTWFuaWZlc3RMb2FkaW5nID0gZnVuY3Rpb24gb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgICAvLyByZXNldCBidWZmZXIgb24gbWFuaWZlc3QgbG9hZGluZ1xuICAgICAgdGhpcy5sb2coJ1RyaWdnZXIgQlVGRkVSX1JFU0VUJyk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHVuZGVmaW5lZCk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5mcmFnTGFzdEticHMgPSAwO1xuICAgICAgdGhpcy5sZXZlbHMgPSB0aGlzLmZyYWdQbGF5aW5nID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gbnVsbDtcbiAgICAgIHRoaXMuYWx0QXVkaW8gPSB0aGlzLmF1ZGlvT25seSA9IHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8ub25NYW5pZmVzdFBhcnNlZCA9IGZ1bmN0aW9uIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIC8vIGRldGVjdCBpZiB3ZSBoYXZlIGRpZmZlcmVudCBraW5kIG9mIGF1ZGlvIGNvZGVjcyB1c2VkIGFtb25nc3QgcGxheWxpc3RzXG4gICAgICB2YXIgYWFjID0gZmFsc2U7XG4gICAgICB2YXIgaGVhYWMgPSBmYWxzZTtcbiAgICAgIGRhdGEubGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIHZhciBjb2RlYyA9IGxldmVsLmF1ZGlvQ29kZWM7XG4gICAgICAgIGlmIChjb2RlYykge1xuICAgICAgICAgIGFhYyA9IGFhYyB8fCBjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTE7XG4gICAgICAgICAgaGVhYWMgPSBoZWFhYyB8fCBjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gYWFjICYmIGhlYWFjICYmICFjaGFuZ2VUeXBlU3VwcG9ydGVkKCk7XG4gICAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICAgIHRoaXMubG9nKCdCb3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5vbkxldmVsTG9hZGluZyA9IGZ1bmN0aW9uIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgICBpZiAoIWxldmVscyB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5JRExFKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tkYXRhLmxldmVsXTtcbiAgICAgIGlmICghbGV2ZWwuZGV0YWlscyB8fCBsZXZlbC5kZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsIHx8IHRoaXMud2FpdEZvckNkblR1bmVJbihsZXZlbC5kZXRhaWxzKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5vbkxldmVsTG9hZGVkID0gZnVuY3Rpb24gb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF9jdXJMZXZlbCRkZXRhaWxzO1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgICAgdmFyIG5ld0xldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgICAgdmFyIG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICB2YXIgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgICBpZiAoIWxldmVscykge1xuICAgICAgICB0aGlzLndhcm4oXCJMZXZlbHMgd2VyZSByZXNldCB3aGlsZSBsb2FkaW5nIGxldmVsIFwiICsgbmV3TGV2ZWxJZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKFwiTGV2ZWwgXCIgKyBuZXdMZXZlbElkICsgXCIgbG9hZGVkIFtcIiArIG5ld0RldGFpbHMuc3RhcnRTTiArIFwiLFwiICsgbmV3RGV0YWlscy5lbmRTTiArIFwiXVwiICsgKG5ld0RldGFpbHMubGFzdFBhcnRTbiA/IFwiW3BhcnQtXCIgKyBuZXdEZXRhaWxzLmxhc3RQYXJ0U24gKyBcIi1cIiArIG5ld0RldGFpbHMubGFzdFBhcnRJbmRleCArIFwiXVwiIDogJycpICsgXCIsIGNjIFtcIiArIG5ld0RldGFpbHMuc3RhcnRDQyArIFwiLCBcIiArIG5ld0RldGFpbHMuZW5kQ0MgKyBcIl0gZHVyYXRpb246XCIgKyBkdXJhdGlvbik7XG4gICAgICB2YXIgY3VyTGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxJZF07XG4gICAgICB2YXIgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgaWYgKGZyYWdDdXJyZW50ICYmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkpKSB7XG4gICAgICAgIGlmIChmcmFnQ3VycmVudC5sZXZlbCAhPT0gZGF0YS5sZXZlbCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNsaWRpbmcgPSAwO1xuICAgICAgaWYgKG5ld0RldGFpbHMubGl2ZSB8fCAoX2N1ckxldmVsJGRldGFpbHMgPSBjdXJMZXZlbC5kZXRhaWxzKSAhPSBudWxsICYmIF9jdXJMZXZlbCRkZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgdmFyIF90aGlzJGxldmVsTGFzdExvYWRlZDtcbiAgICAgICAgdGhpcy5jaGVja0xpdmVVcGRhdGUobmV3RGV0YWlscyk7XG4gICAgICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIGN1ckxldmVsLmRldGFpbHMsIChfdGhpcyRsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxldmVsTGFzdExvYWRlZC5kZXRhaWxzKTtcbiAgICAgIH1cbiAgICAgIC8vIG92ZXJyaWRlIGxldmVsIGluZm9cbiAgICAgIGN1ckxldmVsLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBjdXJMZXZlbDtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1VQREFURUQsIHtcbiAgICAgICAgZGV0YWlsczogbmV3RGV0YWlscyxcbiAgICAgICAgbGV2ZWw6IG5ld0xldmVsSWRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBvbmx5IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciBsZXZlbCB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihuZXdEZXRhaWxzKSkge1xuICAgICAgICAgIC8vIFdhaXQgZm9yIExvdy1MYXRlbmN5IENETiBUdW5lLWluXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgICB0aGlzLnNldFN0YXJ0UG9zaXRpb24obmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgICB9IGVsc2UgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplVG9MaXZlRWRnZShuZXdEZXRhaWxzKTtcbiAgICAgIH1cblxuICAgICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBfcHJvdG8uX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzID0gZnVuY3Rpb24gX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGRhdGEpIHtcbiAgICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0LFxuICAgICAgICBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgICAgdGhpcy53YXJuKFwiTGV2ZWxzIHdlcmUgcmVzZXQgd2hpbGUgZnJhZ21lbnQgbG9hZCB3YXMgaW4gcHJvZ3Jlc3MuIEZyYWdtZW50IFwiICsgZnJhZy5zbiArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIHdpbGwgbm90IGJlIGJ1ZmZlcmVkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgdmFyIGRldGFpbHMgPSBjdXJyZW50TGV2ZWwuZGV0YWlscztcbiAgICAgIGlmICghZGV0YWlscykge1xuICAgICAgICB0aGlzLndhcm4oXCJEcm9wcGluZyBmcmFnbWVudCBcIiArIGZyYWcuc24gKyBcIiBvZiBsZXZlbCBcIiArIGZyYWcubGV2ZWwgKyBcIiBhZnRlciBsZXZlbCBkZXRhaWxzIHdlcmUgcmVzZXRcIik7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjO1xuXG4gICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICAgIHZhciBhY2N1cmF0ZVRpbWVPZmZzZXQgPSBkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XG4gICAgICB2YXIgaW5pdFNlZ21lbnREYXRhID0gKF9mcmFnJGluaXRTZWdtZW50ID0gZnJhZy5pbml0U2VnbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnJGluaXRTZWdtZW50LmRhdGE7XG4gICAgICB2YXIgYXVkaW9Db2RlYyA9IHRoaXMuX2dldEF1ZGlvQ29kZWMoY3VycmVudExldmVsKTtcblxuICAgICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgICAgLy8gdGhpcy5sb2coYFRyYW5zbXV4aW5nICR7ZnJhZy5zbn0gb2YgWyR7ZGV0YWlscy5zdGFydFNOfSAsJHtkZXRhaWxzLmVuZFNOfV0sbGV2ZWwgJHtmcmFnLmxldmVsfSwgY2MgJHtmcmFnLmNjfWApO1xuICAgICAgdmFyIHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIgfHwgbmV3IFRyYW5zbXV4ZXJJbnRlcmZhY2UodGhpcy5obHMsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSwgdGhpcy5faGFuZGxlVHJhbnNtdXhlckZsdXNoLmJpbmQodGhpcykpO1xuICAgICAgdmFyIHBhcnRJbmRleCA9IHBhcnQgPyBwYXJ0LmluZGV4IDogLTE7XG4gICAgICB2YXIgcGFydGlhbCA9IHBhcnRJbmRleCAhPT0gLTE7XG4gICAgICB2YXIgY2h1bmtNZXRhID0gbmV3IENodW5rTWV0YWRhdGEoZnJhZy5sZXZlbCwgZnJhZy5zbiwgZnJhZy5zdGF0cy5jaHVua0NvdW50LCBwYXlsb2FkLmJ5dGVMZW5ndGgsIHBhcnRJbmRleCwgcGFydGlhbCk7XG4gICAgICB2YXIgaW5pdFBUUyA9IHRoaXMuaW5pdFBUU1tmcmFnLmNjXTtcbiAgICAgIHRyYW5zbXV4ZXIucHVzaChwYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGZyYWcsIHBhcnQsIGRldGFpbHMudG90YWxkdXJhdGlvbiwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEsIGluaXRQVFMpO1xuICAgIH07XG4gICAgX3Byb3RvLm9uQXVkaW9UcmFja1N3aXRjaGluZyA9IGZ1bmN0aW9uIG9uQXVkaW9UcmFja1N3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgICAgdmFyIGZyb21BbHRBdWRpbyA9IHRoaXMuYWx0QXVkaW87XG4gICAgICB2YXIgYWx0QXVkaW8gPSAhIWRhdGEudXJsO1xuICAgICAgLy8gaWYgd2Ugc3dpdGNoIG9uIG1haW4gYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCBtZWRpYS5idWZmZXJlZFxuICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgd2Ugc3dpdGNoIHRvIGFsdCBhdWRpbzogYXVkaW8gc3RyZWFtIGNvbnRyb2xsZXIgaXMgaGFuZGxpbmcgaXQuXG4gICAgICAvLyB3ZSB3aWxsIGp1c3QgaGF2ZSB0byBjaGFuZ2UgYnVmZmVyIHNjaGVkdWxpbmcgb24gYXVkaW9UcmFja1N3aXRjaGVkXG4gICAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICAgIGlmICh0aGlzLm1lZGlhQnVmZmVyICE9PSB0aGlzLm1lZGlhKSB7XG4gICAgICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyBvbiBtYWluIGF1ZGlvLCB1c2UgbWVkaWEuYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nJyk7XG4gICAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgICAgICAgdmFyIGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlZmlsbCBhdWRpbyBidWZmZXIgZnJvbSBtYWluOiBjYW5jZWwgYW55IGZyYWcgbG9hZGluZyB0byBzcGVlZCB1cCBhdWRpbyBzd2l0Y2hcbiAgICAgICAgICBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgdG8gbWFpbiBhdWRpbyB0cmFjaywgY2FuY2VsIG1haW4gZnJhZ21lbnQgbG9hZCcpO1xuICAgICAgICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZ0N1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBkZXN0cm95IHRyYW5zbXV4ZXIgdG8gZm9yY2UgaW5pdCBzZWdtZW50IGdlbmVyYXRpb24gKGZvbGxvd2luZyBhdWRpbyBzd2l0Y2gpXG4gICAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgICAgICAvLyBzd2l0Y2ggdG8gSURMRSBzdGF0ZSB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmF1ZGlvT25seSkge1xuICAgICAgICAgIC8vIFJlc2V0IGF1ZGlvIHRyYW5zbXV4ZXIgc28gd2hlbiBzd2l0Y2hpbmcgYmFjayB0byBtYWluIGF1ZGlvIHdlJ3JlIG5vdCBzdGlsbCBhcHBlbmRpbmcgd2hlcmUgd2UgbGVmdCBvZmZcbiAgICAgICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgICAgLy8gSWYgc3dpdGNoaW5nIGZyb20gYWx0IHRvIG1haW4gYXVkaW8sIGZsdXNoIGFsbCBhdWRpbyBhbmQgdHJpZ2dlciB0cmFjayBzd2l0Y2hlZFxuICAgICAgICBpZiAoZnJvbUFsdEF1ZGlvKSB7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICAgIHR5cGU6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIGRhdGEpO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uQXVkaW9UcmFja1N3aXRjaGVkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrU3dpdGNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciB0cmFja0lkID0gZGF0YS5pZDtcbiAgICAgIHZhciBhbHRBdWRpbyA9ICEhdGhpcy5obHMuYXVkaW9UcmFja3NbdHJhY2tJZF0udXJsO1xuICAgICAgaWYgKGFsdEF1ZGlvKSB7XG4gICAgICAgIHZhciB2aWRlb0J1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXI7XG4gICAgICAgIC8vIGlmIHdlIHN3aXRjaGVkIG9uIGFsdGVybmF0ZSBhdWRpbywgZW5zdXJlIHRoYXQgbWFpbiBmcmFnbWVudCBzY2hlZHVsaW5nIGlzIHN5bmNlZCB3aXRoIHZpZGVvIHNvdXJjZWJ1ZmZlciBidWZmZXJlZFxuICAgICAgICBpZiAodmlkZW9CdWZmZXIgJiYgdGhpcy5tZWRpYUJ1ZmZlciAhPT0gdmlkZW9CdWZmZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZycpO1xuICAgICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB2aWRlb0J1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hbHRBdWRpbyA9IGFsdEF1ZGlvO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25CdWZmZXJDcmVhdGVkID0gZnVuY3Rpb24gb25CdWZmZXJDcmVhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICB2YXIgdHJhY2tzID0gZGF0YS50cmFja3M7XG4gICAgICB2YXIgbWVkaWFUcmFjaztcbiAgICAgIHZhciBuYW1lO1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgdHlwZSBpbiB0cmFja3MpIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAodHJhY2suaWQgPT09ICdtYWluJykge1xuICAgICAgICAgIG5hbWUgPSB0eXBlO1xuICAgICAgICAgIG1lZGlhVHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAvLyBrZWVwIHZpZGVvIHNvdXJjZSBidWZmZXIgcmVmZXJlbmNlXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIHZhciB2aWRlb1RyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKHZpZGVvVHJhY2spIHtcbiAgICAgICAgICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IHZpZGVvVHJhY2suYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgICAgdGhpcy5sb2coXCJBbHRlcm5hdGUgdHJhY2sgZm91bmQsIHVzZSBcIiArIG5hbWUgKyBcIi5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdcIik7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLm9uRnJhZ0J1ZmZlcmVkID0gZnVuY3Rpb24gb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBmcmFnID0gZGF0YS5mcmFnLFxuICAgICAgICBwYXJ0ID0gZGF0YS5wYXJ0O1xuICAgICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICAvLyBJZiBhIGxldmVsIHN3aXRjaCB3YXMgcmVxdWVzdGVkIHdoaWxlIGEgZnJhZ21lbnQgd2FzIGJ1ZmZlcmluZywgaXQgd2lsbCBlbWl0IHRoZSBGUkFHX0JVRkZFUkVEIGV2ZW50IHVwb24gY29tcGxldGlvblxuICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIHN0YXRlIGJhY2sgdG8gSURMRSwgc2luY2UgdGhhdCB3aWxsIGludGVyZmVyZSB3aXRoIGEgbGV2ZWwgc3dpdGNoXG4gICAgICAgIHRoaXMud2FybihcIkZyYWdtZW50IFwiICsgZnJhZy5zbiArIChwYXJ0ID8gJyBwOiAnICsgcGFydC5pbmRleCA6ICcnKSArIFwiIG9mIGxldmVsIFwiICsgZnJhZy5sZXZlbCArIFwiIGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogXCIgKyB0aGlzLnN0YXRlKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgIHRoaXMuZnJhZ0xhc3RLYnBzID0gTWF0aC5yb3VuZCg4ICogc3RhdHMudG90YWwgLyAoc3RhdHMuYnVmZmVyaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpKTtcbiAgICAgIGlmIChmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICAgIH1cbiAgICAgIHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUoZnJhZywgcGFydCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfZGF0YSRjb250ZXh0O1xuICAgICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0dBUDpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1I6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICAgIHRoaXMub25GcmFnbWVudE9yS2V5TG9hZEVycm9yKFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIGRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgICAgLy8gaW4gY2FzZSBvZiBub24gZmF0YWwgZXJyb3Igd2hpbGUgbG9hZGluZyBsZXZlbCwgaWYgbGV2ZWwgY29udHJvbGxlciBpcyBub3QgcmV0cnlpbmcgdG8gbG9hZCBsZXZlbCwgc3dpdGNoIGJhY2sgdG8gSURMRVxuICAgICAgICAgIGlmICghZGF0YS5sZXZlbFJldHJ5ICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwgJiYgKChfZGF0YSRjb250ZXh0ID0gZGF0YS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkY29udGV4dC50eXBlKSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SOlxuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgICAgICBpZiAoIWRhdGEucGFyZW50IHx8IGRhdGEucGFyZW50ICE9PSAnbWFpbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMucmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEVycm9yRGV0YWlscy5JTlRFUk5BTF9FWENFUFRJT046XG4gICAgICAgICAgdGhpcy5yZWNvdmVyV29ya2VyRXJyb3IoZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2tzIHRoZSBoZWFsdGggb2YgdGhlIGJ1ZmZlciBhbmQgYXR0ZW1wdHMgdG8gcmVzb2x2ZSBwbGF5YmFjayBzdGFsbHMuXG4gICAgO1xuICAgIF9wcm90by5jaGVja0J1ZmZlciA9IGZ1bmN0aW9uIGNoZWNrQnVmZmVyKCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSxcbiAgICAgICAgZ2FwQ29udHJvbGxlciA9IHRoaXMuZ2FwQ29udHJvbGxlcjtcbiAgICAgIGlmICghbWVkaWEgfHwgIWdhcENvbnRyb2xsZXIgfHwgIW1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBkb24ndCBoYXZlIG1lZGlhIG9yIGlmIHRoZSBtZWRpYSBoYXNuJ3QgYnVmZmVyZWQgYW55dGhpbmcgeWV0IChyZWFkeVN0YXRlIDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxvYWRlZG1ldGFkYXRhIHx8ICFCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpLmxlbmd0aCkge1xuICAgICAgICAvLyBSZXNvbHZlIGdhcHMgdXNpbmcgdGhlIG1haW4gYnVmZmVyLCB3aG9zZSByYW5nZXMgYXJlIHRoZSBpbnRlcnNlY3Rpb25zIG9mIHRoZSBBL1Ygc291cmNlYnVmZmVyc1xuICAgICAgICB2YXIgYWN0aXZlRnJhZyA9IHRoaXMuc3RhdGUgIT09IFN0YXRlLklETEUgPyB0aGlzLmZyYWdDdXJyZW50IDogbnVsbDtcbiAgICAgICAgZ2FwQ29udHJvbGxlci5wb2xsKHRoaXMubGFzdEN1cnJlbnRUaW1lLCBhY3RpdmVGcmFnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgfTtcbiAgICBfcHJvdG8ub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQgPSBmdW5jdGlvbiBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCgpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgLy8gaWYgbG9hZGVkbWV0YWRhdGEgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgZW1lcmdlbmN5IHN3aXRjaCBkb3duIG9uIGZpcnN0IGZyYWdcbiAgICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgICB9O1xuICAgIF9wcm90by5vbkJ1ZmZlckZsdXNoZWQgPSBmdW5jdGlvbiBvbkJ1ZmZlckZsdXNoZWQoZXZlbnQsIF9yZWYpIHtcbiAgICAgIHZhciB0eXBlID0gX3JlZi50eXBlO1xuICAgICAgaWYgKHR5cGUgIT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyB8fCB0aGlzLmF1ZGlvT25seSAmJiAhdGhpcy5hbHRBdWRpbykge1xuICAgICAgICB2YXIgbWVkaWFCdWZmZXIgPSAodHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPID8gdGhpcy52aWRlb0J1ZmZlciA6IHRoaXMubWVkaWFCdWZmZXIpIHx8IHRoaXMubWVkaWE7XG4gICAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhQnVmZmVyLCB0eXBlLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgICAgdGhpcy50aWNrKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ub25MZXZlbHNVcGRhdGVkID0gZnVuY3Rpb24gb25MZXZlbHNVcGRhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbCA+IC0xICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5sZXZlbCA9IHRoaXMuZnJhZ0N1cnJlbnQubGV2ZWw7XG4gICAgICB9XG4gICAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgIH07XG4gICAgX3Byb3RvLnN3YXBBdWRpb0NvZGVjID0gZnVuY3Rpb24gc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gIXRoaXMuYXVkaW9Db2RlY1N3YXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Vla3MgdG8gdGhlIHNldCBzdGFydFBvc2l0aW9uIGlmIG5vdCBlcXVhbCB0byB0aGUgbWVkaWFFbGVtZW50J3MgY3VycmVudCB0aW1lLlxuICAgICAqLztcbiAgICBfcHJvdG8uc2Vla1RvU3RhcnRQb3MgPSBmdW5jdGlvbiBzZWVrVG9TdGFydFBvcygpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgICBpZiAoIW1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICAvLyBvbmx5IGFkanVzdCBjdXJyZW50VGltZSBpZiBkaWZmZXJlbnQgZnJvbSBzdGFydFBvc2l0aW9uIG9yIGlmIHN0YXJ0UG9zaXRpb24gbm90IGJ1ZmZlcmVkXG4gICAgICAvLyBhdCB0aGF0IHN0YWdlLCB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgYnVmZmVyZWQgcmFuZ2UsIGFzIHdlIHJlYWNoIHRoYXQgY29kZSBhZnRlciBmaXJzdCBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZFxuICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPj0gMCAmJiBjdXJyZW50VGltZSA8IHN0YXJ0UG9zaXRpb24pIHtcbiAgICAgICAgaWYgKG1lZGlhLnNlZWtpbmcpIHtcbiAgICAgICAgICB0aGlzLmxvZyhcImNvdWxkIG5vdCBzZWVrIHRvIFwiICsgc3RhcnRQb3NpdGlvbiArIFwiLCBhbHJlYWR5IHNlZWtpbmcgYXQgXCIgKyBjdXJyZW50VGltZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgICAgIHZhciBidWZmZXJTdGFydCA9IGJ1ZmZlcmVkLmxlbmd0aCA/IGJ1ZmZlcmVkLnN0YXJ0KDApIDogMDtcbiAgICAgICAgdmFyIGRlbHRhID0gYnVmZmVyU3RhcnQgLSBzdGFydFBvc2l0aW9uO1xuICAgICAgICBpZiAoZGVsdGEgPiAwICYmIChkZWx0YSA8IHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgfHwgZGVsdGEgPCB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKSkge1xuICAgICAgICAgIHRoaXMubG9nKFwiYWRqdXN0aW5nIHN0YXJ0IHBvc2l0aW9uIGJ5IFwiICsgZGVsdGEgKyBcIiB0byBtYXRjaCBidWZmZXIgc3RhcnRcIik7XG4gICAgICAgICAgc3RhcnRQb3NpdGlvbiArPSBkZWx0YTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nKFwic2VlayB0byB0YXJnZXQgc3RhcnQgcG9zaXRpb24gXCIgKyBzdGFydFBvc2l0aW9uICsgXCIgZnJvbSBjdXJyZW50IHRpbWUgXCIgKyBjdXJyZW50VGltZSk7XG4gICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5fZ2V0QXVkaW9Db2RlYyA9IGZ1bmN0aW9uIF9nZXRBdWRpb0NvZGVjKGN1cnJlbnRMZXZlbCkge1xuICAgICAgdmFyIGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29kZWNTd2FwICYmIGF1ZGlvQ29kZWMpIHtcbiAgICAgICAgdGhpcy5sb2coJ1N3YXBwaW5nIGF1ZGlvIGNvZGVjJyk7XG4gICAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhdWRpb0NvZGVjO1xuICAgIH07XG4gICAgX3Byb3RvLl9sb2FkQml0cmF0ZVRlc3RGcmFnID0gZnVuY3Rpb24gX2xvYWRCaXRyYXRlVGVzdEZyYWcoZnJhZywgbGV2ZWwpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgICB0aGlzLl9kb0ZyYWdMb2FkKGZyYWcsIGxldmVsKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBobHMgPSBfdGhpczIuaGxzO1xuICAgICAgICBpZiAoIWRhdGEgfHwgX3RoaXMyLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gMDtcbiAgICAgICAgX3RoaXMyLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgX3RoaXMyLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpczIuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgICAgdmFyIHN0YXRzID0gZnJhZy5zdGF0cztcbiAgICAgICAgLy8gQml0cmF0ZSB0ZXN0cyBmcmFnbWVudHMgYXJlIG5laXRoZXIgcGFyc2VkIG5vciBidWZmZXJlZFxuICAgICAgICBzdGF0cy5wYXJzaW5nLnN0YXJ0ID0gc3RhdHMucGFyc2luZy5lbmQgPSBzdGF0cy5idWZmZXJpbmcuc3RhcnQgPSBzdGF0cy5idWZmZXJpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BREVELCBkYXRhKTtcbiAgICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUgPSBmdW5jdGlvbiBfaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0cmFuc211eFJlc3VsdCkge1xuICAgICAgdmFyIF9pZDMkc2FtcGxlcztcbiAgICAgIHZhciBpZCA9ICdtYWluJztcbiAgICAgIHZhciBobHMgPSB0aGlzLmhscztcbiAgICAgIHZhciByZW11eFJlc3VsdCA9IHRyYW5zbXV4UmVzdWx0LnJlbXV4UmVzdWx0LFxuICAgICAgICBjaHVua01ldGEgPSB0cmFuc211eFJlc3VsdC5jaHVua01ldGE7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBmcmFnID0gY29udGV4dC5mcmFnLFxuICAgICAgICBwYXJ0ID0gY29udGV4dC5wYXJ0LFxuICAgICAgICBsZXZlbCA9IGNvbnRleHQubGV2ZWw7XG4gICAgICB2YXIgdmlkZW8gPSByZW11eFJlc3VsdC52aWRlbyxcbiAgICAgICAgdGV4dCA9IHJlbXV4UmVzdWx0LnRleHQsXG4gICAgICAgIGlkMyA9IHJlbXV4UmVzdWx0LmlkMyxcbiAgICAgICAgaW5pdFNlZ21lbnQgPSByZW11eFJlc3VsdC5pbml0U2VnbWVudDtcbiAgICAgIHZhciBkZXRhaWxzID0gbGV2ZWwuZGV0YWlscztcbiAgICAgIC8vIFRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBoYW5kbGVzIGF1ZGlvIGJ1ZmZlcmluZyBpZiBIbHMuanMgaXMgcGxheWluZyBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2tcbiAgICAgIHZhciBhdWRpbyA9IHRoaXMuYWx0QXVkaW8gPyB1bmRlZmluZWQgOiByZW11eFJlc3VsdC5hdWRpbztcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaGFzIGJlZW4gYWJvcnRlZC4gV2UgY2hlY2sgdGhpcyBieSBmaXJzdCBzZWVpbmcgaWYgd2UncmUgc3RpbGwgcGxheWluZyB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAgIC8vIElmIHdlIGFyZSwgc3Vic2VxdWVudGx5IGNoZWNrIGlmIHRoZSBjdXJyZW50bHkgbG9hZGluZyBmcmFnbWVudCAoZnJhZ0N1cnJlbnQpIGhhcyBjaGFuZ2VkLlxuICAgICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICAgIGlmIChpbml0U2VnbWVudCkge1xuICAgICAgICBpZiAoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC50cmFja3MpIHtcbiAgICAgICAgICB2YXIgbWFwRnJhZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50IHx8IGZyYWc7XG4gICAgICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQobGV2ZWwsIGluaXRTZWdtZW50LnRyYWNrcywgbWFwRnJhZ21lbnQsIGNodW5rTWV0YSk7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIHtcbiAgICAgICAgICAgIGZyYWc6IG1hcEZyYWdtZW50LFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgdHJhY2tzOiBpbml0U2VnbWVudC50cmFja3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgd291bGQgYmUgbmljZSBpZiBOdW1iZXIuaXNGaW5pdGUgYWN0ZWQgYXMgYSB0eXBlZ3VhcmQsIGJ1dCBpdCBkb2Vzbid0LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTAwMzhcbiAgICAgICAgdmFyIGluaXRQVFMgPSBpbml0U2VnbWVudC5pbml0UFRTO1xuICAgICAgICB2YXIgdGltZXNjYWxlID0gaW5pdFNlZ21lbnQudGltZXNjYWxlO1xuICAgICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoaW5pdFBUUykpIHtcbiAgICAgICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSB7XG4gICAgICAgICAgICBiYXNlVGltZTogaW5pdFBUUyxcbiAgICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHtcbiAgICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBpbml0UFRTOiBpbml0UFRTLFxuICAgICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBdm9pZCBidWZmZXJpbmcgaWYgYmFja3RyYWNraW5nIHRoaXMgZnJhZ21lbnRcbiAgICAgIGlmICh2aWRlbyAmJiBkZXRhaWxzICYmIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgdmFyIHByZXZGcmFnID0gZGV0YWlscy5mcmFnbWVudHNbZnJhZy5zbiAtIDEgLSBkZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICB2YXIgaXNGaXJzdEZyYWdtZW50ID0gZnJhZy5zbiA9PT0gZGV0YWlscy5zdGFydFNOO1xuICAgICAgICB2YXIgaXNGaXJzdEluRGlzY29udGludWl0eSA9ICFwcmV2RnJhZyB8fCBmcmFnLmNjID4gcHJldkZyYWcuY2M7XG4gICAgICAgIGlmIChyZW11eFJlc3VsdC5pbmRlcGVuZGVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB2YXIgc3RhcnRQVFMgPSB2aWRlby5zdGFydFBUUyxcbiAgICAgICAgICAgIGVuZFBUUyA9IHZpZGVvLmVuZFBUUyxcbiAgICAgICAgICAgIHN0YXJ0RFRTID0gdmlkZW8uc3RhcnREVFMsXG4gICAgICAgICAgICBlbmREVFMgPSB2aWRlby5lbmREVFM7XG4gICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbdmlkZW8udHlwZV0gPSB7XG4gICAgICAgICAgICAgIHN0YXJ0UFRTOiBzdGFydFBUUyxcbiAgICAgICAgICAgICAgZW5kUFRTOiBlbmRQVFMsXG4gICAgICAgICAgICAgIHN0YXJ0RFRTOiBzdGFydERUUyxcbiAgICAgICAgICAgICAgZW5kRFRTOiBlbmREVFNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2aWRlby5maXJzdEtleUZyYW1lICYmIHZpZGVvLmluZGVwZW5kZW50ICYmIGNodW5rTWV0YS5pZCA9PT0gMSAmJiAhaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAgICAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWRlby5kcm9wcGVkICYmIHZpZGVvLmluZGVwZW5kZW50KSB7XG4gICAgICAgICAgICAgIC8vIEJhY2t0cmFjayBpZiBkcm9wcGVkIGZyYW1lcyBjcmVhdGUgYSBnYXAgYWZ0ZXIgY3VycmVudFRpbWVcblxuICAgICAgICAgICAgICB2YXIgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICAgICAgICAgICAgdmFyIHRhcmdldEJ1ZmZlclRpbWUgPSAoYnVmZmVySW5mbyA/IGJ1ZmZlckluZm8uZW5kIDogdGhpcy5nZXRMb2FkUG9zaXRpb24oKSkgKyB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlO1xuICAgICAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gdmlkZW8uZmlyc3RLZXlGcmFtZVBUUyA/IHZpZGVvLmZpcnN0S2V5RnJhbWVQVFMgOiBzdGFydFBUUztcbiAgICAgICAgICAgICAgaWYgKCFpc0ZpcnN0RnJhZ21lbnQgJiYgdGFyZ2V0QnVmZmVyVGltZSA8IHN0YXJ0VGltZSAtIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgIWlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2t0cmFjayhmcmFnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgc2VnbWVudCB3aXRoIGEgZ2FwIHRvIGF2b2lkIGxvb3AgbG9hZGluZ1xuICAgICAgICAgICAgICAgIGZyYWcuZ2FwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBTZXQgdmlkZW8gc3RyZWFtIHN0YXJ0IHRvIGZyYWdtZW50IHN0YXJ0IHNvIHRoYXQgdHJ1bmNhdGVkIHNhbXBsZXMgZG8gbm90IGRpc3RvcnQgdGhlIHRpbWVsaW5lLCBhbmQgbWFyayBpdCBwYXJ0aWFsXG4gICAgICAgICAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odmlkZW8udHlwZSwgZnJhZy5zdGFydCwgZW5kUFRTLCBmcmFnLnN0YXJ0LCBlbmREVFMsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0RnJhZ21lbnQgJiYgc3RhcnRQVFMgPiBNQVhfU1RBUlRfR0FQX0pVTVApIHtcbiAgICAgICAgICAgICAgLy8gTWFyayBzZWdtZW50IHdpdGggYSBnYXAgdG8gc2tpcCBsYXJnZSBzdGFydCBnYXBcbiAgICAgICAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKHZpZGVvLnR5cGUsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpO1xuICAgICAgICAgIGlmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gZnJhZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5idWZmZXJGcmFnbWVudERhdGEodmlkZW8sIGZyYWcsIHBhcnQsIGNodW5rTWV0YSwgaXNGaXJzdEZyYWdtZW50IHx8IGlzRmlyc3RJbkRpc2NvbnRpbnVpdHkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmlyc3RGcmFnbWVudCB8fCBpc0ZpcnN0SW5EaXNjb250aW51aXR5KSB7XG4gICAgICAgICAgLy8gTWFyayBzZWdtZW50IHdpdGggYSBnYXAgdG8gYXZvaWQgbG9vcCBsb2FkaW5nXG4gICAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYmFja3RyYWNrKGZyYWcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGF1ZGlvKSB7XG4gICAgICAgIHZhciBfc3RhcnRQVFMgPSBhdWRpby5zdGFydFBUUyxcbiAgICAgICAgICBfZW5kUFRTID0gYXVkaW8uZW5kUFRTLFxuICAgICAgICAgIF9zdGFydERUUyA9IGF1ZGlvLnN0YXJ0RFRTLFxuICAgICAgICAgIF9lbmREVFMgPSBhdWRpby5lbmREVFM7XG4gICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0ge1xuICAgICAgICAgICAgc3RhcnRQVFM6IF9zdGFydFBUUyxcbiAgICAgICAgICAgIGVuZFBUUzogX2VuZFBUUyxcbiAgICAgICAgICAgIHN0YXJ0RFRTOiBfc3RhcnREVFMsXG4gICAgICAgICAgICBlbmREVFM6IF9lbmREVFNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8oRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLCBfc3RhcnRQVFMsIF9lbmRQVFMsIF9zdGFydERUUywgX2VuZERUUyk7XG4gICAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKGF1ZGlvLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpO1xuICAgICAgfVxuICAgICAgaWYgKGRldGFpbHMgJiYgaWQzICE9IG51bGwgJiYgKF9pZDMkc2FtcGxlcyA9IGlkMy5zYW1wbGVzKSAhPSBudWxsICYmIF9pZDMkc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGVtaXR0ZWRJRDMgPSB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgICBzYW1wbGVzOiBpZDMuc2FtcGxlc1xuICAgICAgICB9O1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBlbWl0dGVkSUQzKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZXRhaWxzICYmIHRleHQpIHtcbiAgICAgICAgdmFyIGVtaXR0ZWRUZXh0ID0ge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgICAgc2FtcGxlczogdGV4dC5zYW1wbGVzXG4gICAgICAgIH07XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIGVtaXR0ZWRUZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5fYnVmZmVySW5pdFNlZ21lbnQgPSBmdW5jdGlvbiBfYnVmZmVySW5pdFNlZ21lbnQoY3VycmVudExldmVsLCB0cmFja3MsIGZyYWcsIGNodW5rTWV0YSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmF1ZGlvT25seSA9ICEhdHJhY2tzLmF1ZGlvICYmICF0cmFja3MudmlkZW87XG5cbiAgICAgIC8vIGlmIGF1ZGlvIHRyYWNrIGlzIGV4cGVjdGVkIHRvIGNvbWUgZnJvbSBhdWRpbyBzdHJlYW0gY29udHJvbGxlciwgZGlzY2FyZCBhbnkgY29taW5nIGZyb20gbWFpblxuICAgICAgaWYgKHRoaXMuYWx0QXVkaW8gJiYgIXRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICAgIGRlbGV0ZSB0cmFja3MuYXVkaW87XG4gICAgICB9XG4gICAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgICAgdmFyIGF1ZGlvID0gdHJhY2tzLmF1ZGlvLFxuICAgICAgICB2aWRlbyA9IHRyYWNrcy52aWRlbyxcbiAgICAgICAgYXVkaW92aWRlbyA9IHRyYWNrcy5hdWRpb3ZpZGVvO1xuICAgICAgaWYgKGF1ZGlvKSB7XG4gICAgICAgIHZhciBhdWRpb0NvZGVjID0gY3VycmVudExldmVsLmF1ZGlvQ29kZWM7XG4gICAgICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgICAgIGlmIChhdWRpb0NvZGVjKSB7XG4gICAgICAgICAgICBpZiAoYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJbiB0aGUgY2FzZSB0aGF0IEFBQyBhbmQgSEUtQUFDIGF1ZGlvIGNvZGVjcyBhcmUgc2lnbmFsbGVkIGluIG1hbmlmZXN0LFxuICAgICAgICAgIC8vIGZvcmNlIEhFLUFBQywgYXMgaXQgc2VlbXMgdGhhdCBtb3N0IGJyb3dzZXJzIHByZWZlcnMgaXQuXG4gICAgICAgICAgLy8gZG9uJ3QgZm9yY2UgSEUtQUFDIGlmIG1vbm8gc3RyZWFtLCBvciBpbiBGaXJlZm94XG4gICAgICAgICAgdmFyIGF1ZGlvTWV0YWRhdGEgPSBhdWRpby5tZXRhZGF0YTtcbiAgICAgICAgICBpZiAoYXVkaW9NZXRhZGF0YSAmJiAnY2hhbm5lbENvdW50JyBpbiBhdWRpb01ldGFkYXRhICYmIChhdWRpb01ldGFkYXRhLmNoYW5uZWxDb3VudCB8fCAxKSAhPT0gMSAmJiB1YS5pbmRleE9mKCdmaXJlZm94JykgPT09IC0xKSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhFLUFBQyBpcyBicm9rZW4gb24gQW5kcm9pZCwgYWx3YXlzIHNpZ25hbCBhdWRpbyBjb2RlYyBhcyBBQUMgZXZlbiBpZiB2YXJpYW50IG1hbmlmZXN0IHN0YXRlcyBvdGhlcndpc2VcbiAgICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSAmJiBhdWRpby5jb250YWluZXIgIT09ICdhdWRpby9tcGVnJykge1xuICAgICAgICAgIC8vIEV4Y2x1ZGUgbXBlZyBhdWRpb1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC4yJztcbiAgICAgICAgICB0aGlzLmxvZyhcIkFuZHJvaWQ6IGZvcmNlIGF1ZGlvIGNvZGVjIHRvIFwiICsgYXVkaW9Db2RlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjICYmIGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjICE9PSBhdWRpb0NvZGVjKSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJTd2FwcGluZyBtYW5pZmVzdCBhdWRpbyBjb2RlYyBcXFwiXCIgKyBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyArIFwiXFxcIiBmb3IgXFxcIlwiICsgYXVkaW9Db2RlYyArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBhdWRpby5sZXZlbENvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgICAgYXVkaW8uaWQgPSAnbWFpbic7XG4gICAgICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjpcIiArIGF1ZGlvLmNvbnRhaW5lciArIFwiLCBjb2RlY3Nbc2VsZWN0ZWQvbGV2ZWwvcGFyc2VkXT1bXCIgKyAoYXVkaW9Db2RlYyB8fCAnJykgKyBcIi9cIiArIChjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyB8fCAnJykgKyBcIi9cIiArIGF1ZGlvLmNvZGVjICsgXCJdXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgIHZpZGVvLmxldmVsQ29kZWMgPSBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYztcbiAgICAgICAgdmlkZW8uaWQgPSAnbWFpbic7XG4gICAgICAgIHRoaXMubG9nKFwiSW5pdCB2aWRlbyBidWZmZXIsIGNvbnRhaW5lcjpcIiArIHZpZGVvLmNvbnRhaW5lciArIFwiLCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bXCIgKyAoY3VycmVudExldmVsLnZpZGVvQ29kZWMgfHwgJycpICsgXCIvXCIgKyB2aWRlby5jb2RlYyArIFwiXVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChhdWRpb3ZpZGVvKSB7XG4gICAgICAgIHRoaXMubG9nKFwiSW5pdCBhdWRpb3ZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOlwiICsgYXVkaW92aWRlby5jb250YWluZXIgKyBcIiwgY29kZWNzW2xldmVsL3BhcnNlZF09W1wiICsgY3VycmVudExldmVsLmNvZGVjcyArIFwiL1wiICsgYXVkaW92aWRlby5jb2RlYyArIFwiXVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRyYWNrcyk7XG4gICAgICAvLyBsb29wIHRocm91Z2ggdHJhY2tzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHByb3ZpZGVkIHRvIGJ1ZmZlckNvbnRyb2xsZXJcbiAgICAgIE9iamVjdC5rZXlzKHRyYWNrcykuZm9yRWFjaChmdW5jdGlvbiAodHJhY2tOYW1lKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1t0cmFja05hbWVdO1xuICAgICAgICB2YXIgaW5pdFNlZ21lbnQgPSB0cmFjay5pbml0U2VnbWVudDtcbiAgICAgICAgaWYgKGluaXRTZWdtZW50ICE9IG51bGwgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIF90aGlzMy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVORElORywge1xuICAgICAgICAgICAgdHlwZTogdHJhY2tOYW1lLFxuICAgICAgICAgICAgZGF0YTogaW5pdFNlZ21lbnQsXG4gICAgICAgICAgICBmcmFnOiBmcmFnLFxuICAgICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICAgIGNodW5rTWV0YTogY2h1bmtNZXRhLFxuICAgICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyB0cmlnZ2VyIGhhbmRsZXIgcmlnaHQgbm93XG4gICAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRNYWluRndkQnVmZmVySW5mbyA9IGZ1bmN0aW9uIGdldE1haW5Gd2RCdWZmZXJJbmZvKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgIH07XG4gICAgX3Byb3RvLmJhY2t0cmFjayA9IGZ1bmN0aW9uIGJhY2t0cmFjayhmcmFnKSB7XG4gICAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgIC8vIENhdXNlcyBmaW5kRnJhZ21lbnRzIHRvIGJhY2t0cmFjayB0aHJvdWdoIGZyYWdtZW50cyB0byBmaW5kIHRoZSBrZXlmcmFtZVxuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IGZyYWc7XG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgdGhpcy5mbHVzaEJ1ZmZlckdhcChmcmFnKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydDtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH07XG4gICAgX3Byb3RvLmNoZWNrRnJhZ21lbnRDaGFuZ2VkID0gZnVuY3Rpb24gY2hlY2tGcmFnbWVudENoYW5nZWQoKSB7XG4gICAgICB2YXIgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgICAgdmFyIGZyYWdQbGF5aW5nQ3VycmVudCA9IG51bGw7XG4gICAgICBpZiAodmlkZW8gJiYgdmlkZW8ucmVhZHlTdGF0ZSA+IDEgJiYgdmlkZW8uc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAgIC8qIGlmIHZpZGVvIGVsZW1lbnQgaXMgaW4gc2Vla2VkIHN0YXRlLCBjdXJyZW50VGltZSBjYW4gb25seSBpbmNyZWFzZS5cbiAgICAgICAgICAoYXNzdW1pbmcgdGhhdCBwbGF5YmFjayByYXRlIGlzIHBvc2l0aXZlIC4uLilcbiAgICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgICBtZWRpYSBkZWNvZGUgZXJyb3IsIGNoZWNrIHRoaXMsIHRvIGF2b2lkIHNlZWtpbmcgYmFjayB0b1xuICAgICAgICAgIHdyb25nIHBvc2l0aW9uIGFmdGVyIGEgbWVkaWEgZGVjb2RlIGVycm9yXG4gICAgICAgICovXG5cbiAgICAgICAgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSkpIHtcbiAgICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhjdXJyZW50VGltZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lICsgMC4xKSkge1xuICAgICAgICAgIC8qIGVuc3VyZSB0aGF0IEZSQUdfQ0hBTkdFRCBldmVudCBpcyB0cmlnZ2VyZWQgYXQgc3RhcnR1cCxcbiAgICAgICAgICAgIHdoZW4gZmlyc3QgdmlkZW8gZnJhbWUgaXMgZGlzcGxheWVkIGFuZCBwbGF5YmFjayBpcyBwYXVzZWQuXG4gICAgICAgICAgICBhZGQgYSB0b2xlcmFuY2Ugb2YgMTAwbXMsIGluIGNhc2UgY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsXG4gICAgICAgICAgICBjaGVjayBpZiBjdXJyZW50IHBvcysxMDBtcyBpcyBidWZmZXJlZCBhbmQgdXNlIHRoYXQgYnVmZmVyIHJhbmdlXG4gICAgICAgICAgICBmb3IgRlJBR19DSEFOR0VEIGV2ZW50IHJlcG9ydGluZyAqL1xuICAgICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lICsgMC4xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50KSB7XG4gICAgICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgICAgICAgdmFyIGZyYWdQbGF5aW5nID0gdGhpcy5mcmFnUGxheWluZztcbiAgICAgICAgICB2YXIgZnJhZ0N1cnJlbnRMZXZlbCA9IGZyYWdQbGF5aW5nQ3VycmVudC5sZXZlbDtcbiAgICAgICAgICBpZiAoIWZyYWdQbGF5aW5nIHx8IGZyYWdQbGF5aW5nQ3VycmVudC5zbiAhPT0gZnJhZ1BsYXlpbmcuc24gfHwgZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdDdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBmcmFnUGxheWluZ0N1cnJlbnQ7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0NIQU5HRUQsIHtcbiAgICAgICAgICAgICAgZnJhZzogZnJhZ1BsYXlpbmdDdXJyZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZnJhZ1BsYXlpbmcgfHwgZnJhZ1BsYXlpbmcubGV2ZWwgIT09IGZyYWdDdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfU1dJVENIRUQsIHtcbiAgICAgICAgICAgICAgICBsZXZlbDogZnJhZ0N1cnJlbnRMZXZlbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIF9jcmVhdGVDbGFzcyhTdHJlYW1Db250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcIm5leHRMZXZlbFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBmcmFnID0gdGhpcy5uZXh0QnVmZmVyZWRGcmFnO1xuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgIHJldHVybiBmcmFnLmxldmVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3VycmVudEZyYWdcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mcmFnUGxheWluZyB8fCB0aGlzLmdldEFwcGVuZGVkRnJhZyhtZWRpYS5jdXJyZW50VGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImN1cnJlbnRQcm9ncmFtRGF0ZVRpbWVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgICAgICB2YXIgZnJhZyA9IHRoaXMuY3VycmVudEZyYWc7XG4gICAgICAgICAgaWYgKGZyYWcgJiYgaXNGaW5pdGVOdW1iZXIoY3VycmVudFRpbWUpICYmIGlzRmluaXRlTnVtYmVyKGZyYWcucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgICAgICAgICAgdmFyIGVwb2NNcyA9IGZyYWcucHJvZ3JhbURhdGVUaW1lICsgKGN1cnJlbnRUaW1lIC0gZnJhZy5zdGFydCkgKiAxMDAwO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGVwb2NNcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjdXJyZW50TGV2ZWxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgZnJhZyA9IHRoaXMuY3VycmVudEZyYWc7XG4gICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJuZXh0QnVmZmVyZWRGcmFnXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnO1xuICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhmcmFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZm9yY2VTdGFydExvYWRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yY2VTdGFydExvYWQ7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBTdHJlYW1Db250cm9sbGVyO1xuICB9KEJhc2VTdHJlYW1Db250cm9sbGVyKTtcblxuICAvKipcbiAgICogVGhlIGBIbHNgIGNsYXNzIGlzIHRoZSBjb3JlIG9mIHRoZSBITFMuanMgbGlicmFyeSB1c2VkIHRvIGluc3RhbnRpYXRlIHBsYXllciBpbnN0YW5jZXMuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHZhciBIbHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSByZXF1aXJlZCBNZWRpYVNvdXJjZSBFeHRlbnNpb25zIGFyZSBhdmFpbGFibGUuXG4gICAgICovXG4gICAgSGxzLmlzTVNFU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNNU0VTdXBwb3J0ZWQkMSgpIHtcbiAgICAgIHJldHVybiBpc01TRVN1cHBvcnRlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIE1lZGlhU291cmNlIEV4dGVuc2lvbnMgYXJlIGF2YWlsYWJsZSBhbmQgaXNUeXBlU3VwcG9ydGVkIGNoZWNrcyBwYXNzIGZvciBhbnkgYmFzZWxpbmUgY29kZWNzLlxuICAgICAqLztcbiAgICBIbHMuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZCQxKCkge1xuICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBNZWRpYVNvdXJjZSBnbG9iYWwgdXNlZCBmb3IgTVNFIHBsYXliYWNrIChNYW5hZ2VkTWVkaWFTb3VyY2UsIE1lZGlhU291cmNlLCBvciBXZWJLaXRNZWRpYVNvdXJjZSkuXG4gICAgICovO1xuICAgIEhscy5nZXRNZWRpYVNvdXJjZSA9IGZ1bmN0aW9uIGdldE1lZGlhU291cmNlJDEoKSB7XG4gICAgICByZXR1cm4gZ2V0TWVkaWFTb3VyY2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gSExTIGNsaWVudCB0aGF0IGNhbiBhdHRhY2ggdG8gZXhhY3RseSBvbmUgYEhUTUxNZWRpYUVsZW1lbnRgLlxuICAgICAqIEBwYXJhbSB1c2VyQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGFwcGxpZWQgb3ZlciBgSGxzLkRlZmF1bHRDb25maWdgXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGxzKHVzZXJDb25maWcpIHtcbiAgICAgIGlmICh1c2VyQ29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgICAgdXNlckNvbmZpZyA9IHt9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgcnVudGltZSBjb25maWd1cmF0aW9uIHVzZWQgYnkgdGhlIHBsYXllci4gQXQgaW5zdGFudGlhdGlvbiB0aGlzIGlzIGNvbWJpbmF0aW9uIG9mIGBobHMudXNlckNvbmZpZ2AgbWVyZ2VkIG92ZXIgYEhscy5EZWZhdWx0Q29uZmlnYC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBwcm92aWRlZCBvbiBwbGF5ZXIgaW5zdGFudGlhdGlvbi5cbiAgICAgICAqL1xuICAgICAgdGhpcy51c2VyQ29uZmlnID0gdm9pZCAwO1xuICAgICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IHZvaWQgMDtcbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gdm9pZCAwO1xuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgICAgdGhpcy5fbWF4SGRjcExldmVsID0gbnVsbDtcbiAgICAgIHRoaXMuYWJyQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuYnVmZmVyQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5sYXRlbmN5Q29udHJvbGxlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmVtZUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgICB0aGlzLmNtY2RDb250cm9sbGVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICAgICAgdGhpcy51cmwgPSBudWxsO1xuICAgICAgdGhpcy50cmlnZ2VyaW5nRXhjZXB0aW9uID0gdm9pZCAwO1xuICAgICAgZW5hYmxlTG9ncyh1c2VyQ29uZmlnLmRlYnVnIHx8IGZhbHNlLCAnSGxzIGluc3RhbmNlJyk7XG4gICAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcgPSBtZXJnZUNvbmZpZyhIbHMuRGVmYXVsdENvbmZpZywgdXNlckNvbmZpZyk7XG4gICAgICB0aGlzLnVzZXJDb25maWcgPSB1c2VyQ29uZmlnO1xuICAgICAgaWYgKGNvbmZpZy5wcm9ncmVzc2l2ZSkge1xuICAgICAgICBlbmFibGVTdHJlYW1pbmdNb2RlKGNvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvcmUgY29udHJvbGxlcnMgYW5kIG5ldHdvcmsgbG9hZGVyc1xuICAgICAgdmFyIENvbmZpZ0FickNvbnRyb2xsZXIgPSBjb25maWcuYWJyQ29udHJvbGxlcixcbiAgICAgICAgQ29uZmlnQnVmZmVyQ29udHJvbGxlciA9IGNvbmZpZy5idWZmZXJDb250cm9sbGVyLFxuICAgICAgICBDb25maWdDYXBMZXZlbENvbnRyb2xsZXIgPSBjb25maWcuY2FwTGV2ZWxDb250cm9sbGVyLFxuICAgICAgICBDb25maWdFcnJvckNvbnRyb2xsZXIgPSBjb25maWcuZXJyb3JDb250cm9sbGVyLFxuICAgICAgICBDb25maWdGcHNDb250cm9sbGVyID0gY29uZmlnLmZwc0NvbnRyb2xsZXI7XG4gICAgICB2YXIgZXJyb3JDb250cm9sbGVyID0gbmV3IENvbmZpZ0Vycm9yQ29udHJvbGxlcih0aGlzKTtcbiAgICAgIHZhciBhYnJDb250cm9sbGVyID0gdGhpcy5hYnJDb250cm9sbGVyID0gbmV3IENvbmZpZ0FickNvbnRyb2xsZXIodGhpcyk7XG4gICAgICB2YXIgYnVmZmVyQ29udHJvbGxlciA9IHRoaXMuYnVmZmVyQ29udHJvbGxlciA9IG5ldyBDb25maWdCdWZmZXJDb250cm9sbGVyKHRoaXMpO1xuICAgICAgdmFyIGNhcExldmVsQ29udHJvbGxlciA9IHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyID0gbmV3IENvbmZpZ0NhcExldmVsQ29udHJvbGxlcih0aGlzKTtcbiAgICAgIHZhciBmcHNDb250cm9sbGVyID0gbmV3IENvbmZpZ0Zwc0NvbnRyb2xsZXIodGhpcyk7XG4gICAgICB2YXIgcGxheUxpc3RMb2FkZXIgPSBuZXcgUGxheWxpc3RMb2FkZXIodGhpcyk7XG4gICAgICB2YXIgaWQzVHJhY2tDb250cm9sbGVyID0gbmV3IElEM1RyYWNrQ29udHJvbGxlcih0aGlzKTtcbiAgICAgIHZhciBDb25maWdDb250ZW50U3RlZXJpbmdDb250cm9sbGVyID0gY29uZmlnLmNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI7XG4gICAgICAvLyBDb25lbnRTdGVlcmluZ0NvbnRyb2xsZXIgaXMgZGVmaW5lZCBiZWZvcmUgTGV2ZWxDb250cm9sbGVyIHRvIHJlY2VpdmUgTXVsdGl2YXJpYW50IFBsYXlsaXN0IGV2ZW50cyBmaXJzdFxuICAgICAgdmFyIGNvbnRlbnRTdGVlcmluZyA9IENvbmZpZ0NvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgPyBuZXcgQ29uZmlnQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlcih0aGlzKSA6IG51bGw7XG4gICAgICB2YXIgbGV2ZWxDb250cm9sbGVyID0gdGhpcy5sZXZlbENvbnRyb2xsZXIgPSBuZXcgTGV2ZWxDb250cm9sbGVyKHRoaXMsIGNvbnRlbnRTdGVlcmluZyk7XG4gICAgICAvLyBGcmFnbWVudFRyYWNrZXIgbXVzdCBiZSBkZWZpbmVkIGJlZm9yZSBTdHJlYW1Db250cm9sbGVyIGJlY2F1c2UgdGhlIG9yZGVyIG9mIGV2ZW50IGhhbmRsaW5nIGlzIGltcG9ydGFudFxuICAgICAgdmFyIGZyYWdtZW50VHJhY2tlciA9IG5ldyBGcmFnbWVudFRyYWNrZXIodGhpcyk7XG4gICAgICB2YXIga2V5TG9hZGVyID0gbmV3IEtleUxvYWRlcih0aGlzLmNvbmZpZyk7XG4gICAgICB2YXIgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG5ldyBTdHJlYW1Db250cm9sbGVyKHRoaXMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKTtcblxuICAgICAgLy8gQ2FwIGxldmVsIGNvbnRyb2xsZXIgdXNlcyBzdHJlYW1Db250cm9sbGVyIHRvIGZsdXNoIHRoZSBidWZmZXJcbiAgICAgIGNhcExldmVsQ29udHJvbGxlci5zZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgLy8gZnBzQ29udHJvbGxlciB1c2VzIHN0cmVhbUNvbnRyb2xsZXIgdG8gc3dpdGNoIHdoZW4gZnJhbWVzIGFyZSBiZWluZyBkcm9wcGVkXG4gICAgICBmcHNDb250cm9sbGVyLnNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcik7XG4gICAgICB2YXIgbmV0d29ya0NvbnRyb2xsZXJzID0gW3BsYXlMaXN0TG9hZGVyLCBsZXZlbENvbnRyb2xsZXIsIHN0cmVhbUNvbnRyb2xsZXJdO1xuICAgICAgaWYgKGNvbnRlbnRTdGVlcmluZykge1xuICAgICAgICBuZXR3b3JrQ29udHJvbGxlcnMuc3BsaWNlKDEsIDAsIGNvbnRlbnRTdGVlcmluZyk7XG4gICAgICB9XG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IG5ldHdvcmtDb250cm9sbGVycztcbiAgICAgIHZhciBjb3JlQ29tcG9uZW50cyA9IFthYnJDb250cm9sbGVyLCBidWZmZXJDb250cm9sbGVyLCBjYXBMZXZlbENvbnRyb2xsZXIsIGZwc0NvbnRyb2xsZXIsIGlkM1RyYWNrQ29udHJvbGxlciwgZnJhZ21lbnRUcmFja2VyXTtcbiAgICAgIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLmF1ZGlvVHJhY2tDb250cm9sbGVyLCBuZXR3b3JrQ29udHJvbGxlcnMpO1xuICAgICAgdmFyIEF1ZGlvU3RyZWFtQ29udHJvbGxlckNsYXNzID0gY29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgIGlmIChBdWRpb1N0cmVhbUNvbnRyb2xsZXJDbGFzcykge1xuICAgICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChuZXcgQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3ModGhpcywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpKTtcbiAgICAgIH1cbiAgICAgIC8vIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgc3VidGl0bGVTdHJlYW1Db250cm9sbGVyIGJlY2F1c2UgdGhlIG9yZGVyIG9mIGV2ZW50IGhhbmRsaW5nIGlzIGltcG9ydGFudFxuICAgICAgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIsIG5ldHdvcmtDb250cm9sbGVycyk7XG4gICAgICB2YXIgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3MgPSBjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuICAgICAgaWYgKFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKG5ldyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcyh0aGlzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikpO1xuICAgICAgfVxuICAgICAgdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy50aW1lbGluZUNvbnRyb2xsZXIsIGNvcmVDb21wb25lbnRzKTtcbiAgICAgIGtleUxvYWRlci5lbWVDb250cm9sbGVyID0gdGhpcy5lbWVDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5lbWVDb250cm9sbGVyLCBjb3JlQ29tcG9uZW50cyk7XG4gICAgICB0aGlzLmNtY2RDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5jbWNkQ29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgICAgdGhpcy5sYXRlbmN5Q29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihMYXRlbmN5Q29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IGNvcmVDb21wb25lbnRzO1xuXG4gICAgICAvLyBFcnJvciBjb250cm9sbGVyIGhhbmRsZXMgZXJyb3JzIGJlZm9yZSBhbmQgYWZ0ZXIgYWxsIG90aGVyIGNvbnRyb2xsZXJzXG4gICAgICAvLyBUaGlzIGxpc3RlbmVyIHdpbGwgYmUgaW52b2tlZCBhZnRlciBhbGwgb3RoZXIgY29udHJvbGxlcnMgZXJyb3IgbGlzdGVuZXJzXG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChlcnJvckNvbnRyb2xsZXIpO1xuICAgICAgdmFyIG9uRXJyb3JPdXQgPSBlcnJvckNvbnRyb2xsZXIub25FcnJvck91dDtcbiAgICAgIGlmICh0eXBlb2Ygb25FcnJvck91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLm9uKEV2ZW50cy5FUlJPUiwgb25FcnJvck91dCwgZXJyb3JDb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9wcm90byA9IEhscy5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmNyZWF0ZUNvbnRyb2xsZXIgPSBmdW5jdGlvbiBjcmVhdGVDb250cm9sbGVyKENvbnRyb2xsZXJDbGFzcywgY29tcG9uZW50cykge1xuICAgICAgaWYgKENvbnRyb2xsZXJDbGFzcykge1xuICAgICAgICB2YXIgY29udHJvbGxlckluc3RhbmNlID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICBjb21wb25lbnRzLnB1c2goY29udHJvbGxlckluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbGxlckluc3RhbmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gRGVsZWdhdGUgdGhlIEV2ZW50RW1pdHRlciB0aHJvdWdoIHRoZSBwdWJsaWMgQVBJIG9mIEhscy5qc1xuICAgIDtcbiAgICBfcHJvdG8ub24gPSBmdW5jdGlvbiBvbihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbWl0dGVyLm9uKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5fZW1pdHRlci5vbmNlKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICB0aGlzLl9lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudCk7XG4gICAgfTtcbiAgICBfcHJvdG8ub2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCwgb25jZSkge1xuICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXR0ZXIub2ZmKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCwgb25jZSk7XG4gICAgfTtcbiAgICBfcHJvdG8ubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lcnMoZXZlbnQpO1xuICAgIH07XG4gICAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBuYW1lLCBldmVudE9iamVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZW1pdChldmVudCwgbmFtZSwgZXZlbnRPYmplY3QpO1xuICAgIH07XG4gICAgX3Byb3RvLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyKGV2ZW50LCBldmVudE9iamVjdCkge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmRlYnVnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCBldmVudE9iamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCBldmVudE9iamVjdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdBbiBpbnRlcm5hbCBlcnJvciBoYXBwZW5lZCB3aGlsZSBoYW5kbGluZyBldmVudCAnICsgZXZlbnQgKyAnLiBFcnJvciBtZXNzYWdlOiBcIicgKyBlcnJvci5tZXNzYWdlICsgJ1wiLiBIZXJlIGlzIGEgc3RhY2t0cmFjZTonLCBlcnJvcik7XG4gICAgICAgICAgLy8gUHJldmVudCByZWN1cnNpb24gaW4gZXJyb3IgZXZlbnQgaGFuZGxlcnMgdGhhdCB0aHJvdyAjNTQ5N1xuICAgICAgICAgIGlmICghdGhpcy50cmlnZ2VyaW5nRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJpbmdFeGNlcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGZhdGFsID0gZXZlbnQgPT09IEV2ZW50cy5FUlJPUjtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhdGFsLFxuICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJpbmdFeGNlcHRpb24gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJDb3VudChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi87XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgbG9nZ2VyLmxvZygnZGVzdHJveScpO1xuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5ERVNUUk9ZSU5HLCB1bmRlZmluZWQpO1xuICAgICAgdGhpcy5kZXRhY2hNZWRpYSgpO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuY29yZUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvcmVDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAvLyBSZW1vdmUgYW55IHJlZmVyZW5jZXMgdGhhdCBjb3VsZCBiZSBoZWxkIGluIGNvbmZpZyBvcHRpb25zIG9yIGNhbGxiYWNrc1xuICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgY29uZmlnLnhoclNldHVwID0gY29uZmlnLmZldGNoU2V0dXAgPSB1bmRlZmluZWQ7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLnVzZXJDb25maWcgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIEhscy5qcyB0byBhIG1lZGlhIGVsZW1lbnRcbiAgICAgKi87XG4gICAgX3Byb3RvLmF0dGFjaE1lZGlhID0gZnVuY3Rpb24gYXR0YWNoTWVkaWEobWVkaWEpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2F0dGFjaE1lZGlhJyk7XG4gICAgICB0aGlzLl9tZWRpYSA9IG1lZGlhO1xuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHtcbiAgICAgICAgbWVkaWE6IG1lZGlhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggSGxzLmpzIGZyb20gdGhlIG1lZGlhXG4gICAgICovO1xuICAgIF9wcm90by5kZXRhY2hNZWRpYSA9IGZ1bmN0aW9uIGRldGFjaE1lZGlhKCkge1xuICAgICAgbG9nZ2VyLmxvZygnZGV0YWNoTWVkaWEnKTtcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUVESUFfREVUQUNISU5HLCB1bmRlZmluZWQpO1xuICAgICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc291cmNlIFVSTC4gQ2FuIGJlIHJlbGF0aXZlIG9yIGFic29sdXRlLlxuICAgICAqLztcbiAgICBfcHJvdG8ubG9hZFNvdXJjZSA9IGZ1bmN0aW9uIGxvYWRTb3VyY2UodXJsKSB7XG4gICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgdmFyIGxvYWRlZFNvdXJjZSA9IHRoaXMudXJsO1xuICAgICAgdmFyIGxvYWRpbmdTb3VyY2UgPSB0aGlzLnVybCA9IHVybFRvb2xraXRFeHBvcnRzLmJ1aWxkQWJzb2x1dGVVUkwoc2VsZi5sb2NhdGlvbi5ocmVmLCB1cmwsIHtcbiAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICAgIHRoaXMuX21heEhkY3BMZXZlbCA9IG51bGw7XG4gICAgICBsb2dnZXIubG9nKFwibG9hZFNvdXJjZTpcIiArIGxvYWRpbmdTb3VyY2UpO1xuICAgICAgaWYgKG1lZGlhICYmIGxvYWRlZFNvdXJjZSAmJiAobG9hZGVkU291cmNlICE9PSBsb2FkaW5nU291cmNlIHx8IHRoaXMuYnVmZmVyQ29udHJvbGxlci5oYXNTb3VyY2VUeXBlcygpKSkge1xuICAgICAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xuICAgICAgfVxuICAgICAgLy8gd2hlbiBhdHRhY2hpbmcgdG8gYSBzb3VyY2UgVVJMLCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZFxuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB7XG4gICAgICAgIHVybDogdXJsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBsb2FkaW5nIGRhdGEgZnJvbSB0aGUgc3RyZWFtIHNvdXJjZS5cbiAgICAgKiBEZXBlbmRpbmcgb24gZGVmYXVsdCBjb25maWcsIGNsaWVudCBzdGFydHMgbG9hZGluZyBhdXRvbWF0aWNhbGx5IHdoZW4gYSBzb3VyY2UgaXMgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0UG9zaXRpb24gLSBTZXQgdGhlIHN0YXJ0IHBvc2l0aW9uIHRvIHN0cmVhbSBmcm9tLlxuICAgICAqIERlZmF1bHRzIHRvIC0xIChOb25lOiBzdGFydHMgZnJvbSBlYXJsaWVzdCBwb2ludClcbiAgICAgKi87XG4gICAgX3Byb3RvLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7XG4gICAgICBpZiAoc3RhcnRQb3NpdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5sb2coXCJzdGFydExvYWQoXCIgKyBzdGFydFBvc2l0aW9uICsgXCIpXCIpO1xuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGxvYWRpbmcgb2YgYW55IHN0cmVhbSBkYXRhLlxuICAgICAqLztcbiAgICBfcHJvdG8uc3RvcExvYWQgPSBmdW5jdGlvbiBzdG9wTG9hZCgpIHtcbiAgICAgIGxvZ2dlci5sb2coJ3N0b3BMb2FkJyk7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdW1lcyBzdHJlYW0gY29udHJvbGxlciBzZWdtZW50IGxvYWRpbmcgaWYgcHJldmlvdXNseSBzdGFydGVkLlxuICAgICAqLztcbiAgICBfcHJvdG8ucmVzdW1lQnVmZmVyaW5nID0gZnVuY3Rpb24gcmVzdW1lQnVmZmVyaW5nKCkge1xuICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKCdmcmFnbWVudExvYWRlcicgaW4gY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5zdGFydExvYWQoLTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcHMgc3RyZWFtIGNvbnRyb2xsZXIgc2VnbWVudCBsb2FkaW5nIHdpdGhvdXQgY2hhbmdpbmcgJ3N0YXJ0ZWQnIHN0YXRlIGxpa2Ugc3RvcExvYWQoKS5cbiAgICAgKiBUaGlzIGFsbG93cyBmb3IgbWVkaWEgYnVmZmVyaW5nIHRvIGJlIHBhdXNlZCB3aXRob3V0IGludGVydXB0aW5nIHBsYXlsaXN0IGxvYWRpbmcuXG4gICAgICovO1xuICAgIF9wcm90by5wYXVzZUJ1ZmZlcmluZyA9IGZ1bmN0aW9uIHBhdXNlQnVmZmVyaW5nKCkge1xuICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgICBpZiAoJ2ZyYWdtZW50TG9hZGVyJyBpbiBjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2FwIHRocm91Z2ggcG9zc2libGUgYXVkaW8gY29kZWNzIGluIHRoZSBzdHJlYW0gKGZvciBleGFtcGxlIHRvIHN3aXRjaCBmcm9tIHN0ZXJlbyB0byA1LjEpXG4gICAgICovO1xuICAgIF9wcm90by5zd2FwQXVkaW9Db2RlYyA9IGZ1bmN0aW9uIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgICAgbG9nZ2VyLmxvZygnc3dhcEF1ZGlvQ29kZWMnKTtcbiAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIG1lZGlhLWVsZW1lbnQgZmFpbHMsIHRoaXMgYWxsb3dzIHRvIGRldGFjaCBhbmQgdGhlbiByZS1hdHRhY2ggaXRcbiAgICAgKiBhcyBvbmUgY2FsbCAoY29udmVuaWVuY2UgbWV0aG9kKS5cbiAgICAgKlxuICAgICAqIEF1dG9tYXRpYyByZWNvdmVyeSBvZiBtZWRpYS1lcnJvcnMgYnkgdGhpcyBwcm9jZXNzIGlzIGNvbmZpZ3VyYWJsZS5cbiAgICAgKi87XG4gICAgX3Byb3RvLnJlY292ZXJNZWRpYUVycm9yID0gZnVuY3Rpb24gcmVjb3Zlck1lZGlhRXJyb3IoKSB7XG4gICAgICBsb2dnZXIubG9nKCdyZWNvdmVyTWVkaWFFcnJvcicpO1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5fbWVkaWE7XG4gICAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hNZWRpYShtZWRpYSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlTGV2ZWwgPSBmdW5jdGlvbiByZW1vdmVMZXZlbChsZXZlbEluZGV4KSB7XG4gICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5yZW1vdmVMZXZlbChsZXZlbEluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBsZXZlbHMgKHZhcmlhbnRzKSBzb3J0ZWQgYnkgSERDUC1MRVZFTCwgUkVTT0xVVElPTiAoaGVpZ2h0KSwgRlJBTUUtUkFURSwgQ09ERUNTLCBWSURFTy1SQU5HRSwgYW5kIEJBTkRXSURUSFxuICAgICAqLztcbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBzZWxlY3QgdGhlIGJlc3QgbWF0Y2hpbmcgYXVkaW8gdHJhY2ssIG1ha2luZyBhIGxldmVsIHN3aXRjaCB3aGVuIGEgR3JvdXAgY2hhbmdlIGlzIG5lY2Vzc2FyeS5cbiAgICAgKiBVcGRhdGVzIGBobHMuY29uZmlnLmF1ZGlvUHJlZmVyZW5jZWAuIFJldHVybnMgdGhlIHNlbGVjdGVkIHRyYWNrLCBvciBudWxsIHdoZW4gbm8gbWF0Y2hpbmcgdHJhY2sgaXMgZm91bmQuXG4gICAgICovXG4gICAgX3Byb3RvLnNldEF1ZGlvT3B0aW9uID0gZnVuY3Rpb24gc2V0QXVkaW9PcHRpb24oYXVkaW9PcHRpb24pIHtcbiAgICAgIHZhciBfdGhpcyRhdWRpb1RyYWNrQ29udHI7XG4gICAgICByZXR1cm4gKF90aGlzJGF1ZGlvVHJhY2tDb250ciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRhdWRpb1RyYWNrQ29udHIuc2V0QXVkaW9PcHRpb24oYXVkaW9PcHRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBzZWxlY3QgdGhlIGJlc3QgbWF0Y2hpbmcgc3VidGl0bGUgdHJhY2ssIG1ha2luZyBhIGxldmVsIHN3aXRjaCB3aGVuIGEgR3JvdXAgY2hhbmdlIGlzIG5lY2Vzc2FyeS5cbiAgICAgKiBVcGRhdGVzIGBobHMuY29uZmlnLnN1YnRpdGxlUHJlZmVyZW5jZWAuIFJldHVybnMgdGhlIHNlbGVjdGVkIHRyYWNrLCBvciBudWxsIHdoZW4gbm8gbWF0Y2hpbmcgdHJhY2sgaXMgZm91bmQuXG4gICAgICovO1xuICAgIF9wcm90by5zZXRTdWJ0aXRsZU9wdGlvbiA9IGZ1bmN0aW9uIHNldFN1YnRpdGxlT3B0aW9uKHN1YnRpdGxlT3B0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMkc3VidGl0bGVUcmFja0NvO1xuICAgICAgKF90aGlzJHN1YnRpdGxlVHJhY2tDbyA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRzdWJ0aXRsZVRyYWNrQ28uc2V0U3VidGl0bGVPcHRpb24oc3VidGl0bGVPcHRpb24pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb21wbGV0ZSBsaXN0IG9mIGF1ZGlvIHRyYWNrcyBhY3Jvc3MgYWxsIG1lZGlhIGdyb3Vwc1xuICAgICAqLztcbiAgICBfY3JlYXRlQ2xhc3MoSGxzLCBbe1xuICAgICAga2V5OiBcImxldmVsc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbHM7XG4gICAgICAgIHJldHVybiBsZXZlbHMgPyBsZXZlbHMgOiBbXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbmRleCBvZiBxdWFsaXR5IGxldmVsICh2YXJpYW50KSBjdXJyZW50bHkgcGxheWVkXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY3VycmVudExldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50TGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggaW1tZWRpYXRlbHkuIFRoaXMgd2lsbCBmbHVzaCB0aGUgY3VycmVudCBidWZmZXIgdG8gcmVwbGFjZSB0aGUgcXVhbGl0eSBhc2FwLiBUaGF0IG1lYW5zIHBsYXliYWNrIHdpbGwgaW50ZXJydXB0IGF0IGxlYXN0IHNob3J0bHkgdG8gcmUtYnVmZmVyIGFuZCByZS1zeW5jIGV2ZW50dWFsbHkuIFNldCB0byAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbi5cbiAgICAgICAqLyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJzZXQgY3VycmVudExldmVsOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbmRleCBvZiBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkIGFzIHNjaGVkdWxlZCBieSBzdHJlYW0gY29udHJvbGxlci5cbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJuZXh0TGV2ZWxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YS5cbiAgICAgICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHZpZGVvIHF1YWxpdHkgYXNhcCwgd2l0aG91dCBpbnRlcnJ1cHRpbmcgcGxheWJhY2suXG4gICAgICAgKiBNYXkgYWJvcnQgY3VycmVudCBsb2FkaW5nIG9mIGRhdGEsIGFuZCBmbHVzaCBwYXJ0cyBvZiBidWZmZXIgKG91dHNpZGUgY3VycmVudGx5IHBsYXllZCBmcmFnbWVudCByZWdpb24pLlxuICAgICAgICogQHBhcmFtIG5ld0xldmVsIC0gUGFzcyAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgICAgICovLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcInNldCBuZXh0TGV2ZWw6XCIgKyBuZXdMZXZlbCk7XG4gICAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm4gdGhlIHF1YWxpdHkgbGV2ZWwgb2YgdGhlIGN1cnJlbnRseSBvciBsYXN0IChvZiBub25lIGlzIGxvYWRlZCBjdXJyZW50bHkpIHNlZ21lbnRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJsb2FkTGV2ZWxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEgaW4gYSBjb25zZXJ2YXRpdmUgd2F5LlxuICAgICAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgcXVhbGl0eSB3aXRob3V0IGZsdXNoaW5nLCBidXQgaW50ZXJydXB0IGN1cnJlbnQgbG9hZGluZy5cbiAgICAgICAqIFRodXMgdGhlIG1vbWVudCB3aGVuIHRoZSBxdWFsaXR5IHN3aXRjaCB3aWxsIGFwcGVhciBpbiBlZmZlY3Qgd2lsbCBvbmx5IGJlIGFmdGVyIHRoZSBhbHJlYWR5IGV4aXN0aW5nIGJ1ZmZlci5cbiAgICAgICAqIEBwYXJhbSBuZXdMZXZlbCAtIFBhc3MgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICAgICAqLyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJzZXQgbG9hZExldmVsOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGdldCBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibmV4dExvYWRMZXZlbFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIHNlZ21lbnQgaW4gYSBmdWxseSBcIm5vbi1kZXN0cnVjdGl2ZVwiIHdheS5cbiAgICAgICAqIFNhbWUgYXMgYGxvYWRMZXZlbGAgYnV0IHdpbGwgd2FpdCBmb3IgbmV4dCBzd2l0Y2ggKHVudGlsIGN1cnJlbnQgbG9hZGluZyBpcyBkb25lKS5cbiAgICAgICAqLyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxldmVsKSB7XG4gICAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm4gXCJmaXJzdCBsZXZlbFwiOiBsaWtlIGEgZGVmYXVsdCBsZXZlbCwgaWYgbm90IHNldCxcbiAgICAgICAqIGZhbGxzIGJhY2sgdG8gaW5kZXggb2YgZmlyc3QgbGV2ZWwgcmVmZXJlbmNlZCBpbiBtYW5pZmVzdFxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImZpcnN0TGV2ZWxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgXCJmaXJzdC1sZXZlbFwiLCBzZWUgZ2V0dGVyLlxuICAgICAgICovLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcInNldCBmaXJzdExldmVsOlwiICsgbmV3TGV2ZWwpO1xuICAgICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIHRoZSBkZXNpcmVkIHN0YXJ0IGxldmVsIGZvciB0aGUgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIGxvYWRlZC5cbiAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIG9mIC0xIGluZGljYXRlcyBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLlxuICAgICAgICogU2V0dGluZyBobHMubmV4dEF1dG9MZXZlbCB3aXRob3V0IHNldHRpbmcgYSBzdGFydExldmVsIHdpbGwgcmVzdWx0IGluXG4gICAgICAgKiB0aGUgbmV4dEF1dG9MZXZlbCB2YWx1ZSBiZWluZyB1c2VkIGZvciBvbmUgZnJhZ21lbnQgbG9hZC5cbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdGFydExldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0TGV2ZWwgPSB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsO1xuICAgICAgICBpZiAoc3RhcnRMZXZlbCA9PT0gLTEgJiYgdGhpcy5hYnJDb250cm9sbGVyLmZvcmNlZEF1dG9MZXZlbCA+IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYWJyQ29udHJvbGxlci5mb3JjZWRBdXRvTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0TGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2V0ICBzdGFydCBsZXZlbCAobGV2ZWwgb2YgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIHBsYXllZCBiYWNrKVxuICAgICAgICogaWYgbm90IG92ZXJyaWRlZCBieSB1c2VyLCBmaXJzdCBsZXZlbCBhcHBlYXJpbmcgaW4gbWFuaWZlc3Qgd2lsbCBiZSB1c2VkIGFzIHN0YXJ0IGxldmVsXG4gICAgICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcbiAgICAgICAqIChkZXRlcm1pbmVkIGZyb20gZG93bmxvYWQgb2YgZmlyc3Qgc2VnbWVudClcbiAgICAgICAqLyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJzZXQgc3RhcnRMZXZlbDpcIiArIG5ld0xldmVsKTtcbiAgICAgICAgLy8gaWYgbm90IGluIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBkZXRlY3Rpb24sIGVuc3VyZSBzdGFydExldmVsIGlzIGdyZWF0ZXIgdGhhbiBtaW5BdXRvTGV2ZWxcbiAgICAgICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgICAgIG5ld0xldmVsID0gTWF0aC5tYXgobmV3TGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciBsZXZlbCBjYXBwaW5nIGlzIGVuYWJsZWQuXG4gICAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIHNldCB2aWEgYGNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZWAuXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2FwTGV2ZWxUb1BsYXllclNpemVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBsZXZlbCBjYXBwaW5nLiBJZiBkaXNhYmxlZCBhZnRlciBwcmV2aW91c2x5IGVuYWJsZWQsIGBuZXh0TGV2ZWxTd2l0Y2hgIHdpbGwgYmUgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICAgICAgICovLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc2hvdWxkU3RhcnRDYXBwaW5nKSB7XG4gICAgICAgIHZhciBuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZSA9ICEhc2hvdWxkU3RhcnRDYXBwaW5nO1xuICAgICAgICBpZiAobmV3Q2FwTGV2ZWxUb1BsYXllclNpemUgIT09IHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICAgICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdGFydENhcHBpbmcoKTsgLy8gSWYgY2FwcGluZyBvY2N1cnMsIG5leHRMZXZlbFN3aXRjaCB3aWxsIGhhcHBlbiBiYXNlZCBvbiBzaXplLlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdG9wQ2FwcGluZygpO1xuICAgICAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7IC8vIE5vdyB3ZSdyZSB1bmNhcHBlZCwgZ2V0IHRoZSBuZXh0IGxldmVsIGFzYXAuXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplID0gbmV3Q2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYXBwaW5nL21heCBsZXZlbCB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gYWxnb3JpdGhtIChgQUJSQ29udHJvbGxlcmApXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXV0b0xldmVsQ2FwcGluZ1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmFuZHdpZHRoIGVzdGltYXRlIGluIGJpdHMgcGVyIHNlY29uZCwgd2hlbiBhdmFpbGFibGUuIE90aGVyd2lzZSwgYE5hTmAgaXMgcmV0dXJuZWQuXG4gICAgICAgKi8sXG4gICAgICBzZXQ6XG4gICAgICAvKipcbiAgICAgICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICAgIGlmICh0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nICE9PSBuZXdMZXZlbCkge1xuICAgICAgICAgIGxvZ2dlci5sb2coXCJzZXQgYXV0b0xldmVsQ2FwcGluZzpcIiArIG5ld0xldmVsKTtcbiAgICAgICAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gbmV3TGV2ZWw7XG4gICAgICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuY2hlY2tNYXhBdXRvVXBkYXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImJhbmR3aWR0aEVzdGltYXRlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGJ3RXN0aW1hdG9yID0gdGhpcy5hYnJDb250cm9sbGVyLmJ3RXN0aW1hdG9yO1xuICAgICAgICBpZiAoIWJ3RXN0aW1hdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhYnJFd21hRGVmYXVsdEVzdGltYXRlKSB7XG4gICAgICAgIHRoaXMuYWJyQ29udHJvbGxlci5yZXNldEVzdGltYXRvcihhYnJFd21hRGVmYXVsdEVzdGltYXRlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgdGltZSB0byBmaXJzdCBieXRlIGVzdGltYXRlXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcInR0ZmJFc3RpbWF0ZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBid0VzdGltYXRvciA9IHRoaXMuYWJyQ29udHJvbGxlci5id0VzdGltYXRvcjtcbiAgICAgICAgaWYgKCFid0VzdGltYXRvcikge1xuICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYXhIZGNwTGV2ZWxcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4SGRjcExldmVsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0hkY3BMZXZlbCh2YWx1ZSkgJiYgdGhpcy5fbWF4SGRjcExldmVsICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuX21heEhkY3BMZXZlbCA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLmNoZWNrTWF4QXV0b1VwZGF0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRydWUgd2hlbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGVuYWJsZWRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJhdXRvTGV2ZWxFbmFibGVkXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID09PSAtMTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBMZXZlbCBzZXQgbWFudWFsbHkgKGlmIGFueSlcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYW51YWxMZXZlbFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBtaW4gbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGNvbmZpZy5taW5BdXRvQml0cmF0ZVxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1pbkF1dG9MZXZlbFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscyxcbiAgICAgICAgICBtaW5BdXRvQml0cmF0ZSA9IHRoaXMuY29uZmlnLm1pbkF1dG9CaXRyYXRlO1xuICAgICAgICBpZiAoIWxldmVscykgcmV0dXJuIDA7XG4gICAgICAgIHZhciBsZW4gPSBsZXZlbHMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGxldmVsc1tpXS5tYXhCaXRyYXRlID49IG1pbkF1dG9CaXRyYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbWF4IGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBhdXRvTGV2ZWxDYXBwaW5nXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWF4QXV0b0xldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzLFxuICAgICAgICAgIGF1dG9MZXZlbENhcHBpbmcgPSB0aGlzLmF1dG9MZXZlbENhcHBpbmcsXG4gICAgICAgICAgbWF4SGRjcExldmVsID0gdGhpcy5tYXhIZGNwTGV2ZWw7XG4gICAgICAgIHZhciBtYXhBdXRvTGV2ZWw7XG4gICAgICAgIGlmIChhdXRvTGV2ZWxDYXBwaW5nID09PSAtMSAmJiBsZXZlbHMgIT0gbnVsbCAmJiBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgbWF4QXV0b0xldmVsID0gbGV2ZWxzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4QXV0b0xldmVsID0gYXV0b0xldmVsQ2FwcGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4SGRjcExldmVsKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IG1heEF1dG9MZXZlbDsgaS0tOykge1xuICAgICAgICAgICAgdmFyIGhkY3BMZXZlbCA9IGxldmVsc1tpXS5hdHRyc1snSERDUC1MRVZFTCddO1xuICAgICAgICAgICAgaWYgKGhkY3BMZXZlbCAmJiBoZGNwTGV2ZWwgPD0gbWF4SGRjcExldmVsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4QXV0b0xldmVsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmaXJzdEF1dG9MZXZlbFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFickNvbnRyb2xsZXIuZmlyc3RBdXRvTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogbmV4dCBhdXRvbWF0aWNhbGx5IHNlbGVjdGVkIHF1YWxpdHkgbGV2ZWxcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJuZXh0QXV0b0xldmVsXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHRoaXMgc2V0dGVyIGlzIHVzZWQgdG8gZm9yY2UgbmV4dCBhdXRvIGxldmVsLlxuICAgICAgICogdGhpcyBpcyB1c2VmdWwgdG8gZm9yY2UgYSBzd2l0Y2ggZG93biBpbiBhdXRvIG1vZGU6XG4gICAgICAgKiBpbiBjYXNlIG9mIGxvYWQgZXJyb3Igb24gbGV2ZWwgTiwgaGxzLmpzIGNhbiBzZXQgbmV4dEF1dG9MZXZlbCB0byBOLTEgZm9yIGV4YW1wbGUpXG4gICAgICAgKiBmb3JjZWQgdmFsdWUgaXMgdmFsaWQgZm9yIG9uZSBmcmFnbWVudC4gdXBvbiBzdWNjZXNzZnVsIGZyYWcgbG9hZGluZyBhdCBmb3JjZWQgbGV2ZWwsXG4gICAgICAgKiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVzZXR0ZWQgdG8gLTEgYnkgQUJSIGNvbnRyb2xsZXIuXG4gICAgICAgKi8sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXh0TGV2ZWwpIHtcbiAgICAgICAgdGhpcy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZ2V0IHRoZSBkYXRldGltZSB2YWx1ZSByZWxhdGl2ZSB0byBtZWRpYS5jdXJyZW50VGltZSBmb3IgdGhlIGFjdGl2ZSBsZXZlbCBQcm9ncmFtIERhdGUgVGltZSBpZiBwcmVzZW50XG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGxheWluZ0RhdGVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRQcm9ncmFtRGF0ZVRpbWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm1haW5Gb3J3YXJkQnVmZmVySW5mb1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWxsQXVkaW9UcmFja3NcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hbGxBdWRpb1RyYWNrcyA6IFtdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgbGlzdCBvZiBzZWxlY3RhYmxlIGF1ZGlvIHRyYWNrc1xuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImF1ZGlvVHJhY2tzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFja3MgOiBbXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKVxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImF1ZGlvVHJhY2tcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgICAgICByZXR1cm4gYXVkaW9UcmFja0NvbnRyb2xsZXIgPyBhdWRpb1RyYWNrQ29udHJvbGxlci5hdWRpb1RyYWNrIDogLTE7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogc2VsZWN0cyBhbiBhdWRpbyB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzXG4gICAgICAgKi8sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhdWRpb1RyYWNrSWQpIHtcbiAgICAgICAgdmFyIGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKGF1ZGlvVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA9IGF1ZGlvVHJhY2tJZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGdldCB0aGUgY29tcGxldGUgbGlzdCBvZiBzdWJ0aXRsZSB0cmFja3MgYWNyb3NzIGFsbCBtZWRpYSBncm91cHNcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJhbGxTdWJ0aXRsZVRyYWNrc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLmFsbFN1YnRpdGxlVHJhY2tzIDogW107XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogZ2V0IGFsdGVybmF0ZSBzdWJ0aXRsZSB0cmFja3MgbGlzdCBmcm9tIHBsYXlsaXN0XG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3VidGl0bGVUcmFja3NcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrcyA6IFtdO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3VidGl0bGVUcmFja1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcbiAgICAgIH0sXG4gICAgICBzZXQ6XG4gICAgICAvKipcbiAgICAgICAqIHNlbGVjdCBhbiBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHNldChzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFjayA9IHN1YnRpdGxlVHJhY2tJZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgc3VidGl0bGUgZGlzcGxheSBpcyBlbmFibGVkIG9yIG5vdFxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1lZGlhXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzdWJ0aXRsZURpc3BsYXlcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgICAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZURpc3BsYXkgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xuICAgICAgICovLFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdmFyIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgbW9kZSBmb3IgTG93LUxhdGVuY3kgSExTIGxvYWRpbmdcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJsb3dMYXRlbmN5TW9kZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBFbmFibGUvZGlzYWJsZSBMb3ctTGF0ZW5jeSBITFMgcGFydCBwbGF5bGlzdCBhbmQgc2VnbWVudCBsb2FkaW5nLCBhbmQgc3RhcnQgbGl2ZSBzdHJlYW1zIGF0IHBsYXlsaXN0IFBBUlQtSE9MRC1CQUNLIHJhdGhlciB0aGFuIEhPTEQtQkFDSy5cbiAgICAgICAqLyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG1vZGUpIHtcbiAgICAgICAgdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgPSBtb2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiBsaXZlIHN5bmMgcG9pbnQgKGllIGVkZ2Ugb2YgbGl2ZSBwb3NpdGlvbiBtaW51cyBzYWZldHkgZGVsYXkgZGVmaW5lZCBieSBgYGBobHMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25gYGApXG4gICAgICAgKiBAcmV0dXJucyBudWxsIHByaW9yIHRvIGxvYWRpbmcgbGl2ZSBQbGF5bGlzdFxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImxpdmVTeW5jUG9zaXRpb25cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEVzdGltYXRlZCBwb3NpdGlvbiAoaW4gc2Vjb25kcykgb2YgbGl2ZSBlZGdlIChpZSBlZGdlIG9mIGxpdmUgcGxheWxpc3QgcGx1cyB0aW1lIHN5bmMgcGxheWxpc3QgYWR2YW5jZWQpXG4gICAgICAgKiBAcmV0dXJucyAwIGJlZm9yZSBmaXJzdCBwbGF5bGlzdCBpcyBsb2FkZWRcbiAgICAgICAqL1xuICAgIH0sIHtcbiAgICAgIGtleTogXCJsYXRlbmN5XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubGF0ZW5jeTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYmVmb3JlIHRoZSBwbGF5ZXIgc2Vla3MgZm9yd2FyZCB0byBgYGBobHMubGl2ZVN5bmNQb3NpdGlvbmBgYFxuICAgICAgICogY29uZmlndXJlZCB1c2luZyBgYGBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRgYGAgKG11bHRpcGxlIG9mIHRhcmdldCBkdXJhdGlvbikgb3IgYGBgbGl2ZU1heExhdGVuY3lEdXJhdGlvbmBgYFxuICAgICAgICogQHJldHVybnMgMCBiZWZvcmUgZmlyc3QgcGxheWxpc3QgaXMgbG9hZGVkXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWF4TGF0ZW5jeVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLm1heExhdGVuY3k7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGFyZ2V0IGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYXMgY2FsY3VsYXRlZCBieSB0aGUgbGF0ZW5jeSBjb250cm9sbGVyXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidGFyZ2V0TGF0ZW5jeVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLnRhcmdldExhdGVuY3k7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIGVkZ2Ugb2YgdGhlIGN1cnJlbnQgbGl2ZSBwbGF5bGlzdCBpcyBhZHZhbmNpbmcgb3IgMSBpZiB0aGVyZSBpcyBub25lXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZHJpZnRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5kcmlmdDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBzZXQgdG8gdHJ1ZSB3aGVuIHN0YXJ0TG9hZCBpcyBjYWxsZWQgYmVmb3JlIE1BTklGRVNUX1BBUlNFRCBldmVudFxuICAgICAgICovXG4gICAgfSwge1xuICAgICAga2V5OiBcImZvcmNlU3RhcnRMb2FkXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5mb3JjZVN0YXJ0TG9hZDtcbiAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgIGtleTogXCJ2ZXJzaW9uXCIsXG4gICAgICBnZXQ6XG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgdmlkZW8tZGV2L2hscy5qcyBwYWNrYWdlIHZlcnNpb24uXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFwiMS41LjE3XCI7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIkV2ZW50c1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBFdmVudHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIkVycm9yVHlwZXNcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRXJyb3JUeXBlcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiRXJyb3JEZXRhaWxzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEVycm9yRGV0YWlscztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBhcHBsaWVkIHRvIG5ldyBpbnN0YW5jZXMuXG4gICAgICAgKi9cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiRGVmYXVsdENvbmZpZ1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICghSGxzLmRlZmF1bHRDb25maWcpIHtcbiAgICAgICAgICByZXR1cm4gaGxzRGVmYXVsdENvbmZpZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGxzLmRlZmF1bHRDb25maWc7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVwbGFjZSB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGFwcGxpZWQgdG8gbmV3IGluc3RhbmNlcy5cbiAgICAgICAqLyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGRlZmF1bHRDb25maWcpIHtcbiAgICAgICAgSGxzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gSGxzO1xuICB9KCk7XG4gIEhscy5kZWZhdWx0Q29uZmlnID0gdm9pZCAwO1xuXG4gIHJldHVybiBIbHM7XG5cbn0pKTtcbn0pKGZhbHNlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///473\n")},551:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/**\n * @license React\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\nvar aa=__webpack_require__(540),ca=__webpack_require__(982);function p(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da=new Set,ea={};function fa(a,b){ha(a,b);ha(a+"Capture",b)}\nfunction ha(a,b){ea[a]=b;for(a=0;a<b.length;a++)da.add(b[a])}\nvar ia=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,la=\n{},ma={};function oa(a){if(ja.call(ma,a))return!0;if(ja.call(la,a))return!1;if(ka.test(a))return ma[a]=!0;la[a]=!0;return!1}function pa(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}\nfunction qa(a,b,c,d){if(null===b||"undefined"===typeof b||pa(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function v(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var z={};\n"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){z[a]=new v(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];z[b]=new v(b,1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){z[a]=new v(a,2,!1,a.toLowerCase(),null,!1,!1)});\n["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){z[a]=new v(a,2,!1,a,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){z[a]=new v(a,3,!1,a.toLowerCase(),null,!1,!1)});\n["checked","multiple","muted","selected"].forEach(function(a){z[a]=new v(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){z[a]=new v(a,4,!1,a,null,!1,!1)});["cols","rows","size","span"].forEach(function(a){z[a]=new v(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){z[a]=new v(a,5,!1,a.toLowerCase(),null,!1,!1)});var ra=/[\\-:]([a-z])/g;function sa(a){return a[1].toUpperCase()}\n"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(ra,\nsa);z[b]=new v(b,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!1,!1)});\nz.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!0,!0)});\nfunction ta(a,b,c,d){var e=z.hasOwnProperty(b)?z[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1])qa(b,c,e,d)&&(c=null),d||null===e?oa(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)))}\nvar ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for("react.element"),wa=Symbol.for("react.portal"),ya=Symbol.for("react.fragment"),za=Symbol.for("react.strict_mode"),Aa=Symbol.for("react.profiler"),Ba=Symbol.for("react.provider"),Ca=Symbol.for("react.context"),Da=Symbol.for("react.forward_ref"),Ea=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha=Symbol.for("react.lazy");Symbol.for("react.scope");Symbol.for("react.debug_trace_mode");\nvar Ia=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden");Symbol.for("react.cache");Symbol.for("react.tracing_marker");var Ja=Symbol.iterator;function Ka(a){if(null===a||"object"!==typeof a)return null;a=Ja&&a[Ja]||a["@@iterator"];return"function"===typeof a?a:null}var A=Object.assign,La;function Ma(a){if(void 0===La)try{throw Error();}catch(c){var b=c.stack.trim().match(/\\n( *(at )?)/);La=b&&b[1]||""}return"\\n"+La+a}var Na=!1;\nfunction Oa(a,b){if(!a||Na)return"";Na=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(l){var d=l}Reflect.construct(a,[],b)}else{try{b.call()}catch(l){d=l}a.call(b.prototype)}else{try{throw Error();}catch(l){d=l}a()}}catch(l){if(l&&d&&"string"===typeof l.stack){for(var e=l.stack.split("\\n"),\nf=d.stack.split("\\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k="\\n"+e[g].replace(" at new "," at ");a.displayName&&k.includes("<anonymous>")&&(k=k.replace("<anonymous>",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{Na=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:"")?Ma(a):""}\nfunction Pa(a){switch(a.tag){case 5:return Ma(a.type);case 16:return Ma("Lazy");case 13:return Ma("Suspense");case 19:return Ma("SuspenseList");case 0:case 2:case 15:return a=Oa(a.type,!1),a;case 11:return a=Oa(a.type.render,!1),a;case 1:return a=Oa(a.type,!0),a;default:return""}}\nfunction Qa(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ya:return"Fragment";case wa:return"Portal";case Aa:return"Profiler";case za:return"StrictMode";case Ea:return"Suspense";case Fa:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Ca:return(a.displayName||"Context")+".Consumer";case Ba:return(a._context.displayName||"Context")+".Provider";case Da:var b=a.render;a=a.displayName;a||(a=b.displayName||\nb.name||"",a=""!==a?"ForwardRef("+a+")":"ForwardRef");return a;case Ga:return b=a.displayName||null,null!==b?b:Qa(a.type)||"Memo";case Ha:b=a._payload;a=a._init;try{return Qa(a(b))}catch(c){}}return null}\nfunction Ra(a){var b=a.type;switch(a.tag){case 24:return"Cache";case 9:return(b.displayName||"Context")+".Consumer";case 10:return(b._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return a=b.render,a=a.displayName||a.name||"",b.displayName||(""!==a?"ForwardRef("+a+")":"ForwardRef");case 7:return"Fragment";case 5:return b;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa(b);case 8:return b===za?"StrictMode":"Mode";case 22:return"Offscreen";\ncase 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof b)return b.displayName||b.name||null;if("string"===typeof b)return b}return null}function Sa(a){switch(typeof a){case "boolean":case "number":case "string":case "undefined":return a;case "object":return a;default:return""}}\nfunction Ta(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}\nfunction Ua(a){var b=Ta(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=\nnull;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ta(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}\nfunction Ya(a,b){var c=b.checked;return A({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function ab(a,b){b=b.checked;null!=b&&ta(a,"checked",b,!1)}\nfunction bb(a,b){ab(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?cb(a,b.type,c):b.hasOwnProperty("defaultValue")&&cb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}\nfunction db(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}\nfunction cb(a,b,c){if("number"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}var eb=Array.isArray;\nfunction fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}\nfunction gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p(91));return A({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p(92));if(eb(c)){if(1<c.length)throw Error(p(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:Sa(c)}}\nfunction ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}function kb(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}\nfunction lb(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?kb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}\nvar mb,nb=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{mb=mb||document.createElement("div");mb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=mb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});\nfunction ob(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}\nvar pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,\nzoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=["Webkit","ms","Moz","O"];Object.keys(pb).forEach(function(a){qb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);pb[b]=pb[a]})});function rb(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||pb.hasOwnProperty(a)&&pb[a]?(""+b).trim():b+"px"}\nfunction sb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=rb(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var tb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});\nfunction ub(a,b){if(b){if(tb[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p(60));if("object"!==typeof b.dangerouslySetInnerHTML||!("__html"in b.dangerouslySetInnerHTML))throw Error(p(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(p(62));}}\nfunction vb(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var wb=null;function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;\nfunction Bb(a){if(a=Cb(a)){if("function"!==typeof yb)throw Error(p(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(){}var Ib=!1;function Jb(a,b,c){if(Ib)return a(b,c);Ib=!0;try{return Gb(a,b,c)}finally{if(Ib=!1,null!==zb||null!==Ab)Hb(),Fb()}}\nfunction Kb(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==\ntypeof c)throw Error(p(231,b,typeof c));return c}var Lb=!1;if(ia)try{var Mb={};Object.defineProperty(Mb,"passive",{get:function(){Lb=!0}});window.addEventListener("test",Mb,Mb);window.removeEventListener("test",Mb,Mb)}catch(a){Lb=!1}function Nb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this.onError(m)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(a){Ob=!0;Pb=a}};function Tb(a,b,c,d,e,f,g,h,k){Ob=!1;Pb=null;Nb.apply(Sb,arguments)}\nfunction Ub(a,b,c,d,e,f,g,h,k){Tb.apply(this,arguments);if(Ob){if(Ob){var l=Pb;Ob=!1;Pb=null}else throw Error(p(198));Qb||(Qb=!0,Rb=l)}}function Vb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Wb(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Xb(a){if(Vb(a)!==a)throw Error(p(188));}\nfunction Yb(a){var b=a.alternate;if(!b){b=Vb(a);if(null===b)throw Error(p(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Xb(e),a;if(f===d)return Xb(e),b;f=f.sibling}throw Error(p(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===\nc){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(p(189));}}if(c.alternate!==d)throw Error(p(190));}if(3!==c.tag)throw Error(p(188));return c.stateNode.current===c?a:b}function Zb(a){a=Yb(a);return null!==a?$b(a):null}function $b(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=$b(a);if(null!==b)return b;a=a.sibling}return null}\nvar ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(a){if(lc&&"function"===typeof lc.onCommitFiberRoot)try{lc.onCommitFiberRoot(kc,a,void 0,128===(a.current.flags&128))}catch(b){}}\nvar oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(a){a>>>=0;return 0===a?32:31-(pc(a)/qc|0)|0}var rc=64,sc=4194304;\nfunction tc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;\ndefault:return a}}function uc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=tc(h):(f&=g,0!==f&&(d=tc(f)))}else g=c&~e,0!==g?d=tc(g):0!==f&&(d=tc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-oc(b),e=1<<c,d|=a[c],b&=~e;return d}\nfunction vc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}\nfunction wc(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-oc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=vc(h,b)}else k<=b&&(a.expiredLanes|=h);f&=~h}}function xc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function yc(){var a=rc;rc<<=1;0===(rc&4194240)&&(rc=64);return a}function zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}\nfunction Ac(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-oc(b);a[b]=c}function Bc(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-oc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f}}\nfunction Cc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-oc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e}}var C=0;function Dc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=!1,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");\nfunction Sc(a,b){switch(a){case "focusin":case "focusout":Lc=null;break;case "dragenter":case "dragleave":Mc=null;break;case "mouseover":case "mouseout":Nc=null;break;case "pointerover":case "pointerout":Oc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Pc.delete(b.pointerId)}}\nfunction Tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=Cb(b),null!==b&&Fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}\nfunction Uc(a,b,c,d,e){switch(b){case "focusin":return Lc=Tc(Lc,a,b,c,d,e),!0;case "dragenter":return Mc=Tc(Mc,a,b,c,d,e),!0;case "mouseover":return Nc=Tc(Nc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Oc.set(f,Tc(Oc.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Pc.set(f,Tc(Pc.get(f)||null,a,b,c,d,e)),!0}return!1}\nfunction Vc(a){var b=Wc(a.target);if(null!==b){var c=Vb(b);if(null!==c)if(b=c.tag,13===b){if(b=Wb(c),null!==b){a.blockedOn=b;Ic(a.priority,function(){Gc(c)});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}\nfunction Xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=Yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);wb=d;c.target.dispatchEvent(d);wb=null}else return b=Cb(c),null!==b&&Fc(b),a.blockedOn=c,!1;b.shift()}return!0}function Zc(a,b,c){Xc(a)&&c.delete(b)}function $c(){Jc=!1;null!==Lc&&Xc(Lc)&&(Lc=null);null!==Mc&&Xc(Mc)&&(Mc=null);null!==Nc&&Xc(Nc)&&(Nc=null);Oc.forEach(Zc);Pc.forEach(Zc)}\nfunction ad(a,b){a.blockedOn===b&&(a.blockedOn=null,Jc||(Jc=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)))}\nfunction bd(a){function b(b){return ad(b,a)}if(0<Kc.length){ad(Kc[0],a);for(var c=1;c<Kc.length;c++){var d=Kc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==Lc&&ad(Lc,a);null!==Mc&&ad(Mc,a);null!==Nc&&ad(Nc,a);Oc.forEach(b);Pc.forEach(b);for(c=0;c<Qc.length;c++)d=Qc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Qc.length&&(c=Qc[0],null===c.blockedOn);)Vc(c),null===c.blockedOn&&Qc.shift()}var cd=ua.ReactCurrentBatchConfig,dd=!0;\nfunction ed(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=1,fd(a,b,c,d)}finally{C=e,cd.transition=f}}function gd(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=4,fd(a,b,c,d)}finally{C=e,cd.transition=f}}\nfunction fd(a,b,c,d){if(dd){var e=Yc(a,b,c,d);if(null===e)hd(a,b,d,id,c),Sc(a,d);else if(Uc(e,a,b,c,d))d.stopPropagation();else if(Sc(a,d),b&4&&-1<Rc.indexOf(a)){for(;null!==e;){var f=Cb(e);null!==f&&Ec(f);f=Yc(a,b,c,d);null===f&&hd(a,b,d,id,c);if(f===e)break;e=f}null!==e&&d.stopPropagation()}else hd(a,b,d,null,c)}}var id=null;\nfunction Yc(a,b,c,d){id=null;a=xb(d);a=Wc(a);if(null!==a)if(b=Vb(a),null===b)a=null;else if(c=b.tag,13===c){a=Wb(b);if(null!==a)return a;a=null}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null}else b!==a&&(a=null);id=a;return null}\nfunction jd(a){switch(a){case "cancel":case "click":case "close":case "contextmenu":case "copy":case "cut":case "auxclick":case "dblclick":case "dragend":case "dragstart":case "drop":case "focusin":case "focusout":case "input":case "invalid":case "keydown":case "keypress":case "keyup":case "mousedown":case "mouseup":case "paste":case "pause":case "play":case "pointercancel":case "pointerdown":case "pointerup":case "ratechange":case "reset":case "resize":case "seeked":case "submit":case "touchcancel":case "touchend":case "touchstart":case "volumechange":case "change":case "selectionchange":case "textInput":case "compositionstart":case "compositionend":case "compositionupdate":case "beforeblur":case "afterblur":case "beforeinput":case "blur":case "fullscreenchange":case "focus":case "hashchange":case "popstate":case "select":case "selectstart":return 1;case "drag":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "mousemove":case "mouseout":case "mouseover":case "pointermove":case "pointerout":case "pointerover":case "scroll":case "toggle":case "touchmove":case "wheel":case "mouseenter":case "mouseleave":case "pointerenter":case "pointerleave":return 4;\ncase "message":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var a,b=ld,c=b.length,d,e="value"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}\nfunction od(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}\nfunction rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}A(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&\n(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}\nvar sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in\na)return a.movementX;a!==yd&&(yd&&"mousemove"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return"movementY"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=A({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A({},sd,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",\nSpacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",\n119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}\nvar Qd=A({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=od(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Nd[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return"keypress"===a.type?od(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===\na.type?od(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=A({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A({},Ad,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},\ndeltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&"CompositionEvent"in window,be=null;ia&&"documentMode"in document&&(be=document.documentMode);var ce=ia&&"TextEvent"in window&&!be,de=ia&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;\nfunction ge(a,b){switch(a){case "keyup":return-1!==$d.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return!0;default:return!1}}function he(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case "compositionend":return he(b);case "keypress":if(32!==b.which)return null;fe=!0;return ee;case "textInput":return a=b.data,a===ee&&fe?null:a;default:return null}}\nfunction ke(a,b){if(ie)return"compositionend"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return de&&"ko"!==b.locale?null:b.data;default:return null}}\nvar le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!le[a.type]:"textarea"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,"onChange");0<b.length&&(c=new td("onChange","change",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}\nfunction ve(a,b){if("change"===a)return b}var we=!1;if(ia){var xe;if(ia){var ye="oninput"in document;if(!ye){var ze=document.createElement("div");ze.setAttribute("oninput","return;");ye="function"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be),qe=pe=null)}function Be(a){if("value"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));Jb(re,b)}}\nfunction Ce(a,b,c){"focusin"===a?(Ae(),pe=b,qe=c,pe.attachEvent("onpropertychange",Be)):"focusout"===a&&Ae()}function De(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return te(qe)}function Ee(a,b){if("click"===a)return te(b)}function Fe(a,b){if("input"===a||"change"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He="function"===typeof Object.is?Object.is:Ge;\nfunction Ie(a,b){if(He(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++){var e=c[d];if(!ja.call(b,e)||!He(a[e],b[e]))return!1}return!0}function Je(a){for(;a&&a.firstChild;)a=a.firstChild;return a}\nfunction Ke(a,b){var c=Je(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Je(c)}}function Le(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Le(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}\nfunction Me(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Ne(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}\nfunction Oe(a){var b=Me(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Le(c.ownerDocument.documentElement,c)){if(null!==d&&Ne(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ke(c,f);var g=Ke(c,\nd);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)))}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});"function"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}\nvar Pe=ia&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;\nfunction Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,"selectionStart"in d&&Ne(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Ie(Se,d)||(Se=d,d=oe(Re,"onSelect"),0<d.length&&(b=new td("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}\nfunction Ve(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var We={animationend:Ve("Animation","AnimationEnd"),animationiteration:Ve("Animation","AnimationIteration"),animationstart:Ve("Animation","AnimationStart"),transitionend:Ve("Transition","TransitionEnd")},Xe={},Ye={};\nia&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),"TransitionEvent"in window||delete We.transitionend.transition);function Ze(a){if(Xe[a])return Xe[a];if(!We[a])return a;var b=We[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Ye)return Xe[a]=b[c];return a}var $e=Ze("animationend"),af=Ze("animationiteration"),bf=Ze("animationstart"),cf=Ze("transitionend"),df=new Map,ef="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");\nfunction ff(a,b){df.set(a,b);fa(b,[a])}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,"on"+kf)}ff($e,"onAnimationEnd");ff(af,"onAnimationIteration");ff(bf,"onAnimationStart");ff("dblclick","onDoubleClick");ff("focusin","onFocus");ff("focusout","onBlur");ff(cf,"onTransitionEnd");ha("onMouseEnter",["mouseout","mouseover"]);ha("onMouseLeave",["mouseout","mouseover"]);ha("onPointerEnter",["pointerout","pointerover"]);\nha("onPointerLeave",["pointerout","pointerover"]);fa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));\nfa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));\nfunction nf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Ub(d,b,void 0,a);a.currentTarget=null}\nfunction se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}}}if(Qb)throw a=Rb,Qb=!1,Rb=null,a;}\nfunction D(a,b){var c=b[of];void 0===c&&(c=b[of]=new Set);var d=a+"__bubble";c.has(d)||(pf(b,a,2,!1),c.add(d))}function qf(a,b,c){var d=0;b&&(d|=4);pf(c,a,d,b)}var rf="_reactListening"+Math.random().toString(36).slice(2);function sf(a){if(!a[rf]){a[rf]=!0;da.forEach(function(b){"selectionchange"!==b&&(mf.has(b)||qf(b,!1,a),qf(b,!0,a))});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[rf]||(b[rf]=!0,qf("selectionchange",!1,b))}}\nfunction pf(a,b,c,d){switch(jd(b)){case 1:var e=ed;break;case 4:e=gd;break;default:e=fd}c=e.bind(null,b,c,a);e=void 0;!Lb||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}\nfunction hd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=Wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Jb(function(){var d=f,e=xb(c),g=[];\na:{var h=df.get(a);if(void 0!==h){var k=td,n=a;switch(a){case "keypress":if(0===od(c))break a;case "keydown":case "keyup":k=Rd;break;case "focusin":n="focus";k=Fd;break;case "focusout":n="blur";k=Fd;break;case "beforeblur":case "afterblur":k=Fd;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=Bd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=\nDd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Vd;break;case $e:case af:case bf:k=Hd;break;case cf:k=Xd;break;case "scroll":k=vd;break;case "wheel":k=Zd;break;case "copy":case "cut":case "paste":k=Jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Td}var t=0!==(b&4),J=!t&&"scroll"===a,x=t?null!==h?h+"Capture":null:h;t=[];for(var w=d,u;null!==\nw;){u=w;var F=u.stateNode;5===u.tag&&null!==F&&(u=F,null!==x&&(F=Kb(w,x),null!=F&&t.push(tf(w,F,u))));if(J)break;w=w.return}0<t.length&&(h=new k(h,n,null,c,e),g.push({event:h,listeners:t}))}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&c!==wb&&(n=c.relatedTarget||c.fromElement)&&(Wc(n)||n[uf]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(n=c.relatedTarget||c.toElement,k=d,n=n?Wc(n):null,null!==\nn&&(J=Vb(n),n!==J||5!==n.tag&&6!==n.tag))n=null}else k=null,n=d;if(k!==n){t=Bd;F="onMouseLeave";x="onMouseEnter";w="mouse";if("pointerout"===a||"pointerover"===a)t=Td,F="onPointerLeave",x="onPointerEnter",w="pointer";J=null==k?h:ue(k);u=null==n?h:ue(n);h=new t(F,w+"leave",k,c,e);h.target=J;h.relatedTarget=u;F=null;Wc(e)===d&&(t=new t(x,w+"enter",n,c,e),t.target=u,t.relatedTarget=J,F=t);J=F;if(k&&n)b:{t=k;x=n;w=0;for(u=t;u;u=vf(u))w++;u=0;for(F=x;F;F=vf(F))u++;for(;0<w-u;)t=vf(t),w--;for(;0<u-w;)x=\nvf(x),u--;for(;w--;){if(t===x||null!==x&&t===x.alternate)break b;t=vf(t);x=vf(x)}t=null}else t=null;null!==k&&wf(g,h,k,t,!1);null!==n&&null!==J&&wf(g,J,n,t,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var na=ve;else if(me(h))if(we)na=Fe;else{na=De;var xa=Ce}else(k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(na=Ee);if(na&&(na=na(a,d))){ne(g,na,c,e);break a}xa&&xa(a,h,d);"focusout"===a&&(xa=h._wrapperState)&&\nxa.controlled&&"number"===h.type&&cb(h,"number",h.value)}xa=d?ue(d):window;switch(a){case "focusin":if(me(xa)||"true"===xa.contentEditable)Qe=xa,Re=d,Se=null;break;case "focusout":Se=Re=Qe=null;break;case "mousedown":Te=!0;break;case "contextmenu":case "mouseup":case "dragend":Te=!1;Ue(g,c,e);break;case "selectionchange":if(Pe)break;case "keydown":case "keyup":Ue(g,c,e)}var $a;if(ae)b:{switch(a){case "compositionstart":var ba="onCompositionStart";break b;case "compositionend":ba="onCompositionEnd";\nbreak b;case "compositionupdate":ba="onCompositionUpdate";break b}ba=void 0}else ie?ge(a,c)&&(ba="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(ba="onCompositionStart");ba&&(de&&"ko"!==c.locale&&(ie||"onCompositionStart"!==ba?"onCompositionEnd"===ba&&ie&&($a=nd()):(kd=e,ld="value"in kd?kd.value:kd.textContent,ie=!0)),xa=oe(d,ba),0<xa.length&&(ba=new Ld(ba,a,null,c,e),g.push({event:ba,listeners:xa}),$a?ba.data=$a:($a=he(c),null!==$a&&(ba.data=$a))));if($a=ce?je(a,c):ke(a,c))d=oe(d,"onBeforeInput"),\n0<d.length&&(e=new Ld("onBeforeInput","beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=$a)}se(g,b)})}function tf(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Kb(a,c),null!=f&&d.unshift(tf(a,f,e)),f=Kb(a,b),null!=f&&d.push(tf(a,f,e)));a=a.return}return d}function vf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}\nfunction wf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Kb(c,f),null!=k&&g.unshift(tf(c,k,h))):e||(k=Kb(c,f),null!=k&&g.push(tf(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}var xf=/\\r\\n?/g,yf=/\\u0000|\\uFFFD/g;function zf(a){return("string"===typeof a?a:""+a).replace(xf,"\\n").replace(yf,"")}function Af(a,b,c){b=zf(b);if(zf(a)!==b&&c)throw Error(p(425));}function Bf(){}\nvar Cf=null,Df=null;function Ef(a,b){return"textarea"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}\nvar Ff="function"===typeof setTimeout?setTimeout:void 0,Gf="function"===typeof clearTimeout?clearTimeout:void 0,Hf="function"===typeof Promise?Promise:void 0,Jf="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof Hf?function(a){return Hf.resolve(null).then(a).catch(If)}:Ff;function If(a){setTimeout(function(){throw a;})}\nfunction Kf(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,"/$"===c){if(0===d){a.removeChild(e);bd(b);return}d--}else"$"!==c&&"$?"!==c&&"$!"!==c||d++;c=e}while(c);bd(b)}function Lf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if("$"===b||"$!"===b||"$?"===b)break;if("/$"===b)return null}}return a}\nfunction Mf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--}else"/$"===c&&b++}a=a.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of="__reactFiber$"+Nf,Pf="__reactProps$"+Nf,uf="__reactContainer$"+Nf,of="__reactEvents$"+Nf,Qf="__reactListeners$"+Nf,Rf="__reactHandles$"+Nf;\nfunction Wc(a){var b=a[Of];if(b)return b;for(var c=a.parentNode;c;){if(b=c[uf]||c[Of]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Mf(a);null!==a;){if(c=a[Of])return c;a=Mf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[Of]||a[uf];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p(33));}function Db(a){return a[Pf]||null}var Sf=[],Tf=-1;function Uf(a){return{current:a}}\nfunction E(a){0>Tf||(a.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G(a,b){Tf++;Sf[Tf]=a.current;a.current=b}var Vf={},H=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(a,b){var c=a.type.contextTypes;if(!c)return Vf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}\nfunction Zf(a){a=a.childContextTypes;return null!==a&&void 0!==a}function $f(){E(Wf);E(H)}function ag(a,b,c){if(H.current!==Vf)throw Error(p(168));G(H,b);G(Wf,c)}function bg(a,b,c){var d=a.stateNode;b=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p(108,Ra(a)||"Unknown",e));return A({},c,d)}\nfunction cg(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf;Xf=H.current;G(H,a);G(Wf,Wf.current);return!0}function dg(a,b,c){var d=a.stateNode;if(!d)throw Error(p(169));c?(a=bg(a,b,Xf),d.__reactInternalMemoizedMergedChildContext=a,E(Wf),E(H),G(H,a)):E(Wf);G(Wf,c)}var eg=null,fg=!1,gg=!1;function hg(a){null===eg?eg=[a]:eg.push(a)}function ig(a){fg=!0;hg(a)}\nfunction jg(){if(!gg&&null!==eg){gg=!0;var a=0,b=C;try{var c=eg;for(C=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}eg=null;fg=!1}catch(e){throw null!==eg&&(eg=eg.slice(a+1)),ac(fc,jg),e;}finally{C=b,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg="";function tg(a,b){kg[lg++]=ng;kg[lg++]=mg;mg=a;ng=b}\nfunction ug(a,b,c){og[pg++]=rg;og[pg++]=sg;og[pg++]=qg;qg=a;var d=rg;a=sg;var e=32-oc(d)-1;d&=~(1<<e);c+=1;var f=32-oc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;rg=1<<32-oc(b)+e|c<<e|d;sg=f+a}else rg=1<<f|c<<e|d,sg=a}function vg(a){null!==a.return&&(tg(a,1),ug(a,1,0))}function wg(a){for(;a===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;a===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I=!1,zg=null;\nfunction Ag(a,b){var c=Bg(5,null,null,0);c.elementType="DELETED";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c)}\nfunction Cg(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,xg=a,yg=Lf(b.firstChild),!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,xg=a,yg=null,!0):!1;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==qg?{id:rg,overflow:sg}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=Bg(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,xg=a,yg=\nnull,!0):!1;default:return!1}}function Dg(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function Eg(a){if(I){var b=yg;if(b){var c=b;if(!Cg(a,b)){if(Dg(a))throw Error(p(418));b=Lf(c.nextSibling);var d=xg;b&&Cg(a,b)?Ag(d,c):(a.flags=a.flags&-4097|2,I=!1,xg=a)}}else{if(Dg(a))throw Error(p(418));a.flags=a.flags&-4097|2;I=!1;xg=a}}}function Fg(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;xg=a}\nfunction Gg(a){if(a!==xg)return!1;if(!I)return Fg(a),I=!0,!1;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b="head"!==b&&"body"!==b&&!Ef(a.type,a.memoizedProps));if(b&&(b=yg)){if(Dg(a))throw Hg(),Error(p(418));for(;b;)Ag(a,b),b=Lf(b.nextSibling)}Fg(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){yg=Lf(a.nextSibling);break a}b--}else"$"!==c&&"$!"!==c&&"$?"!==c||b++}a=a.nextSibling}yg=\nnull}}else yg=xg?Lf(a.stateNode.nextSibling):null;return!0}function Hg(){for(var a=yg;a;)a=Lf(a.nextSibling)}function Ig(){yg=xg=null;I=!1}function Jg(a){null===zg?zg=[a]:zg.push(a)}var Kg=ua.ReactCurrentBatchConfig;\nfunction Lg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p(309));var d=c.stateNode}if(!d)throw Error(p(147,a));var e=d,f=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;null===a?delete b[f]:b[f]=a};b._stringRef=f;return b}if("string"!==typeof a)throw Error(p(284));if(!c._owner)throw Error(p(290,a));}return a}\nfunction Mg(a,b){a=Object.prototype.toString.call(b);throw Error(p(31,"[object Object]"===a?"object with keys {"+Object.keys(b).join(", ")+"}":a));}function Ng(a){var b=a._init;return b(a._payload)}\nfunction Og(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c)}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Pg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&\nnull===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Qg(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===ya)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===Ha&&Ng(f)===b.type))return d=e(b,c.props),d.ref=Lg(a,b,c),d.return=a,d;d=Rg(c.type,c.key,c.props,null,a.mode,d);d.ref=Lg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||\nb.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=Sg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Tg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function q(a,b,c){if("string"===typeof b&&""!==b||"number"===typeof b)return b=Qg(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case va:return c=Rg(b.type,b.key,b.props,null,a.mode,c),\nc.ref=Lg(a,null,b),c.return=a,c;case wa:return b=Sg(b,a.mode,c),b.return=a,b;case Ha:var d=b._init;return q(a,d(b._payload),c)}if(eb(b)||Ka(b))return b=Tg(b,a.mode,c,null),b.return=a,b;Mg(a,b)}return null}function r(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c&&""!==c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case va:return c.key===e?k(a,b,c,d):null;case wa:return c.key===e?l(a,b,c,d):null;case Ha:return e=c._init,r(a,\nb,e(c._payload),d)}if(eb(c)||Ka(c))return null!==e?null:m(a,b,c,d,null);Mg(a,c)}return null}function y(a,b,c,d,e){if("string"===typeof d&&""!==d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case va:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case wa:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Ha:var f=d._init;return y(a,b,c,f(d._payload),e)}if(eb(d)||Ka(d))return a=a.get(c)||null,m(b,a,d,e,null);Mg(b,d)}return null}\nfunction n(e,g,h,k){for(var l=null,m=null,u=g,w=g=0,x=null;null!==u&&w<h.length;w++){u.index>w?(x=u,u=null):x=u.sibling;var n=r(e,u,h[w],k);if(null===n){null===u&&(u=x);break}a&&u&&null===n.alternate&&b(e,u);g=f(n,g,w);null===m?l=n:m.sibling=n;m=n;u=x}if(w===h.length)return c(e,u),I&&tg(e,w),l;if(null===u){for(;w<h.length;w++)u=q(e,h[w],k),null!==u&&(g=f(u,g,w),null===m?l=u:m.sibling=u,m=u);I&&tg(e,w);return l}for(u=d(e,u);w<h.length;w++)x=y(u,e,w,h[w],k),null!==x&&(a&&null!==x.alternate&&u.delete(null===\nx.key?w:x.key),g=f(x,g,w),null===m?l=x:m.sibling=x,m=x);a&&u.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function t(e,g,h,k){var l=Ka(h);if("function"!==typeof l)throw Error(p(150));h=l.call(h);if(null==h)throw Error(p(151));for(var u=l=null,m=g,w=g=0,x=null,n=h.next();null!==m&&!n.done;w++,n=h.next()){m.index>w?(x=m,m=null):x=m.sibling;var t=r(e,m,n.value,k);if(null===t){null===m&&(m=x);break}a&&m&&null===t.alternate&&b(e,m);g=f(t,g,w);null===u?l=t:u.sibling=t;u=t;m=x}if(n.done)return c(e,\nm),I&&tg(e,w),l;if(null===m){for(;!n.done;w++,n=h.next())n=q(e,n.value,k),null!==n&&(g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);I&&tg(e,w);return l}for(m=d(e,m);!n.done;w++,n=h.next())n=y(m,e,w,n.value,k),null!==n&&(a&&null!==n.alternate&&m.delete(null===n.key?w:n.key),g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);a&&m.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function J(a,d,f,h){"object"===typeof f&&null!==f&&f.type===ya&&null===f.key&&(f=f.props.children);if("object"===typeof f&&null!==f){switch(f.$$typeof){case va:a:{for(var k=\nf.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===ya){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||"object"===typeof k&&null!==k&&k.$$typeof===Ha&&Ng(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=Lg(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling}f.type===ya?(d=Tg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Rg(f.type,f.key,f.props,null,a.mode,h),h.ref=Lg(a,d,f),h.return=a,a=h)}return g(a);case wa:a:{for(l=f.key;null!==\nd;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=Sg(f,a.mode,h);d.return=a;a=d}return g(a);case Ha:return l=f._init,J(a,d,l(f._payload),h)}if(eb(f))return n(a,d,f,h);if(Ka(f))return t(a,d,f,h);Mg(a,f)}return"string"===typeof f&&""!==f||"number"===typeof f?(f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):\n(c(a,d),d=Qg(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return J}var Ug=Og(!0),Vg=Og(!1),Wg=Uf(null),Xg=null,Yg=null,Zg=null;function $g(){Zg=Yg=Xg=null}function ah(a){var b=Wg.current;E(Wg);a._currentValue=b}function bh(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return}}\nfunction ch(a,b){Xg=a;Zg=Yg=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(dh=!0),a.firstContext=null)}function eh(a){var b=a._currentValue;if(Zg!==a)if(a={context:a,memoizedValue:b,next:null},null===Yg){if(null===Xg)throw Error(p(308));Yg=a;Xg.dependencies={lanes:0,firstContext:a}}else Yg=Yg.next=a;return b}var fh=null;function gh(a){null===fh?fh=[a]:fh.push(a)}\nfunction hh(a,b,c,d){var e=b.interleaved;null===e?(c.next=c,gh(b)):(c.next=e.next,e.next=c);b.interleaved=c;return ih(a,d)}function ih(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}var jh=!1;function kh(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}\nfunction lh(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function mh(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}\nfunction nh(a,b,c){var d=a.updateQueue;if(null===d)return null;d=d.shared;if(0!==(K&2)){var e=d.pending;null===e?b.next=b:(b.next=e.next,e.next=b);d.pending=b;return ih(a,c)}e=d.interleaved;null===e?(b.next=b,gh(d)):(b.next=e.next,e.next=b);d.interleaved=b;return ih(a,c)}function oh(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}\nfunction ph(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=\nb;c.lastBaseUpdate=b}\nfunction qh(a,b,c,d){var e=a.updateQueue;jh=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k))}if(null!==f){var q=e.baseState;g=0;m=l=k=null;h=f;do{var r=h.lane,y=h.eventTime;if((d&r)===r){null!==m&&(m=m.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,\nnext:null});a:{var n=a,t=h;r=b;y=c;switch(t.tag){case 1:n=t.payload;if("function"===typeof n){q=n.call(y,q,r);break a}q=n;break a;case 3:n.flags=n.flags&-65537|128;case 0:n=t.payload;r="function"===typeof n?n.call(y,q,r):n;if(null===r||void 0===r)break a;q=A({},q,r);break a;case 2:jh=!0}}null!==h.callback&&0!==h.lane&&(a.flags|=64,r=e.effects,null===r?e.effects=[h]:r.push(h))}else y={eventTime:y,lane:r,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=y,k=q):m=m.next=y,g|=r;\nh=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else r=h,h=r.next,r.next=null,e.lastBaseUpdate=r,e.shared.pending=null}while(1);null===m&&(k=q);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);rh|=g;a.lanes=g;a.memoizedState=q}}\nfunction sh(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(p(191,e));e.call(d)}}}var th={},uh=Uf(th),vh=Uf(th),wh=Uf(th);function xh(a){if(a===th)throw Error(p(174));return a}\nfunction yh(a,b){G(wh,b);G(vh,a);G(uh,th);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:lb(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=lb(b,a)}E(uh);G(uh,b)}function zh(){E(uh);E(vh);E(wh)}function Ah(a){xh(wh.current);var b=xh(uh.current);var c=lb(b,a.type);b!==c&&(G(vh,a),G(uh,c))}function Bh(a){vh.current===a&&(E(uh),E(vh))}var L=Uf(0);\nfunction Ch(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var Dh=[];\nfunction Eh(){for(var a=0;a<Dh.length;a++)Dh[a]._workInProgressVersionPrimary=null;Dh.length=0}var Fh=ua.ReactCurrentDispatcher,Gh=ua.ReactCurrentBatchConfig,Hh=0,M=null,N=null,O=null,Ih=!1,Jh=!1,Kh=0,Lh=0;function P(){throw Error(p(321));}function Mh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}\nfunction Nh(a,b,c,d,e,f){Hh=f;M=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Fh.current=null===a||null===a.memoizedState?Oh:Ph;a=c(d,e);if(Jh){f=0;do{Jh=!1;Kh=0;if(25<=f)throw Error(p(301));f+=1;O=N=null;b.updateQueue=null;Fh.current=Qh;a=c(d,e)}while(Jh)}Fh.current=Rh;b=null!==N&&null!==N.next;Hh=0;O=N=M=null;Ih=!1;if(b)throw Error(p(300));return a}function Sh(){var a=0!==Kh;Kh=0;return a}\nfunction Th(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===O?M.memoizedState=O=a:O=O.next=a;return O}function Uh(){if(null===N){var a=M.alternate;a=null!==a?a.memoizedState:null}else a=N.next;var b=null===O?M.memoizedState:O.next;if(null!==b)O=b,N=a;else{if(null===a)throw Error(p(310));N=a;a={memoizedState:N.memoizedState,baseState:N.baseState,baseQueue:N.baseQueue,queue:N.queue,next:null};null===O?M.memoizedState=O=a:O=O.next=a}return O}\nfunction Vh(a,b){return"function"===typeof b?b(a):b}\nfunction Wh(a){var b=Uh(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=N,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((Hh&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else{var q={lane:m,action:l.action,hasEagerState:l.hasEagerState,\neagerState:l.eagerState,next:null};null===k?(h=k=q,g=d):k=k.next=q;M.lanes|=m;rh|=m}l=l.next}while(null!==l&&l!==f);null===k?g=d:k.next=h;He(d,b.memoizedState)||(dh=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d}a=c.interleaved;if(null!==a){e=a;do f=e.lane,M.lanes|=f,rh|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return[b.memoizedState,c.dispatch]}\nfunction Xh(a){var b=Uh(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(dh=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function Yh(){}\nfunction Zh(a,b){var c=M,d=Uh(),e=b(),f=!He(d.memoizedState,e);f&&(d.memoizedState=e,dh=!0);d=d.queue;$h(ai.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==O&&O.memoizedState.tag&1){c.flags|=2048;bi(9,ci.bind(null,c,d,e,b),void 0,null);if(null===Q)throw Error(p(349));0!==(Hh&30)||di(c,b,e)}return e}function di(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=M.updateQueue;null===b?(b={lastEffect:null,stores:null},M.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a))}\nfunction ci(a,b,c,d){b.value=c;b.getSnapshot=d;ei(b)&&fi(a)}function ai(a,b,c){return c(function(){ei(b)&&fi(a)})}function ei(a){var b=a.getSnapshot;a=a.value;try{var c=b();return!He(a,c)}catch(d){return!0}}function fi(a){var b=ih(a,1);null!==b&&gi(b,a,1,-1)}\nfunction hi(a){var b=Th();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh,lastRenderedState:a};b.queue=a;a=a.dispatch=ii.bind(null,M,a);return[b.memoizedState,a]}\nfunction bi(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=M.updateQueue;null===b?(b={lastEffect:null,stores:null},M.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function ji(){return Uh().memoizedState}function ki(a,b,c,d){var e=Th();M.flags|=a;e.memoizedState=bi(1|b,c,void 0,void 0===d?null:d)}\nfunction li(a,b,c,d){var e=Uh();d=void 0===d?null:d;var f=void 0;if(null!==N){var g=N.memoizedState;f=g.destroy;if(null!==d&&Mh(d,g.deps)){e.memoizedState=bi(b,c,f,d);return}}M.flags|=a;e.memoizedState=bi(1|b,c,f,d)}function mi(a,b){return ki(8390656,8,a,b)}function $h(a,b){return li(2048,8,a,b)}function ni(a,b){return li(4,2,a,b)}function oi(a,b){return li(4,4,a,b)}\nfunction pi(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function qi(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return li(4,4,pi.bind(null,b,a),c)}function ri(){}function si(a,b){var c=Uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}\nfunction ti(a,b){var c=Uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function ui(a,b,c){if(0===(Hh&21))return a.baseState&&(a.baseState=!1,dh=!0),a.memoizedState=c;He(c,b)||(c=yc(),M.lanes|=c,rh|=c,a.baseState=!0);return b}function vi(a,b){var c=C;C=0!==c&&4>c?c:4;a(!0);var d=Gh.transition;Gh.transition={};try{a(!1),b()}finally{C=c,Gh.transition=d}}function wi(){return Uh().memoizedState}\nfunction xi(a,b,c){var d=yi(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(zi(a))Ai(b,c);else if(c=hh(a,b,c,d),null!==c){var e=R();gi(c,a,d,e);Bi(c,b,d)}}\nfunction ii(a,b,c){var d=yi(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(zi(a))Ai(b,e);else{var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(He(h,g)){var k=b.interleaved;null===k?(e.next=e,gh(b)):(e.next=k.next,k.next=e);b.interleaved=e;return}}catch(l){}finally{}c=hh(a,b,e,d);null!==c&&(e=R(),gi(c,a,d,e),Bi(c,b,d))}}\nfunction zi(a){var b=a.alternate;return a===M||null!==b&&b===M}function Ai(a,b){Jh=Ih=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}function Bi(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}\nvar Rh={readContext:eh,useCallback:P,useContext:P,useEffect:P,useImperativeHandle:P,useInsertionEffect:P,useLayoutEffect:P,useMemo:P,useReducer:P,useRef:P,useState:P,useDebugValue:P,useDeferredValue:P,useTransition:P,useMutableSource:P,useSyncExternalStore:P,useId:P,unstable_isNewReconciler:!1},Oh={readContext:eh,useCallback:function(a,b){Th().memoizedState=[a,void 0===b?null:b];return a},useContext:eh,useEffect:mi,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ki(4194308,\n4,pi.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ki(4194308,4,a,b)},useInsertionEffect:function(a,b){return ki(4,2,a,b)},useMemo:function(a,b){var c=Th();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=Th();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=xi.bind(null,M,a);return[d.memoizedState,a]},useRef:function(a){var b=\nTh();a={current:a};return b.memoizedState=a},useState:hi,useDebugValue:ri,useDeferredValue:function(a){return Th().memoizedState=a},useTransition:function(){var a=hi(!1),b=a[0];a=vi.bind(null,a[1]);Th().memoizedState=a;return[b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=M,e=Th();if(I){if(void 0===c)throw Error(p(407));c=c()}else{c=b();if(null===Q)throw Error(p(349));0!==(Hh&30)||di(d,b,c)}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;mi(ai.bind(null,d,\nf,a),[a]);d.flags|=2048;bi(9,ci.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=Th(),b=Q.identifierPrefix;if(I){var c=sg;var d=rg;c=(d&~(1<<32-oc(d)-1)).toString(32)+c;b=":"+b+"R"+c;c=Kh++;0<c&&(b+="H"+c.toString(32));b+=":"}else c=Lh++,b=":"+b+"r"+c.toString(32)+":";return a.memoizedState=b},unstable_isNewReconciler:!1},Ph={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Wh,useRef:ji,useState:function(){return Wh(Vh)},\nuseDebugValue:ri,useDeferredValue:function(a){var b=Uh();return ui(b,N.memoizedState,a)},useTransition:function(){var a=Wh(Vh)[0],b=Uh().memoizedState;return[a,b]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1},Qh={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Xh,useRef:ji,useState:function(){return Xh(Vh)},useDebugValue:ri,useDeferredValue:function(a){var b=Uh();return null===\nN?b.memoizedState=a:ui(b,N.memoizedState,a)},useTransition:function(){var a=Xh(Vh)[0],b=Uh().memoizedState;return[a,b]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1};function Ci(a,b){if(a&&a.defaultProps){b=A({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}function Di(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}\nvar Ei={isMounted:function(a){return(a=a._reactInternals)?Vb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=R(),e=yi(a),f=mh(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=nh(a,f,e);null!==b&&(gi(b,a,e,d),oh(b,a,e))},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=R(),e=yi(a),f=mh(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=nh(a,f,e);null!==b&&(gi(b,a,e,d),oh(b,a,e))},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=R(),d=\nyi(a),e=mh(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);b=nh(a,e,d);null!==b&&(gi(b,a,d,c),oh(b,a,d))}};function Fi(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Ie(c,d)||!Ie(e,f):!0}\nfunction Gi(a,b,c){var d=!1,e=Vf;var f=b.contextType;"object"===typeof f&&null!==f?f=eh(f):(e=Zf(b)?Xf:H.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Yf(a,e):Vf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Ei;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}\nfunction Hi(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Ei.enqueueReplaceState(b,b.state,null)}\nfunction Ii(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs={};kh(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=eh(f):(f=Zf(b)?Xf:H.current,e.context=Yf(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Di(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,\n"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Ei.enqueueReplaceState(e,e.state,null),qh(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4194308)}function Ji(a,b){try{var c="",d=b;do c+=Pa(d),d=d.return;while(d);var e=c}catch(f){e="\\nError generating stack: "+f.message+"\\n"+f.stack}return{value:a,source:b,stack:e,digest:null}}\nfunction Ki(a,b,c){return{value:a,source:null,stack:null!=c?c:null,digest:null!=b?b:null}}function Li(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Mi="function"===typeof WeakMap?WeakMap:Map;function Ni(a,b,c){c=mh(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Oi||(Oi=!0,Pi=d);Li(a,b)};return c}\nfunction Qi(a,b,c){c=mh(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Li(a,b)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){Li(a,b);"function"!==typeof d&&(null===Ri?Ri=new Set([this]):Ri.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}\nfunction Si(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Mi;var e=new Set;d.set(b,e)}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Ti.bind(null,a,b,c),b.then(a,a))}function Ui(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return}while(null!==a);return null}\nfunction Vi(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=mh(-1,1),b.tag=2,nh(c,b,1))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Wi=ua.ReactCurrentOwner,dh=!1;function Xi(a,b,c,d){b.child=null===a?Vg(b,null,c,d):Ug(b,a.child,c,d)}\nfunction Yi(a,b,c,d,e){c=c.render;var f=b.ref;ch(b,e);d=Nh(a,b,c,d,f,e);c=Sh();if(null!==a&&!dh)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi(a,b,e);I&&c&&vg(b);b.flags|=1;Xi(a,b,d,e);return b.child}\nfunction $i(a,b,c,d,e){if(null===a){var f=c.type;if("function"===typeof f&&!aj(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,bj(a,b,f,d,e);a=Rg(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:Ie;if(c(g,d)&&a.ref===b.ref)return Zi(a,b,e)}b.flags|=1;a=Pg(f,d);a.ref=b.ref;a.return=b;return b.child=a}\nfunction bj(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(Ie(f,d)&&a.ref===b.ref)if(dh=!1,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(dh=!0);else return b.lanes=a.lanes,Zi(a,b,e)}return cj(a,b,c,d,e)}\nfunction dj(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(ej,fj),fj|=c;else{if(0===(c&1073741824))return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,G(ej,fj),fj|=a,null;b.memoizedState={baseLanes:0,cachePool:null,transitions:null};d=null!==f?f.baseLanes:c;G(ej,fj);fj|=d}else null!==\nf?(d=f.baseLanes|c,b.memoizedState=null):d=c,G(ej,fj),fj|=d;Xi(a,b,e,c);return b.child}function gj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152}function cj(a,b,c,d,e){var f=Zf(c)?Xf:H.current;f=Yf(b,f);ch(b,e);c=Nh(a,b,c,d,f,e);d=Sh();if(null!==a&&!dh)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi(a,b,e);I&&d&&vg(b);b.flags|=1;Xi(a,b,c,e);return b.child}\nfunction hj(a,b,c,d,e){if(Zf(c)){var f=!0;cg(b)}else f=!1;ch(b,e);if(null===b.stateNode)ij(a,b),Gi(b,c,d),Ii(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=eh(l):(l=Zf(c)?Xf:H.current,l=Yf(b,l));var m=c.getDerivedStateFromProps,q="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;q||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||\n(h!==d||k!==l)&&Hi(b,g,d,l);jh=!1;var r=b.memoizedState;g.state=r;qh(b,d,g,e);k=b.memoizedState;h!==d||r!==k||Wf.current||jh?("function"===typeof m&&(Di(b,c,m,d),k=b.memoizedState),(h=jh||Fi(b,c,h,d,r,k,l))?(q||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.flags|=4194308)):\n("function"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1)}else{g=b.stateNode;lh(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:Ci(b.type,h);g.props=l;q=b.pendingProps;r=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=eh(k):(k=Zf(c)?Xf:H.current,k=Yf(b,k));var y=c.getDerivedStateFromProps;(m="function"===typeof y||"function"===typeof g.getSnapshotBeforeUpdate)||\n"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==q||r!==k)&&Hi(b,g,d,k);jh=!1;r=b.memoizedState;g.state=r;qh(b,d,g,e);var n=b.memoizedState;h!==q||r!==n||Wf.current||jh?("function"===typeof y&&(Di(b,c,y,d),n=b.memoizedState),(l=jh||Fi(b,c,l,d,r,n,k)||!1)?(m||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,n,k),"function"===typeof g.UNSAFE_componentWillUpdate&&\ng.UNSAFE_componentWillUpdate(d,n,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=n),g.props=d,g.state=n,g.context=k,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===\na.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),d=!1)}return jj(a,b,c,d,f,e)}\nfunction jj(a,b,c,d,e,f){gj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&dg(b,c,!1),Zi(a,b,f);d=b.stateNode;Wi.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Ug(b,a.child,null,f),b.child=Ug(b,null,h,f)):Xi(a,b,h,f);b.memoizedState=d.state;e&&dg(b,c,!0);return b.child}function kj(a){var b=a.stateNode;b.pendingContext?ag(a,b.pendingContext,b.pendingContext!==b.context):b.context&&ag(a,b.context,!1);yh(a,b.containerInfo)}\nfunction lj(a,b,c,d,e){Ig();Jg(e);b.flags|=256;Xi(a,b,c,d);return b.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(a){return{baseLanes:a,cachePool:null,transitions:null}}\nfunction oj(a,b,c){var d=b.pendingProps,e=L.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;G(L,e&1);if(null===a){Eg(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:"$!"===a.data?b.lanes=8:b.lanes=1073741824,null;g=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,g={mode:"hidden",children:g},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=\ng):f=pj(g,d,0,null),a=Tg(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=nj(c),b.memoizedState=mj,a):qj(b,g)}e=a.memoizedState;if(null!==e&&(h=e.dehydrated,null!==h))return rj(a,b,g,d,h,e,c);if(f){f=d.fallback;g=b.mode;e=a.child;h=e.sibling;var k={mode:"hidden",children:d.children};0===(g&1)&&b.child!==e?(d=b.child,d.childLanes=0,d.pendingProps=k,b.deletions=null):(d=Pg(e,k),d.subtreeFlags=e.subtreeFlags&14680064);null!==h?f=Pg(h,f):(f=Tg(f,g,c,null),f.flags|=2);f.return=\nb;d.return=b;d.sibling=f;b.child=d;d=f;f=b.child;g=a.child.memoizedState;g=null===g?nj(c):{baseLanes:g.baseLanes|c,cachePool:null,transitions:g.transitions};f.memoizedState=g;f.childLanes=a.childLanes&~c;b.memoizedState=mj;return d}f=a.child;a=f.sibling;d=Pg(f,{mode:"visible",children:d.children});0===(b.mode&1)&&(d.lanes=c);d.return=b;d.sibling=null;null!==a&&(c=b.deletions,null===c?(b.deletions=[a],b.flags|=16):c.push(a));b.child=d;b.memoizedState=null;return d}\nfunction qj(a,b){b=pj({mode:"visible",children:b},a.mode,0,null);b.return=a;return a.child=b}function sj(a,b,c,d){null!==d&&Jg(d);Ug(b,a.child,null,c);a=qj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}\nfunction rj(a,b,c,d,e,f,g){if(c){if(b.flags&256)return b.flags&=-257,d=Ki(Error(p(422))),sj(a,b,g,d);if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=pj({mode:"visible",children:d.children},e,0,null);f=Tg(f,e,g,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&Ug(b,a.child,null,g);b.child.memoizedState=nj(g);b.memoizedState=mj;return f}if(0===(b.mode&1))return sj(a,b,g,null);if("$!"===e.data){d=e.nextSibling&&e.nextSibling.dataset;\nif(d)var h=d.dgst;d=h;f=Error(p(419));d=Ki(f,d,void 0);return sj(a,b,g,d)}h=0!==(g&a.childLanes);if(dh||h){d=Q;if(null!==d){switch(g&-g){case 4:e=2;break;case 16:e=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:e=32;break;case 536870912:e=268435456;break;default:e=0}e=0!==(e&(d.suspendedLanes|g))?0:e;\n0!==e&&e!==f.retryLane&&(f.retryLane=e,ih(a,e),gi(d,a,e,-1))}tj();d=Ki(Error(p(421)));return sj(a,b,g,d)}if("$?"===e.data)return b.flags|=128,b.child=a.child,b=uj.bind(null,a),e._reactRetry=b,null;a=f.treeContext;yg=Lf(e.nextSibling);xg=b;I=!0;zg=null;null!==a&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=a.id,sg=a.overflow,qg=b);b=qj(b,d.children);b.flags|=4096;return b}function vj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);bh(a.return,b,c)}\nfunction wj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e)}\nfunction xj(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Xi(a,b,d.children,c);d=L.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else{if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&vj(a,c,b);else if(19===a.tag)vj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}G(L,d);if(0===(b.mode&1))b.memoizedState=\nnull;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Ch(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);wj(b,!1,e,c,f);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Ch(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}wj(b,!0,c,null,f);break;case "together":wj(b,!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}\nfunction ij(a,b){0===(b.mode&1)&&null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2)}function Zi(a,b,c){null!==a&&(b.dependencies=a.dependencies);rh|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p(153));if(null!==b.child){a=b.child;c=Pg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Pg(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}\nfunction yj(a,b,c){switch(b.tag){case 3:kj(b);Ig();break;case 5:Ah(b);break;case 1:Zf(b.type)&&cg(b);break;case 4:yh(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;G(Wg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return G(L,L.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return oj(a,b,c);G(L,L.current&1);a=Zi(a,b,c);return null!==a?a.sibling:null}G(L,L.current&1);break;case 19:d=0!==(c&\nb.childLanes);if(0!==(a.flags&128)){if(d)return xj(a,b,c);b.flags|=128}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);G(L,L.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,dj(a,b,c)}return Zi(a,b,c)}var zj,Aj,Bj,Cj;\nzj=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Aj=function(){};\nBj=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;xh(uh.current);var f=null;switch(c){case "input":e=Ya(a,e);d=Ya(a,d);f=[];break;case "select":e=A({},e,{value:void 0});d=A({},d,{value:void 0});f=[];break;case "textarea":e=gb(a,e);d=gb(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=Bf)}ub(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&\n(c||(c={}),c[g]="")}else"dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ea.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,\nc)),c=k;else"dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(ea.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&D("scroll",a),f||h===k||(f=[])):(f=f||[]).push(l,k))}c&&(f=f||[]).push("style",c);var l=f;if(b.updateQueue=l)b.flags|=4}};Cj=function(a,b,c,d){c!==d&&(b.flags|=4)};\nfunction Dj(a,b){if(!I)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}\nfunction S(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}\nfunction Ej(a,b,c){var d=b.pendingProps;wg(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(b),null;case 1:return Zf(b.type)&&$f(),S(b),null;case 3:d=b.stateNode;zh();E(Wf);E(H);Eh();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)Gg(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==zg&&(Fj(zg),zg=null));Aj(a,b);S(b);return null;case 5:Bh(b);var e=xh(wh.current);\nc=b.type;if(null!==a&&null!=b.stateNode)Bj(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else{if(!d){if(null===b.stateNode)throw Error(p(166));S(b);return null}a=xh(uh.current);if(Gg(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Of]=b;d[Pf]=f;a=0!==(b.mode&1);switch(c){case "dialog":D("cancel",d);D("close",d);break;case "iframe":case "object":case "embed":D("load",d);break;case "video":case "audio":for(e=0;e<lf.length;e++)D(lf[e],d);break;case "source":D("error",d);break;case "img":case "image":case "link":D("error",\nd);D("load",d);break;case "details":D("toggle",d);break;case "input":Za(d,f);D("invalid",d);break;case "select":d._wrapperState={wasMultiple:!!f.multiple};D("invalid",d);break;case "textarea":hb(d,f),D("invalid",d)}ub(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,h,a),e=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,\nh,a),e=["children",""+h]):ea.hasOwnProperty(g)&&null!=h&&"onScroll"===g&&D("scroll",d)}switch(c){case "input":Va(d);db(d,f,!0);break;case "textarea":Va(d);jb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=Bf)}d=e;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=kb(c));"http://www.w3.org/1999/xhtml"===a?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\\x3c/script>",a=a.removeChild(a.firstChild)):\n"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Of]=b;a[Pf]=d;zj(a,b,!1,!1);b.stateNode=a;a:{g=vb(c,d);switch(c){case "dialog":D("cancel",a);D("close",a);e=d;break;case "iframe":case "object":case "embed":D("load",a);e=d;break;case "video":case "audio":for(e=0;e<lf.length;e++)D(lf[e],a);e=d;break;case "source":D("error",a);e=d;break;case "img":case "image":case "link":D("error",\na);D("load",a);e=d;break;case "details":D("toggle",a);e=d;break;case "input":Za(a,d);e=Ya(a,d);D("invalid",a);break;case "option":e=d;break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=A({},d,{value:void 0});D("invalid",a);break;case "textarea":hb(a,d);e=gb(a,d);D("invalid",a);break;default:e=d}ub(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?sb(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&nb(a,k)):"children"===f?"string"===typeof k?("textarea"!==\nc||""!==k)&&ob(a,k):"number"===typeof k&&ob(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(ea.hasOwnProperty(f)?null!=k&&"onScroll"===f&&D("scroll",a):null!=k&&ta(a,f,k,g))}switch(c){case "input":Va(a);db(a,d,!1);break;case "textarea":Va(a);jb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Sa(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,\n!0);break;default:"function"===typeof e.onClick&&(a.onclick=Bf)}switch(c){case "button":case "input":case "select":case "textarea":d=!!d.autoFocus;break a;case "img":d=!0;break a;default:d=!1}}d&&(b.flags|=4)}null!==b.ref&&(b.flags|=512,b.flags|=2097152)}S(b);return null;case 6:if(a&&null!=b.stateNode)Cj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(p(166));c=xh(wh.current);xh(uh.current);if(Gg(b)){d=b.stateNode;c=b.memoizedProps;d[Of]=b;if(f=d.nodeValue!==c)if(a=\nxg,null!==a)switch(a.tag){case 3:Af(d.nodeValue,c,0!==(a.mode&1));break;case 5:!0!==a.memoizedProps.suppressHydrationWarning&&Af(d.nodeValue,c,0!==(a.mode&1))}f&&(b.flags|=4)}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Of]=b,b.stateNode=d}S(b);return null;case 13:E(L);d=b.memoizedState;if(null===a||null!==a.memoizedState&&null!==a.memoizedState.dehydrated){if(I&&null!==yg&&0!==(b.mode&1)&&0===(b.flags&128))Hg(),Ig(),b.flags|=98560,f=!1;else if(f=Gg(b),null!==d&&null!==d.dehydrated){if(null===\na){if(!f)throw Error(p(318));f=b.memoizedState;f=null!==f?f.dehydrated:null;if(!f)throw Error(p(317));f[Of]=b}else Ig(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;S(b);f=!1}else null!==zg&&(Fj(zg),zg=null),f=!0;if(!f)return b.flags&65536?b:null}if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;d!==(null!==a&&null!==a.memoizedState)&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(L.current&1)?0===T&&(T=3):tj()));null!==b.updateQueue&&(b.flags|=4);S(b);return null;case 4:return zh(),\nAj(a,b),null===a&&sf(b.stateNode.containerInfo),S(b),null;case 10:return ah(b.type._context),S(b),null;case 17:return Zf(b.type)&&$f(),S(b),null;case 19:E(L);f=b.memoizedState;if(null===f)return S(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Dj(f,!1);else{if(0!==T||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Ch(a);if(null!==g){b.flags|=128;Dj(f,!1);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,\ng=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;G(L,L.current&1|2);return b.child}a=\na.sibling}null!==f.tail&&B()>Gj&&(b.flags|=128,d=!0,Dj(f,!1),b.lanes=4194304)}else{if(!d)if(a=Ch(g),null!==a){if(b.flags|=128,d=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Dj(f,!0),null===f.tail&&"hidden"===f.tailMode&&!g.alternate&&!I)return S(b),null}else 2*B()-f.renderingStartTime>Gj&&1073741824!==c&&(b.flags|=128,d=!0,Dj(f,!1),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g)}if(null!==f.tail)return b=f.tail,f.rendering=\nb,f.tail=b.sibling,f.renderingStartTime=B(),b.sibling=null,c=L.current,G(L,d?c&1|2:c&1),b;S(b);return null;case 22:case 23:return Hj(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(fj&1073741824)&&(S(b),b.subtreeFlags&6&&(b.flags|=8192)):S(b),null;case 24:return null;case 25:return null}throw Error(p(156,b.tag));}\nfunction Ij(a,b){wg(b);switch(b.tag){case 1:return Zf(b.type)&&$f(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return zh(),E(Wf),E(H),Eh(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Bh(b),null;case 13:E(L);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p(340));Ig()}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return E(L),null;case 4:return zh(),null;case 10:return ah(b.type._context),null;case 22:case 23:return Hj(),\nnull;case 24:return null;default:return null}}var Jj=!1,U=!1,Kj="function"===typeof WeakSet?WeakSet:Set,V=null;function Lj(a,b){var c=a.ref;if(null!==c)if("function"===typeof c)try{c(null)}catch(d){W(a,b,d)}else c.current=null}function Mj(a,b,c){try{c()}catch(d){W(a,b,d)}}var Nj=!1;\nfunction Oj(a,b){Cf=dd;a=Me();if(Ne(a)){if("selectionStart"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType}catch(F){c=null;break a}var g=0,h=-1,k=-1,l=0,m=0,q=a,r=null;b:for(;;){for(var y;;){q!==c||0!==e&&3!==q.nodeType||(h=g+e);q!==f||0!==d&&3!==q.nodeType||(k=g+d);3===q.nodeType&&(g+=\nq.nodeValue.length);if(null===(y=q.firstChild))break;r=q;q=y}for(;;){if(q===a)break b;r===c&&++l===e&&(h=g);r===f&&++m===d&&(k=g);if(null!==(y=q.nextSibling))break;q=r;r=q.parentNode}q=y}c=-1===h||-1===k?null:{start:h,end:k}}else c=null}c=c||{start:0,end:0}}else c=null;Df={focusedElem:a,selectionRange:c};dd=!1;for(V=b;null!==V;)if(b=V,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,V=a;else for(;null!==V;){b=V;try{var n=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;\ncase 1:if(null!==n){var t=n.memoizedProps,J=n.memoizedState,x=b.stateNode,w=x.getSnapshotBeforeUpdate(b.elementType===b.type?t:Ci(b.type,t),J);x.__reactInternalSnapshotBeforeUpdate=w}break;case 3:var u=b.stateNode.containerInfo;1===u.nodeType?u.textContent="":9===u.nodeType&&u.documentElement&&u.removeChild(u.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163));}}catch(F){W(b,b.return,F)}a=b.sibling;if(null!==a){a.return=b.return;V=a;break}V=b.return}n=Nj;Nj=!1;return n}\nfunction Pj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Mj(b,c,f)}e=e.next}while(e!==d)}}function Qj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function Rj(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c}"function"===typeof b?b(a):b.current=a}}\nfunction Sj(a){var b=a.alternate;null!==b&&(a.alternate=null,Sj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Of],delete b[Pf],delete b[of],delete b[Qf],delete b[Rf]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null}function Tj(a){return 5===a.tag||3===a.tag||4===a.tag}\nfunction Uj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Tj(a.return))return null;a=a.return}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}\nfunction Vj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=Bf));else if(4!==d&&(a=a.child,null!==a))for(Vj(a,b,c),a=a.sibling;null!==a;)Vj(a,b,c),a=a.sibling}\nfunction Wj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Wj(a,b,c),a=a.sibling;null!==a;)Wj(a,b,c),a=a.sibling}var X=null,Xj=!1;function Yj(a,b,c){for(c=c.child;null!==c;)Zj(a,b,c),c=c.sibling}\nfunction Zj(a,b,c){if(lc&&"function"===typeof lc.onCommitFiberUnmount)try{lc.onCommitFiberUnmount(kc,c)}catch(h){}switch(c.tag){case 5:U||Lj(c,b);case 6:var d=X,e=Xj;X=null;Yj(a,b,c);X=d;Xj=e;null!==X&&(Xj?(a=X,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):X.removeChild(c.stateNode));break;case 18:null!==X&&(Xj?(a=X,c=c.stateNode,8===a.nodeType?Kf(a.parentNode,c):1===a.nodeType&&Kf(a,c),bd(a)):Kf(X,c.stateNode));break;case 4:d=X;e=Xj;X=c.stateNode.containerInfo;Xj=!0;\nYj(a,b,c);X=d;Xj=e;break;case 0:case 11:case 14:case 15:if(!U&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Mj(c,b,g):0!==(f&4)&&Mj(c,b,g));e=e.next}while(e!==d)}Yj(a,b,c);break;case 1:if(!U&&(Lj(c,b),d=c.stateNode,"function"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount()}catch(h){W(c,b,h)}Yj(a,b,c);break;case 21:Yj(a,b,c);break;case 22:c.mode&1?(U=(d=U)||null!==\nc.memoizedState,Yj(a,b,c),U=d):Yj(a,b,c);break;default:Yj(a,b,c)}}function ak(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Kj);b.forEach(function(b){var d=bk.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}\nfunction ck(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:X=h.stateNode;Xj=!1;break a;case 3:X=h.stateNode.containerInfo;Xj=!0;break a;case 4:X=h.stateNode.containerInfo;Xj=!0;break a}h=h.return}if(null===X)throw Error(p(160));Zj(f,g,e);X=null;Xj=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null}catch(l){W(e,b,l)}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)dk(b,a),b=b.sibling}\nfunction dk(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:ck(b,a);ek(a);if(d&4){try{Pj(3,a,a.return),Qj(3,a)}catch(t){W(a,a.return,t)}try{Pj(5,a,a.return)}catch(t){W(a,a.return,t)}}break;case 1:ck(b,a);ek(a);d&512&&null!==c&&Lj(c,c.return);break;case 5:ck(b,a);ek(a);d&512&&null!==c&&Lj(c,c.return);if(a.flags&32){var e=a.stateNode;try{ob(e,"")}catch(t){W(a,a.return,t)}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==c?c.memoizedProps:f,h=a.type,k=a.updateQueue;\na.updateQueue=null;if(null!==k)try{"input"===h&&"radio"===f.type&&null!=f.name&&ab(e,f);vb(h,g);var l=vb(h,f);for(g=0;g<k.length;g+=2){var m=k[g],q=k[g+1];"style"===m?sb(e,q):"dangerouslySetInnerHTML"===m?nb(e,q):"children"===m?ob(e,q):ta(e,m,q,l)}switch(h){case "input":bb(e,f);break;case "textarea":ib(e,f);break;case "select":var r=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var y=f.value;null!=y?fb(e,!!f.multiple,y,!1):r!==!!f.multiple&&(null!=f.defaultValue?fb(e,!!f.multiple,\nf.defaultValue,!0):fb(e,!!f.multiple,f.multiple?[]:"",!1))}e[Pf]=f}catch(t){W(a,a.return,t)}}break;case 6:ck(b,a);ek(a);if(d&4){if(null===a.stateNode)throw Error(p(162));e=a.stateNode;f=a.memoizedProps;try{e.nodeValue=f}catch(t){W(a,a.return,t)}}break;case 3:ck(b,a);ek(a);if(d&4&&null!==c&&c.memoizedState.isDehydrated)try{bd(b.containerInfo)}catch(t){W(a,a.return,t)}break;case 4:ck(b,a);ek(a);break;case 13:ck(b,a);ek(a);e=a.child;e.flags&8192&&(f=null!==e.memoizedState,e.stateNode.isHidden=f,!f||\nnull!==e.alternate&&null!==e.alternate.memoizedState||(fk=B()));d&4&&ak(a);break;case 22:m=null!==c&&null!==c.memoizedState;a.mode&1?(U=(l=U)||m,ck(b,a),U=l):ck(b,a);ek(a);if(d&8192){l=null!==a.memoizedState;if((a.stateNode.isHidden=l)&&!m&&0!==(a.mode&1))for(V=a,m=a.child;null!==m;){for(q=V=m;null!==V;){r=V;y=r.child;switch(r.tag){case 0:case 11:case 14:case 15:Pj(4,r,r.return);break;case 1:Lj(r,r.return);var n=r.stateNode;if("function"===typeof n.componentWillUnmount){d=r;c=r.return;try{b=d,n.props=\nb.memoizedProps,n.state=b.memoizedState,n.componentWillUnmount()}catch(t){W(d,c,t)}}break;case 5:Lj(r,r.return);break;case 22:if(null!==r.memoizedState){gk(q);continue}}null!==y?(y.return=r,V=y):gk(q)}m=m.sibling}a:for(m=null,q=a;;){if(5===q.tag){if(null===m){m=q;try{e=q.stateNode,l?(f=e.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(h=q.stateNode,k=q.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty("display")?k.display:null,h.style.display=\nrb("display",g))}catch(t){W(a,a.return,t)}}}else if(6===q.tag){if(null===m)try{q.stateNode.nodeValue=l?"":q.memoizedProps}catch(t){W(a,a.return,t)}}else if((22!==q.tag&&23!==q.tag||null===q.memoizedState||q===a)&&null!==q.child){q.child.return=q;q=q.child;continue}if(q===a)break a;for(;null===q.sibling;){if(null===q.return||q.return===a)break a;m===q&&(m=null);q=q.return}m===q&&(m=null);q.sibling.return=q.return;q=q.sibling}}break;case 19:ck(b,a);ek(a);d&4&&ak(a);break;case 21:break;default:ck(b,\na),ek(a)}}function ek(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Tj(c)){var d=c;break a}c=c.return}throw Error(p(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(ob(e,""),d.flags&=-33);var f=Uj(a);Wj(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Uj(a);Vj(a,h,g);break;default:throw Error(p(161));}}catch(k){W(a,a.return,k)}a.flags&=-3}b&4096&&(a.flags&=-4097)}function hk(a,b,c){V=a;ik(a,b,c)}\nfunction ik(a,b,c){for(var d=0!==(a.mode&1);null!==V;){var e=V,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Jj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||U;h=Jj;var l=U;Jj=g;if((U=k)&&!l)for(V=e;null!==V;)g=V,k=g.child,22===g.tag&&null!==g.memoizedState?jk(e):null!==k?(k.return=g,V=k):jk(e);for(;null!==f;)V=f,ik(f,b,c),f=f.sibling;V=e;Jj=h;U=l}kk(a,b,c)}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,V=f):kk(a,b,c)}}\nfunction kk(a){for(;null!==V;){var b=V;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:U||Qj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!U)if(null===c)d.componentDidMount();else{var e=b.elementType===b.type?c.memoizedProps:Ci(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate)}var f=b.updateQueue;null!==f&&sh(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=\nb.child.stateNode;break;case 1:c=b.child.stateNode}sh(b,g,c)}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case "button":case "input":case "select":case "textarea":k.autoFocus&&c.focus();break;case "img":k.src&&(c.src=k.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var m=l.memoizedState;if(null!==m){var q=m.dehydrated;null!==q&&bd(q)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;\ndefault:throw Error(p(163));}U||b.flags&512&&Rj(b)}catch(r){W(b,b.return,r)}}if(b===a){V=null;break}c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}function gk(a){for(;null!==V;){var b=V;if(b===a){V=null;break}var c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}\nfunction jk(a){for(;null!==V;){var b=V;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Qj(4,b)}catch(k){W(b,c,k)}break;case 1:var d=b.stateNode;if("function"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount()}catch(k){W(b,e,k)}}var f=b.return;try{Rj(b)}catch(k){W(b,f,k)}break;case 5:var g=b.return;try{Rj(b)}catch(k){W(b,g,k)}}}catch(k){W(b,b.return,k)}if(b===a){V=null;break}var h=b.sibling;if(null!==h){h.return=b.return;V=h;break}V=b.return}}\nvar lk=Math.ceil,mk=ua.ReactCurrentDispatcher,nk=ua.ReactCurrentOwner,ok=ua.ReactCurrentBatchConfig,K=0,Q=null,Y=null,Z=0,fj=0,ej=Uf(0),T=0,pk=null,rh=0,qk=0,rk=0,sk=null,tk=null,fk=0,Gj=Infinity,uk=null,Oi=!1,Pi=null,Ri=null,vk=!1,wk=null,xk=0,yk=0,zk=null,Ak=-1,Bk=0;function R(){return 0!==(K&6)?B():-1!==Ak?Ak:Ak=B()}\nfunction yi(a){if(0===(a.mode&1))return 1;if(0!==(K&2)&&0!==Z)return Z&-Z;if(null!==Kg.transition)return 0===Bk&&(Bk=yc()),Bk;a=C;if(0!==a)return a;a=window.event;a=void 0===a?16:jd(a.type);return a}function gi(a,b,c,d){if(50<yk)throw yk=0,zk=null,Error(p(185));Ac(a,c,d);if(0===(K&2)||a!==Q)a===Q&&(0===(K&2)&&(qk|=c),4===T&&Ck(a,Z)),Dk(a,d),1===c&&0===K&&0===(b.mode&1)&&(Gj=B()+500,fg&&jg())}\nfunction Dk(a,b){var c=a.callbackNode;wc(a,b);var d=uc(a,a===Q?Z:0);if(0===d)null!==c&&bc(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&bc(c);if(1===b)0===a.tag?ig(Ek.bind(null,a)):hg(Ek.bind(null,a)),Jf(function(){0===(K&6)&&jg()}),c=null;else{switch(Dc(d)){case 1:c=fc;break;case 4:c=gc;break;case 16:c=hc;break;case 536870912:c=jc;break;default:c=hc}c=Fk(c,Gk.bind(null,a))}a.callbackPriority=b;a.callbackNode=c}}\nfunction Gk(a,b){Ak=-1;Bk=0;if(0!==(K&6))throw Error(p(327));var c=a.callbackNode;if(Hk()&&a.callbackNode!==c)return null;var d=uc(a,a===Q?Z:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Ik(a,d);else{b=d;var e=K;K|=2;var f=Jk();if(Q!==a||Z!==b)uk=null,Gj=B()+500,Kk(a,b);do try{Lk();break}catch(h){Mk(a,h)}while(1);$g();mk.current=f;K=e;null!==Y?b=0:(Q=null,Z=0,b=T)}if(0!==b){2===b&&(e=xc(a),0!==e&&(d=e,b=Nk(a,e)));if(1===b)throw c=pk,Kk(a,0),Ck(a,d),Dk(a,B()),c;if(6===b)Ck(a,d);\nelse{e=a.current.alternate;if(0===(d&30)&&!Ok(e)&&(b=Ik(a,d),2===b&&(f=xc(a),0!==f&&(d=f,b=Nk(a,f))),1===b))throw c=pk,Kk(a,0),Ck(a,d),Dk(a,B()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p(345));case 2:Pk(a,tk,uk);break;case 3:Ck(a,d);if((d&130023424)===d&&(b=fk+500-B(),10<b)){if(0!==uc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){R();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Ff(Pk.bind(null,a,tk,uk),b);break}Pk(a,tk,uk);break;case 4:Ck(a,d);if((d&4194240)===\nd)break;b=a.eventTimes;for(e=-1;0<d;){var g=31-oc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f}d=e;d=B()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*lk(d/1960))-d;if(10<d){a.timeoutHandle=Ff(Pk.bind(null,a,tk,uk),d);break}Pk(a,tk,uk);break;case 5:Pk(a,tk,uk);break;default:throw Error(p(329));}}}Dk(a,B());return a.callbackNode===c?Gk.bind(null,a):null}\nfunction Nk(a,b){var c=sk;a.current.memoizedState.isDehydrated&&(Kk(a,b).flags|=256);a=Ik(a,b);2!==a&&(b=tk,tk=c,null!==b&&Fj(b));return a}function Fj(a){null===tk?tk=a:tk.push.apply(tk,a)}\nfunction Ok(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!He(f(),e))return!1}catch(g){return!1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else{if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return!0;b=b.return}b.sibling.return=b.return;b=b.sibling}}return!0}\nfunction Ck(a,b){b&=~rk;b&=~qk;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-oc(b),d=1<<c;a[c]=-1;b&=~d}}function Ek(a){if(0!==(K&6))throw Error(p(327));Hk();var b=uc(a,0);if(0===(b&1))return Dk(a,B()),null;var c=Ik(a,b);if(0!==a.tag&&2===c){var d=xc(a);0!==d&&(b=d,c=Nk(a,d))}if(1===c)throw c=pk,Kk(a,0),Ck(a,b),Dk(a,B()),c;if(6===c)throw Error(p(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Pk(a,tk,uk);Dk(a,B());return null}\nfunction Qk(a,b){var c=K;K|=1;try{return a(b)}finally{K=c,0===K&&(Gj=B()+500,fg&&jg())}}function Rk(a){null!==wk&&0===wk.tag&&0===(K&6)&&Hk();var b=K;K|=1;var c=ok.transition,d=C;try{if(ok.transition=null,C=1,a)return a()}finally{C=d,ok.transition=c,K=b,0===(K&6)&&jg()}}function Hj(){fj=ej.current;E(ej)}\nfunction Kk(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Gf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;wg(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&$f();break;case 3:zh();E(Wf);E(H);Eh();break;case 5:Bh(d);break;case 4:zh();break;case 13:E(L);break;case 19:E(L);break;case 10:ah(d.type._context);break;case 22:case 23:Hj()}c=c.return}Q=a;Y=a=Pg(a.current,null);Z=fj=b;T=0;pk=null;rk=qk=rh=0;tk=sk=null;if(null!==fh){for(b=\n0;b<fh.length;b++)if(c=fh[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g}c.pending=d}fh=null}return a}\nfunction Mk(a,b){do{var c=Y;try{$g();Fh.current=Rh;if(Ih){for(var d=M.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}Ih=!1}Hh=0;O=N=M=null;Jh=!1;Kh=0;nk.current=null;if(null===c||null===c.return){T=1;pk=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Z;h.flags|=32768;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k,m=h,q=m.tag;if(0===(m.mode&1)&&(0===q||11===q||15===q)){var r=m.alternate;r?(m.updateQueue=r.updateQueue,m.memoizedState=r.memoizedState,\nm.lanes=r.lanes):(m.updateQueue=null,m.memoizedState=null)}var y=Ui(g);if(null!==y){y.flags&=-257;Vi(y,g,h,f,b);y.mode&1&&Si(f,l,b);b=y;k=l;var n=b.updateQueue;if(null===n){var t=new Set;t.add(k);b.updateQueue=t}else n.add(k);break a}else{if(0===(b&1)){Si(f,l,b);tj();break a}k=Error(p(426))}}else if(I&&h.mode&1){var J=Ui(g);if(null!==J){0===(J.flags&65536)&&(J.flags|=256);Vi(J,g,h,f,b);Jg(Ji(k,h));break a}}f=k=Ji(k,h);4!==T&&(T=2);null===sk?sk=[f]:sk.push(f);f=g;do{switch(f.tag){case 3:f.flags|=65536;\nb&=-b;f.lanes|=b;var x=Ni(f,k,b);ph(f,x);break a;case 1:h=k;var w=f.type,u=f.stateNode;if(0===(f.flags&128)&&("function"===typeof w.getDerivedStateFromError||null!==u&&"function"===typeof u.componentDidCatch&&(null===Ri||!Ri.has(u)))){f.flags|=65536;b&=-b;f.lanes|=b;var F=Qi(f,h,b);ph(f,F);break a}}f=f.return}while(null!==f)}Sk(c)}catch(na){b=na;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}function Jk(){var a=mk.current;mk.current=Rh;return null===a?Rh:a}\nfunction tj(){if(0===T||3===T||2===T)T=4;null===Q||0===(rh&268435455)&&0===(qk&268435455)||Ck(Q,Z)}function Ik(a,b){var c=K;K|=2;var d=Jk();if(Q!==a||Z!==b)uk=null,Kk(a,b);do try{Tk();break}catch(e){Mk(a,e)}while(1);$g();K=c;mk.current=d;if(null!==Y)throw Error(p(261));Q=null;Z=0;return T}function Tk(){for(;null!==Y;)Uk(Y)}function Lk(){for(;null!==Y&&!cc();)Uk(Y)}function Uk(a){var b=Vk(a.alternate,a,fj);a.memoizedProps=a.pendingProps;null===b?Sk(a):Y=b;nk.current=null}\nfunction Sk(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Ej(c,b,fj),null!==c){Y=c;return}}else{c=Ij(c,b);if(null!==c){c.flags&=32767;Y=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{T=6;Y=null;return}}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===T&&(T=5)}function Pk(a,b,c){var d=C,e=ok.transition;try{ok.transition=null,C=1,Wk(a,b,c,d)}finally{ok.transition=e,C=d}return null}\nfunction Wk(a,b,c,d){do Hk();while(null!==wk);if(0!==(K&6))throw Error(p(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(p(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Bc(a,f);a===Q&&(Y=Q=null,Z=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||vk||(vk=!0,Fk(hc,function(){Hk();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=ok.transition;ok.transition=null;\nvar g=C;C=1;var h=K;K|=4;nk.current=null;Oj(a,c);dk(c,a);Oe(Df);dd=!!Cf;Df=Cf=null;a.current=c;hk(c,a,e);dc();K=h;C=g;ok.transition=f}else a.current=c;vk&&(vk=!1,wk=a,xk=e);f=a.pendingLanes;0===f&&(Ri=null);mc(c.stateNode,d);Dk(a,B());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)e=b[c],d(e.value,{componentStack:e.stack,digest:e.digest});if(Oi)throw Oi=!1,a=Pi,Pi=null,a;0!==(xk&1)&&0!==a.tag&&Hk();f=a.pendingLanes;0!==(f&1)?a===zk?yk++:(yk=0,zk=a):yk=0;jg();return null}\nfunction Hk(){if(null!==wk){var a=Dc(xk),b=ok.transition,c=C;try{ok.transition=null;C=16>a?16:a;if(null===wk)var d=!1;else{a=wk;wk=null;xk=0;if(0!==(K&6))throw Error(p(331));var e=K;K|=4;for(V=a.current;null!==V;){var f=V,g=f.child;if(0!==(V.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(V=l;null!==V;){var m=V;switch(m.tag){case 0:case 11:case 15:Pj(8,m,f)}var q=m.child;if(null!==q)q.return=m,V=q;else for(;null!==V;){m=V;var r=m.sibling,y=m.return;Sj(m);if(m===\nl){V=null;break}if(null!==r){r.return=y;V=r;break}V=y}}}var n=f.alternate;if(null!==n){var t=n.child;if(null!==t){n.child=null;do{var J=t.sibling;t.sibling=null;t=J}while(null!==t)}}V=f}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,V=g;else b:for(;null!==V;){f=V;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Pj(9,f,f.return)}var x=f.sibling;if(null!==x){x.return=f.return;V=x;break b}V=f.return}}var w=a.current;for(V=w;null!==V;){g=V;var u=g.child;if(0!==(g.subtreeFlags&2064)&&null!==\nu)u.return=g,V=u;else b:for(g=w;null!==V;){h=V;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Qj(9,h)}}catch(na){W(h,h.return,na)}if(h===g){V=null;break b}var F=h.sibling;if(null!==F){F.return=h.return;V=F;break b}V=h.return}}K=e;jg();if(lc&&"function"===typeof lc.onPostCommitFiberRoot)try{lc.onPostCommitFiberRoot(kc,a)}catch(na){}d=!0}return d}finally{C=c,ok.transition=b}}return!1}function Xk(a,b,c){b=Ji(c,b);b=Ni(a,b,1);a=nh(a,b,1);b=R();null!==a&&(Ac(a,1,b),Dk(a,b))}\nfunction W(a,b,c){if(3===a.tag)Xk(a,a,c);else for(;null!==b;){if(3===b.tag){Xk(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if("function"===typeof b.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Ri||!Ri.has(d))){a=Ji(c,a);a=Qi(b,a,1);b=nh(b,a,1);a=R();null!==b&&(Ac(b,1,a),Dk(b,a));break}}b=b.return}}\nfunction Ti(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=R();a.pingedLanes|=a.suspendedLanes&c;Q===a&&(Z&c)===c&&(4===T||3===T&&(Z&130023424)===Z&&500>B()-fk?Kk(a,0):rk|=c);Dk(a,b)}function Yk(a,b){0===b&&(0===(a.mode&1)?b=1:(b=sc,sc<<=1,0===(sc&130023424)&&(sc=4194304)));var c=R();a=ih(a,b);null!==a&&(Ac(a,b,c),Dk(a,c))}function uj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Yk(a,c)}\nfunction bk(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p(314));}null!==d&&d.delete(b);Yk(a,c)}var Vk;\nVk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Wf.current)dh=!0;else{if(0===(a.lanes&c)&&0===(b.flags&128))return dh=!1,yj(a,b,c);dh=0!==(a.flags&131072)?!0:!1}else dh=!1,I&&0!==(b.flags&1048576)&&ug(b,ng,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;ij(a,b);a=b.pendingProps;var e=Yf(b,H.current);ch(b,c);e=Nh(null,b,d,a,e,c);var f=Sh();b.flags|=1;"object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof?(b.tag=1,b.memoizedState=null,b.updateQueue=\nnull,Zf(d)?(f=!0,cg(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,kh(b),e.updater=Ei,b.stateNode=e,e._reactInternals=b,Ii(b,d,a,c),b=jj(null,b,d,!0,f,c)):(b.tag=0,I&&f&&vg(b),Xi(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{ij(a,b);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=Zk(d);a=Ci(d,a);switch(e){case 0:b=cj(null,b,d,a,c);break a;case 1:b=hj(null,b,d,a,c);break a;case 11:b=Yi(null,b,d,a,c);break a;case 14:b=$i(null,b,d,Ci(d.type,a),c);break a}throw Error(p(306,\nd,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),cj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),hj(a,b,d,e,c);case 3:a:{kj(b);if(null===a)throw Error(p(387));d=b.pendingProps;f=b.memoizedState;e=f.element;lh(a,b);qh(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:!1,cache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=\nf,b.memoizedState=f,b.flags&256){e=Ji(Error(p(423)),b);b=lj(a,b,d,c,e);break a}else if(d!==e){e=Ji(Error(p(424)),b);b=lj(a,b,d,c,e);break a}else for(yg=Lf(b.stateNode.containerInfo.firstChild),xg=b,I=!0,zg=null,c=Vg(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else{Ig();if(d===e){b=Zi(a,b,c);break a}Xi(a,b,d,c)}b=b.child}return b;case 5:return Ah(b),null===a&&Eg(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ef(d,e)?g=null:null!==f&&Ef(d,f)&&(b.flags|=32),\ngj(a,b),Xi(a,b,g,c),b.child;case 6:return null===a&&Eg(b),null;case 13:return oj(a,b,c);case 4:return yh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Ug(b,null,d,c):Xi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),Yi(a,b,d,e,c);case 7:return Xi(a,b,b.pendingProps,c),b.child;case 8:return Xi(a,b,b.pendingProps.children,c),b.child;case 12:return Xi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;\ng=e.value;G(Wg,d._currentValue);d._currentValue=g;if(null!==f)if(He(f.value,g)){if(f.children===e.children&&!Wf.current){b=Zi(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=mh(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);l.pending=k}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);bh(f.return,\nc,b);h.lanes|=c;break}k=k.next}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);bh(g,c,b);g=f.sibling}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return}f=g}Xi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,d=b.pendingProps.children,ch(b,c),e=eh(e),d=d(e),b.flags|=1,Xi(a,b,d,c),\nb.child;case 14:return d=b.type,e=Ci(d,b.pendingProps),e=Ci(d.type,e),$i(a,b,d,e,c);case 15:return bj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),ij(a,b),b.tag=1,Zf(d)?(a=!0,cg(b)):a=!1,ch(b,c),Gi(b,d,e),Ii(b,d,e,c),jj(null,b,d,!0,a,c);case 19:return xj(a,b,c);case 22:return dj(a,b,c)}throw Error(p(156,b.tag));};function Fk(a,b){return ac(a,b)}\nfunction $k(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null}function Bg(a,b,c,d){return new $k(a,b,c,d)}function aj(a){a=a.prototype;return!(!a||!a.isReactComponent)}\nfunction Zk(a){if("function"===typeof a)return aj(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Da)return 11;if(a===Ga)return 14}return 2}\nfunction Pg(a,b){var c=a.alternate;null===c?(c=Bg(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};\nc.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}\nfunction Rg(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)aj(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ya:return Tg(c.children,e,f,b);case za:g=8;e|=8;break;case Aa:return a=Bg(12,c,b,e|2),a.elementType=Aa,a.lanes=f,a;case Ea:return a=Bg(13,c,b,e),a.elementType=Ea,a.lanes=f,a;case Fa:return a=Bg(19,c,b,e),a.elementType=Fa,a.lanes=f,a;case Ia:return pj(c,e,f,b);default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Ba:g=10;break a;case Ca:g=9;break a;case Da:g=11;\nbreak a;case Ga:g=14;break a;case Ha:g=16;d=null;break a}throw Error(p(130,null==a?a:typeof a,""));}b=Bg(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Tg(a,b,c,d){a=Bg(7,a,d,b);a.lanes=c;return a}function pj(a,b,c,d){a=Bg(22,a,d,b);a.elementType=Ia;a.lanes=c;a.stateNode={isHidden:!1};return a}function Qg(a,b,c){a=Bg(6,a,null,b);a.lanes=c;return a}\nfunction Sg(a,b,c){b=Bg(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}\nfunction al(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=zc(0);this.expirationTimes=zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=zc(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=\nnull}function bl(a,b,c,d,e,f,g,h,k){a=new al(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=Bg(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};kh(f);return a}function cl(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:wa,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}\nfunction dl(a){if(!a)return Vf;a=a._reactInternals;a:{if(Vb(a)!==a||1!==a.tag)throw Error(p(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Zf(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return}while(null!==b);throw Error(p(171));}if(1===a.tag){var c=a.type;if(Zf(c))return bg(a,c,b)}return b}\nfunction el(a,b,c,d,e,f,g,h,k){a=bl(c,d,!0,a,e,f,g,h,k);a.context=dl(null);c=a.current;d=R();e=yi(c);f=mh(d,e);f.callback=void 0!==b&&null!==b?b:null;nh(c,f,e);a.current.lanes=e;Ac(a,e,d);Dk(a,d);return a}function fl(a,b,c,d){var e=b.current,f=R(),g=yi(e);c=dl(c);null===b.context?b.context=c:b.pendingContext=c;b=mh(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);a=nh(e,b,g);null!==a&&(gi(a,e,g,f),oh(a,e,g));return g}\nfunction gl(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function hl(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function il(a,b){hl(a,b);(a=a.alternate)&&hl(a,b)}function jl(){return null}var kl="function"===typeof reportError?reportError:function(a){console.error(a)};function ll(a){this._internalRoot=a}\nml.prototype.render=ll.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p(409));fl(a,b,null,null)};ml.prototype.unmount=ll.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Rk(function(){fl(null,a,null,null)});b[uf]=null}};function ml(a){this._internalRoot=a}\nml.prototype.unstable_scheduleHydration=function(a){if(a){var b=Hc();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Qc.length&&0!==b&&b<Qc[c].priority;c++);Qc.splice(c,0,a);0===c&&Vc(a)}};function nl(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function ol(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function pl(){}\nfunction ql(a,b,c,d,e){if(e){if("function"===typeof d){var f=d;d=function(){var a=gl(g);f.call(a)}}var g=el(b,d,a,0,null,!1,!1,"",pl);a._reactRootContainer=g;a[uf]=g.current;sf(8===a.nodeType?a.parentNode:a);Rk();return g}for(;e=a.lastChild;)a.removeChild(e);if("function"===typeof d){var h=d;d=function(){var a=gl(k);h.call(a)}}var k=bl(a,0,!1,null,null,!1,!1,"",pl);a._reactRootContainer=k;a[uf]=k.current;sf(8===a.nodeType?a.parentNode:a);Rk(function(){fl(b,k,c,d)});return k}\nfunction rl(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if("function"===typeof e){var h=e;e=function(){var a=gl(g);h.call(a)}}fl(b,g,a,e)}else g=ql(c,b,a,e,d);return gl(g)}Ec=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=tc(b.pendingLanes);0!==c&&(Cc(b,c|1),Dk(b,B()),0===(K&6)&&(Gj=B()+500,jg()))}break;case 13:Rk(function(){var b=ih(a,1);if(null!==b){var c=R();gi(b,a,1,c)}}),il(a,1)}};\nFc=function(a){if(13===a.tag){var b=ih(a,134217728);if(null!==b){var c=R();gi(b,a,134217728,c)}il(a,134217728)}};Gc=function(a){if(13===a.tag){var b=yi(a),c=ih(a,b);if(null!==c){var d=R();gi(c,a,b,d)}il(a,b)}};Hc=function(){return C};Ic=function(a,b){var c=C;try{return C=a,b()}finally{C=c}};\nyb=function(a,b,c){switch(b){case "input":bb(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+\'][type="radio"]\');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(p(90));Wa(d);bb(d,e)}}}break;case "textarea":ib(a,c);break;case "select":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Qk;Hb=Rk;\nvar sl={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Qk]},tl={findFiberByHostInstance:Wc,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"};\nvar ul={bundleType:tl.bundleType,version:tl.version,rendererPackageName:tl.rendererPackageName,rendererConfig:tl.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Zb(a);return null===a?null:a.stateNode},findFiberByHostInstance:tl.findFiberByHostInstance||\njl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var vl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl.isDisabled&&vl.supportsFiber)try{kc=vl.inject(ul),lc=vl}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl;\nexports.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!nl(b))throw Error(p(200));return cl(a,b,null,c)};exports.createRoot=function(a,b){if(!nl(a))throw Error(p(299));var c=!1,d="",e=kl;null!==b&&void 0!==b&&(!0===b.unstable_strictMode&&(c=!0),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=bl(a,1,!1,null,null,c,!1,d,e);a[uf]=b.current;sf(8===a.nodeType?a.parentNode:a);return new ll(b)};\nexports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(p(188));a=Object.keys(a).join(",");throw Error(p(268,a));}a=Zb(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a){return Rk(a)};exports.hydrate=function(a,b,c){if(!ol(b))throw Error(p(200));return rl(null,a,b,!0,c)};\nexports.hydrateRoot=function(a,b,c){if(!nl(a))throw Error(p(405));var d=null!=c&&c.hydratedSources||null,e=!1,f="",g=kl;null!==c&&void 0!==c&&(!0===c.unstable_strictMode&&(e=!0),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=el(b,null,a,1,null!=c?c:null,e,!1,f,g);a[uf]=b.current;sf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,\ne);return new ml(b)};exports.render=function(a,b,c){if(!ol(b))throw Error(p(200));return rl(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!ol(a))throw Error(p(40));return a._reactRootContainer?(Rk(function(){rl(null,null,a,!1,function(){a._reactRootContainer=null;a[uf]=null})}),!0):!1};exports.unstable_batchedUpdates=Qk;\nexports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!ol(c))throw Error(p(200));if(null==a||void 0===a._reactInternals)throw Error(p(38));return rl(a,b,c,!1,d)};exports.version="18.3.1-next-f1338f8080-20240426";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhLE9BQU8sbUJBQU8sQ0FBQyxHQUFPLEtBQUssbUJBQU8sQ0FBQyxHQUFXLEVBQUUsY0FBYyx5RUFBeUUsbUJBQW1CLG1EQUFtRCxvQ0FBb0MsMkhBQTJILHFCQUFxQixpQkFBaUIsUUFBUTtBQUN2YSxpQkFBaUIsUUFBUSxRQUFRLFdBQVc7QUFDNUM7QUFDQSxFQUFFLE9BQU8sZUFBZSwwQkFBMEIsMEJBQTBCLDhCQUE4QixTQUFTLFNBQVMscUJBQXFCLGlDQUFpQyxpQkFBaUIsdUNBQXVDLDZCQUE2QixxQ0FBcUMsNkJBQTZCLCtCQUErQjtBQUN4VyxxQkFBcUIsMERBQTBELGNBQWMsMkJBQTJCLGdCQUFnQixvQkFBb0IsdUJBQXVCLDRCQUE0QixTQUFTLDBCQUEwQix5Q0FBeUMscUJBQXFCLDBCQUEwQix1QkFBdUIsb0JBQW9CLFlBQVksbUJBQW1CLHlCQUF5QjtBQUM3YSxzS0FBc0ssZ0NBQWdDLEVBQUUsNEhBQTRILFdBQVcsbUNBQW1DLEVBQUUseUVBQXlFLDhDQUE4QztBQUMzZSw0RkFBNEYsZ0NBQWdDLEVBQUUsNlFBQTZRLDhDQUE4QztBQUN6Yiw4REFBOEQsZ0NBQWdDLEVBQUUsMkNBQTJDLGdDQUFnQyxFQUFFLGtEQUFrRCxnQ0FBZ0MsRUFBRSx3Q0FBd0MsOENBQThDLEVBQUUsdUJBQXVCLGVBQWU7QUFDL1gseWxDQUF5bEM7QUFDemxDLElBQUksZ0NBQWdDLEVBQUUsMEdBQTBHLHVCQUF1QiwwREFBMEQsRUFBRSx3REFBd0QsdUJBQXVCLGtFQUFrRSxFQUFFLCtDQUErQyw4Q0FBOEM7QUFDbmQsc0ZBQXNGLHlEQUF5RCw4Q0FBOEM7QUFDN0wscUJBQXFCLG9DQUFvQztBQUN6RCw0YkFBNGIsMEJBQTBCO0FBQ3RkLHFDQUFxQyxrQ0FBa0MsMEJBQTBCLG1DQUFtQyx1QkFBdUIsZUFBZSw2Q0FBNkMsNkJBQTZCLG1DQUFtQyx1QkFBdUIsZUFBZSxtQkFBbUIsZUFBZSxTQUFTLDJDQUEyQyxlQUFlLGdCQUFnQjtBQUNsYixpQkFBaUIsbUJBQW1CLE1BQU0sOEJBQThCLCtCQUErQixJQUFJLHFCQUFxQixlQUFlLDRDQUE0QyxlQUFlLGdCQUFnQixnREFBZ0QsSUFBSSx3QkFBd0IsU0FBUyxRQUFRLDBCQUEwQixLQUFLLElBQUksU0FBUyxTQUFTLElBQUksb0JBQW9CLEtBQUssSUFBSSxlQUFlLFNBQVMsSUFBSSxLQUFLLFNBQVMsb0NBQW9DO0FBQzNkLGdEQUFnRCx3QkFBd0IsS0FBSyxLQUFLLFdBQVcsd0JBQXdCLGlCQUFpQixnQ0FBZ0MsMkNBQTJDLHFGQUFxRixTQUFTLGtCQUFrQixRQUFRLFFBQVEsZ0NBQWdDO0FBQ2pYLGVBQWUsY0FBYyx5QkFBeUIsMEJBQTBCLDhCQUE4QixrQ0FBa0MsK0NBQStDLHdDQUF3QyxnQ0FBZ0M7QUFDdlEsZUFBZSx1QkFBdUIsNERBQTRELGdDQUFnQyxVQUFVLHlCQUF5Qix1QkFBdUIseUJBQXlCLDJCQUEyQix5QkFBeUIsNkJBQTZCLDBDQUEwQyxxREFBcUQsOERBQThELHVCQUF1QixnQkFBZ0I7QUFDMWUsc0RBQXNELFNBQVMsbUVBQW1FLHFCQUFxQixVQUFVLElBQUksZ0JBQWdCLFdBQVc7QUFDaE0sZUFBZSxhQUFhLGNBQWMsc0JBQXNCLG9EQUFvRCw4REFBOEQsbUNBQW1DLCtHQUErRyx3QkFBd0IsZ0JBQWdCLHNCQUFzQixvQkFBb0Isb0JBQW9CLHFCQUFxQix5Q0FBeUM7QUFDeGUseUJBQXlCLHNCQUFzQix5QkFBeUIsNkJBQTZCLDhCQUE4Qix5R0FBeUcsZ0NBQWdDLFlBQVksZUFBZSxpQkFBaUIscUVBQXFFLHVCQUF1QjtBQUNwWixlQUFlLGFBQWE7QUFDNUIsZUFBZSxxR0FBcUcsdUdBQXVHLG9CQUFvQiwyQkFBMkIsK0JBQStCLG9CQUFvQixpQkFBaUIsT0FBTyxnQkFBZ0IsRUFBRSwyQkFBMkIsd0JBQXdCLEVBQUUsT0FBTyxvQkFBb0IsU0FBUyxzQkFBc0IsT0FBTyx5QkFBeUI7QUFDdGYsS0FBSyxlQUFlLGVBQWUseUNBQXlDLGVBQWUsZUFBZSxzQkFBc0IsZUFBZSxtQkFBbUIsU0FBUyw4Q0FBOEMsSUFBSSxtQ0FBbUMsZUFBZSxxREFBcUQsc0NBQXNDLElBQUksK0JBQStCLFNBQVM7QUFDdFosaUJBQWlCLGdCQUFnQixXQUFXLElBQUksd0dBQXdHLEVBQUUsaUJBQWlCLDBGQUEwRiw4QkFBOEIsaUJBQWlCLGdIQUFnSCxpQkFBaUIsWUFBWTtBQUNqYyxpQkFBaUIsUUFBUSwyQkFBMkIsNEJBQTRCLGdEQUFnRCxvQ0FBb0MsbUNBQW1DLDJCQUEyQixPQUFPLDJHQUEyRztBQUNwVixtQkFBbUIsZ0VBQWdFLGFBQWEseUVBQXlFLGtDQUFrQyw0QkFBNEIsaUJBQWlCLFNBQVMsb0JBQW9CLGtEQUFrRDtBQUN2VSxtQkFBbUIsNklBQTZJO0FBQ2hLLHFCQUFxQixZQUFZLE1BQU0sS0FBSyxZQUFZLFdBQVcsbUJBQW1CLFFBQVEsV0FBVyw0R0FBNEcsS0FBSyxXQUFXLE9BQU8sUUFBUSxXQUFXLEtBQUssbUJBQW1CLGlCQUFpQiw2QkFBNkIsT0FBTyxrQ0FBa0M7QUFDOVcsaUJBQWlCLHNEQUFzRCxXQUFXLElBQUksMEVBQTBFLEVBQUUsaUJBQWlCLGNBQWMsWUFBWSxhQUFhLGlCQUFpQixZQUFZLDhCQUE4QixVQUFVLGlDQUFpQyxPQUFPLElBQUksZ0JBQWdCLElBQUksaUJBQWlCO0FBQ2hYLGlCQUFpQix1Q0FBdUMsd0dBQXdHLCtCQUErQixlQUFlLG9CQUFvQixnRUFBZ0UsZUFBZSxVQUFVLDhDQUE4Qyx1REFBdUQ7QUFDaGEsaUJBQWlCO0FBQ2pCLHNCQUFzQixrRkFBa0YseUNBQXlDLGtCQUFrQixFQUFFLEdBQUcsZUFBZSxnRkFBZ0YsS0FBSyxxQ0FBcUMscURBQXFELG9CQUFvQixhQUFhLDZCQUE2QixLQUFLLGFBQWEsOEJBQThCO0FBQ3BkLGlCQUFpQixNQUFNLG1CQUFtQix1Q0FBdUMsY0FBYyxRQUFRO0FBQ3ZHLFFBQVE7QUFDUixpSkFBaUosOEJBQThCLG9DQUFvQyx1QkFBdUIsNkNBQTZDLFlBQVksRUFBRSxFQUFFLG1CQUFtQjtBQUMxVCxpQkFBaUIsVUFBVSx1Q0FBdUMseUNBQXlDLDRCQUE0Qiw2QkFBNkIsVUFBVSxZQUFZLEVBQUUseUhBQXlIO0FBQ3JULGlCQUFpQixNQUFNLG9GQUFvRixvQ0FBb0MsdUNBQXVDLDRHQUE0RztBQUNsUyxpQkFBaUIsb0RBQW9ELFVBQVUsa0xBQWtMLGtCQUFrQixZQUFZLGVBQWUsaUNBQWlDLHlEQUF5RCxxQ0FBcUM7QUFDN2EsZUFBZSxZQUFZLDhDQUE4QyxrQkFBa0IsdUNBQXVDLGVBQWUsNkJBQTZCLGNBQWMsT0FBTyxjQUFjLFdBQVcsTUFBTSxhQUFhLFdBQVcsY0FBYyxpQkFBaUIsWUFBWSxlQUFlLFVBQVUsbUJBQW1CLG9CQUFvQixNQUFNLElBQUksaUJBQWlCLFFBQVE7QUFDeFksaUJBQWlCLGtCQUFrQix3QkFBd0IsWUFBWSx3QkFBd0IsT0FBTyxZQUFZLHNVQUFzVSxLQUFLLFFBQVEsYUFBYSxpQkFBaUI7QUFDbmUsd0NBQXdDLFNBQVMsVUFBVSxVQUFVLFVBQVUsb0NBQW9DLGVBQWUsT0FBTyxFQUFFLHNDQUFzQyx5Q0FBeUMsU0FBUyxNQUFNLCtCQUErQiw4Q0FBOEMsSUFBSSxhQUFhLFNBQVMsaUJBQWlCLG9DQUFvQyxvQkFBb0IsTUFBTSxPQUFPLCtCQUErQixNQUFNLFFBQVE7QUFDbmQsK0JBQStCLHlCQUF5QixPQUFPLE9BQU8sU0FBUyxNQUFNLFFBQVEseUJBQXlCLGtCQUFrQixlQUFlLFlBQVksb0JBQW9CLFNBQVMsWUFBWSxLQUFLLElBQUksbURBQW1ELFNBQVMsd0JBQXdCLGVBQWUsZUFBZSxzQkFBc0Isd0RBQXdELGdDQUFnQyxZQUFZLGVBQWU7QUFDaGQsZUFBZSxrQkFBa0IsT0FBTyxRQUFRLGdDQUFnQyxvQkFBb0IsaUJBQWlCLEVBQUUsZUFBZSxrQkFBa0Isa0JBQWtCLGFBQWEsV0FBVyxhQUFhLElBQUksU0FBUyxNQUFNLHNCQUFzQixjQUFjLEVBQUUsRUFBRSx3QkFBd0Isd0JBQXdCLFlBQVkscUJBQXFCLCtCQUErQixLQUFLLHVCQUF1QixFQUFFLEVBQUUsVUFBVSxLQUFLLElBQUksSUFBSSxNQUFNLFVBQVUsS0FBSyxJQUFJLElBQUksTUFBTSxZQUFZLE9BQU8sY0FBYyxFQUFFLEVBQUU7QUFDemYsR0FBRyxLQUFLLElBQUksSUFBSSxNQUFNLFVBQVUsS0FBSyxJQUFJLElBQUksTUFBTSxZQUFZLDRCQUE0Qix3Q0FBd0MsaUNBQWlDLG1DQUFtQyxlQUFlLFFBQVEsMkJBQTJCLGVBQWUsaUNBQWlDLGNBQWMsU0FBUyxFQUFFLFlBQVkscUJBQXFCLFlBQVk7QUFDL1csNFZBQTRWLGVBQWUsb0RBQW9ELDhEQUE4RDtBQUM3ZCx3REFBd0QsZUFBZSxPQUFPLGtDQUFrQztBQUNoSCxlQUFlLGFBQWEsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGtCQUFrQixrQkFBa0IsMkxBQTJMLHVGQUF1RixnQ0FBZ0MsZ0NBQWdDLGdDQUFnQztBQUNsZixrQkFBa0IsaUJBQWlCLHFCQUFxQixrQkFBa0IseURBQXlELFVBQVUsV0FBVyxzQ0FBc0MsMkNBQTJDLGtCQUFrQixtRkFBbUYscUJBQXFCLG1CQUFtQixvQ0FBb0MsSUFBSSxpQ0FBaUM7QUFDL2IsaUJBQWlCLFVBQVUsa0NBQWtDLDhNQUE4TSw2RUFBNkUsc0VBQXNFO0FBQzlaLGlCQUFpQixnRkFBZ0YsSUFBSSxFQUFFLDZCQUE2QixXQUFXLHFDQUFxQywrQkFBK0IsT0FBTyxlQUFlLDZCQUE2Qix5Q0FBeUMsY0FBYyxTQUFTLE9BQU8sMEJBQTBCLFNBQVMsZUFBZSxpQkFBaUIsS0FBSyxjQUFjO0FBQ25hLG1CQUFtQixrQkFBa0Isb0RBQW9ELGVBQWUsV0FBVyxPQUFPLGlCQUFpQix3QkFBd0IsaUJBQWlCLG1CQUFtQixnQkFBZ0Isa0JBQWtCLHNCQUFzQixvQkFBb0Isa0JBQWtCLG1CQUFtQix3QkFBd0IsSUFBSSxFQUFFLHNCQUFzQixPQUFPLFFBQVEsUUFBUTtBQUNuWSxpQkFBaUIsMEJBQTBCLHNCQUFzQixFQUFFLEVBQUUsc0JBQXNCLHNCQUFzQixPQUFPLFFBQVEsZUFBZSxNQUFNLGtEQUFrRDtBQUN2TSxpQkFBaUIsVUFBVSx1Q0FBdUMsTUFBTSwwQ0FBMEMsTUFBTSx5Q0FBeUMsTUFBTSw0REFBNEQsTUFBTTtBQUN6Tyx5QkFBeUIseUNBQXlDLGlGQUFpRix1Q0FBdUMsc0JBQXNCLHFCQUFxQix1Q0FBdUM7QUFDNVEsdUJBQXVCLFVBQVUsNkNBQTZDLCtDQUErQywrQ0FBK0MscUNBQXFDLHdDQUF3QyxTQUFTLHlGQUF5RjtBQUMzVixlQUFlLG1CQUFtQixhQUFhLFlBQVksK0JBQStCLHFCQUFxQixjQUFjLHlCQUF5QixNQUFNLEVBQUUsUUFBUSwrREFBK0QscURBQXFELFFBQVE7QUFDbFMsZUFBZSwrQkFBK0IsNkJBQTZCLFdBQVcsRUFBRSwrREFBK0QsYUFBYSxnQkFBZ0Isa0NBQWtDLEtBQUssMEJBQTBCLFFBQVEscURBQXFELFVBQVUsU0FBUyxtQkFBbUIsbUJBQW1CLGNBQWMsTUFBTSw2QkFBNkIsNkJBQTZCLDZCQUE2QixlQUFlO0FBQ3JlLGlCQUFpQjtBQUNqQixlQUFlLGNBQWMsZUFBZSxnQkFBZ0IsWUFBWSxZQUFZLFlBQVksS0FBSyxZQUFZLHFDQUFxQyxvQkFBb0Isb0JBQW9CLG9CQUFvQixjQUFjLGNBQWMsUUFBUSxZQUFZLGdEQUFnRCxLQUFLLDBDQUEwQyxzQ0FBc0M7QUFDdlkscUJBQXFCLHdCQUF3QixtQkFBbUIsSUFBSSxnQkFBZ0IsUUFBUSxxQkFBcUIscUJBQXFCLHdCQUF3QixtQkFBbUIsSUFBSSxnQkFBZ0IsUUFBUTtBQUM3TSxxQkFBcUIsT0FBTyxrQkFBa0IsbUNBQW1DLDBDQUEwQyx1Q0FBdUMsS0FBSyxTQUFTLEVBQUUsWUFBWSxnQkFBZ0IsY0FBYyx5QkFBeUIsZUFBZSxJQUFJLDhCQUE4Qix1QkFBdUI7QUFDN1QscUJBQXFCLFFBQVEsUUFBUSxRQUFRLHVDQUF1Qyx3QkFBd0IsUUFBUSxxQkFBcUIsT0FBTyxlQUFlLGtHQUFrRyxPQUFPLHFCQUFxQixLQUFLO0FBQ2xTLGVBQWUsVUFBVSxzMEJBQXMwQjtBQUMvMUIsNEJBQTRCLGlCQUFpQixpQkFBaUIsMEJBQTBCLHlCQUF5QixrQkFBa0IsbUJBQW1CLDRCQUE0QixjQUFjLGdCQUFnQiwwRUFBMEUsUUFBUSxpQkFBaUIsS0FBSyxVQUFVLFFBQVEsc0JBQXNCLEtBQUs7QUFDclcsZUFBZSxnQkFBZ0Isd0RBQXdELGVBQWUseUJBQXlCLGNBQWMsU0FBUyxjQUFjO0FBQ3BLLGVBQWUsc0JBQXNCLGtCQUFrQixtQkFBbUIsWUFBWSxtQkFBbUIsY0FBYyx3QkFBd0IsaUVBQWlFLCtGQUErRiw2QkFBNkIsWUFBWSxlQUFlLDBCQUEwQix5QkFBeUIsdUJBQXVCO0FBQ2piLCtDQUErQyw0QkFBNEIsdUJBQXVCLCtIQUErSCxxQkFBcUIsaUJBQWlCLEVBQUU7QUFDelEsUUFBUSwwREFBMEQsK0JBQStCLGdDQUFnQyxrQkFBa0IsS0FBSyxnQkFBZ0IsNEJBQTRCLEtBQUssaUtBQWlLLHVHQUF1Ryx1QkFBdUI7QUFDeGUscUJBQXFCLGtHQUFrRyxVQUFVLHVCQUF1QixzQ0FBc0MsbUJBQW1CLEtBQUssZUFBZSxtQkFBbUIsS0FBSyxnQkFBZ0IsbUJBQW1CLEtBQUssOENBQThDLG1CQUFtQixLQUFLLDBCQUEwQixnRUFBZ0UsbUJBQW1CLEtBQUssT0FBTyxnQkFBZ0I7QUFDcGYsOExBQThMLEtBQUs7QUFDbk0sMEZBQTBGLEtBQUssZ0VBQWdFLGVBQWUsdUJBQXVCLG9FQUFvRSxjQUFjO0FBQ3ZSLFdBQVcsS0FBSyxnQkFBZ0IsVUFBVSx1QkFBdUIsK0JBQStCLGdKQUFnSixzSEFBc0gsa0NBQWtDLHFCQUFxQix1REFBdUQsbUJBQW1CO0FBQ3ZlLCtEQUErRCxtQkFBbUIsS0FBSywrR0FBK0csbUJBQW1CLEtBQUssdUdBQXVHLG1CQUFtQixLQUFLLDZDQUE2QyxtQkFBbUIsS0FBSyxtQkFBbUIsK0RBQStEO0FBQ3BmLG1CQUFtQiw4RkFBOEYsc0JBQXNCLHVFQUF1RSwwREFBMEQ7QUFDeFEsaUJBQWlCLFVBQVUsOENBQThDLHNDQUFzQywwREFBMEQsa0JBQWtCLGVBQWUsV0FBVyxrREFBa0QsVUFBVSxpQkFBaUIsVUFBVSxtQ0FBbUMsNENBQTRDLE1BQU0sVUFBVSxtREFBbUQ7QUFDOWIsaUJBQWlCLG1GQUFtRixVQUFVLHlCQUF5QiwyRUFBMkUseUNBQXlDLCtDQUErQyxZQUFZLDZEQUE2RDtBQUNuWCxRQUFRLG1KQUFtSixlQUFlLDhDQUE4QyxvREFBb0QscUJBQXFCLE1BQU0sbUJBQW1CLDREQUE0RCxvQkFBb0IsR0FBRyxvQkFBb0IsZUFBZSxRQUFRLGVBQWUsWUFBWTtBQUNuZCxpQkFBaUIseUJBQXlCLFVBQVUsT0FBTyxPQUFPLE9BQU8sNEJBQTRCLFFBQVEscUNBQXFDLGtDQUFrQyxHQUFHLGtDQUFrQyxNQUFNLFdBQVcseURBQXlELGNBQWMsdURBQXVELGVBQWUscUNBQXFDLFNBQVMsaUJBQWlCO0FBQ3RiLG1CQUFtQiwwRkFBMEYsZUFBZSxtRUFBbUUsaUJBQWlCLDRCQUE0QixpQkFBaUIsMENBQTBDLGlCQUFpQiwrQ0FBK0M7QUFDdlcsaUJBQWlCLG9CQUFvQix5RUFBeUUsc0NBQXNDLGdDQUFnQyxRQUFRLFdBQVcsS0FBSyxXQUFXLDBDQUEwQyxTQUFTLGVBQWUsS0FBSyxnQkFBZ0IsZ0JBQWdCO0FBQzlULGlCQUFpQixZQUFZLElBQUksVUFBVSxFQUFFLEVBQUUsbUJBQW1CLHlCQUF5QixxQkFBcUIsbUJBQW1CLElBQUksR0FBRyxLQUFLLEVBQUUsRUFBRSxrQkFBa0IsZ0JBQWdCLFFBQVEsZUFBZSxTQUFTLFNBQVMsaUJBQWlCO0FBQy9PLGNBQWMsd0JBQXdCLGlDQUFpQyxFQUFFLElBQUksc0RBQXNELFNBQVMsS0FBSyx1QkFBdUIsV0FBVyxpQkFBaUIsU0FBUyxlQUFlLDhDQUE4QztBQUMxUSxlQUFlLDhDQUE4QyxxRUFBcUUsNElBQTRJLCtFQUErRSxtQkFBbUIsaURBQWlELHFDQUFxQyw4QkFBOEIsVUFBVTtBQUM5ZSxHQUFHLHdSQUF3UixLQUFLLFFBQVEsZUFBZSx5QkFBeUIsNENBQTRDLEVBQUUsdUNBQXVDLFFBQVEsV0FBVztBQUN4YjtBQUNBLG1CQUFtQiwrREFBK0QsK0RBQStELDBDQUEwQyw2RUFBNkUsb0dBQW9HLHNHQUFzRyxvQkFBb0I7QUFDdGUsaUJBQWlCLFNBQVMsbUNBQW1DLHlCQUF5QixtQkFBbUIsU0FBUyxRQUFRLG1NQUFtTSxNQUFNO0FBQ25VLG9QQUFvUCxlQUFlLHNCQUFzQixtQkFBbUIsY0FBYyw2REFBNkQsU0FBUztBQUNoWSxpQkFBaUIsWUFBWSxVQUFVLGFBQWEsYUFBYSxNQUFNLHFFQUFxRSxlQUFlLHdCQUF3Qiw4QkFBOEIsMEJBQTBCLCtCQUErQix3QkFBd0Isd0JBQXdCLHlCQUF5Qiw0Q0FBNEMsNENBQTRDO0FBQzNhLGtEQUFrRCw4RkFBOEYsaUhBQWlILHNFQUFzRSw2RkFBNkY7QUFDcGEsbUdBQW1HO0FBQ25HLG1CQUFtQiw4QkFBOEIsa0JBQWtCLGlCQUFpQjtBQUNwRixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsS0FBSyxxQkFBcUIsY0FBYyxHQUFHLGFBQWEsMEJBQTBCLEtBQUssS0FBSywwQ0FBMEMsYUFBYSwyQ0FBMkMsVUFBVSxJQUFJLGFBQWEsV0FBVyxLQUFLLE9BQU8sYUFBYSxrQkFBa0IsYUFBYSwyQ0FBMkMsVUFBVSxNQUFNO0FBQzNZLGdCQUFnQixZQUFZLDhCQUE4QixtQkFBbUIsa0NBQWtDLG1CQUFtQixRQUFRLFVBQVUsWUFBWSw2REFBNkQsZUFBZSxXQUFXLFNBQVMsdUJBQXVCLDBEQUEwRCxFQUFFLHVDQUF1QztBQUMxWCxxQkFBcUIsY0FBYyxnQkFBZ0IsTUFBTSxZQUFZLE1BQU0sYUFBYSxxQkFBcUIsU0FBUyw0REFBNEQscUNBQXFDLHFCQUFxQixnRUFBZ0UsVUFBVTtBQUN0VCx1QkFBdUIsUUFBUSwwQ0FBMEMsRUFBRSxtQkFBbUIsWUFBWSxpQkFBaUIsZ0NBQWdDLGlEQUFpRCx3QkFBd0IsU0FBUyxFQUFFLFlBQVksOEZBQThGLFdBQVcsS0FBSyxTQUFTLEVBQUUsUUFBUSxtQkFBbUIsUUFBUSxpQkFBaUIsTUFBTSxXQUFXLGdCQUFnQixXQUFXLGNBQWM7QUFDbGUsR0FBRyxnQkFBZ0IsZUFBZSxhQUFhLFVBQVUscUNBQXFDLGlDQUFpQyxNQUFNLHlCQUF5QixLQUFLLE1BQU0seUJBQXlCLEtBQUssTUFBTSx3Q0FBd0MsTUFBTSxxQ0FBcUMsMElBQTBJLE1BQU07QUFDaGIsR0FBRyxNQUFNLDJFQUEyRSxNQUFNLDZCQUE2QixNQUFNLGFBQWEsTUFBTSxtQkFBbUIsTUFBTSxrQkFBa0IsTUFBTSx5Q0FBeUMsTUFBTSx5S0FBeUssbUVBQW1FLEtBQUssY0FBYztBQUMvZSxFQUFFLEVBQUUsSUFBSSxrQkFBa0IsNEVBQTRFLFdBQVcsV0FBVywyQ0FBMkMsb0JBQW9CLElBQUksY0FBYyxHQUFHLHFDQUFxQyxtQ0FBbUMseUVBQXlFLFNBQVMsMEVBQTBFLE1BQU07QUFDMWIsZ0RBQWdELGdCQUFnQixVQUFVLEtBQUssaUJBQWlCLGlCQUFpQixVQUFVLDhGQUE4RixrQkFBa0Isa0JBQWtCLDJCQUEyQixXQUFXLGtCQUFrQixPQUFPLHlFQUF5RSxJQUFJLFdBQVcsSUFBSSxJQUFJLElBQUksUUFBUSxFQUFFLFlBQVksSUFBSSxRQUFRLEVBQUUsWUFBWSxLQUFLLE1BQU0sYUFBYSxLQUFLLE1BQU07QUFDbmYsVUFBVSxLQUFLLElBQUksRUFBRSw0Q0FBNEMsUUFBUSxRQUFRLE9BQU8sWUFBWSx5QkFBeUIscUNBQXFDLEdBQUcsaUJBQWlCLHVDQUF1Qyx3REFBd0QsMEJBQTBCLEtBQUssTUFBTSxVQUFVLGdHQUFnRyxxQkFBcUIsYUFBYSxRQUFRLGNBQWM7QUFDNWQseURBQXlELGtCQUFrQixVQUFVLHlFQUF5RSxNQUFNLDhCQUE4QixNQUFNLHVCQUF1QixNQUFNLHVEQUF1RCxVQUFVLE1BQU0sbUNBQW1DLHNDQUFzQyxPQUFPLFNBQVMsVUFBVSxvREFBb0QsUUFBUTtBQUMzYyxRQUFRLGtEQUFrRCxRQUFRLFVBQVUsbUdBQW1HLGlOQUFpTixzQkFBc0IscURBQXFEO0FBQzNjLHNFQUFzRSxvQkFBb0IsYUFBYSxRQUFRLEVBQUUsbUJBQW1CLE9BQU8sdUNBQXVDLGlCQUFpQiwyQkFBMkIsU0FBUyxFQUFFLHNCQUFzQix3R0FBd0csV0FBVyxTQUFTLGVBQWUsd0JBQXdCLGNBQWMsb0JBQW9CO0FBQ3BjLHVCQUF1Qiw0QkFBNEIsZ0JBQWdCLEVBQUUsb0NBQW9DLHlCQUF5QixpSEFBaUgsV0FBVyxzQkFBc0Isb0JBQW9CLEVBQUUsb0NBQW9DLGVBQWUsbUVBQW1FLG1CQUFtQixRQUFRLHFDQUFxQztBQUNoZSxvQkFBb0IsaUJBQWlCO0FBQ3JDLHVQQUF1UCwwQ0FBMEMsSUFBSSxlQUFlLHNCQUFzQixTQUFTO0FBQ25WLGlCQUFpQixZQUFZLEdBQUcsb0JBQW9CLGlCQUFpQiwyQ0FBMkMsVUFBVSxpQkFBaUIsTUFBTSxPQUFPLElBQUkscUNBQXFDLElBQUksU0FBUyxNQUFNLGVBQWUsS0FBSyxRQUFRLGlCQUFpQixpQkFBaUIsc0JBQXNCLFVBQVUsU0FBUyxxQ0FBcUMseUJBQXlCO0FBQ3pYLGVBQWUsb0JBQW9CLFlBQVksRUFBRSxFQUFFLG1CQUFtQixhQUFhLGdDQUFnQyxrQkFBa0IsSUFBSSxrQkFBa0Isb0JBQW9CLFlBQVk7QUFDM0wsZUFBZSxZQUFZLGNBQWMsdUJBQXVCLEVBQUUsRUFBRSxtQkFBbUIsY0FBYyx3REFBd0QsU0FBUyxFQUFFLG9CQUFvQixRQUFRLFNBQVMsSUFBSSxlQUFlLFlBQVksZUFBZSxlQUFlLDZEQUE2RCxlQUFlLDJDQUEyQyxvQkFBb0IsZUFBZSxtQkFBbUIsZ0JBQWdCLGVBQWUsT0FBTztBQUM3ZCxjQUFjLDBDQUEwQyxnQkFBZ0IsS0FBSyxpQkFBaUIsWUFBWSxTQUFTLDBCQUEwQixpQkFBaUIsMEJBQTBCLGdCQUFnQixrQkFBa0IsMkdBQTJHLFFBQVEsR0FBRyxxQkFBcUIsaUhBQWlIO0FBQ3RkLGVBQWUsc0JBQXNCLDRCQUE0QixjQUFjLE1BQU0sS0FBSyxtQkFBbUIsc0NBQXNDLE9BQU8sUUFBUSxtQkFBbUIsa0JBQWtCLHNCQUFzQixrREFBa0Qsc0JBQXNCLG1FQUFtRSxXQUFXO0FBQ25YLGVBQWUsbUVBQW1FLGFBQWEsT0FBTyxpQkFBaUIsU0FBUyxtQkFBbUIsa0JBQWtCLDBCQUEwQix1RkFBdUYsUUFBUSx3QkFBd0IsZUFBZSw0QkFBNEIsZUFBZSxNQUFNO0FBQ3RYLGNBQWMsbUJBQW1CLE1BQU0sWUFBWSxJQUFJLFNBQVMsUUFBUSxXQUFXLEtBQUssV0FBVyxXQUFXLGdCQUFnQixRQUFRLE1BQU0sU0FBUyxpREFBaUQsUUFBUSxXQUFXLFlBQVksMERBQTBELGlCQUFpQixZQUFZLFlBQVksS0FBSztBQUM3VSxtQkFBbUIsWUFBWSxZQUFZLFlBQVksS0FBSyxTQUFTLEtBQUssaUJBQWlCLFdBQVcsS0FBSyxpQkFBaUIsU0FBUyxZQUFZLDRCQUE0QixNQUFNLEtBQUssd0JBQXdCLE9BQU8seUJBQXlCLGVBQWUscUNBQXFDLGVBQWUsS0FBSyxPQUFPLGlEQUFpRCxLQUFLLE9BQU8seUVBQXlFO0FBQ3JjLGlCQUFpQix3QkFBd0Isd0JBQXdCLGNBQWMsV0FBVyxjQUFjO0FBQ3hHLGlCQUFpQixjQUFjLG9CQUFvQixvRUFBb0UsK0RBQStELHVHQUF1Ryw4REFBOEQsa0JBQWtCLHVCQUF1QixnREFBZ0Q7QUFDcGIsWUFBWSxrQkFBa0IsZUFBZSx5Q0FBeUMsZUFBZSxNQUFNLFNBQVMsTUFBTSxRQUFRLGFBQWEsNkJBQTZCLG9CQUFvQixTQUFTLHdEQUF3RCxLQUFLLDZCQUE2Qix3QkFBd0IsS0FBSyxPQUFPLGVBQWUsZUFBZSwyQ0FBMkMsWUFBWTtBQUM1WixlQUFlLG1CQUFtQiwyQkFBMkIsTUFBTSxnR0FBZ0csY0FBYyxrQ0FBa0MsS0FBSyxFQUFFLDZCQUE2QixNQUFNLGVBQWUsa0JBQWtCLDZCQUE2QiwwQkFBMEIsR0FBRyxnQkFBZ0IsUUFBUSxFQUFFLEVBQUUsbUJBQW1CLGFBQWEsYUFBYSxVQUFVLHFCQUFxQixRQUFRLElBQUkscUNBQXFDLGdCQUFnQjtBQUNqZ0IsTUFBTSw0Q0FBNEMsU0FBUyxjQUFjLGFBQWEsRUFBRSxxQkFBcUIsY0FBYyxXQUFXLEtBQUssZUFBZSw0QkFBNEI7QUFDdEwsbUJBQW1CLFFBQVEseURBQXlELGFBQWEsV0FBVyxNQUFNLGlDQUFpQyxrQkFBa0IsNEJBQTRCLGVBQWUsd0ZBQXdGLGNBQWMsYUFBYSw2QkFBNkIsZUFBZSxTQUFTLDJDQUEyQyxvQ0FBb0M7QUFDdmMsaUJBQWlCLG9DQUFvQywwREFBMEQsOEJBQThCLE9BQU8sZUFBZSxjQUFjO0FBQ2pMLGVBQWUsZ0JBQWdCLE1BQU0sa0JBQWtCLGtEQUFrRCxnQkFBZ0Isa0JBQWtCLEtBQUssU0FBUyxvQkFBb0IsWUFBWSxnQkFBZ0IsY0FBYyxTQUFTLDBEQUEwRCxTQUFTLGdCQUFnQixVQUFVLFVBQVUsZUFBZSxTQUFTLGtCQUFrQixVQUFVLGdDQUFnQyxjQUFjLGtEQUFrRCxXQUFXLFNBQVMsY0FBYztBQUM3ZixpQ0FBaUMsU0FBUyxvQkFBb0IsNERBQTRELFNBQVMsV0FBVyxTQUFTLG9CQUFvQixhQUFhLGlEQUFpRCxvSkFBb0oseUNBQXlDLGdCQUFnQixXQUFXLFNBQVMsb0JBQW9CO0FBQzlkLGdJQUFnSSxzQkFBc0IsV0FBVyxTQUFTLHNCQUFzQiw4REFBOEQsU0FBUyxXQUFXLFNBQVMsa0JBQWtCLDRGQUE0RixrQ0FBa0MsbUJBQW1CO0FBQzliLGdDQUFnQyw2Q0FBNkMsc0JBQXNCLDRCQUE0QiwwREFBMEQsUUFBUSxZQUFZLG9CQUFvQiwwQkFBMEIsdUZBQXVGLGtDQUFrQyxtQkFBbUIseUNBQXlDLHlDQUF5QztBQUN6ZCxtQkFBbUIscURBQXFELFFBQVEsWUFBWSxzQkFBc0IsMEZBQTBGLGtDQUFrQyxtQkFBbUIsOERBQThELDhEQUE4RCxzQkFBc0IsZ0NBQWdDLHdEQUF3RCxRQUFRO0FBQ25mLG9CQUFvQix1Q0FBdUMscUJBQXFCLEtBQUssbUNBQW1DLG9CQUFvQixhQUFhLGdCQUFnQixNQUFNLGlDQUFpQyxXQUFXLHlCQUF5QixJQUFJLElBQUksMkNBQTJDLGFBQWEsS0FBSyxXQUFXLHNFQUFzRSxXQUFXLFNBQVMsYUFBYSxXQUFXO0FBQ3RiLHdEQUF3RCx5QkFBeUIsY0FBYyxFQUFFLFdBQVcsU0FBUyxvQkFBb0IsWUFBWSw2Q0FBNkMsWUFBWSwrQkFBK0IsNkNBQTZDLGtCQUFrQixnQkFBZ0IsbUNBQW1DLHVCQUF1QixhQUFhLGdCQUFnQixNQUFNLGlDQUFpQyxXQUFXLHlCQUF5QixJQUFJLElBQUk7QUFDdGUsZ0JBQWdCLGFBQWEsS0FBSyxRQUFRLG9GQUFvRixXQUFXLFNBQVMsYUFBYSxRQUFRLDhJQUE4SSx5QkFBeUIsY0FBYyxFQUFFLFdBQVcsU0FBUyxvQkFBb0IsK0VBQStFLGtDQUFrQyxtQkFBbUIsV0FBVztBQUNyaEIsVUFBVSxTQUFTLEVBQUUsY0FBYyxTQUFTLFdBQVcsY0FBYyxlQUFlLHdCQUF3QixXQUFXLElBQUksU0FBUywyRkFBMkYsZUFBZSxlQUFlLGdCQUFnQixXQUFXLElBQUksUUFBUSxPQUFPLE1BQU0sWUFBWSxZQUFZLDZJQUE2SSxZQUFZLFdBQVcsWUFBWTtBQUN6ZixFQUFFLEVBQUUsdUhBQXVILGVBQWUsc0JBQXNCLFdBQVcsSUFBSSxRQUFRLEtBQUssT0FBTyxNQUFNLFlBQVksWUFBWSxpQkFBaUIsV0FBVyxJQUFJLFlBQVksZ0RBQWdELDJCQUEyQiwyQkFBMkIsUUFBUTtBQUMzWCxzREFBc0QsU0FBUyw0REFBNEQsY0FBYyxjQUFjLGVBQWUsaUJBQWlCLE1BQU0sa0JBQWtCLG1CQUFtQixLQUFLLFNBQVMsRUFBRSxrQkFBa0IscUhBQXFILGVBQWU7QUFDeFksaUJBQWlCLEtBQUssV0FBVyxpQkFBaUIsZ0ZBQWdGLGVBQWUsc0JBQXNCLGdCQUFnQixvQ0FBb0MsWUFBWSxpQ0FBaUMsS0FBSyxpQkFBaUIsd0JBQXdCLGtCQUFrQixTQUFTLFlBQVksZUFBZTtBQUM1VyxxQkFBcUIsb0JBQW9CLG1EQUFtRCxnQkFBZ0IsZUFBZSxpQkFBaUIsV0FBVyxrQkFBa0IsdUJBQXVCLElBQUksZUFBZSxTQUFTLDBFQUEwRSxrQ0FBa0MsVUFBVSxlQUFlLGVBQWUsMkVBQTJFLHNDQUFzQztBQUNqZSxpQkFBaUIsZ0JBQWdCLG1DQUFtQywwSEFBMEgsRUFBRSxpQkFBaUIsT0FBTztBQUN4TixtQkFBbUIsb0JBQW9CLHdCQUF3QixXQUFXLGNBQWMsZ0JBQWdCLDJDQUEyQyxZQUFZLGVBQWUsZ0JBQWdCLG1EQUFtRCxnQkFBZ0IsZUFBZSxtQkFBbUIsZ0JBQWdCLDJDQUEyQyxjQUFjLGtCQUFrQixLQUFLLFVBQVU7QUFDN1ksaUJBQWlCLGtDQUFrQyxzQ0FBc0Msa0JBQWtCLG9CQUFvQixhQUFhLEdBQUcsT0FBTyw2RkFBNkYsMEJBQTBCLFNBQVMsZ0JBQWdCLDBCQUEwQixXQUFXLEdBQUcsNEZBQTRGLGdCQUFnQixPQUFPLG1CQUFtQjtBQUNwZCxFQUFFO0FBQ0YscUJBQXFCLG9CQUFvQixNQUFNLDhEQUE4RCxhQUFhLHNCQUFzQixpQkFBaUIsWUFBWSxzQkFBc0IsSUFBSSxrQkFBa0IsaUhBQWlILGFBQWEsa0JBQWtCLElBQUksV0FBVyxJQUFJLEdBQUcsMkJBQTJCLGNBQWMscUJBQXFCO0FBQzdiLFVBQVUsRUFBRSxHQUFHLFlBQVksSUFBSSxJQUFJLGNBQWMsbUJBQW1CLDBCQUEwQixnQkFBZ0IsUUFBUSxJQUFJLFFBQVEsa0NBQWtDLG1CQUFtQix3Q0FBd0MsZ0NBQWdDLE1BQU0sTUFBTSxRQUFRLGNBQWMsMEZBQTBGLFFBQVEsNkVBQTZFO0FBQ2hkLFNBQVMsaURBQWlELHVFQUF1RSxTQUFTLGdCQUFnQixjQUFjLG9CQUFvQixtQkFBbUIsdUJBQXVCLGFBQWEsSUFBSSxzQkFBc0IsYUFBYSxrQ0FBa0MsTUFBTSxVQUFVO0FBQzVVLG1CQUFtQixZQUFZLGVBQWUsb0JBQW9CLFdBQVcsS0FBSyx3QkFBd0IsYUFBYSxnQkFBZ0IsSUFBSSwrQ0FBK0MsWUFBWSxTQUFTLCtCQUErQixlQUFlLDhCQUE4QjtBQUMzUixpQkFBaUIsUUFBUSxRQUFRLFNBQVMsYUFBYSxVQUFVLGtFQUFrRSxNQUFNLDRFQUE0RSxNQUFNLFFBQVEsY0FBYyxNQUFNLE1BQU0sTUFBTSxlQUFlLGVBQWUscUJBQXFCLG1CQUFtQix5QkFBeUIsZUFBZSw4QkFBOEI7QUFDL1ksZUFBZSxZQUFZLFNBQVMsRUFBRSxlQUFlLHNCQUFzQiw4RUFBOEUsMERBQTBELDhCQUE4Qix3QkFBd0IsaUJBQWlCLFVBQVUsU0FBUyxlQUFlLEtBQUssaUJBQWlCLEVBQUUsNkNBQTZDLFdBQVcsMEJBQTBCLFlBQVksWUFBWTtBQUM5YixjQUFjLFlBQVksWUFBWSw2Q0FBNkMsWUFBWSwrR0FBK0csYUFBYSxxQkFBcUIsaUJBQWlCLHFCQUFxQixZQUFZLHVCQUF1QiwrQkFBK0I7QUFDeFYseUJBQXlCLEtBQUssSUFBSSxxQkFBcUIsbUJBQW1CLFVBQVUsa0RBQWtELFNBQVMsT0FBTyxJQUFJLEdBQUcsTUFBTSxLQUFLLDZCQUE2QixLQUFLLFNBQVMsbUJBQW1CLGNBQWMsU0FBUyxVQUFVLGNBQWMsMEJBQTBCLEtBQUssV0FBVyxNQUFNLHlCQUF5QixTQUFTLGNBQWMsYUFBYSxLQUFLO0FBQ3ZZLGNBQWMsT0FBTyx1RUFBdUUsd0NBQXdDLFNBQVMsY0FBYyxhQUFhLGtCQUFrQixnQ0FBZ0MsY0FBYyxzQ0FBc0Msb0JBQW9CLEtBQUssZ0NBQWdDLElBQUksR0FBRyxtR0FBbUcsd0NBQXdDO0FBQ3pkLGlCQUFpQjtBQUNqQixlQUFlLHFCQUFxQixnQ0FBZ0Msd0JBQXdCLGtDQUFrQyxhQUFhLGFBQWEsYUFBYSxjQUFjLFNBQVMsZ0JBQWdCLGVBQWUsYUFBYSxTQUFTLGNBQWMsd0JBQXdCLEdBQUcsYUFBYSxtQ0FBbUMsdUZBQXVGLCtDQUErQyxLQUFLLE9BQU87QUFDNWQsbUNBQW1DLGdDQUFnQyxXQUFXLE1BQU0sU0FBUyx1QkFBdUIsc0JBQXNCLCtCQUErQixrQkFBa0IsY0FBYyxjQUFjLHNCQUFzQixnQkFBZ0IsYUFBYSxJQUFJLHNDQUFzQyxhQUFhLDJCQUEyQjtBQUM1VixlQUFlLHFCQUFxQixnQ0FBZ0Msd0JBQXdCLCtDQUErQyxhQUFhLGVBQWUsZUFBZSw0QkFBNEIsYUFBYSwrQkFBK0Isa0JBQWtCLG9DQUFvQyxzQkFBc0IsWUFBWTtBQUN0VixpQkFBaUIsOENBQThDLDZCQUE2QixVQUFVLDRCQUE0QiwwREFBMEQsY0FBYyx3Q0FBd0MsZ0NBQWdDLHVCQUF1QixTQUFTLG1CQUFtQixlQUFlLEdBQUcsdUJBQXVCLGdCQUFnQixhQUFhLDRCQUE0QjtBQUN2YSxxQkFBcUIsVUFBVSxnQkFBZ0IsYUFBYSxtQkFBbUIsb0JBQW9CLGFBQWEsRUFBRSxlQUFlLG9CQUFvQixVQUFVLElBQUksVUFBVSxlQUFlLFNBQVMsVUFBVSxlQUFlLGNBQWM7QUFDNU8sZUFBZSxXQUFXLCtCQUErQiw4QkFBOEIsR0FBRyxnR0FBZ0csVUFBVSwrQkFBK0I7QUFDbk8scUJBQXFCLEdBQUcsMkNBQTJDLGdCQUFnQixhQUFhLDRCQUE0QixvSUFBb0ksU0FBUyxjQUFjLDBCQUEwQixxQkFBcUIsV0FBVyxXQUFXO0FBQzVWLHFCQUFxQixXQUFXLG9CQUFvQixhQUFhLGFBQWEsc0JBQXNCLFlBQVksMkJBQTJCLDRCQUE0QixRQUFRLFdBQVcsOEJBQThCLGlCQUFpQix5QkFBeUIsaUJBQWlCLHNCQUFzQixpQkFBaUIsbUJBQW1CLGlCQUFpQjtBQUM5VixpQkFBaUIsc0RBQXNELFNBQVMsNERBQTRELGdCQUFnQixtQkFBbUIsMENBQTBDLG1DQUFtQyxlQUFlLGlCQUFpQixXQUFXLG9CQUFvQixzQkFBc0IsOENBQThDLHNCQUFzQjtBQUNyWixpQkFBaUIsV0FBVyxvQkFBb0Isc0JBQXNCLDhDQUE4QyxNQUFNLHNCQUFzQixTQUFTLG1CQUFtQiw0RUFBNEUsa0RBQWtELFNBQVMsaUJBQWlCLFFBQVEsaUJBQWlCLE1BQU0sb0JBQW9CLGlCQUFpQixJQUFJLFVBQVUsUUFBUSxxQkFBcUIsY0FBYztBQUNqYyxtQkFBbUIsWUFBWSxHQUFHLDREQUE0RCxpQkFBaUIsZ0NBQWdDLFVBQVUsWUFBWTtBQUNySyxtQkFBbUIsZUFBZSw0REFBNEQsaUJBQWlCLEtBQUssa0JBQWtCLGdGQUFnRixtQ0FBbUMsbUJBQW1CLGVBQWUsWUFBWSxvQkFBb0IsbURBQW1ELGdCQUFnQixRQUFRLFVBQVUsU0FBUyxjQUFjO0FBQ3ZhLGVBQWUsa0JBQWtCLDhCQUE4QixpQkFBaUIsU0FBUyxnQkFBZ0IsMkNBQTJDLFlBQVksbUJBQW1CLG9CQUFvQixjQUFjLGtCQUFrQixLQUFLLFVBQVU7QUFDdFAsUUFBUSwrUkFBK1IsS0FBSyx5Q0FBeUMseUNBQXlDLFNBQVMsZ0VBQWdFLDBDQUEwQztBQUNqZix1QkFBdUIsK0JBQStCLHlCQUF5QixrQ0FBa0MsbUJBQW1CLHVCQUF1QixXQUFXLG9CQUFvQixNQUFNLHNCQUFzQixTQUFTLDRCQUE0QixXQUFXLG9CQUFvQiw4QkFBOEIsR0FBRywrRkFBK0YsVUFBVSwrQkFBK0IsMEJBQTBCLG9CQUFvQjtBQUNqZixLQUFLLEdBQUcsV0FBVyx5QkFBeUIsMkRBQTJELDRCQUE0QiwwQkFBMEIsb0JBQW9CLHFCQUFxQixxQkFBcUIsWUFBWSw4QkFBOEIsc0NBQXNDLGVBQWUsTUFBTSxrQ0FBa0MsTUFBTSxLQUFLLE1BQU0sZ0NBQWdDLHVCQUF1QixrQkFBa0IsT0FBTyx1QkFBdUIsVUFBVTtBQUNwZSxVQUFVLGNBQWMsd0NBQXdDLFNBQVMsa0JBQWtCLGdDQUFnQyxNQUFNLFNBQVMsU0FBUyxzQ0FBc0MsY0FBYyxPQUFPLDZCQUE2QixPQUFPLDJDQUEyQyx5QkFBeUIsNkJBQTZCLEtBQUssZ0xBQWdMLGNBQWM7QUFDdGhCLDhDQUE4QyxXQUFXLCtCQUErQiwwQkFBMEIscUNBQXFDLFlBQVksa0ZBQWtGLEtBQUssZ0xBQWdMLGNBQWMsK0NBQStDLFdBQVc7QUFDbGYsNENBQTRDLDBCQUEwQixxQ0FBcUMsWUFBWSxtRkFBbUYsaUJBQWlCLHNCQUFzQixNQUFNLElBQUksaUJBQWlCLDBDQUEwQyxTQUFTLFNBQVMscUJBQXFCLGtCQUFrQixTQUFTLDZCQUE2QixNQUFNLGtCQUFrQjtBQUM3YSxRQUFRLHNCQUFzQix5Q0FBeUMsaUNBQWlDLG9CQUFvQiw0QkFBNEIsWUFBWSxxQ0FBcUMsWUFBWSxrQ0FBa0MscUNBQXFDLG9CQUFvQiw0QkFBNEIsUUFBUSxZQUFZLHFDQUFxQyxZQUFZLGtDQUFrQyxrQ0FBa0Msb0JBQW9CO0FBQ3plLGdCQUFnQixRQUFRLHFDQUFxQyxZQUFZLG9DQUFvQywyQkFBMkIsY0FBYztBQUN0SixtQkFBbUIsY0FBYyxvQkFBb0Isb0hBQW9ILGFBQWEsOERBQThELGFBQWEsY0FBYyxvQkFBb0IsaUhBQWlIO0FBQ3BaLHFCQUFxQixVQUFVLGtGQUFrRixnR0FBZ0c7QUFDak4scUJBQXFCLGtCQUFrQixVQUFVLHdCQUF3QixVQUFVLE1BQU0sb0JBQW9CLHVGQUF1Rix3QkFBd0IsNkJBQTZCLDZEQUE2RDtBQUN0VCx5T0FBeU8sNERBQTRELGlCQUFpQixJQUFJLGFBQWEsdUJBQXVCLFNBQVMsUUFBUSxTQUFTLHNEQUFzRCxPQUFPO0FBQ3JiLG1CQUFtQixPQUFPLGdFQUFnRSxpQkFBaUIsSUFBSSx1QkFBdUIsU0FBUyxzQkFBc0IsU0FBUyxHQUFHLCtDQUErQyxtQkFBbUIsV0FBVyxRQUFRLFdBQVcsY0FBYyxjQUFjLHNCQUFzQixpQkFBaUIsU0FBUztBQUM3VixtQkFBbUIsV0FBVyxRQUFRLHNDQUFzQywwQkFBMEIsY0FBYyxxQkFBcUIsYUFBYSxzQkFBc0IsU0FBUyxrQkFBa0IsMEVBQTBFLFFBQVEsbUVBQW1FLGNBQWMsZ0NBQWdDLDZCQUE2QixFQUFFLEVBQUU7QUFDM2EsbUJBQW1CLGtCQUFrQixhQUFhLHFCQUFxQixjQUFjLFdBQVcsbURBQW1ELHVEQUF1RCxlQUFlLEdBQUcsTUFBTSwwRUFBMEUsY0FBYyxXQUFXLGdCQUFnQjtBQUNyVix1QkFBdUIsa0xBQWtMLGVBQWUsVUFBVSxTQUFTLGtDQUFrQyxxQkFBcUI7QUFDbFMsdUJBQXVCLFdBQVcsWUFBWSxRQUFRLGtCQUFrQixPQUFPLHlGQUF5RixZQUFZLFdBQVcsWUFBWTtBQUMzTSx1QkFBdUIsYUFBYSxhQUFhLDRJQUE0SSwrQkFBK0IsWUFBWSxXQUFXLGlCQUFpQixVQUFVLG9CQUFvQixzQkFBc0IsWUFBWSxnQkFBZ0IsMENBQTBDLFdBQVcsVUFBVSxZQUFZLFdBQVc7QUFDMWEsdUJBQXVCLGFBQWEsc0JBQXNCLG9HQUFvRyxzQ0FBc0M7QUFDcE0sbUJBQW1CLGtFQUFrRSx3REFBd0QsNENBQTRDLGdCQUFnQixLQUFLLHlHQUF5Ryw0Q0FBNEMsd0NBQXdDLGlCQUFpQiw2Q0FBNkMseUJBQXlCLFNBQVMsTUFBTTtBQUNqZiw0REFBNEQsWUFBWSxlQUFlLGlCQUFpQixZQUFZLHlFQUF5RSx1QkFBdUIseUJBQXlCLFVBQVUsUUFBUSxrQkFBa0IsT0FBTyx5RkFBeUYsWUFBWSxXQUFXLFlBQVk7QUFDcFosdUJBQXVCLFVBQVUsU0FBUyxNQUFNLFVBQVUsUUFBUSx5REFBeUQsa0JBQWtCLG9DQUFvQyxVQUFVLGdDQUFnQyx1RUFBdUUsd0dBQXdHO0FBQzFZLDRCQUE0QixNQUFNLHNCQUFzQixVQUFVLFlBQVksa0JBQWtCO0FBQ2hHLDBNQUEwTSxLQUFLLGNBQWMsUUFBUSxrQkFBa0Isd0NBQXdDLFVBQVUsaUJBQWlCLFlBQVksZ0JBQWdCLHVFQUF1RSxpQ0FBaUM7QUFDOWIscUlBQXFJLE1BQU0sa0JBQWtCLFVBQVUsWUFBWSxzQkFBc0I7QUFDek07QUFDQSw2SUFBNkk7QUFDN0kseUJBQXlCLFFBQVEsd0JBQXdCLHlDQUF5QyxjQUFjLGFBQWEsd0VBQXdFLFdBQVcsOEVBQThFLHdCQUF3QixjQUFjLGVBQWUsZUFBZSxrQkFBa0IsbUdBQW1HO0FBQ3ZkLHVCQUF1QixLQUFLLE1BQU0sYUFBYSxZQUFZLGVBQWUsUUFBUSw4Q0FBOEMsZUFBZSxPQUFPO0FBQ3RKLG1CQUFtQiw0REFBNEQseURBQXlELHdCQUF3Qiw4Q0FBOEMsU0FBUyxhQUFhLE1BQU0sa0JBQWtCLHVIQUF1SCxhQUFhLGFBQWEsZ0NBQWdDLHlCQUF5QjtBQUN0YywySUFBMkksa0JBQWtCLGdFQUFnRSxNQUFNLGFBQWEsU0FBUyxVQUFVLFlBQVksT0FBTyxtQ0FBbUMsdUlBQXVJLGlEQUFpRDtBQUNqZixFQUFFLFdBQVcsWUFBWSxVQUFVLElBQUksVUFBVSx3QkFBd0Isa0JBQWtCLGtFQUFrRSxrQkFBa0IsNkJBQTZCLG1CQUFtQixTQUFTLFVBQVUsWUFBWSxRQUFRLG1DQUFtQyxFQUFFLDRCQUE0QixXQUFXLGVBQWUsMkVBQTJFLFVBQVUscUJBQXFCO0FBQzNjLGlCQUFpQixNQUFNLDBCQUEwQixnQkFBZ0IsV0FBVyxpQkFBaUIscUJBQXFCLGdCQUFnQixxQkFBcUIsZ0NBQWdDLFdBQVcscUJBQXFCO0FBQ3ZOLDJCQUEyQixNQUFNLG9FQUFvRSxtRUFBbUUsYUFBYSxTQUFTLE1BQU0sbUNBQW1DLFdBQVcsaUJBQWlCLFdBQVcsV0FBVyxXQUFXLFlBQVksVUFBVSxxQ0FBcUMsNEJBQTRCLG1CQUFtQixTQUFTLHdDQUF3QyxrQkFBa0I7QUFDamQsa0JBQWtCLElBQUksZ0JBQWdCLGlCQUFpQixtQkFBbUIsdUJBQXVCLFVBQVUsSUFBSSxhQUFhLGFBQWEsV0FBVyxNQUFNLFlBQVksTUFBTSxtUEFBbVAsTUFBTSwyQkFBMkIsTUFBTSxZQUFZO0FBQ2xkLDZEQUE2RCxLQUFLLG9CQUFvQixtQkFBbUIsNEZBQTRGLGdCQUFnQixxQkFBcUIsS0FBSyxLQUFLLFFBQVEsMkVBQTJFLG1CQUFtQixjQUFjLFNBQVMsbUJBQW1CLFdBQVcsa0JBQWtCLHVCQUF1QjtBQUN4Yix1QkFBdUIsc0JBQXNCLDBCQUEwQiwyRUFBMkU7QUFDbEosbUJBQW1CLDhDQUE4QyxxQkFBcUIsWUFBWSxrQ0FBa0MsS0FBSywrQ0FBK0MsU0FBUyxFQUFFLGdEQUFnRCw2QkFBNkIsd0JBQXdCLGlCQUFpQixVQUFVLFNBQVMsaUJBQWlCLEtBQUssaUJBQWlCLEVBQUUseUNBQXlDLFdBQVcsMEJBQTBCLFlBQVksS0FBSyxPQUFPO0FBQzNkLEtBQUssZUFBZSwwQkFBMEIsV0FBVyxTQUFTLHlEQUF5RCxJQUFJLCtEQUErRCxlQUFlLE1BQU0sd0JBQXdCLFVBQVUsaUJBQWlCLFNBQVMsRUFBRSxjQUFjLDJCQUEyQixVQUFVLE1BQU0sWUFBWSxZQUFZLElBQUksSUFBSSxrQkFBa0IsTUFBTSwwQ0FBMEMsTUFBTSw2QkFBNkI7QUFDL2MsaUJBQWlCLHlFQUF5RSxtQkFBbUIsMENBQTBDLFlBQVksb0NBQW9DLG1EQUFtRCxtQkFBbUIsVUFBVSx1QkFBdUIsVUFBVSxlQUFlLGlCQUFpQix5REFBeUQsZUFBZTtBQUNoYSxtQkFBbUIsY0FBYyxhQUFhLEtBQUssTUFBTSxhQUFhLE1BQU0seUJBQXlCLE1BQU0sdUNBQXVDLE1BQU0sc0RBQXNELHNCQUFzQixrQkFBa0IsTUFBTSwwQkFBMEIsYUFBYSxpRUFBaUUsK0NBQStDLGlCQUFpQixZQUFZLCtCQUErQixpQkFBaUIsTUFBTTtBQUN0ZSxjQUFjLHNCQUFzQixzQkFBc0IsYUFBYSxrQkFBa0IsMkRBQTJELGVBQWUsV0FBVyxpQkFBaUIsMkNBQTJDLGlCQUFpQjtBQUMzUCxpQkFBaUIsa0JBQWtCLFNBQVMsRUFBRSxtREFBbUQsbUNBQW1DLGlCQUFpQixVQUFVLFNBQVMsZUFBZSxLQUFLLGlCQUFpQixFQUFFLHdDQUF3QyxXQUFXLDBCQUEwQixjQUFjO0FBQzFTLHFCQUFxQixzQkFBc0IsVUFBVSxjQUFjLGVBQWUsV0FBVyxVQUFVLHVCQUF1QixVQUFVLEtBQUssTUFBTSxvQkFBb0IsSUFBSSxhQUFhLEVBQUUsTUFBTSxJQUFJLGFBQWEsRUFBRSxLQUFLLE1BQU0sMEJBQTBCLFVBQVUsS0FBSyxNQUFNLHFGQUFxRixRQUFRLE1BQU0sT0FBTyxvRkFBb0YsV0FBVztBQUN0ZCxTQUFTLFdBQVcsa01BQWtNLFlBQVksV0FBVyxzQkFBc0IsdUVBQXVFLGtFQUFrRSxXQUFXLHNEQUFzRCxhQUFhO0FBQzFkLFFBQVEsMldBQTJXLDZCQUE2QixRQUFRLGdDQUFnQyxxQkFBcUI7QUFDN2MsaUJBQWlCLHlCQUF5Qix1QkFBdUIsZUFBZSxTQUFTLHVDQUF1QyxvQ0FBb0MsTUFBTSwwQkFBMEIsZUFBZSxTQUFTLHVDQUF1QztBQUNuUSxjQUFjLDhEQUE4RCx1QkFBdUIsU0FBUywrRkFBK0YsbUJBQW1CLFNBQVMsNkVBQTZFLGtCQUFrQixlQUFlO0FBQ3JWLG1CQUFtQixxQkFBcUIsTUFBTSxjQUFjLDRGQUE0Rix5Q0FBeUMscUJBQXFCLEtBQUssTUFBTSxLQUFLLEtBQUsscUVBQXFFLG9KQUFvSixRQUFRLEtBQUssWUFBWSxhQUFhO0FBQzFlLFNBQVMsNEZBQTRGLEtBQUssT0FBTywwQ0FBMEMsS0FBSyxZQUFZLGlCQUFpQixVQUFVLGNBQWMsU0FBUyxzQkFBc0IsUUFBUSxRQUFRLGlCQUFpQixVQUFVLDRCQUE0QixhQUFhLE1BQU0scURBQXFELE1BQU0sa0NBQWtDLFlBQVksZUFBZSxNQUFNLDJCQUEyQixNQUFNO0FBQzdlLEdBQUcsWUFBWSxNQUFNLDZCQUE2QixNQUFNLHFCQUFxQixlQUFlLE1BQU0sK0JBQStCLDBCQUEwQixlQUFlLE1BQU0sdUNBQXVDLFFBQVEsT0FBTyx1Q0FBdUMsV0FBVztBQUN4Uix1RkFBdUYsVUFBVSxtQkFBbUIsV0FBVyxNQUFNLHNCQUFzQixNQUFNLE1BQU0sa0NBQWtDLHNEQUFzRCxJQUFJLGdCQUFnQix1QkFBdUIsS0FBSyxtQ0FBbUMsOENBQThDO0FBQ2hZLDRDQUE0QyxRQUFRLHVIQUF1SCxRQUFRLFFBQVEsY0FBYyxjQUFjLEdBQUcsVUFBVSxVQUFVLDRCQUE0QixhQUFhLElBQUksTUFBTSxxREFBcUQsSUFBSSxNQUFNLGtDQUFrQyxZQUFZLGVBQWUsSUFBSSxNQUFNLDJCQUEyQixJQUFJLE1BQU07QUFDNWMsR0FBRyxZQUFZLElBQUksTUFBTSw2QkFBNkIsSUFBSSxNQUFNLHFCQUFxQixVQUFVLGVBQWUsTUFBTSxrQkFBa0IsTUFBTSwrQkFBK0IsMEJBQTBCLE1BQU0sSUFBSSxhQUFhLEVBQUUsZUFBZSxNQUFNLHdCQUF3QixVQUFVLGVBQWUsTUFBTSxZQUFZLFFBQVEsSUFBSSxtQ0FBbUMsV0FBVztBQUNoWCw4TkFBOE4sVUFBVSxtQkFBbUIsV0FBVyxNQUFNLHNCQUFzQixNQUFNLE1BQU0sb0VBQW9FLE1BQU0sc0NBQXNDLFVBQVU7QUFDeGEsSUFBSSxNQUFNLHNEQUFzRCxVQUFVLHlFQUF5RSxRQUFRLGdCQUFnQixRQUFRLGNBQWMsZ0JBQWdCLDhDQUE4QyxLQUFLLFlBQVkseURBQXlELEtBQUssK0RBQStELGlCQUFpQixlQUFlLFVBQVUsY0FBYyxrQkFBa0IsUUFBUTtBQUMvZCwwQkFBMEIsd0NBQXdDLE1BQU0sdUZBQXVGLGdCQUFnQixrRkFBa0YsS0FBSyxZQUFZLGFBQWEsa0JBQWtCLHdFQUF3RSxpRkFBaUYsK0NBQStDO0FBQ3pmLEdBQUcsMEJBQTBCLGtCQUFrQiw2QkFBNkIsMEJBQTBCLFFBQVEsK0RBQStELEtBQUssS0FBSyxzQ0FBc0Msa0NBQWtDLHdDQUF3QyxXQUFXLGlJQUFpSSxtQ0FBbUMsS0FBSyxZQUFZO0FBQ3ZlLDBEQUEwRCw2Q0FBNkMsMENBQTBDLGFBQWEsa0JBQWtCLDZCQUE2QixvQkFBb0IsY0FBYywwQkFBMEIsS0FBSyxvREFBb0QsU0FBUyxFQUFFLFFBQVEsYUFBYSxhQUFhLFNBQVMsZ0JBQWdCLHVDQUF1QyxpQkFBaUIsSUFBSSxjQUFjLFNBQVM7QUFDM2Qsd2FBQXdhLDBDQUEwQyxjQUFjLG1CQUFtQixlQUFlO0FBQ2xnQixVQUFVLG9FQUFvRSxLQUFLLDJCQUEyQiw2SkFBNkosaUdBQWlHLCtGQUErRjtBQUMzYywwRkFBMEYsS0FBSyxZQUFZLHFNQUFxTSxvQkFBb0Isb0JBQW9CO0FBQ3hWLGlCQUFpQixNQUFNLGNBQWMsK0VBQStFLHNHQUFzRyx5QkFBeUIsYUFBYSxrQkFBa0Isa0NBQWtDLDBDQUEwQyxLQUFLLFVBQVUsNkNBQTZDLHlCQUF5Qix3QkFBd0Isd0NBQXdDO0FBQ25mLEtBQUssb0JBQW9CLHFCQUFxQixpRUFBaUUsaUJBQWlCLFlBQVkseUNBQXlDLFFBQVEsU0FBUyxTQUFTLG9CQUFvQixtQkFBbUIsSUFBSSxJQUFJLFNBQVMsVUFBVTtBQUNqUixpQkFBaUIsTUFBTSxPQUFPLFVBQVUsK0JBQStCLDJDQUEyQyxRQUFRLDZDQUE2Qyx1Q0FBdUMsd0JBQXdCLGVBQWUsbUNBQW1DLGdCQUFnQixJQUFJLHNCQUFzQixTQUFTLE9BQU8sUUFBUSxxQ0FBcUMsUUFBUSxFQUFFLFdBQVcsRUFBRSxzQ0FBc0Msc0NBQXNDO0FBQ2xlLG9CQUFvQixpQ0FBaUMsSUFBSSxJQUFJLE1BQU0sRUFBRSxpQkFBaUIsc0JBQXNCLHNCQUFzQixrQ0FBa0MsSUFBSSxlQUFlLElBQUksdUJBQXVCLGVBQWUsWUFBWSxNQUFNLGVBQWUsWUFBWSxJQUFJLGdDQUFnQyxNQUFNLFFBQVEsU0FBUyxxRUFBcUUsVUFBVSxTQUFTLEVBQUUsSUFBSSxJQUFJLGtCQUFrQixvQ0FBb0M7QUFDamUsb0JBQW9CLDJIQUEySCx3Q0FBd0MsTUFBTSx1Q0FBdUMsb0dBQW9HLE1BQU0sbUNBQW1DLDhCQUE4QixTQUFTLGdCQUFnQixZQUFZLGFBQWEsa0JBQWtCLElBQUksTUFBTSxXQUFXLEtBQUssTUFBTTtBQUNuZixtQkFBbUIsb0JBQW9CLDZCQUE2QixhQUFhLGVBQWUsR0FBRyxrQkFBa0IsZ0JBQWdCLGlCQUFpQixzQkFBc0IsU0FBUyxjQUFjLGlCQUFpQixnQkFBZ0IsNkJBQTZCLGFBQWEsZUFBZSxHQUFHLGtCQUFrQixlQUFlLGNBQWMsU0FBUyxjQUFjLGVBQWUsWUFBWSxhQUFhLGtCQUFrQixjQUFjLFdBQVcsTUFBTSxZQUFZO0FBQzNjLGVBQWUsa0JBQWtCLG1DQUFtQyxhQUFhLGlCQUFpQixlQUFlLHdHQUF3RyxpQkFBaUIsY0FBYyxvQkFBb0IscUJBQXFCLHFCQUFxQixvQkFBb0IsaUJBQWlCLG1CQUFtQixlQUFlO0FBQzdYLGVBQWUsUUFBUSxFQUFFLEtBQUssaUJBQWlCLEVBQUUsNkNBQTZDLFdBQVcsMEJBQTBCLGdCQUFnQixpQ0FBaUMsRUFBRSx3QkFBd0Isd0NBQXdDLGdDQUFnQztBQUN0UixtQkFBbUIsWUFBWSw4UEFBOFAsOERBQThELFNBQVM7QUFDcFcsbUJBQW1CLFlBQVkscUVBQXFFLDhEQUE4RCxTQUFTLHVCQUF1QixpQkFBaUIsbUJBQW1CLGNBQWMsU0FBUztBQUM3UCxtQkFBbUIsdURBQXVELDhCQUE4QixVQUFVLGNBQWMsa0JBQWtCLG9CQUFvQixPQUFPLFVBQVUsSUFBSSxLQUFLLDBIQUEwSCxNQUFNLDZIQUE2SCxNQUFNLFdBQVcsS0FBSyw0QkFBNEI7QUFDL2UsVUFBVSxJQUFJLEtBQUssTUFBTSw2RkFBNkYsV0FBVyxHQUFHLG9CQUFvQixRQUFRLHVEQUF1RCxTQUFTLGFBQWEsVUFBVSxNQUFNLHFGQUFxRix5RUFBeUUsU0FBUyxTQUFTLFVBQVUsTUFBTSxrQkFBa0IsTUFBTTtBQUNyZCx5Q0FBeUMsTUFBTSxtQkFBbUIsZUFBZSxvQkFBb0IsYUFBYSxtQkFBbUIsa0JBQWtCLGlDQUFpQyxzQkFBc0Isd0JBQXdCLGlDQUFpQztBQUN2USxpQkFBaUIsa0JBQWtCLHdCQUF3QixXQUFXLEtBQUssV0FBVyxJQUFJLGdCQUFnQixPQUFPLFNBQVMsRUFBRSxjQUFjLHFCQUFxQixNQUFNLFFBQVEsbUNBQW1DLE1BQU0sUUFBUSxtQ0FBbUMsTUFBTSxRQUFRLFdBQVcsZ0NBQWdDLFVBQVUsT0FBTyxNQUFNLGtCQUFrQiwwQkFBMEIsY0FBYyxTQUFTLFVBQVUsc0NBQXNDLFNBQVM7QUFDN2MsaUJBQWlCLDRCQUE0QixjQUFjLHVDQUF1QyxNQUFNLFFBQVEsSUFBSSx5QkFBeUIsU0FBUyxnQkFBZ0IsSUFBSSxpQkFBaUIsU0FBUyxpQkFBaUIsTUFBTSxlQUFlLE1BQU0sZ0NBQWdDLE1BQU0sZUFBZSxNQUFNLGdDQUFnQyxlQUFlLGtCQUFrQixJQUFJLFNBQVMsU0FBUyxpQkFBaUIsaUNBQWlDO0FBQ3BiLG1CQUFtQixnQkFBZ0IscURBQXFELFFBQVEsY0FBYyxRQUFRLFdBQVcsTUFBTSxvQkFBb0IsNkZBQTZGLFVBQVUscUJBQXFCLE1BQU0sd0JBQXdCLE1BQU0sZ0RBQWdELHlDQUF5QyxjQUFjO0FBQ2xhLDJEQUEyRCxRQUFRLFNBQVMsaUJBQWlCLE1BQU0sZUFBZSxNQUFNLFFBQVEsMENBQTBDLGNBQWMsa0JBQWtCLElBQUksY0FBYyxTQUFTLGlCQUFpQixNQUFNLGVBQWUsTUFBTSxtREFBbUQsb0JBQW9CLFNBQVMsZ0JBQWdCLE1BQU0sZUFBZSxNQUFNLE1BQU0sZ0JBQWdCLE1BQU0sVUFBVTtBQUNsYixnRUFBZ0UsV0FBVyxNQUFNLDJDQUEyQywwQ0FBMEMsTUFBTSxXQUFXLHlCQUF5QixrRUFBa0UsU0FBUyxFQUFFLFVBQVUsU0FBUyxFQUFFLElBQUksVUFBVSxjQUFjLGdEQUFnRCxNQUFNLHNCQUFzQixrQkFBa0IsK0NBQStDLElBQUksV0FBVyxJQUFJO0FBQzllLGlFQUFpRSxTQUFTLFVBQVUsTUFBTSxzQkFBc0IsTUFBTSxtQ0FBbUMsTUFBTSxVQUFVLGdDQUFnQyxZQUFZLGtCQUFrQixFQUFFLGNBQWMsYUFBYSxJQUFJLElBQUk7QUFDNVEsaUJBQWlCLFNBQVMsa0JBQWtCLG1CQUFtQixnQkFBZ0IsMkNBQTJDLFNBQVMsaUJBQWlCLGlGQUFpRixpQkFBaUIsVUFBVSxTQUFTLGlCQUFpQixLQUFLLGlCQUFpQixFQUFFLHlDQUF5QyxnQkFBZ0IsV0FBVyxnQkFBZ0IsMEJBQTBCLGFBQWEsTUFBTSxnQkFBZ0IsTUFBTSxXQUFXLE1BQU0sY0FBYztBQUN4ZSxVQUFVLGVBQWUsY0FBYyxRQUFRLElBQUksR0FBRyxtQkFBbUIsU0FBUyxFQUFFLFVBQVUsUUFBUSxRQUFRLFdBQVcscUJBQXFCLGNBQWMseUJBQXlCLG9DQUFvQyxZQUFZLFVBQVUsTUFBTSxzREFBc0QsVUFBVSxNQUFNLDhCQUE4QixTQUFTLGdCQUFnQixZQUFZLHlCQUF5QixtQkFBbUIsSUFBSTtBQUM5YSxtQkFBbUIseUJBQXlCLFNBQVMsRUFBRSxrQkFBa0Isa0JBQWtCLGlDQUFpQyxPQUFPLHdEQUF3RCxLQUFLLFFBQVEsS0FBSyxxQkFBcUIsU0FBUyx3RkFBd0YsS0FBSyxTQUFTLDJCQUEyQixJQUFJLEtBQUssSUFBSSxVQUFVO0FBQ25ZLGVBQWUsS0FBSyxTQUFTLEVBQUUsUUFBUSx1QkFBdUIsa0JBQWtCLElBQUksb0NBQW9DLGtDQUFrQyxNQUFNLHlCQUF5QixtREFBbUQsS0FBSyx3RUFBd0UsOEVBQThFLG9CQUFvQixvQkFBb0IsTUFBTSwyQkFBMkIsYUFBYSxPQUFPLHNDQUFzQztBQUMxZ0Isa0JBQWtCLE1BQU0sMkJBQTJCLFVBQVUsTUFBTSx5QkFBeUIsd0JBQXdCLElBQUksc0JBQXNCLGVBQWUsZ0ZBQWdGLE1BQU0saUNBQWlDLE1BQU0sYUFBYSxhQUFhLGNBQWMsbUNBQW1DLGtCQUFrQixhQUFhLHNCQUFzQixhQUFhLG1CQUFtQixrQkFBa0IsTUFBTTtBQUNsZCw2QkFBNkIsc0JBQXNCLFNBQVMsaUJBQWlCLFVBQVUsT0FBTyxNQUFNLFlBQVksYUFBYSxrQkFBa0IsSUFBSSxNQUFNLFlBQVksZUFBZSxLQUFLLFNBQVMsRUFBRSxRQUFRLFVBQVUsT0FBTyxNQUFNLGdCQUFnQixhQUFhLGtCQUFrQixJQUFJLE1BQU07QUFDNVIsZUFBZSxLQUFLLFNBQVMsRUFBRSxRQUFRLElBQUksY0FBYyxzQ0FBc0MsSUFBSSxRQUFRLFNBQVMsU0FBUyxNQUFNLHlCQUF5Qiw0Q0FBNEMsZUFBZSxJQUFJLHNCQUFzQixTQUFTLFVBQVUsZUFBZSxJQUFJLE1BQU0sU0FBUyxTQUFTLE1BQU0sc0JBQXNCLElBQUksTUFBTSxTQUFTLFdBQVcsU0FBUyxnQkFBZ0IsVUFBVSxPQUFPLE1BQU0sZ0JBQWdCLGFBQWEsa0JBQWtCLElBQUksTUFBTTtBQUNsZCw2UUFBNlEsYUFBYTtBQUMxUixlQUFlLDJCQUEyQixnQ0FBZ0Msb0RBQW9ELElBQUksa0JBQWtCLGVBQWUsMkJBQTJCLFNBQVMscUJBQXFCLDBDQUEwQyxVQUFVO0FBQ2hSLGlCQUFpQixxQkFBcUIsUUFBUSxzQkFBc0Isa0VBQWtFLHVDQUF1QyxlQUFlLHlFQUF5RSxnQkFBZ0IsU0FBUyxLQUFLLGNBQWMsWUFBWSxNQUFNLFlBQVksTUFBTSxhQUFhLE1BQU0sb0JBQW9CLE1BQU0sYUFBYSx3QkFBd0IscUJBQXFCO0FBQzViLGlCQUFpQixNQUFNLEtBQUssaUNBQWlDLHFCQUFxQix3Q0FBd0Msc0JBQXNCLHFCQUFxQixtREFBbUQsS0FBSyxJQUFJLFFBQVEsS0FBSyxXQUFXLDJDQUEyQyxPQUFPLEtBQUssTUFBTSxTQUFTLFFBQVEsU0FBUyxLQUFLLGFBQWEsSUFBSSw4QkFBOEIsVUFBVSx3Q0FBd0MsZ0RBQWdEO0FBQ3RlLEtBQUssc0JBQXNCLHdIQUF3SCxpQkFBaUIsa0JBQWtCLFVBQVUsa0NBQWtDLG1CQUFtQixNQUFNLGVBQWUsMkNBQTJDLHFCQUFxQixtQkFBbUIsY0FBYyxJQUFJLGtDQUFrQyxNQUFNLDRDQUE0QyxNQUFNLFlBQVksTUFBTSxlQUFlO0FBQzFlLFFBQVEsZUFBZSxTQUFTLElBQUksRUFBRSxlQUFlLE9BQU8sT0FBTyxXQUFXLE1BQU0sSUFBSSxRQUFRLHdGQUF3RixTQUFTLDRDQUE0QyxNQUFNLFlBQVksTUFBTSxtQkFBbUIsTUFBTSwrQkFBK0IsVUFBVTtBQUN2VSxpQkFBaUIsU0FBUywyREFBMkQsVUFBVSxtQ0FBbUMsU0FBUyxlQUFlO0FBQzFKLGVBQWUsYUFBYSxFQUFFLGtCQUFrQixvQkFBb0IsK0NBQStDLFdBQVcsS0FBSywyQkFBMkIsVUFBVSxJQUFJLHVCQUF1QixTQUFTLFdBQVcsVUFBVSxpREFBaUQsS0FBSyxlQUFlLEtBQUssaUJBQWlCLEVBQUUsMENBQTBDLFdBQVcsMEJBQTBCLGFBQWE7QUFDMVosaUJBQWlCLE9BQU8sT0FBTyxvQkFBb0Isa0JBQWtCLHdCQUF3QixJQUFJLEVBQUUsc0JBQXNCLFFBQVEsT0FBTyxlQUFlLGlDQUFpQyxLQUFLLGNBQWMsbUNBQW1DLGNBQWMscUJBQXFCLFlBQVksdUJBQXVCLGdEQUFnRCw2QkFBNkIsbUNBQW1DLGtCQUFrQixZQUFZLFVBQVU7QUFDNWMsaUJBQWlCLFFBQVEsS0FBSyxJQUFJLFlBQVksUUFBUSxrQ0FBa0MsZUFBZSx1Q0FBdUMsUUFBUSxLQUFLLHdCQUF3QixJQUFJLHVDQUF1QyxRQUFRLHlDQUF5QyxjQUFjLGNBQWM7QUFDM1MsaUJBQWlCLG9CQUFvQixrQkFBa0Isc0JBQXNCLG1DQUFtQywyQkFBMkIsU0FBUyxFQUFFLFFBQVEsTUFBTSxjQUFjLGtDQUFrQywyQkFBMkIsTUFBTSxZQUFZLE1BQU0sS0FBSyxLQUFLLE1BQU0sYUFBYSxNQUFNLFlBQVksTUFBTSxhQUFhLE1BQU0sYUFBYSxNQUFNLDRCQUE0QixNQUFNLHFCQUFxQixXQUFXLElBQUksdUJBQXVCLE9BQU8sSUFBSSxRQUFRLFdBQVcsV0FBVyxjQUFjO0FBQ3RmLEVBQUUsWUFBWSx5Q0FBeUMsbUJBQW1CLHlCQUF5QixhQUFhLGFBQWEsU0FBUyxTQUFTLFlBQVksUUFBUTtBQUNuSyxpQkFBaUIsR0FBRyxRQUFRLElBQUksS0FBSyxjQUFjLE9BQU8sMEJBQTBCLFNBQVMsRUFBRSxjQUFjLDJCQUEyQixTQUFTLE1BQU0sS0FBSyxXQUFXLE1BQU0sS0FBSyxnQkFBZ0IsOEJBQThCLElBQUksS0FBSyxPQUFPLE1BQU0sR0FBRywyQkFBMkIsSUFBSSxlQUFlLDhEQUE4RCxvQkFBb0IsNENBQTRDLGtCQUFrQjtBQUN2YiwyREFBMkQsWUFBWSxhQUFhLGNBQWMsY0FBYyxvQkFBb0IsSUFBSSxJQUFJLG9CQUFvQixhQUFhLGNBQWMsU0FBUyxnQkFBZ0IsY0FBYyxRQUFRLEtBQUssY0FBYyxVQUFVLEtBQUssUUFBUSxpQkFBaUIscUJBQXFCLFlBQVksYUFBYSxvQ0FBb0MsY0FBYyxZQUFZLFNBQVMsWUFBWSxhQUFhLDRCQUE0QixJQUFJLEdBQUcsY0FBYztBQUNwZSxNQUFNLFdBQVcsZ0JBQWdCLFFBQVEsUUFBUSxXQUFXLDJCQUEyQixvSkFBb0osZUFBZSxNQUFNLFdBQVcsZ0JBQWdCLFFBQVEsU0FBUyxXQUFXLGdCQUFnQixNQUFNLFVBQVUsS0FBSyxnQ0FBZ0MsU0FBUyxNQUFNLFNBQVMsY0FBYyxpQkFBaUIsY0FBYztBQUNqYyxjQUFjLDJCQUEyQiwwREFBMEQsaUJBQWlCLFFBQVEsS0FBSyxXQUFXLGdDQUFnQyxPQUFPLEtBQUssTUFBTSxTQUFTLFFBQVEsU0FBUyxLQUFLLElBQUksYUFBYSxnQ0FBZ0MsT0FBTyxJQUFJLFNBQVMsY0FBYyxLQUFLLFNBQVMsT0FBTyxjQUFjLEtBQUssZ0JBQWdCLE9BQU8sZUFBZSwyQkFBMkIsK0JBQStCLG1CQUFtQjtBQUMzYyxlQUFlLFFBQVEsR0FBRyxrQkFBa0IsV0FBVyx3QkFBd0IsMEJBQTBCLElBQUksUUFBUSxLQUFLLFVBQVUsYUFBYSxlQUFlLElBQUksT0FBTyw2REFBNkQsS0FBSyxJQUFJLE9BQU8sUUFBUSxZQUFZLGFBQWEsSUFBSSxPQUFPLE1BQU0sZ0JBQWdCLGFBQWEsbUJBQW1CLHdCQUF3QixJQUFJLG1DQUFtQyxRQUFRLG9CQUFvQjtBQUNyYixxQkFBcUIsUUFBUSxpQkFBaUIsaUNBQWlDLGlCQUFpQixzQkFBc0Isd0JBQXdCLG9CQUFvQixrQkFBa0IscUNBQXFDLG9CQUFvQixxQkFBcUIsMkJBQTJCLFFBQVEsc0JBQXNCLDJFQUEyRSxLQUFLLFlBQVksR0FBRyxzQkFBc0Isa0NBQWtDLGdCQUFnQjtBQUNsZSxRQUFRLElBQUksUUFBUSxLQUFLLGdCQUFnQixRQUFRLFFBQVEsT0FBTyxRQUFRLFdBQVcsWUFBWSxVQUFVLEtBQUssSUFBSSxJQUFJLGdCQUFnQixpQkFBaUIsc0JBQXNCLGlCQUFpQixpQkFBaUIsa0JBQWtCLFVBQVUsMkNBQTJDLFdBQVcsc0JBQXNCLHVDQUF1QyxFQUFFLGlDQUFpQyw0QkFBNEIsaUJBQWlCLHVDQUF1QyxLQUFLO0FBQzFkLGNBQWMsY0FBYyxpQ0FBaUMsSUFBSSxtQkFBbUIsWUFBWSxzQkFBc0IsS0FBSyxLQUFLLFFBQVEsS0FBSyxpQ0FBaUMsUUFBUSxLQUFLLGdCQUFnQixTQUFTLEVBQUUsa0JBQWtCLHFCQUFxQixrQkFBa0IsYUFBYSxZQUFZLFdBQVcsS0FBSyxXQUFXLFFBQVEsU0FBUyxFQUFFLFFBQVEsY0FBYyxpQ0FBaUMsY0FBYywyQkFBMkIsVUFBVSxTQUFTLEVBQUUsSUFBSSwyQkFBMkIsTUFBTTtBQUNoZixHQUFHLE9BQU8sTUFBTSxhQUFhLFdBQVcsSUFBSSxNQUFNLE1BQU0sa0JBQWtCLGFBQWEsY0FBYyxhQUFhLGFBQWEsR0FBRyxnQkFBZ0IsZUFBZSxJQUFJLGlCQUFpQixLQUFLLHNEQUFzRCxZQUFZLFNBQVMsRUFBRSxJQUFJLG9DQUFvQyx3Q0FBd0MsZ0JBQWdCLGFBQWEsa0JBQWtCLElBQUksUUFBUSxZQUFZLGdCQUFnQixRQUFRLFNBQVMsRUFBRSxJQUFJLGNBQWM7QUFDcGQsaUJBQWlCLGVBQWUsU0FBUyxFQUFFLElBQUksMEJBQTBCLGNBQWMsZ0NBQWdDLFVBQVUsaUJBQWlCLFVBQVUsT0FBTyxRQUFRLGdCQUFnQixhQUFhLGtCQUFrQixJQUFJLFFBQVEsWUFBWSxJQUFJLEtBQUssd0RBQXdELCtCQUErQixXQUFXLEtBQUssU0FBUyxRQUFRLHFCQUFxQixTQUFTLG1CQUFtQixVQUFVLFlBQVksWUFBWSxNQUFNO0FBQzVjLGtCQUFrQix1QkFBdUIsVUFBVSxTQUFTLEVBQUUsY0FBYyxVQUFVLE1BQU0sbUJBQW1CLGtCQUFrQiwwSEFBMEgsVUFBVSxZQUFZLFlBQVksTUFBTSw4QkFBOEIsT0FBTztBQUN4VSxtQkFBbUIsa0JBQWtCLHNCQUFzQixNQUFNLGtDQUFrQyw4RUFBOEUsUUFBUSxpQkFBaUIsMkVBQTJFLFVBQVUsVUFBVSw4QkFBOEIsZUFBZSwwQkFBMEIsMEJBQTBCO0FBQzFZLGlCQUFpQixRQUFRLGNBQWMsMEJBQTBCLHNCQUFzQiwwQkFBMEIsTUFBTSxzQkFBc0IsTUFBTSw2QkFBNkIsc0JBQXNCLFFBQVE7QUFDOU0sbUJBQW1CLGtFQUFrRSxLQUFLLDZEQUE2RCw4QkFBOEIsc0RBQXNELFVBQVUsY0FBYyxvQkFBb0IsUUFBUSxpQkFBaUIsc0JBQXNCLFFBQVEscUJBQXFCLFdBQVcsV0FBVztBQUN6WCxrT0FBa08sU0FBUyx3QkFBd0IsR0FBRyxRQUFRLGlCQUFpQixVQUFVLGdCQUFnQixTQUFTLGNBQWMsVUFBVSxVQUFVLDBCQUEwQixRQUFRLDBCQUEwQixRQUFRLDJCQUEyQixRQUFRLHNDQUFzQyxRQUFRO0FBQ3pmLFFBQVEsU0FBUyxvRkFBb0Ysb0ZBQW9GLFVBQVUsTUFBTSxnQ0FBZ0MsaUJBQWlCLGtCQUFrQixZQUFZLFFBQVEsZUFBZSxzQkFBc0IsWUFBWSx3QkFBd0Isd0hBQXdIO0FBQ2plLGlDQUFpQyxzQkFBc0IsZ0JBQWdCLFFBQVEsZUFBZSxzQkFBc0IsZ0JBQWdCLFFBQVEsa0dBQWtHLEVBQUUscUNBQXFDLEtBQUssS0FBSyxVQUFVLFlBQVksUUFBUSxZQUFZLFVBQVUsU0FBUztBQUM1Viw0QkFBNEIsbUNBQW1DLHlCQUF5QixtSEFBbUgscUZBQXFGLCtDQUErQyx3REFBd0QseURBQXlELFdBQVcsa0JBQWtCLGlCQUFpQjtBQUM5ZSxVQUFVLHNCQUFzQixrQkFBa0IsOEJBQThCLHlDQUF5QyxZQUFZLFNBQVMsMENBQTBDLFNBQVMsRUFBRSxxQkFBcUIsYUFBYSxVQUFVLHlCQUF5QixTQUFTLEVBQUUsa0JBQWtCLGNBQWMsY0FBYyxRQUFRLG9CQUFvQixhQUFhLFdBQVcsZ0JBQWdCLDJDQUEyQyxhQUFhLFdBQVcsY0FBYyx1QkFBdUI7QUFDN2UsS0FBSyxXQUFXLE1BQU0sVUFBVSxrREFBa0Qsb0JBQW9CLFdBQVcsZ0NBQWdDLFdBQVcsY0FBYyx1QkFBdUIsVUFBVSxZQUFZLGVBQWUsdUJBQXVCLGFBQWEsU0FBUyxFQUFFLFVBQVUsT0FBTyxNQUFNLFlBQVksYUFBYSxrQkFBa0IsSUFBSSxNQUFNLFdBQVcsSUFBSSxxQkFBcUIsVUFBVSxTQUFTO0FBQ3haLFFBQVEsNEVBQTRFLCtDQUErQyxpS0FBaUsseUJBQXlCLHlCQUF5Qiw0QkFBNEIsaUJBQWlCO0FBQ25ZLHFCQUFxQixXQUFXLFdBQVcsbUZBQW1GLGFBQWEsY0FBYyxvQkFBb0IsOEVBQThFLFlBQVksK0JBQStCLG9CQUFvQiw2QkFBNkIsb0JBQW9CLHFCQUFxQix1QkFBdUIsZUFBZSxjQUFjO0FBQ3BiLGVBQWUsMENBQTBDLHlCQUF5QixhQUFhLG9CQUFvQixvQkFBb0I7QUFDdkksaUJBQWlCLGtCQUFrQixpTkFBaU4seUJBQXlCLDBCQUEwQixnQkFBZ0IsZ0JBQWdCLGdDQUFnQyxnQ0FBZ0MsNEJBQTRCLGlCQUFpQiw4QkFBOEI7QUFDbGQsb0JBQW9CLGdCQUFnQixZQUFZO0FBQ2hELHlCQUF5QixRQUFRLElBQUksc0NBQXNDLGdDQUFnQyxpQkFBaUIsb0NBQW9DLFlBQVksS0FBSyxNQUFNLDZEQUE2RCwyREFBMkQsMkRBQTJELDJCQUEyQiw0REFBNEQsYUFBYSxRQUFRLFlBQVksUUFBUTtBQUMxZSxRQUFRLGFBQWEsUUFBUSxhQUFhLE9BQU8sUUFBUSwyQ0FBMkMsY0FBYyxnQkFBZ0IsU0FBUyxVQUFVLFNBQVMscUJBQXFCLGNBQWMsVUFBVSxTQUFTLHFCQUFxQixlQUFlLGlCQUFpQixVQUFVLGFBQWEsYUFBYSxTQUFTLG1CQUFtQixpQkFBaUIsVUFBVTtBQUNwVyxtQkFBbUIsZ0RBQWdELFVBQVUsYUFBYSxvRkFBb0Y7QUFDOUssdUJBQXVCLFdBQVcscUJBQXFCLHdFQUF3RSxzQkFBc0Isd0RBQXdELHdCQUF3QixzQkFBc0IsNEJBQTRCLHdJQUF3SSx5QkFBeUIsd0JBQXdCLDBCQUEwQjtBQUMxZSxLQUFLLCtCQUErQixvQkFBb0IsK0JBQStCLG9CQUFvQixZQUFZLGNBQWMsaUJBQWlCLHFGQUFxRixNQUFNLFNBQVMsbUJBQW1CLGtFQUFrRSxPQUFPO0FBQ3RWLGVBQWUsZ0JBQWdCLG9CQUFvQixHQUFHLDRDQUE0QyxRQUFRLEdBQUcsY0FBYyw2QkFBNkIsUUFBUSxzQkFBc0Isd0RBQXdELFNBQVMsV0FBVyxnQkFBZ0IscUJBQXFCLGNBQWMsYUFBYSwwQkFBMEI7QUFDNVYsK0JBQStCLHlCQUF5QixtQkFBbUIsWUFBWSxNQUFNLFFBQVEsVUFBVSx1Q0FBdUMsVUFBVSxrQkFBa0IsVUFBVSxRQUFRLFNBQVMscUJBQXFCLDhCQUE4QixRQUFRLGdEQUFnRCxVQUFVLFdBQVcsV0FBVyxvQkFBb0IseUJBQXlCLFlBQVksa0NBQWtDO0FBQ25iLGVBQWUsWUFBWSx3QkFBd0Isb0JBQW9CLGdDQUFnQyxrQ0FBa0MsaUJBQWlCLGtCQUFrQixrQ0FBa0Msa0JBQWtCLDRCQUE0QixpQkFBaUIsUUFBUSx5QkFBeUIsY0FBYyxZQUFZLCtEQUErRCxrQkFBa0IsZUFBZTtBQUN4YSxvREFBb0QseUJBQXlCLGdDQUFnQyxtQkFBbUIscURBQXFELHlCQUF5QixhQUFhLHdCQUF3QixzQkFBc0IsY0FBYyxxQkFBcUIsRUFBRSxhQUFhLGVBQWU7QUFDMVUsb0RBQW9ELE1BQU0sV0FBVyxHQUFHLG9DQUFvQyxZQUFZLHFDQUFxQyxLQUFLLGlCQUFpQixlQUFlLGVBQWUsNkRBQTZELGVBQWUsNkhBQTZIO0FBQzFaLHVCQUF1QixNQUFNLDBCQUEwQixRQUFRLGFBQWEsWUFBWSxXQUFXLG1DQUFtQyx3QkFBd0IsZ0JBQWdCLGtDQUFrQyxLQUFLLFNBQVMsS0FBSyxjQUFjLGtCQUFrQiwwQkFBMEIsUUFBUSxhQUFhLFlBQVksV0FBVyx1Q0FBdUMsd0JBQXdCLGdCQUFnQixrQ0FBa0MsY0FBYyxZQUFZLEVBQUU7QUFDdGQsdUJBQXVCLDRCQUE0QixNQUFNLFFBQVEsMEJBQTBCLFFBQVEsYUFBYSxZQUFZLFdBQVcsWUFBWSxxQkFBcUIsYUFBYSxlQUFlLGNBQWMseUJBQXlCLHlDQUF5Qyx5QkFBeUIsMERBQTBELE1BQU0sc0JBQXNCLGNBQWMsYUFBYSxVQUFVLGFBQWE7QUFDcmIsZUFBZSxlQUFlLHNCQUFzQixhQUFhLFVBQVUsb0JBQW9CLGtCQUFrQixlQUFlLGVBQWUsc0JBQXNCLGFBQWEsVUFBVSxZQUFZLFVBQVUsY0FBYyxVQUFVLGlCQUFpQixRQUFRLElBQUksZUFBZSxRQUFRO0FBQzlSLG1CQUFtQixVQUFVLHFCQUFxQixTQUFTLDhCQUE4QixRQUFRLGFBQWEsZ0JBQWdCLDJFQUEyRSxRQUFRLFdBQVcsS0FBSyxXQUFXLDJCQUEyQixZQUFZLHlCQUF5QixNQUFNLFVBQVUsTUFBTSx3QkFBd0IsTUFBTSwyREFBMkQsTUFBTTtBQUNqYSxRQUFRLG9EQUFvRCxLQUFLO0FBQ2pFLFFBQVEsa2JBQWtiLFFBQVEsaUNBQWlDO0FBQ25lLDRLQUE0Syx3REFBd0Qsc0NBQXNDLHdDQUF3Qyx1QkFBdUIsV0FBVywwREFBMEQ7QUFDOVksb0JBQW9CLGVBQWUsa0VBQWtFLDhCQUE4Qix1QkFBdUIsa0JBQWtCLGVBQWUsOEJBQThCLG1CQUFtQix1S0FBdUssZ0NBQWdDLGdCQUFnQixrQ0FBa0M7QUFDcmUsbUJBQW1CLGFBQWEsdUJBQXVCLDJCQUEyQix3QkFBd0IsZUFBZSxvREFBb0QsMkJBQTJCLHVCQUF1QixRQUFRLDRCQUE0QixVQUFVLGlCQUFpQixhQUFhLGNBQWMsZUFBZSxpQkFBaUIsOEJBQThCO0FBQ3ZYLG1CQUFtQixpQkFBaUIsOEJBQThCLHNEQUFzRCx1S0FBdUsseUNBQXlDLGdCQUFnQixNQUFNLGFBQWEsV0FBVztBQUN0WCxHQUFHLGtCQUFrQixjQUFjLGlCQUFpQiw4QkFBOEIsMEJBQTBCLDhCQUE4QixhQUFhLDZCQUE2Qiw0Q0FBNEMsNkJBQTZCLDJCQUEyQixXQUFXLEVBQUUsVUFBVSwrQkFBK0I7QUFDOVUsMkNBQTJDLG1CQUFtQiw4QkFBOEIsMERBQTBELHVCQUF1QixlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnRzcC1zdHJlYW0tdmlld2VyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzP2NhNWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbi8qXG4gTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4qL1xuJ3VzZSBzdHJpY3QnO3ZhciBhYT1yZXF1aXJlKFwicmVhY3RcIiksY2E9cmVxdWlyZShcInNjaGVkdWxlclwiKTtmdW5jdGlvbiBwKGEpe2Zvcih2YXIgYj1cImh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PVwiK2EsYz0xO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspYis9XCImYXJnc1tdPVwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbY10pO3JldHVyblwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IFwiK2IrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwifXZhciBkYT1uZXcgU2V0LGVhPXt9O2Z1bmN0aW9uIGZhKGEsYil7aGEoYSxiKTtoYShhK1wiQ2FwdHVyZVwiLGIpfVxuZnVuY3Rpb24gaGEoYSxiKXtlYVthXT1iO2ZvcihhPTA7YTxiLmxlbmd0aDthKyspZGEuYWRkKGJbYV0pfVxudmFyIGlhPSEoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB3aW5kb3d8fFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93LmRvY3VtZW50fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KSxqYT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LGthPS9eWzpBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXVs6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcLS4wLTlcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwXSokLyxsYT1cbnt9LG1hPXt9O2Z1bmN0aW9uIG9hKGEpe2lmKGphLmNhbGwobWEsYSkpcmV0dXJuITA7aWYoamEuY2FsbChsYSxhKSlyZXR1cm4hMTtpZihrYS50ZXN0KGEpKXJldHVybiBtYVthXT0hMDtsYVthXT0hMDtyZXR1cm4hMX1mdW5jdGlvbiBwYShhLGIsYyxkKXtpZihudWxsIT09YyYmMD09PWMudHlwZSlyZXR1cm4hMTtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJmdW5jdGlvblwiOmNhc2UgXCJzeW1ib2xcIjpyZXR1cm4hMDtjYXNlIFwiYm9vbGVhblwiOmlmKGQpcmV0dXJuITE7aWYobnVsbCE9PWMpcmV0dXJuIWMuYWNjZXB0c0Jvb2xlYW5zO2E9YS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsNSk7cmV0dXJuXCJkYXRhLVwiIT09YSYmXCJhcmlhLVwiIT09YTtkZWZhdWx0OnJldHVybiExfX1cbmZ1bmN0aW9uIHFhKGEsYixjLGQpe2lmKG51bGw9PT1ifHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGJ8fHBhKGEsYixjLGQpKXJldHVybiEwO2lmKGQpcmV0dXJuITE7aWYobnVsbCE9PWMpc3dpdGNoKGMudHlwZSl7Y2FzZSAzOnJldHVybiFiO2Nhc2UgNDpyZXR1cm4hMT09PWI7Y2FzZSA1OnJldHVybiBpc05hTihiKTtjYXNlIDY6cmV0dXJuIGlzTmFOKGIpfHwxPmJ9cmV0dXJuITF9ZnVuY3Rpb24gdihhLGIsYyxkLGUsZixnKXt0aGlzLmFjY2VwdHNCb29sZWFucz0yPT09Ynx8Mz09PWJ8fDQ9PT1iO3RoaXMuYXR0cmlidXRlTmFtZT1kO3RoaXMuYXR0cmlidXRlTmFtZXNwYWNlPWU7dGhpcy5tdXN0VXNlUHJvcGVydHk9Yzt0aGlzLnByb3BlcnR5TmFtZT1hO3RoaXMudHlwZT1iO3RoaXMuc2FuaXRpemVVUkw9Zjt0aGlzLnJlbW92ZUVtcHR5U3RyaW5nPWd9dmFyIHo9e307XG5cImNoaWxkcmVuIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGRlZmF1bHRWYWx1ZSBkZWZhdWx0Q2hlY2tlZCBpbm5lckhUTUwgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyBzdHlsZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3pbYV09bmV3IHYoYSwwLCExLGEsbnVsbCwhMSwhMSl9KTtbW1wiYWNjZXB0Q2hhcnNldFwiLFwiYWNjZXB0LWNoYXJzZXRcIl0sW1wiY2xhc3NOYW1lXCIsXCJjbGFzc1wiXSxbXCJodG1sRm9yXCIsXCJmb3JcIl0sW1wiaHR0cEVxdWl2XCIsXCJodHRwLWVxdWl2XCJdXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWFbMF07eltiXT1uZXcgdihiLDEsITEsYVsxXSxudWxsLCExLCExKX0pO1tcImNvbnRlbnRFZGl0YWJsZVwiLFwiZHJhZ2dhYmxlXCIsXCJzcGVsbENoZWNrXCIsXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3pbYV09bmV3IHYoYSwyLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO1xuW1wiYXV0b1JldmVyc2VcIixcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcImZvY3VzYWJsZVwiLFwicHJlc2VydmVBbHBoYVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3pbYV09bmV3IHYoYSwyLCExLGEsbnVsbCwhMSwhMSl9KTtcImFsbG93RnVsbFNjcmVlbiBhc3luYyBhdXRvRm9jdXMgYXV0b1BsYXkgY29udHJvbHMgZGVmYXVsdCBkZWZlciBkaXNhYmxlZCBkaXNhYmxlUGljdHVyZUluUGljdHVyZSBkaXNhYmxlUmVtb3RlUGxheWJhY2sgZm9ybU5vVmFsaWRhdGUgaGlkZGVuIGxvb3Agbm9Nb2R1bGUgbm9WYWxpZGF0ZSBvcGVuIHBsYXlzSW5saW5lIHJlYWRPbmx5IHJlcXVpcmVkIHJldmVyc2VkIHNjb3BlZCBzZWFtbGVzcyBpdGVtU2NvcGVcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXt6W2FdPW5ldyB2KGEsMywhMSxhLnRvTG93ZXJDYXNlKCksbnVsbCwhMSwhMSl9KTtcbltcImNoZWNrZWRcIixcIm11bHRpcGxlXCIsXCJtdXRlZFwiLFwic2VsZWN0ZWRcIl0uZm9yRWFjaChmdW5jdGlvbihhKXt6W2FdPW5ldyB2KGEsMywhMCxhLG51bGwsITEsITEpfSk7W1wiY2FwdHVyZVwiLFwiZG93bmxvYWRcIl0uZm9yRWFjaChmdW5jdGlvbihhKXt6W2FdPW5ldyB2KGEsNCwhMSxhLG51bGwsITEsITEpfSk7W1wiY29sc1wiLFwicm93c1wiLFwic2l6ZVwiLFwic3BhblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3pbYV09bmV3IHYoYSw2LCExLGEsbnVsbCwhMSwhMSl9KTtbXCJyb3dTcGFuXCIsXCJzdGFydFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3pbYV09bmV3IHYoYSw1LCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO3ZhciByYT0vW1xcLTpdKFthLXpdKS9nO2Z1bmN0aW9uIHNhKGEpe3JldHVybiBhWzFdLnRvVXBwZXJDYXNlKCl9XG5cImFjY2VudC1oZWlnaHQgYWxpZ25tZW50LWJhc2VsaW5lIGFyYWJpYy1mb3JtIGJhc2VsaW5lLXNoaWZ0IGNhcC1oZWlnaHQgY2xpcC1wYXRoIGNsaXAtcnVsZSBjb2xvci1pbnRlcnBvbGF0aW9uIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyBjb2xvci1wcm9maWxlIGNvbG9yLXJlbmRlcmluZyBkb21pbmFudC1iYXNlbGluZSBlbmFibGUtYmFja2dyb3VuZCBmaWxsLW9wYWNpdHkgZmlsbC1ydWxlIGZsb29kLWNvbG9yIGZsb29kLW9wYWNpdHkgZm9udC1mYW1pbHkgZm9udC1zaXplIGZvbnQtc2l6ZS1hZGp1c3QgZm9udC1zdHJldGNoIGZvbnQtc3R5bGUgZm9udC12YXJpYW50IGZvbnQtd2VpZ2h0IGdseXBoLW5hbWUgZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCBnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCBob3Jpei1hZHYteCBob3Jpei1vcmlnaW4teCBpbWFnZS1yZW5kZXJpbmcgbGV0dGVyLXNwYWNpbmcgbGlnaHRpbmctY29sb3IgbWFya2VyLWVuZCBtYXJrZXItbWlkIG1hcmtlci1zdGFydCBvdmVybGluZS1wb3NpdGlvbiBvdmVybGluZS10aGlja25lc3MgcGFpbnQtb3JkZXIgcGFub3NlLTEgcG9pbnRlci1ldmVudHMgcmVuZGVyaW5nLWludGVudCBzaGFwZS1yZW5kZXJpbmcgc3RvcC1jb2xvciBzdG9wLW9wYWNpdHkgc3RyaWtldGhyb3VnaC1wb3NpdGlvbiBzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyBzdHJva2UtZGFzaGFycmF5IHN0cm9rZS1kYXNob2Zmc2V0IHN0cm9rZS1saW5lY2FwIHN0cm9rZS1saW5lam9pbiBzdHJva2UtbWl0ZXJsaW1pdCBzdHJva2Utb3BhY2l0eSBzdHJva2Utd2lkdGggdGV4dC1hbmNob3IgdGV4dC1kZWNvcmF0aW9uIHRleHQtcmVuZGVyaW5nIHVuZGVybGluZS1wb3NpdGlvbiB1bmRlcmxpbmUtdGhpY2tuZXNzIHVuaWNvZGUtYmlkaSB1bmljb2RlLXJhbmdlIHVuaXRzLXBlci1lbSB2LWFscGhhYmV0aWMgdi1oYW5naW5nIHYtaWRlb2dyYXBoaWMgdi1tYXRoZW1hdGljYWwgdmVjdG9yLWVmZmVjdCB2ZXJ0LWFkdi15IHZlcnQtb3JpZ2luLXggdmVydC1vcmlnaW4teSB3b3JkLXNwYWNpbmcgd3JpdGluZy1tb2RlIHhtbG5zOnhsaW5rIHgtaGVpZ2h0XCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKHJhLFxuc2EpO3pbYl09bmV3IHYoYiwxLCExLGEsbnVsbCwhMSwhMSl9KTtcInhsaW5rOmFjdHVhdGUgeGxpbms6YXJjcm9sZSB4bGluazpyb2xlIHhsaW5rOnNob3cgeGxpbms6dGl0bGUgeGxpbms6dHlwZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShyYSxzYSk7eltiXT1uZXcgdihiLDEsITEsYSxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwhMSwhMSl9KTtbXCJ4bWw6YmFzZVwiLFwieG1sOmxhbmdcIixcInhtbDpzcGFjZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShyYSxzYSk7eltiXT1uZXcgdihiLDEsITEsYSxcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLCExLCExKX0pO1tcInRhYkluZGV4XCIsXCJjcm9zc09yaWdpblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3pbYV09bmV3IHYoYSwxLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCExLCExKX0pO1xuei54bGlua0hyZWY9bmV3IHYoXCJ4bGlua0hyZWZcIiwxLCExLFwieGxpbms6aHJlZlwiLFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCEwLCExKTtbXCJzcmNcIixcImhyZWZcIixcImFjdGlvblwiLFwiZm9ybUFjdGlvblwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3pbYV09bmV3IHYoYSwxLCExLGEudG9Mb3dlckNhc2UoKSxudWxsLCEwLCEwKX0pO1xuZnVuY3Rpb24gdGEoYSxiLGMsZCl7dmFyIGU9ei5oYXNPd25Qcm9wZXJ0eShiKT96W2JdOm51bGw7aWYobnVsbCE9PWU/MCE9PWUudHlwZTpkfHwhKDI8Yi5sZW5ndGgpfHxcIm9cIiE9PWJbMF0mJlwiT1wiIT09YlswXXx8XCJuXCIhPT1iWzFdJiZcIk5cIiE9PWJbMV0pcWEoYixjLGUsZCkmJihjPW51bGwpLGR8fG51bGw9PT1lP29hKGIpJiYobnVsbD09PWM/YS5yZW1vdmVBdHRyaWJ1dGUoYik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKTplLm11c3RVc2VQcm9wZXJ0eT9hW2UucHJvcGVydHlOYW1lXT1udWxsPT09Yz8zPT09ZS50eXBlPyExOlwiXCI6YzooYj1lLmF0dHJpYnV0ZU5hbWUsZD1lLmF0dHJpYnV0ZU5hbWVzcGFjZSxudWxsPT09Yz9hLnJlbW92ZUF0dHJpYnV0ZShiKTooZT1lLnR5cGUsYz0zPT09ZXx8ND09PWUmJiEwPT09Yz9cIlwiOlwiXCIrYyxkP2Euc2V0QXR0cmlidXRlTlMoZCxiLGMpOmEuc2V0QXR0cmlidXRlKGIsYykpKX1cbnZhciB1YT1hYS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCx2YT1TeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSx3YT1TeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLHlhPVN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSx6YT1TeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksQWE9U3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLEJhPVN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSxDYT1TeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxEYT1TeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksRWE9U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLEZhPVN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLEdhPVN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLEhhPVN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpO1N5bWJvbC5mb3IoXCJyZWFjdC5zY29wZVwiKTtTeW1ib2wuZm9yKFwicmVhY3QuZGVidWdfdHJhY2VfbW9kZVwiKTtcbnZhciBJYT1TeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpO1N5bWJvbC5mb3IoXCJyZWFjdC5sZWdhY3lfaGlkZGVuXCIpO1N5bWJvbC5mb3IoXCJyZWFjdC5jYWNoZVwiKTtTeW1ib2wuZm9yKFwicmVhY3QudHJhY2luZ19tYXJrZXJcIik7dmFyIEphPVN5bWJvbC5pdGVyYXRvcjtmdW5jdGlvbiBLYShhKXtpZihudWxsPT09YXx8XCJvYmplY3RcIiE9PXR5cGVvZiBhKXJldHVybiBudWxsO2E9SmEmJmFbSmFdfHxhW1wiQEBpdGVyYXRvclwiXTtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hOm51bGx9dmFyIEE9T2JqZWN0LmFzc2lnbixMYTtmdW5jdGlvbiBNYShhKXtpZih2b2lkIDA9PT1MYSl0cnl7dGhyb3cgRXJyb3IoKTt9Y2F0Y2goYyl7dmFyIGI9Yy5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtMYT1iJiZiWzFdfHxcIlwifXJldHVyblwiXFxuXCIrTGErYX12YXIgTmE9ITE7XG5mdW5jdGlvbiBPYShhLGIpe2lmKCFhfHxOYSlyZXR1cm5cIlwiO05hPSEwO3ZhciBjPUVycm9yLnByZXBhcmVTdGFja1RyYWNlO0Vycm9yLnByZXBhcmVTdGFja1RyYWNlPXZvaWQgMDt0cnl7aWYoYilpZihiPWZ1bmN0aW9uKCl7dGhyb3cgRXJyb3IoKTt9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcInByb3BzXCIse3NldDpmdW5jdGlvbigpe3Rocm93IEVycm9yKCk7fX0pLFwib2JqZWN0XCI9PT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5jb25zdHJ1Y3Qpe3RyeXtSZWZsZWN0LmNvbnN0cnVjdChiLFtdKX1jYXRjaChsKXt2YXIgZD1sfVJlZmxlY3QuY29uc3RydWN0KGEsW10sYil9ZWxzZXt0cnl7Yi5jYWxsKCl9Y2F0Y2gobCl7ZD1sfWEuY2FsbChiLnByb3RvdHlwZSl9ZWxzZXt0cnl7dGhyb3cgRXJyb3IoKTt9Y2F0Y2gobCl7ZD1sfWEoKX19Y2F0Y2gobCl7aWYobCYmZCYmXCJzdHJpbmdcIj09PXR5cGVvZiBsLnN0YWNrKXtmb3IodmFyIGU9bC5zdGFjay5zcGxpdChcIlxcblwiKSxcbmY9ZC5zdGFjay5zcGxpdChcIlxcblwiKSxnPWUubGVuZ3RoLTEsaD1mLmxlbmd0aC0xOzE8PWcmJjA8PWgmJmVbZ10hPT1mW2hdOyloLS07Zm9yKDsxPD1nJiYwPD1oO2ctLSxoLS0paWYoZVtnXSE9PWZbaF0pe2lmKDEhPT1nfHwxIT09aCl7ZG8gaWYoZy0tLGgtLSwwPmh8fGVbZ10hPT1mW2hdKXt2YXIgaz1cIlxcblwiK2VbZ10ucmVwbGFjZShcIiBhdCBuZXcgXCIsXCIgYXQgXCIpO2EuZGlzcGxheU5hbWUmJmsuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSYmKGs9ay5yZXBsYWNlKFwiPGFub255bW91cz5cIixhLmRpc3BsYXlOYW1lKSk7cmV0dXJuIGt9d2hpbGUoMTw9ZyYmMDw9aCl9YnJlYWt9fX1maW5hbGx5e05hPSExLEVycm9yLnByZXBhcmVTdGFja1RyYWNlPWN9cmV0dXJuKGE9YT9hLmRpc3BsYXlOYW1lfHxhLm5hbWU6XCJcIik/TWEoYSk6XCJcIn1cbmZ1bmN0aW9uIFBhKGEpe3N3aXRjaChhLnRhZyl7Y2FzZSA1OnJldHVybiBNYShhLnR5cGUpO2Nhc2UgMTY6cmV0dXJuIE1hKFwiTGF6eVwiKTtjYXNlIDEzOnJldHVybiBNYShcIlN1c3BlbnNlXCIpO2Nhc2UgMTk6cmV0dXJuIE1hKFwiU3VzcGVuc2VMaXN0XCIpO2Nhc2UgMDpjYXNlIDI6Y2FzZSAxNTpyZXR1cm4gYT1PYShhLnR5cGUsITEpLGE7Y2FzZSAxMTpyZXR1cm4gYT1PYShhLnR5cGUucmVuZGVyLCExKSxhO2Nhc2UgMTpyZXR1cm4gYT1PYShhLnR5cGUsITApLGE7ZGVmYXVsdDpyZXR1cm5cIlwifX1cbmZ1bmN0aW9uIFFhKGEpe2lmKG51bGw9PWEpcmV0dXJuIG51bGw7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGEpcmV0dXJuIGEuZGlzcGxheU5hbWV8fGEubmFtZXx8bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpcmV0dXJuIGE7c3dpdGNoKGEpe2Nhc2UgeWE6cmV0dXJuXCJGcmFnbWVudFwiO2Nhc2Ugd2E6cmV0dXJuXCJQb3J0YWxcIjtjYXNlIEFhOnJldHVyblwiUHJvZmlsZXJcIjtjYXNlIHphOnJldHVyblwiU3RyaWN0TW9kZVwiO2Nhc2UgRWE6cmV0dXJuXCJTdXNwZW5zZVwiO2Nhc2UgRmE6cmV0dXJuXCJTdXNwZW5zZUxpc3RcIn1pZihcIm9iamVjdFwiPT09dHlwZW9mIGEpc3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2UgQ2E6cmV0dXJuKGEuZGlzcGxheU5hbWV8fFwiQ29udGV4dFwiKStcIi5Db25zdW1lclwiO2Nhc2UgQmE6cmV0dXJuKGEuX2NvbnRleHQuZGlzcGxheU5hbWV8fFwiQ29udGV4dFwiKStcIi5Qcm92aWRlclwiO2Nhc2UgRGE6dmFyIGI9YS5yZW5kZXI7YT1hLmRpc3BsYXlOYW1lO2F8fChhPWIuZGlzcGxheU5hbWV8fFxuYi5uYW1lfHxcIlwiLGE9XCJcIiE9PWE/XCJGb3J3YXJkUmVmKFwiK2ErXCIpXCI6XCJGb3J3YXJkUmVmXCIpO3JldHVybiBhO2Nhc2UgR2E6cmV0dXJuIGI9YS5kaXNwbGF5TmFtZXx8bnVsbCxudWxsIT09Yj9iOlFhKGEudHlwZSl8fFwiTWVtb1wiO2Nhc2UgSGE6Yj1hLl9wYXlsb2FkO2E9YS5faW5pdDt0cnl7cmV0dXJuIFFhKGEoYikpfWNhdGNoKGMpe319cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBSYShhKXt2YXIgYj1hLnR5cGU7c3dpdGNoKGEudGFnKXtjYXNlIDI0OnJldHVyblwiQ2FjaGVcIjtjYXNlIDk6cmV0dXJuKGIuZGlzcGxheU5hbWV8fFwiQ29udGV4dFwiKStcIi5Db25zdW1lclwiO2Nhc2UgMTA6cmV0dXJuKGIuX2NvbnRleHQuZGlzcGxheU5hbWV8fFwiQ29udGV4dFwiKStcIi5Qcm92aWRlclwiO2Nhc2UgMTg6cmV0dXJuXCJEZWh5ZHJhdGVkRnJhZ21lbnRcIjtjYXNlIDExOnJldHVybiBhPWIucmVuZGVyLGE9YS5kaXNwbGF5TmFtZXx8YS5uYW1lfHxcIlwiLGIuZGlzcGxheU5hbWV8fChcIlwiIT09YT9cIkZvcndhcmRSZWYoXCIrYStcIilcIjpcIkZvcndhcmRSZWZcIik7Y2FzZSA3OnJldHVyblwiRnJhZ21lbnRcIjtjYXNlIDU6cmV0dXJuIGI7Y2FzZSA0OnJldHVyblwiUG9ydGFsXCI7Y2FzZSAzOnJldHVyblwiUm9vdFwiO2Nhc2UgNjpyZXR1cm5cIlRleHRcIjtjYXNlIDE2OnJldHVybiBRYShiKTtjYXNlIDg6cmV0dXJuIGI9PT16YT9cIlN0cmljdE1vZGVcIjpcIk1vZGVcIjtjYXNlIDIyOnJldHVyblwiT2Zmc2NyZWVuXCI7XG5jYXNlIDEyOnJldHVyblwiUHJvZmlsZXJcIjtjYXNlIDIxOnJldHVyblwiU2NvcGVcIjtjYXNlIDEzOnJldHVyblwiU3VzcGVuc2VcIjtjYXNlIDE5OnJldHVyblwiU3VzcGVuc2VMaXN0XCI7Y2FzZSAyNTpyZXR1cm5cIlRyYWNpbmdNYXJrZXJcIjtjYXNlIDE6Y2FzZSAwOmNhc2UgMTc6Y2FzZSAyOmNhc2UgMTQ6Y2FzZSAxNTppZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYilyZXR1cm4gYi5kaXNwbGF5TmFtZXx8Yi5uYW1lfHxudWxsO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYilyZXR1cm4gYn1yZXR1cm4gbnVsbH1mdW5jdGlvbiBTYShhKXtzd2l0Y2godHlwZW9mIGEpe2Nhc2UgXCJib29sZWFuXCI6Y2FzZSBcIm51bWJlclwiOmNhc2UgXCJzdHJpbmdcIjpjYXNlIFwidW5kZWZpbmVkXCI6cmV0dXJuIGE7Y2FzZSBcIm9iamVjdFwiOnJldHVybiBhO2RlZmF1bHQ6cmV0dXJuXCJcIn19XG5mdW5jdGlvbiBUYShhKXt2YXIgYj1hLnR5cGU7cmV0dXJuKGE9YS5ub2RlTmFtZSkmJlwiaW5wdXRcIj09PWEudG9Mb3dlckNhc2UoKSYmKFwiY2hlY2tib3hcIj09PWJ8fFwicmFkaW9cIj09PWIpfVxuZnVuY3Rpb24gVWEoYSl7dmFyIGI9VGEoYSk/XCJjaGVja2VkXCI6XCJ2YWx1ZVwiLGM9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxiKSxkPVwiXCIrYVtiXTtpZighYS5oYXNPd25Qcm9wZXJ0eShiKSYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5nZXQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLnNldCl7dmFyIGU9Yy5nZXQsZj1jLnNldDtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGUuY2FsbCh0aGlzKX0sc2V0OmZ1bmN0aW9uKGEpe2Q9XCJcIithO2YuY2FsbCh0aGlzLGEpfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGIse2VudW1lcmFibGU6Yy5lbnVtZXJhYmxlfSk7cmV0dXJue2dldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGR9LHNldFZhbHVlOmZ1bmN0aW9uKGEpe2Q9XCJcIithfSxzdG9wVHJhY2tpbmc6ZnVuY3Rpb24oKXthLl92YWx1ZVRyYWNrZXI9XG5udWxsO2RlbGV0ZSBhW2JdfX19fWZ1bmN0aW9uIFZhKGEpe2EuX3ZhbHVlVHJhY2tlcnx8KGEuX3ZhbHVlVHJhY2tlcj1VYShhKSl9ZnVuY3Rpb24gV2EoYSl7aWYoIWEpcmV0dXJuITE7dmFyIGI9YS5fdmFsdWVUcmFja2VyO2lmKCFiKXJldHVybiEwO3ZhciBjPWIuZ2V0VmFsdWUoKTt2YXIgZD1cIlwiO2EmJihkPVRhKGEpP2EuY2hlY2tlZD9cInRydWVcIjpcImZhbHNlXCI6YS52YWx1ZSk7YT1kO3JldHVybiBhIT09Yz8oYi5zZXRWYWx1ZShhKSwhMCk6ITF9ZnVuY3Rpb24gWGEoYSl7YT1hfHwoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudD9kb2N1bWVudDp2b2lkIDApO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYSlyZXR1cm4gbnVsbDt0cnl7cmV0dXJuIGEuYWN0aXZlRWxlbWVudHx8YS5ib2R5fWNhdGNoKGIpe3JldHVybiBhLmJvZHl9fVxuZnVuY3Rpb24gWWEoYSxiKXt2YXIgYz1iLmNoZWNrZWQ7cmV0dXJuIEEoe30sYix7ZGVmYXVsdENoZWNrZWQ6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsdmFsdWU6dm9pZCAwLGNoZWNrZWQ6bnVsbCE9Yz9jOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZH0pfWZ1bmN0aW9uIFphKGEsYil7dmFyIGM9bnVsbD09Yi5kZWZhdWx0VmFsdWU/XCJcIjpiLmRlZmF1bHRWYWx1ZSxkPW51bGwhPWIuY2hlY2tlZD9iLmNoZWNrZWQ6Yi5kZWZhdWx0Q2hlY2tlZDtjPVNhKG51bGwhPWIudmFsdWU/Yi52YWx1ZTpjKTthLl93cmFwcGVyU3RhdGU9e2luaXRpYWxDaGVja2VkOmQsaW5pdGlhbFZhbHVlOmMsY29udHJvbGxlZDpcImNoZWNrYm94XCI9PT1iLnR5cGV8fFwicmFkaW9cIj09PWIudHlwZT9udWxsIT1iLmNoZWNrZWQ6bnVsbCE9Yi52YWx1ZX19ZnVuY3Rpb24gYWIoYSxiKXtiPWIuY2hlY2tlZDtudWxsIT1iJiZ0YShhLFwiY2hlY2tlZFwiLGIsITEpfVxuZnVuY3Rpb24gYmIoYSxiKXthYihhLGIpO3ZhciBjPVNhKGIudmFsdWUpLGQ9Yi50eXBlO2lmKG51bGwhPWMpaWYoXCJudW1iZXJcIj09PWQpe2lmKDA9PT1jJiZcIlwiPT09YS52YWx1ZXx8YS52YWx1ZSE9YylhLnZhbHVlPVwiXCIrY31lbHNlIGEudmFsdWUhPT1cIlwiK2MmJihhLnZhbHVlPVwiXCIrYyk7ZWxzZSBpZihcInN1Ym1pdFwiPT09ZHx8XCJyZXNldFwiPT09ZCl7YS5yZW1vdmVBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtyZXR1cm59Yi5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpP2NiKGEsYi50eXBlLGMpOmIuaGFzT3duUHJvcGVydHkoXCJkZWZhdWx0VmFsdWVcIikmJmNiKGEsYi50eXBlLFNhKGIuZGVmYXVsdFZhbHVlKSk7bnVsbD09Yi5jaGVja2VkJiZudWxsIT1iLmRlZmF1bHRDaGVja2VkJiYoYS5kZWZhdWx0Q2hlY2tlZD0hIWIuZGVmYXVsdENoZWNrZWQpfVxuZnVuY3Rpb24gZGIoYSxiLGMpe2lmKGIuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKXx8Yi5oYXNPd25Qcm9wZXJ0eShcImRlZmF1bHRWYWx1ZVwiKSl7dmFyIGQ9Yi50eXBlO2lmKCEoXCJzdWJtaXRcIiE9PWQmJlwicmVzZXRcIiE9PWR8fHZvaWQgMCE9PWIudmFsdWUmJm51bGwhPT1iLnZhbHVlKSlyZXR1cm47Yj1cIlwiK2EuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU7Y3x8Yj09PWEudmFsdWV8fChhLnZhbHVlPWIpO2EuZGVmYXVsdFZhbHVlPWJ9Yz1hLm5hbWU7XCJcIiE9PWMmJihhLm5hbWU9XCJcIik7YS5kZWZhdWx0Q2hlY2tlZD0hIWEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZDtcIlwiIT09YyYmKGEubmFtZT1jKX1cbmZ1bmN0aW9uIGNiKGEsYixjKXtpZihcIm51bWJlclwiIT09Ynx8WGEoYS5vd25lckRvY3VtZW50KSE9PWEpbnVsbD09Yz9hLmRlZmF1bHRWYWx1ZT1cIlwiK2EuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU6YS5kZWZhdWx0VmFsdWUhPT1cIlwiK2MmJihhLmRlZmF1bHRWYWx1ZT1cIlwiK2MpfXZhciBlYj1BcnJheS5pc0FycmF5O1xuZnVuY3Rpb24gZmIoYSxiLGMsZCl7YT1hLm9wdGlvbnM7aWYoYil7Yj17fTtmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKyliW1wiJFwiK2NbZV1dPSEwO2ZvcihjPTA7YzxhLmxlbmd0aDtjKyspZT1iLmhhc093blByb3BlcnR5KFwiJFwiK2FbY10udmFsdWUpLGFbY10uc2VsZWN0ZWQhPT1lJiYoYVtjXS5zZWxlY3RlZD1lKSxlJiZkJiYoYVtjXS5kZWZhdWx0U2VsZWN0ZWQ9ITApfWVsc2V7Yz1cIlwiK1NhKGMpO2I9bnVsbDtmb3IoZT0wO2U8YS5sZW5ndGg7ZSsrKXtpZihhW2VdLnZhbHVlPT09Yyl7YVtlXS5zZWxlY3RlZD0hMDtkJiYoYVtlXS5kZWZhdWx0U2VsZWN0ZWQ9ITApO3JldHVybn1udWxsIT09Ynx8YVtlXS5kaXNhYmxlZHx8KGI9YVtlXSl9bnVsbCE9PWImJihiLnNlbGVjdGVkPSEwKX19XG5mdW5jdGlvbiBnYihhLGIpe2lmKG51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpdGhyb3cgRXJyb3IocCg5MSkpO3JldHVybiBBKHt9LGIse3ZhbHVlOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLGNoaWxkcmVuOlwiXCIrYS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZX0pfWZ1bmN0aW9uIGhiKGEsYil7dmFyIGM9Yi52YWx1ZTtpZihudWxsPT1jKXtjPWIuY2hpbGRyZW47Yj1iLmRlZmF1bHRWYWx1ZTtpZihudWxsIT1jKXtpZihudWxsIT1iKXRocm93IEVycm9yKHAoOTIpKTtpZihlYihjKSl7aWYoMTxjLmxlbmd0aCl0aHJvdyBFcnJvcihwKDkzKSk7Yz1jWzBdfWI9Y31udWxsPT1iJiYoYj1cIlwiKTtjPWJ9YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsVmFsdWU6U2EoYyl9fVxuZnVuY3Rpb24gaWIoYSxiKXt2YXIgYz1TYShiLnZhbHVlKSxkPVNhKGIuZGVmYXVsdFZhbHVlKTtudWxsIT1jJiYoYz1cIlwiK2MsYyE9PWEudmFsdWUmJihhLnZhbHVlPWMpLG51bGw9PWIuZGVmYXVsdFZhbHVlJiZhLmRlZmF1bHRWYWx1ZSE9PWMmJihhLmRlZmF1bHRWYWx1ZT1jKSk7bnVsbCE9ZCYmKGEuZGVmYXVsdFZhbHVlPVwiXCIrZCl9ZnVuY3Rpb24gamIoYSl7dmFyIGI9YS50ZXh0Q29udGVudDtiPT09YS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSYmXCJcIiE9PWImJm51bGwhPT1iJiYoYS52YWx1ZT1iKX1mdW5jdGlvbiBrYihhKXtzd2l0Y2goYSl7Y2FzZSBcInN2Z1wiOnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtjYXNlIFwibWF0aFwiOnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiO2RlZmF1bHQ6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJ9fVxuZnVuY3Rpb24gbGIoYSxiKXtyZXR1cm4gbnVsbD09YXx8XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PT1hP2tiKGIpOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09PWEmJlwiZm9yZWlnbk9iamVjdFwiPT09Yj9cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjphfVxudmFyIG1iLG5iPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgTVNBcHAmJk1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uP2Z1bmN0aW9uKGIsYyxkLGUpe01TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uKCl7cmV0dXJuIGEoYixjLGQsZSl9KX06YX0oZnVuY3Rpb24oYSxiKXtpZihcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIhPT1hLm5hbWVzcGFjZVVSSXx8XCJpbm5lckhUTUxcImluIGEpYS5pbm5lckhUTUw9YjtlbHNle21iPW1ifHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO21iLmlubmVySFRNTD1cIjxzdmc+XCIrYi52YWx1ZU9mKCkudG9TdHJpbmcoKStcIjwvc3ZnPlwiO2ZvcihiPW1iLmZpcnN0Q2hpbGQ7YS5maXJzdENoaWxkOylhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7Zm9yKDtiLmZpcnN0Q2hpbGQ7KWEuYXBwZW5kQ2hpbGQoYi5maXJzdENoaWxkKX19KTtcbmZ1bmN0aW9uIG9iKGEsYil7aWYoYil7dmFyIGM9YS5maXJzdENoaWxkO2lmKGMmJmM9PT1hLmxhc3RDaGlsZCYmMz09PWMubm9kZVR5cGUpe2Mubm9kZVZhbHVlPWI7cmV0dXJufX1hLnRleHRDb250ZW50PWJ9XG52YXIgcGI9e2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiEwLGFzcGVjdFJhdGlvOiEwLGJvcmRlckltYWdlT3V0c2V0OiEwLGJvcmRlckltYWdlU2xpY2U6ITAsYm9yZGVySW1hZ2VXaWR0aDohMCxib3hGbGV4OiEwLGJveEZsZXhHcm91cDohMCxib3hPcmRpbmFsR3JvdXA6ITAsY29sdW1uQ291bnQ6ITAsY29sdW1uczohMCxmbGV4OiEwLGZsZXhHcm93OiEwLGZsZXhQb3NpdGl2ZTohMCxmbGV4U2hyaW5rOiEwLGZsZXhOZWdhdGl2ZTohMCxmbGV4T3JkZXI6ITAsZ3JpZEFyZWE6ITAsZ3JpZFJvdzohMCxncmlkUm93RW5kOiEwLGdyaWRSb3dTcGFuOiEwLGdyaWRSb3dTdGFydDohMCxncmlkQ29sdW1uOiEwLGdyaWRDb2x1bW5FbmQ6ITAsZ3JpZENvbHVtblNwYW46ITAsZ3JpZENvbHVtblN0YXJ0OiEwLGZvbnRXZWlnaHQ6ITAsbGluZUNsYW1wOiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHRhYlNpemU6ITAsd2lkb3dzOiEwLHpJbmRleDohMCxcbnpvb206ITAsZmlsbE9wYWNpdHk6ITAsZmxvb2RPcGFjaXR5OiEwLHN0b3BPcGFjaXR5OiEwLHN0cm9rZURhc2hhcnJheTohMCxzdHJva2VEYXNob2Zmc2V0OiEwLHN0cm9rZU1pdGVybGltaXQ6ITAsc3Ryb2tlT3BhY2l0eTohMCxzdHJva2VXaWR0aDohMH0scWI9W1wiV2Via2l0XCIsXCJtc1wiLFwiTW96XCIsXCJPXCJdO09iamVjdC5rZXlzKHBiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3FiLmZvckVhY2goZnVuY3Rpb24oYil7Yj1iK2EuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zdWJzdHJpbmcoMSk7cGJbYl09cGJbYV19KX0pO2Z1bmN0aW9uIHJiKGEsYixjKXtyZXR1cm4gbnVsbD09Ynx8XCJib29sZWFuXCI9PT10eXBlb2YgYnx8XCJcIj09PWI/XCJcIjpjfHxcIm51bWJlclwiIT09dHlwZW9mIGJ8fDA9PT1ifHxwYi5oYXNPd25Qcm9wZXJ0eShhKSYmcGJbYV0/KFwiXCIrYikudHJpbSgpOmIrXCJweFwifVxuZnVuY3Rpb24gc2IoYSxiKXthPWEuc3R5bGU7Zm9yKHZhciBjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9MD09PWMuaW5kZXhPZihcIi0tXCIpLGU9cmIoYyxiW2NdLGQpO1wiZmxvYXRcIj09PWMmJihjPVwiY3NzRmxvYXRcIik7ZD9hLnNldFByb3BlcnR5KGMsZSk6YVtjXT1lfX12YXIgdGI9QSh7bWVudWl0ZW06ITB9LHthcmVhOiEwLGJhc2U6ITAsYnI6ITAsY29sOiEwLGVtYmVkOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9KTtcbmZ1bmN0aW9uIHViKGEsYil7aWYoYil7aWYodGJbYV0mJihudWxsIT1iLmNoaWxkcmVufHxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSl0aHJvdyBFcnJvcihwKDEzNyxhKSk7aWYobnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCl7aWYobnVsbCE9Yi5jaGlsZHJlbil0aHJvdyBFcnJvcihwKDYwKSk7aWYoXCJvYmplY3RcIiE9PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MfHwhKFwiX19odG1sXCJpbiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSl0aHJvdyBFcnJvcihwKDYxKSk7fWlmKG51bGwhPWIuc3R5bGUmJlwib2JqZWN0XCIhPT10eXBlb2YgYi5zdHlsZSl0aHJvdyBFcnJvcihwKDYyKSk7fX1cbmZ1bmN0aW9uIHZiKGEsYil7aWYoLTE9PT1hLmluZGV4T2YoXCItXCIpKXJldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYi5pcztzd2l0Y2goYSl7Y2FzZSBcImFubm90YXRpb24teG1sXCI6Y2FzZSBcImNvbG9yLXByb2ZpbGVcIjpjYXNlIFwiZm9udC1mYWNlXCI6Y2FzZSBcImZvbnQtZmFjZS1zcmNcIjpjYXNlIFwiZm9udC1mYWNlLXVyaVwiOmNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6Y2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6Y2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiEwfX12YXIgd2I9bnVsbDtmdW5jdGlvbiB4YihhKXthPWEudGFyZ2V0fHxhLnNyY0VsZW1lbnR8fHdpbmRvdzthLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50JiYoYT1hLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtyZXR1cm4gMz09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmF9dmFyIHliPW51bGwsemI9bnVsbCxBYj1udWxsO1xuZnVuY3Rpb24gQmIoYSl7aWYoYT1DYihhKSl7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIHliKXRocm93IEVycm9yKHAoMjgwKSk7dmFyIGI9YS5zdGF0ZU5vZGU7YiYmKGI9RGIoYikseWIoYS5zdGF0ZU5vZGUsYS50eXBlLGIpKX19ZnVuY3Rpb24gRWIoYSl7emI/QWI/QWIucHVzaChhKTpBYj1bYV06emI9YX1mdW5jdGlvbiBGYigpe2lmKHpiKXt2YXIgYT16YixiPUFiO0FiPXpiPW51bGw7QmIoYSk7aWYoYilmb3IoYT0wO2E8Yi5sZW5ndGg7YSsrKUJiKGJbYV0pfX1mdW5jdGlvbiBHYihhLGIpe3JldHVybiBhKGIpfWZ1bmN0aW9uIEhiKCl7fXZhciBJYj0hMTtmdW5jdGlvbiBKYihhLGIsYyl7aWYoSWIpcmV0dXJuIGEoYixjKTtJYj0hMDt0cnl7cmV0dXJuIEdiKGEsYixjKX1maW5hbGx5e2lmKEliPSExLG51bGwhPT16Ynx8bnVsbCE9PUFiKUhiKCksRmIoKX19XG5mdW5jdGlvbiBLYihhLGIpe3ZhciBjPWEuc3RhdGVOb2RlO2lmKG51bGw9PT1jKXJldHVybiBudWxsO3ZhciBkPURiKGMpO2lmKG51bGw9PT1kKXJldHVybiBudWxsO2M9ZFtiXTthOnN3aXRjaChiKXtjYXNlIFwib25DbGlja1wiOmNhc2UgXCJvbkNsaWNrQ2FwdHVyZVwiOmNhc2UgXCJvbkRvdWJsZUNsaWNrXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VEb3duXCI6Y2FzZSBcIm9uTW91c2VEb3duQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlTW92ZVwiOmNhc2UgXCJvbk1vdXNlTW92ZUNhcHR1cmVcIjpjYXNlIFwib25Nb3VzZVVwXCI6Y2FzZSBcIm9uTW91c2VVcENhcHR1cmVcIjpjYXNlIFwib25Nb3VzZUVudGVyXCI6KGQ9IWQuZGlzYWJsZWQpfHwoYT1hLnR5cGUsZD0hKFwiYnV0dG9uXCI9PT1hfHxcImlucHV0XCI9PT1hfHxcInNlbGVjdFwiPT09YXx8XCJ0ZXh0YXJlYVwiPT09YSkpO2E9IWQ7YnJlYWsgYTtkZWZhdWx0OmE9ITF9aWYoYSlyZXR1cm4gbnVsbDtpZihjJiZcImZ1bmN0aW9uXCIhPT1cbnR5cGVvZiBjKXRocm93IEVycm9yKHAoMjMxLGIsdHlwZW9mIGMpKTtyZXR1cm4gY312YXIgTGI9ITE7aWYoaWEpdHJ5e3ZhciBNYj17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoTWIsXCJwYXNzaXZlXCIse2dldDpmdW5jdGlvbigpe0xiPSEwfX0pO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLE1iLE1iKTt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRlc3RcIixNYixNYil9Y2F0Y2goYSl7TGI9ITF9ZnVuY3Rpb24gTmIoYSxiLGMsZCxlLGYsZyxoLGspe3ZhciBsPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywzKTt0cnl7Yi5hcHBseShjLGwpfWNhdGNoKG0pe3RoaXMub25FcnJvcihtKX19dmFyIE9iPSExLFBiPW51bGwsUWI9ITEsUmI9bnVsbCxTYj17b25FcnJvcjpmdW5jdGlvbihhKXtPYj0hMDtQYj1hfX07ZnVuY3Rpb24gVGIoYSxiLGMsZCxlLGYsZyxoLGspe09iPSExO1BiPW51bGw7TmIuYXBwbHkoU2IsYXJndW1lbnRzKX1cbmZ1bmN0aW9uIFViKGEsYixjLGQsZSxmLGcsaCxrKXtUYi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYoT2Ipe2lmKE9iKXt2YXIgbD1QYjtPYj0hMTtQYj1udWxsfWVsc2UgdGhyb3cgRXJyb3IocCgxOTgpKTtRYnx8KFFiPSEwLFJiPWwpfX1mdW5jdGlvbiBWYihhKXt2YXIgYj1hLGM9YTtpZihhLmFsdGVybmF0ZSlmb3IoO2IucmV0dXJuOyliPWIucmV0dXJuO2Vsc2V7YT1iO2RvIGI9YSwwIT09KGIuZmxhZ3MmNDA5OCkmJihjPWIucmV0dXJuKSxhPWIucmV0dXJuO3doaWxlKGEpfXJldHVybiAzPT09Yi50YWc/YzpudWxsfWZ1bmN0aW9uIFdiKGEpe2lmKDEzPT09YS50YWcpe3ZhciBiPWEubWVtb2l6ZWRTdGF0ZTtudWxsPT09YiYmKGE9YS5hbHRlcm5hdGUsbnVsbCE9PWEmJihiPWEubWVtb2l6ZWRTdGF0ZSkpO2lmKG51bGwhPT1iKXJldHVybiBiLmRlaHlkcmF0ZWR9cmV0dXJuIG51bGx9ZnVuY3Rpb24gWGIoYSl7aWYoVmIoYSkhPT1hKXRocm93IEVycm9yKHAoMTg4KSk7fVxuZnVuY3Rpb24gWWIoYSl7dmFyIGI9YS5hbHRlcm5hdGU7aWYoIWIpe2I9VmIoYSk7aWYobnVsbD09PWIpdGhyb3cgRXJyb3IocCgxODgpKTtyZXR1cm4gYiE9PWE/bnVsbDphfWZvcih2YXIgYz1hLGQ9Yjs7KXt2YXIgZT1jLnJldHVybjtpZihudWxsPT09ZSlicmVhazt2YXIgZj1lLmFsdGVybmF0ZTtpZihudWxsPT09Zil7ZD1lLnJldHVybjtpZihudWxsIT09ZCl7Yz1kO2NvbnRpbnVlfWJyZWFrfWlmKGUuY2hpbGQ9PT1mLmNoaWxkKXtmb3IoZj1lLmNoaWxkO2Y7KXtpZihmPT09YylyZXR1cm4gWGIoZSksYTtpZihmPT09ZClyZXR1cm4gWGIoZSksYjtmPWYuc2libGluZ310aHJvdyBFcnJvcihwKDE4OCkpO31pZihjLnJldHVybiE9PWQucmV0dXJuKWM9ZSxkPWY7ZWxzZXtmb3IodmFyIGc9ITEsaD1lLmNoaWxkO2g7KXtpZihoPT09Yyl7Zz0hMDtjPWU7ZD1mO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZTtjPWY7YnJlYWt9aD1oLnNpYmxpbmd9aWYoIWcpe2ZvcihoPWYuY2hpbGQ7aDspe2lmKGg9PT1cbmMpe2c9ITA7Yz1mO2Q9ZTticmVha31pZihoPT09ZCl7Zz0hMDtkPWY7Yz1lO2JyZWFrfWg9aC5zaWJsaW5nfWlmKCFnKXRocm93IEVycm9yKHAoMTg5KSk7fX1pZihjLmFsdGVybmF0ZSE9PWQpdGhyb3cgRXJyb3IocCgxOTApKTt9aWYoMyE9PWMudGFnKXRocm93IEVycm9yKHAoMTg4KSk7cmV0dXJuIGMuc3RhdGVOb2RlLmN1cnJlbnQ9PT1jP2E6Yn1mdW5jdGlvbiBaYihhKXthPVliKGEpO3JldHVybiBudWxsIT09YT8kYihhKTpudWxsfWZ1bmN0aW9uICRiKGEpe2lmKDU9PT1hLnRhZ3x8Nj09PWEudGFnKXJldHVybiBhO2ZvcihhPWEuY2hpbGQ7bnVsbCE9PWE7KXt2YXIgYj0kYihhKTtpZihudWxsIT09YilyZXR1cm4gYjthPWEuc2libGluZ31yZXR1cm4gbnVsbH1cbnZhciBhYz1jYS51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLGJjPWNhLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrLGNjPWNhLnVuc3RhYmxlX3Nob3VsZFlpZWxkLGRjPWNhLnVuc3RhYmxlX3JlcXVlc3RQYWludCxCPWNhLnVuc3RhYmxlX25vdyxlYz1jYS51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCxmYz1jYS51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSxnYz1jYS51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSxoYz1jYS51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxpYz1jYS51bnN0YWJsZV9Mb3dQcmlvcml0eSxqYz1jYS51bnN0YWJsZV9JZGxlUHJpb3JpdHksa2M9bnVsbCxsYz1udWxsO2Z1bmN0aW9uIG1jKGEpe2lmKGxjJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgbGMub25Db21taXRGaWJlclJvb3QpdHJ5e2xjLm9uQ29tbWl0RmliZXJSb290KGtjLGEsdm9pZCAwLDEyOD09PShhLmN1cnJlbnQuZmxhZ3MmMTI4KSl9Y2F0Y2goYil7fX1cbnZhciBvYz1NYXRoLmNsejMyP01hdGguY2x6MzI6bmMscGM9TWF0aC5sb2cscWM9TWF0aC5MTjI7ZnVuY3Rpb24gbmMoYSl7YT4+Pj0wO3JldHVybiAwPT09YT8zMjozMS0ocGMoYSkvcWN8MCl8MH12YXIgcmM9NjQsc2M9NDE5NDMwNDtcbmZ1bmN0aW9uIHRjKGEpe3N3aXRjaChhJi1hKXtjYXNlIDE6cmV0dXJuIDE7Y2FzZSAyOnJldHVybiAyO2Nhc2UgNDpyZXR1cm4gNDtjYXNlIDg6cmV0dXJuIDg7Y2FzZSAxNjpyZXR1cm4gMTY7Y2FzZSAzMjpyZXR1cm4gMzI7Y2FzZSA2NDpjYXNlIDEyODpjYXNlIDI1NjpjYXNlIDUxMjpjYXNlIDEwMjQ6Y2FzZSAyMDQ4OmNhc2UgNDA5NjpjYXNlIDgxOTI6Y2FzZSAxNjM4NDpjYXNlIDMyNzY4OmNhc2UgNjU1MzY6Y2FzZSAxMzEwNzI6Y2FzZSAyNjIxNDQ6Y2FzZSA1MjQyODg6Y2FzZSAxMDQ4NTc2OmNhc2UgMjA5NzE1MjpyZXR1cm4gYSY0MTk0MjQwO2Nhc2UgNDE5NDMwNDpjYXNlIDgzODg2MDg6Y2FzZSAxNjc3NzIxNjpjYXNlIDMzNTU0NDMyOmNhc2UgNjcxMDg4NjQ6cmV0dXJuIGEmMTMwMDIzNDI0O2Nhc2UgMTM0MjE3NzI4OnJldHVybiAxMzQyMTc3Mjg7Y2FzZSAyNjg0MzU0NTY6cmV0dXJuIDI2ODQzNTQ1NjtjYXNlIDUzNjg3MDkxMjpyZXR1cm4gNTM2ODcwOTEyO2Nhc2UgMTA3Mzc0MTgyNDpyZXR1cm4gMTA3Mzc0MTgyNDtcbmRlZmF1bHQ6cmV0dXJuIGF9fWZ1bmN0aW9uIHVjKGEsYil7dmFyIGM9YS5wZW5kaW5nTGFuZXM7aWYoMD09PWMpcmV0dXJuIDA7dmFyIGQ9MCxlPWEuc3VzcGVuZGVkTGFuZXMsZj1hLnBpbmdlZExhbmVzLGc9YyYyNjg0MzU0NTU7aWYoMCE9PWcpe3ZhciBoPWcmfmU7MCE9PWg/ZD10YyhoKTooZiY9ZywwIT09ZiYmKGQ9dGMoZikpKX1lbHNlIGc9YyZ+ZSwwIT09Zz9kPXRjKGcpOjAhPT1mJiYoZD10YyhmKSk7aWYoMD09PWQpcmV0dXJuIDA7aWYoMCE9PWImJmIhPT1kJiYwPT09KGImZSkmJihlPWQmLWQsZj1iJi1iLGU+PWZ8fDE2PT09ZSYmMCE9PShmJjQxOTQyNDApKSlyZXR1cm4gYjswIT09KGQmNCkmJihkfD1jJjE2KTtiPWEuZW50YW5nbGVkTGFuZXM7aWYoMCE9PWIpZm9yKGE9YS5lbnRhbmdsZW1lbnRzLGImPWQ7MDxiOyljPTMxLW9jKGIpLGU9MTw8YyxkfD1hW2NdLGImPX5lO3JldHVybiBkfVxuZnVuY3Rpb24gdmMoYSxiKXtzd2l0Y2goYSl7Y2FzZSAxOmNhc2UgMjpjYXNlIDQ6cmV0dXJuIGIrMjUwO2Nhc2UgODpjYXNlIDE2OmNhc2UgMzI6Y2FzZSA2NDpjYXNlIDEyODpjYXNlIDI1NjpjYXNlIDUxMjpjYXNlIDEwMjQ6Y2FzZSAyMDQ4OmNhc2UgNDA5NjpjYXNlIDgxOTI6Y2FzZSAxNjM4NDpjYXNlIDMyNzY4OmNhc2UgNjU1MzY6Y2FzZSAxMzEwNzI6Y2FzZSAyNjIxNDQ6Y2FzZSA1MjQyODg6Y2FzZSAxMDQ4NTc2OmNhc2UgMjA5NzE1MjpyZXR1cm4gYis1RTM7Y2FzZSA0MTk0MzA0OmNhc2UgODM4ODYwODpjYXNlIDE2Nzc3MjE2OmNhc2UgMzM1NTQ0MzI6Y2FzZSA2NzEwODg2NDpyZXR1cm4tMTtjYXNlIDEzNDIxNzcyODpjYXNlIDI2ODQzNTQ1NjpjYXNlIDUzNjg3MDkxMjpjYXNlIDEwNzM3NDE4MjQ6cmV0dXJuLTE7ZGVmYXVsdDpyZXR1cm4tMX19XG5mdW5jdGlvbiB3YyhhLGIpe2Zvcih2YXIgYz1hLnN1c3BlbmRlZExhbmVzLGQ9YS5waW5nZWRMYW5lcyxlPWEuZXhwaXJhdGlvblRpbWVzLGY9YS5wZW5kaW5nTGFuZXM7MDxmOyl7dmFyIGc9MzEtb2MoZiksaD0xPDxnLGs9ZVtnXTtpZigtMT09PWspe2lmKDA9PT0oaCZjKXx8MCE9PShoJmQpKWVbZ109dmMoaCxiKX1lbHNlIGs8PWImJihhLmV4cGlyZWRMYW5lc3w9aCk7ZiY9fmh9fWZ1bmN0aW9uIHhjKGEpe2E9YS5wZW5kaW5nTGFuZXMmLTEwNzM3NDE4MjU7cmV0dXJuIDAhPT1hP2E6YSYxMDczNzQxODI0PzEwNzM3NDE4MjQ6MH1mdW5jdGlvbiB5Yygpe3ZhciBhPXJjO3JjPDw9MTswPT09KHJjJjQxOTQyNDApJiYocmM9NjQpO3JldHVybiBhfWZ1bmN0aW9uIHpjKGEpe2Zvcih2YXIgYj1bXSxjPTA7MzE+YztjKyspYi5wdXNoKGEpO3JldHVybiBifVxuZnVuY3Rpb24gQWMoYSxiLGMpe2EucGVuZGluZ0xhbmVzfD1iOzUzNjg3MDkxMiE9PWImJihhLnN1c3BlbmRlZExhbmVzPTAsYS5waW5nZWRMYW5lcz0wKTthPWEuZXZlbnRUaW1lcztiPTMxLW9jKGIpO2FbYl09Y31mdW5jdGlvbiBCYyhhLGIpe3ZhciBjPWEucGVuZGluZ0xhbmVzJn5iO2EucGVuZGluZ0xhbmVzPWI7YS5zdXNwZW5kZWRMYW5lcz0wO2EucGluZ2VkTGFuZXM9MDthLmV4cGlyZWRMYW5lcyY9YjthLm11dGFibGVSZWFkTGFuZXMmPWI7YS5lbnRhbmdsZWRMYW5lcyY9YjtiPWEuZW50YW5nbGVtZW50czt2YXIgZD1hLmV2ZW50VGltZXM7Zm9yKGE9YS5leHBpcmF0aW9uVGltZXM7MDxjOyl7dmFyIGU9MzEtb2MoYyksZj0xPDxlO2JbZV09MDtkW2VdPS0xO2FbZV09LTE7YyY9fmZ9fVxuZnVuY3Rpb24gQ2MoYSxiKXt2YXIgYz1hLmVudGFuZ2xlZExhbmVzfD1iO2ZvcihhPWEuZW50YW5nbGVtZW50cztjOyl7dmFyIGQ9MzEtb2MoYyksZT0xPDxkO2UmYnxhW2RdJmImJihhW2RdfD1iKTtjJj1+ZX19dmFyIEM9MDtmdW5jdGlvbiBEYyhhKXthJj0tYTtyZXR1cm4gMTxhPzQ8YT8wIT09KGEmMjY4NDM1NDU1KT8xNjo1MzY4NzA5MTI6NDoxfXZhciBFYyxGYyxHYyxIYyxJYyxKYz0hMSxLYz1bXSxMYz1udWxsLE1jPW51bGwsTmM9bnVsbCxPYz1uZXcgTWFwLFBjPW5ldyBNYXAsUWM9W10sUmM9XCJtb3VzZWRvd24gbW91c2V1cCB0b3VjaGNhbmNlbCB0b3VjaGVuZCB0b3VjaHN0YXJ0IGF1eGNsaWNrIGRibGNsaWNrIHBvaW50ZXJjYW5jZWwgcG9pbnRlcmRvd24gcG9pbnRlcnVwIGRyYWdlbmQgZHJhZ3N0YXJ0IGRyb3AgY29tcG9zaXRpb25lbmQgY29tcG9zaXRpb25zdGFydCBrZXlkb3duIGtleXByZXNzIGtleXVwIGlucHV0IHRleHRJbnB1dCBjb3B5IGN1dCBwYXN0ZSBjbGljayBjaGFuZ2UgY29udGV4dG1lbnUgcmVzZXQgc3VibWl0XCIuc3BsaXQoXCIgXCIpO1xuZnVuY3Rpb24gU2MoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcImZvY3VzaW5cIjpjYXNlIFwiZm9jdXNvdXRcIjpMYz1udWxsO2JyZWFrO2Nhc2UgXCJkcmFnZW50ZXJcIjpjYXNlIFwiZHJhZ2xlYXZlXCI6TWM9bnVsbDticmVhaztjYXNlIFwibW91c2VvdmVyXCI6Y2FzZSBcIm1vdXNlb3V0XCI6TmM9bnVsbDticmVhaztjYXNlIFwicG9pbnRlcm92ZXJcIjpjYXNlIFwicG9pbnRlcm91dFwiOk9jLmRlbGV0ZShiLnBvaW50ZXJJZCk7YnJlYWs7Y2FzZSBcImdvdHBvaW50ZXJjYXB0dXJlXCI6Y2FzZSBcImxvc3Rwb2ludGVyY2FwdHVyZVwiOlBjLmRlbGV0ZShiLnBvaW50ZXJJZCl9fVxuZnVuY3Rpb24gVGMoYSxiLGMsZCxlLGYpe2lmKG51bGw9PT1hfHxhLm5hdGl2ZUV2ZW50IT09ZilyZXR1cm4gYT17YmxvY2tlZE9uOmIsZG9tRXZlbnROYW1lOmMsZXZlbnRTeXN0ZW1GbGFnczpkLG5hdGl2ZUV2ZW50OmYsdGFyZ2V0Q29udGFpbmVyczpbZV19LG51bGwhPT1iJiYoYj1DYihiKSxudWxsIT09YiYmRmMoYikpLGE7YS5ldmVudFN5c3RlbUZsYWdzfD1kO2I9YS50YXJnZXRDb250YWluZXJzO251bGwhPT1lJiYtMT09PWIuaW5kZXhPZihlKSYmYi5wdXNoKGUpO3JldHVybiBhfVxuZnVuY3Rpb24gVWMoYSxiLGMsZCxlKXtzd2l0Y2goYil7Y2FzZSBcImZvY3VzaW5cIjpyZXR1cm4gTGM9VGMoTGMsYSxiLGMsZCxlKSwhMDtjYXNlIFwiZHJhZ2VudGVyXCI6cmV0dXJuIE1jPVRjKE1jLGEsYixjLGQsZSksITA7Y2FzZSBcIm1vdXNlb3ZlclwiOnJldHVybiBOYz1UYyhOYyxhLGIsYyxkLGUpLCEwO2Nhc2UgXCJwb2ludGVyb3ZlclwiOnZhciBmPWUucG9pbnRlcklkO09jLnNldChmLFRjKE9jLmdldChmKXx8bnVsbCxhLGIsYyxkLGUpKTtyZXR1cm4hMDtjYXNlIFwiZ290cG9pbnRlcmNhcHR1cmVcIjpyZXR1cm4gZj1lLnBvaW50ZXJJZCxQYy5zZXQoZixUYyhQYy5nZXQoZil8fG51bGwsYSxiLGMsZCxlKSksITB9cmV0dXJuITF9XG5mdW5jdGlvbiBWYyhhKXt2YXIgYj1XYyhhLnRhcmdldCk7aWYobnVsbCE9PWIpe3ZhciBjPVZiKGIpO2lmKG51bGwhPT1jKWlmKGI9Yy50YWcsMTM9PT1iKXtpZihiPVdiKGMpLG51bGwhPT1iKXthLmJsb2NrZWRPbj1iO0ljKGEucHJpb3JpdHksZnVuY3Rpb24oKXtHYyhjKX0pO3JldHVybn19ZWxzZSBpZigzPT09YiYmYy5zdGF0ZU5vZGUuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCl7YS5ibG9ja2VkT249Mz09PWMudGFnP2Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm86bnVsbDtyZXR1cm59fWEuYmxvY2tlZE9uPW51bGx9XG5mdW5jdGlvbiBYYyhhKXtpZihudWxsIT09YS5ibG9ja2VkT24pcmV0dXJuITE7Zm9yKHZhciBiPWEudGFyZ2V0Q29udGFpbmVyczswPGIubGVuZ3RoOyl7dmFyIGM9WWMoYS5kb21FdmVudE5hbWUsYS5ldmVudFN5c3RlbUZsYWdzLGJbMF0sYS5uYXRpdmVFdmVudCk7aWYobnVsbD09PWMpe2M9YS5uYXRpdmVFdmVudDt2YXIgZD1uZXcgYy5jb25zdHJ1Y3RvcihjLnR5cGUsYyk7d2I9ZDtjLnRhcmdldC5kaXNwYXRjaEV2ZW50KGQpO3diPW51bGx9ZWxzZSByZXR1cm4gYj1DYihjKSxudWxsIT09YiYmRmMoYiksYS5ibG9ja2VkT249YywhMTtiLnNoaWZ0KCl9cmV0dXJuITB9ZnVuY3Rpb24gWmMoYSxiLGMpe1hjKGEpJiZjLmRlbGV0ZShiKX1mdW5jdGlvbiAkYygpe0pjPSExO251bGwhPT1MYyYmWGMoTGMpJiYoTGM9bnVsbCk7bnVsbCE9PU1jJiZYYyhNYykmJihNYz1udWxsKTtudWxsIT09TmMmJlhjKE5jKSYmKE5jPW51bGwpO09jLmZvckVhY2goWmMpO1BjLmZvckVhY2goWmMpfVxuZnVuY3Rpb24gYWQoYSxiKXthLmJsb2NrZWRPbj09PWImJihhLmJsb2NrZWRPbj1udWxsLEpjfHwoSmM9ITAsY2EudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhjYS51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSwkYykpKX1cbmZ1bmN0aW9uIGJkKGEpe2Z1bmN0aW9uIGIoYil7cmV0dXJuIGFkKGIsYSl9aWYoMDxLYy5sZW5ndGgpe2FkKEtjWzBdLGEpO2Zvcih2YXIgYz0xO2M8S2MubGVuZ3RoO2MrKyl7dmFyIGQ9S2NbY107ZC5ibG9ja2VkT249PT1hJiYoZC5ibG9ja2VkT249bnVsbCl9fW51bGwhPT1MYyYmYWQoTGMsYSk7bnVsbCE9PU1jJiZhZChNYyxhKTtudWxsIT09TmMmJmFkKE5jLGEpO09jLmZvckVhY2goYik7UGMuZm9yRWFjaChiKTtmb3IoYz0wO2M8UWMubGVuZ3RoO2MrKylkPVFjW2NdLGQuYmxvY2tlZE9uPT09YSYmKGQuYmxvY2tlZE9uPW51bGwpO2Zvcig7MDxRYy5sZW5ndGgmJihjPVFjWzBdLG51bGw9PT1jLmJsb2NrZWRPbik7KVZjKGMpLG51bGw9PT1jLmJsb2NrZWRPbiYmUWMuc2hpZnQoKX12YXIgY2Q9dWEuUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsZGQ9ITA7XG5mdW5jdGlvbiBlZChhLGIsYyxkKXt2YXIgZT1DLGY9Y2QudHJhbnNpdGlvbjtjZC50cmFuc2l0aW9uPW51bGw7dHJ5e0M9MSxmZChhLGIsYyxkKX1maW5hbGx5e0M9ZSxjZC50cmFuc2l0aW9uPWZ9fWZ1bmN0aW9uIGdkKGEsYixjLGQpe3ZhciBlPUMsZj1jZC50cmFuc2l0aW9uO2NkLnRyYW5zaXRpb249bnVsbDt0cnl7Qz00LGZkKGEsYixjLGQpfWZpbmFsbHl7Qz1lLGNkLnRyYW5zaXRpb249Zn19XG5mdW5jdGlvbiBmZChhLGIsYyxkKXtpZihkZCl7dmFyIGU9WWMoYSxiLGMsZCk7aWYobnVsbD09PWUpaGQoYSxiLGQsaWQsYyksU2MoYSxkKTtlbHNlIGlmKFVjKGUsYSxiLGMsZCkpZC5zdG9wUHJvcGFnYXRpb24oKTtlbHNlIGlmKFNjKGEsZCksYiY0JiYtMTxSYy5pbmRleE9mKGEpKXtmb3IoO251bGwhPT1lOyl7dmFyIGY9Q2IoZSk7bnVsbCE9PWYmJkVjKGYpO2Y9WWMoYSxiLGMsZCk7bnVsbD09PWYmJmhkKGEsYixkLGlkLGMpO2lmKGY9PT1lKWJyZWFrO2U9Zn1udWxsIT09ZSYmZC5zdG9wUHJvcGFnYXRpb24oKX1lbHNlIGhkKGEsYixkLG51bGwsYyl9fXZhciBpZD1udWxsO1xuZnVuY3Rpb24gWWMoYSxiLGMsZCl7aWQ9bnVsbDthPXhiKGQpO2E9V2MoYSk7aWYobnVsbCE9PWEpaWYoYj1WYihhKSxudWxsPT09YilhPW51bGw7ZWxzZSBpZihjPWIudGFnLDEzPT09Yyl7YT1XYihiKTtpZihudWxsIT09YSlyZXR1cm4gYTthPW51bGx9ZWxzZSBpZigzPT09Yyl7aWYoYi5zdGF0ZU5vZGUuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZClyZXR1cm4gMz09PWIudGFnP2Iuc3RhdGVOb2RlLmNvbnRhaW5lckluZm86bnVsbDthPW51bGx9ZWxzZSBiIT09YSYmKGE9bnVsbCk7aWQ9YTtyZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIGpkKGEpe3N3aXRjaChhKXtjYXNlIFwiY2FuY2VsXCI6Y2FzZSBcImNsaWNrXCI6Y2FzZSBcImNsb3NlXCI6Y2FzZSBcImNvbnRleHRtZW51XCI6Y2FzZSBcImNvcHlcIjpjYXNlIFwiY3V0XCI6Y2FzZSBcImF1eGNsaWNrXCI6Y2FzZSBcImRibGNsaWNrXCI6Y2FzZSBcImRyYWdlbmRcIjpjYXNlIFwiZHJhZ3N0YXJ0XCI6Y2FzZSBcImRyb3BcIjpjYXNlIFwiZm9jdXNpblwiOmNhc2UgXCJmb2N1c291dFwiOmNhc2UgXCJpbnB1dFwiOmNhc2UgXCJpbnZhbGlkXCI6Y2FzZSBcImtleWRvd25cIjpjYXNlIFwia2V5cHJlc3NcIjpjYXNlIFwia2V5dXBcIjpjYXNlIFwibW91c2Vkb3duXCI6Y2FzZSBcIm1vdXNldXBcIjpjYXNlIFwicGFzdGVcIjpjYXNlIFwicGF1c2VcIjpjYXNlIFwicGxheVwiOmNhc2UgXCJwb2ludGVyY2FuY2VsXCI6Y2FzZSBcInBvaW50ZXJkb3duXCI6Y2FzZSBcInBvaW50ZXJ1cFwiOmNhc2UgXCJyYXRlY2hhbmdlXCI6Y2FzZSBcInJlc2V0XCI6Y2FzZSBcInJlc2l6ZVwiOmNhc2UgXCJzZWVrZWRcIjpjYXNlIFwic3VibWl0XCI6Y2FzZSBcInRvdWNoY2FuY2VsXCI6Y2FzZSBcInRvdWNoZW5kXCI6Y2FzZSBcInRvdWNoc3RhcnRcIjpjYXNlIFwidm9sdW1lY2hhbmdlXCI6Y2FzZSBcImNoYW5nZVwiOmNhc2UgXCJzZWxlY3Rpb25jaGFuZ2VcIjpjYXNlIFwidGV4dElucHV0XCI6Y2FzZSBcImNvbXBvc2l0aW9uc3RhcnRcIjpjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpjYXNlIFwiY29tcG9zaXRpb251cGRhdGVcIjpjYXNlIFwiYmVmb3JlYmx1clwiOmNhc2UgXCJhZnRlcmJsdXJcIjpjYXNlIFwiYmVmb3JlaW5wdXRcIjpjYXNlIFwiYmx1clwiOmNhc2UgXCJmdWxsc2NyZWVuY2hhbmdlXCI6Y2FzZSBcImZvY3VzXCI6Y2FzZSBcImhhc2hjaGFuZ2VcIjpjYXNlIFwicG9wc3RhdGVcIjpjYXNlIFwic2VsZWN0XCI6Y2FzZSBcInNlbGVjdHN0YXJ0XCI6cmV0dXJuIDE7Y2FzZSBcImRyYWdcIjpjYXNlIFwiZHJhZ2VudGVyXCI6Y2FzZSBcImRyYWdleGl0XCI6Y2FzZSBcImRyYWdsZWF2ZVwiOmNhc2UgXCJkcmFnb3ZlclwiOmNhc2UgXCJtb3VzZW1vdmVcIjpjYXNlIFwibW91c2VvdXRcIjpjYXNlIFwibW91c2VvdmVyXCI6Y2FzZSBcInBvaW50ZXJtb3ZlXCI6Y2FzZSBcInBvaW50ZXJvdXRcIjpjYXNlIFwicG9pbnRlcm92ZXJcIjpjYXNlIFwic2Nyb2xsXCI6Y2FzZSBcInRvZ2dsZVwiOmNhc2UgXCJ0b3VjaG1vdmVcIjpjYXNlIFwid2hlZWxcIjpjYXNlIFwibW91c2VlbnRlclwiOmNhc2UgXCJtb3VzZWxlYXZlXCI6Y2FzZSBcInBvaW50ZXJlbnRlclwiOmNhc2UgXCJwb2ludGVybGVhdmVcIjpyZXR1cm4gNDtcbmNhc2UgXCJtZXNzYWdlXCI6c3dpdGNoKGVjKCkpe2Nhc2UgZmM6cmV0dXJuIDE7Y2FzZSBnYzpyZXR1cm4gNDtjYXNlIGhjOmNhc2UgaWM6cmV0dXJuIDE2O2Nhc2UgamM6cmV0dXJuIDUzNjg3MDkxMjtkZWZhdWx0OnJldHVybiAxNn1kZWZhdWx0OnJldHVybiAxNn19dmFyIGtkPW51bGwsbGQ9bnVsbCxtZD1udWxsO2Z1bmN0aW9uIG5kKCl7aWYobWQpcmV0dXJuIG1kO3ZhciBhLGI9bGQsYz1iLmxlbmd0aCxkLGU9XCJ2YWx1ZVwiaW4ga2Q/a2QudmFsdWU6a2QudGV4dENvbnRlbnQsZj1lLmxlbmd0aDtmb3IoYT0wO2E8YyYmYlthXT09PWVbYV07YSsrKTt2YXIgZz1jLWE7Zm9yKGQ9MTtkPD1nJiZiW2MtZF09PT1lW2YtZF07ZCsrKTtyZXR1cm4gbWQ9ZS5zbGljZShhLDE8ZD8xLWQ6dm9pZCAwKX1cbmZ1bmN0aW9uIG9kKGEpe3ZhciBiPWEua2V5Q29kZTtcImNoYXJDb2RlXCJpbiBhPyhhPWEuY2hhckNvZGUsMD09PWEmJjEzPT09YiYmKGE9MTMpKTphPWI7MTA9PT1hJiYoYT0xMyk7cmV0dXJuIDMyPD1hfHwxMz09PWE/YTowfWZ1bmN0aW9uIHBkKCl7cmV0dXJuITB9ZnVuY3Rpb24gcWQoKXtyZXR1cm4hMX1cbmZ1bmN0aW9uIHJkKGEpe2Z1bmN0aW9uIGIoYixkLGUsZixnKXt0aGlzLl9yZWFjdE5hbWU9Yjt0aGlzLl90YXJnZXRJbnN0PWU7dGhpcy50eXBlPWQ7dGhpcy5uYXRpdmVFdmVudD1mO3RoaXMudGFyZ2V0PWc7dGhpcy5jdXJyZW50VGFyZ2V0PW51bGw7Zm9yKHZhciBjIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShjKSYmKGI9YVtjXSx0aGlzW2NdPWI/YihmKTpmW2NdKTt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD0obnVsbCE9Zi5kZWZhdWx0UHJldmVudGVkP2YuZGVmYXVsdFByZXZlbnRlZDohMT09PWYucmV0dXJuVmFsdWUpP3BkOnFkO3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9cWQ7cmV0dXJuIHRoaXN9QShiLnByb3RvdHlwZSx7cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITA7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5wcmV2ZW50RGVmYXVsdD9hLnByZXZlbnREZWZhdWx0KCk6XCJ1bmtub3duXCIhPT10eXBlb2YgYS5yZXR1cm5WYWx1ZSYmXG4oYS5yZXR1cm5WYWx1ZT0hMSksdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9cGQpfSxzdG9wUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm5hdGl2ZUV2ZW50O2EmJihhLnN0b3BQcm9wYWdhdGlvbj9hLnN0b3BQcm9wYWdhdGlvbigpOlwidW5rbm93blwiIT09dHlwZW9mIGEuY2FuY2VsQnViYmxlJiYoYS5jYW5jZWxCdWJibGU9ITApLHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9cGQpfSxwZXJzaXN0OmZ1bmN0aW9uKCl7fSxpc1BlcnNpc3RlbnQ6cGR9KTtyZXR1cm4gYn1cbnZhciBzZD17ZXZlbnRQaGFzZTowLGJ1YmJsZXM6MCxjYW5jZWxhYmxlOjAsdGltZVN0YW1wOmZ1bmN0aW9uKGEpe3JldHVybiBhLnRpbWVTdGFtcHx8RGF0ZS5ub3coKX0sZGVmYXVsdFByZXZlbnRlZDowLGlzVHJ1c3RlZDowfSx0ZD1yZChzZCksdWQ9QSh7fSxzZCx7dmlldzowLGRldGFpbDowfSksdmQ9cmQodWQpLHdkLHhkLHlkLEFkPUEoe30sdWQse3NjcmVlblg6MCxzY3JlZW5ZOjAsY2xpZW50WDowLGNsaWVudFk6MCxwYWdlWDowLHBhZ2VZOjAsY3RybEtleTowLHNoaWZ0S2V5OjAsYWx0S2V5OjAsbWV0YUtleTowLGdldE1vZGlmaWVyU3RhdGU6emQsYnV0dG9uOjAsYnV0dG9uczowLHJlbGF0ZWRUYXJnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIHZvaWQgMD09PWEucmVsYXRlZFRhcmdldD9hLmZyb21FbGVtZW50PT09YS5zcmNFbGVtZW50P2EudG9FbGVtZW50OmEuZnJvbUVsZW1lbnQ6YS5yZWxhdGVkVGFyZ2V0fSxtb3ZlbWVudFg6ZnVuY3Rpb24oYSl7aWYoXCJtb3ZlbWVudFhcImluXG5hKXJldHVybiBhLm1vdmVtZW50WDthIT09eWQmJih5ZCYmXCJtb3VzZW1vdmVcIj09PWEudHlwZT8od2Q9YS5zY3JlZW5YLXlkLnNjcmVlblgseGQ9YS5zY3JlZW5ZLXlkLnNjcmVlblkpOnhkPXdkPTAseWQ9YSk7cmV0dXJuIHdkfSxtb3ZlbWVudFk6ZnVuY3Rpb24oYSl7cmV0dXJuXCJtb3ZlbWVudFlcImluIGE/YS5tb3ZlbWVudFk6eGR9fSksQmQ9cmQoQWQpLENkPUEoe30sQWQse2RhdGFUcmFuc2ZlcjowfSksRGQ9cmQoQ2QpLEVkPUEoe30sdWQse3JlbGF0ZWRUYXJnZXQ6MH0pLEZkPXJkKEVkKSxHZD1BKHt9LHNkLHthbmltYXRpb25OYW1lOjAsZWxhcHNlZFRpbWU6MCxwc2V1ZG9FbGVtZW50OjB9KSxIZD1yZChHZCksSWQ9QSh7fSxzZCx7Y2xpcGJvYXJkRGF0YTpmdW5jdGlvbihhKXtyZXR1cm5cImNsaXBib2FyZERhdGFcImluIGE/YS5jbGlwYm9hcmREYXRhOndpbmRvdy5jbGlwYm9hcmREYXRhfX0pLEpkPXJkKElkKSxLZD1BKHt9LHNkLHtkYXRhOjB9KSxMZD1yZChLZCksTWQ9e0VzYzpcIkVzY2FwZVwiLFxuU3BhY2ViYXI6XCIgXCIsTGVmdDpcIkFycm93TGVmdFwiLFVwOlwiQXJyb3dVcFwiLFJpZ2h0OlwiQXJyb3dSaWdodFwiLERvd246XCJBcnJvd0Rvd25cIixEZWw6XCJEZWxldGVcIixXaW46XCJPU1wiLE1lbnU6XCJDb250ZXh0TWVudVwiLEFwcHM6XCJDb250ZXh0TWVudVwiLFNjcm9sbDpcIlNjcm9sbExvY2tcIixNb3pQcmludGFibGVLZXk6XCJVbmlkZW50aWZpZWRcIn0sTmQ9ezg6XCJCYWNrc3BhY2VcIiw5OlwiVGFiXCIsMTI6XCJDbGVhclwiLDEzOlwiRW50ZXJcIiwxNjpcIlNoaWZ0XCIsMTc6XCJDb250cm9sXCIsMTg6XCJBbHRcIiwxOTpcIlBhdXNlXCIsMjA6XCJDYXBzTG9ja1wiLDI3OlwiRXNjYXBlXCIsMzI6XCIgXCIsMzM6XCJQYWdlVXBcIiwzNDpcIlBhZ2VEb3duXCIsMzU6XCJFbmRcIiwzNjpcIkhvbWVcIiwzNzpcIkFycm93TGVmdFwiLDM4OlwiQXJyb3dVcFwiLDM5OlwiQXJyb3dSaWdodFwiLDQwOlwiQXJyb3dEb3duXCIsNDU6XCJJbnNlcnRcIiw0NjpcIkRlbGV0ZVwiLDExMjpcIkYxXCIsMTEzOlwiRjJcIiwxMTQ6XCJGM1wiLDExNTpcIkY0XCIsMTE2OlwiRjVcIiwxMTc6XCJGNlwiLDExODpcIkY3XCIsXG4xMTk6XCJGOFwiLDEyMDpcIkY5XCIsMTIxOlwiRjEwXCIsMTIyOlwiRjExXCIsMTIzOlwiRjEyXCIsMTQ0OlwiTnVtTG9ja1wiLDE0NTpcIlNjcm9sbExvY2tcIiwyMjQ6XCJNZXRhXCJ9LE9kPXtBbHQ6XCJhbHRLZXlcIixDb250cm9sOlwiY3RybEtleVwiLE1ldGE6XCJtZXRhS2V5XCIsU2hpZnQ6XCJzaGlmdEtleVwifTtmdW5jdGlvbiBQZChhKXt2YXIgYj10aGlzLm5hdGl2ZUV2ZW50O3JldHVybiBiLmdldE1vZGlmaWVyU3RhdGU/Yi5nZXRNb2RpZmllclN0YXRlKGEpOihhPU9kW2FdKT8hIWJbYV06ITF9ZnVuY3Rpb24gemQoKXtyZXR1cm4gUGR9XG52YXIgUWQ9QSh7fSx1ZCx7a2V5OmZ1bmN0aW9uKGEpe2lmKGEua2V5KXt2YXIgYj1NZFthLmtleV18fGEua2V5O2lmKFwiVW5pZGVudGlmaWVkXCIhPT1iKXJldHVybiBifXJldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT8oYT1vZChhKSwxMz09PWE/XCJFbnRlclwiOlN0cmluZy5mcm9tQ2hhckNvZGUoYSkpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/TmRbYS5rZXlDb2RlXXx8XCJVbmlkZW50aWZpZWRcIjpcIlwifSxjb2RlOjAsbG9jYXRpb246MCxjdHJsS2V5OjAsc2hpZnRLZXk6MCxhbHRLZXk6MCxtZXRhS2V5OjAscmVwZWF0OjAsbG9jYWxlOjAsZ2V0TW9kaWZpZXJTdGF0ZTp6ZCxjaGFyQ29kZTpmdW5jdGlvbihhKXtyZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/b2QoYSk6MH0sa2V5Q29kZTpmdW5jdGlvbihhKXtyZXR1cm5cImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP2Eua2V5Q29kZTowfSx3aGljaDpmdW5jdGlvbihhKXtyZXR1cm5cImtleXByZXNzXCI9PT1cbmEudHlwZT9vZChhKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP2Eua2V5Q29kZTowfX0pLFJkPXJkKFFkKSxTZD1BKHt9LEFkLHtwb2ludGVySWQ6MCx3aWR0aDowLGhlaWdodDowLHByZXNzdXJlOjAsdGFuZ2VudGlhbFByZXNzdXJlOjAsdGlsdFg6MCx0aWx0WTowLHR3aXN0OjAscG9pbnRlclR5cGU6MCxpc1ByaW1hcnk6MH0pLFRkPXJkKFNkKSxVZD1BKHt9LHVkLHt0b3VjaGVzOjAsdGFyZ2V0VG91Y2hlczowLGNoYW5nZWRUb3VjaGVzOjAsYWx0S2V5OjAsbWV0YUtleTowLGN0cmxLZXk6MCxzaGlmdEtleTowLGdldE1vZGlmaWVyU3RhdGU6emR9KSxWZD1yZChVZCksV2Q9QSh7fSxzZCx7cHJvcGVydHlOYW1lOjAsZWxhcHNlZFRpbWU6MCxwc2V1ZG9FbGVtZW50OjB9KSxYZD1yZChXZCksWWQ9QSh7fSxBZCx7ZGVsdGFYOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFYXCJpbiBhP2EuZGVsdGFYOlwid2hlZWxEZWx0YVhcImluIGE/LWEud2hlZWxEZWx0YVg6MH0sXG5kZWx0YVk6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVlcImluIGE/YS5kZWx0YVk6XCJ3aGVlbERlbHRhWVwiaW4gYT8tYS53aGVlbERlbHRhWTpcIndoZWVsRGVsdGFcImluIGE/LWEud2hlZWxEZWx0YTowfSxkZWx0YVo6MCxkZWx0YU1vZGU6MH0pLFpkPXJkKFlkKSwkZD1bOSwxMywyNywzMl0sYWU9aWEmJlwiQ29tcG9zaXRpb25FdmVudFwiaW4gd2luZG93LGJlPW51bGw7aWEmJlwiZG9jdW1lbnRNb2RlXCJpbiBkb2N1bWVudCYmKGJlPWRvY3VtZW50LmRvY3VtZW50TW9kZSk7dmFyIGNlPWlhJiZcIlRleHRFdmVudFwiaW4gd2luZG93JiYhYmUsZGU9aWEmJighYWV8fGJlJiY4PGJlJiYxMT49YmUpLGVlPVN0cmluZy5mcm9tQ2hhckNvZGUoMzIpLGZlPSExO1xuZnVuY3Rpb24gZ2UoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcImtleXVwXCI6cmV0dXJuLTEhPT0kZC5pbmRleE9mKGIua2V5Q29kZSk7Y2FzZSBcImtleWRvd25cIjpyZXR1cm4gMjI5IT09Yi5rZXlDb2RlO2Nhc2UgXCJrZXlwcmVzc1wiOmNhc2UgXCJtb3VzZWRvd25cIjpjYXNlIFwiZm9jdXNvdXRcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBoZShhKXthPWEuZGV0YWlsO3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmXCJkYXRhXCJpbiBhP2EuZGF0YTpudWxsfXZhciBpZT0hMTtmdW5jdGlvbiBqZShhLGIpe3N3aXRjaChhKXtjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpyZXR1cm4gaGUoYik7Y2FzZSBcImtleXByZXNzXCI6aWYoMzIhPT1iLndoaWNoKXJldHVybiBudWxsO2ZlPSEwO3JldHVybiBlZTtjYXNlIFwidGV4dElucHV0XCI6cmV0dXJuIGE9Yi5kYXRhLGE9PT1lZSYmZmU/bnVsbDphO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxuZnVuY3Rpb24ga2UoYSxiKXtpZihpZSlyZXR1cm5cImNvbXBvc2l0aW9uZW5kXCI9PT1hfHwhYWUmJmdlKGEsYik/KGE9bmQoKSxtZD1sZD1rZD1udWxsLGllPSExLGEpOm51bGw7c3dpdGNoKGEpe2Nhc2UgXCJwYXN0ZVwiOnJldHVybiBudWxsO2Nhc2UgXCJrZXlwcmVzc1wiOmlmKCEoYi5jdHJsS2V5fHxiLmFsdEtleXx8Yi5tZXRhS2V5KXx8Yi5jdHJsS2V5JiZiLmFsdEtleSl7aWYoYi5jaGFyJiYxPGIuY2hhci5sZW5ndGgpcmV0dXJuIGIuY2hhcjtpZihiLndoaWNoKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGIud2hpY2gpfXJldHVybiBudWxsO2Nhc2UgXCJjb21wb3NpdGlvbmVuZFwiOnJldHVybiBkZSYmXCJrb1wiIT09Yi5sb2NhbGU/bnVsbDpiLmRhdGE7ZGVmYXVsdDpyZXR1cm4gbnVsbH19XG52YXIgbGU9e2NvbG9yOiEwLGRhdGU6ITAsZGF0ZXRpbWU6ITAsXCJkYXRldGltZS1sb2NhbFwiOiEwLGVtYWlsOiEwLG1vbnRoOiEwLG51bWJlcjohMCxwYXNzd29yZDohMCxyYW5nZTohMCxzZWFyY2g6ITAsdGVsOiEwLHRleHQ6ITAsdGltZTohMCx1cmw6ITAsd2VlazohMH07ZnVuY3Rpb24gbWUoYSl7dmFyIGI9YSYmYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVyblwiaW5wdXRcIj09PWI/ISFsZVthLnR5cGVdOlwidGV4dGFyZWFcIj09PWI/ITA6ITF9ZnVuY3Rpb24gbmUoYSxiLGMsZCl7RWIoZCk7Yj1vZShiLFwib25DaGFuZ2VcIik7MDxiLmxlbmd0aCYmKGM9bmV3IHRkKFwib25DaGFuZ2VcIixcImNoYW5nZVwiLG51bGwsYyxkKSxhLnB1c2goe2V2ZW50OmMsbGlzdGVuZXJzOmJ9KSl9dmFyIHBlPW51bGwscWU9bnVsbDtmdW5jdGlvbiByZShhKXtzZShhLDApfWZ1bmN0aW9uIHRlKGEpe3ZhciBiPXVlKGEpO2lmKFdhKGIpKXJldHVybiBhfVxuZnVuY3Rpb24gdmUoYSxiKXtpZihcImNoYW5nZVwiPT09YSlyZXR1cm4gYn12YXIgd2U9ITE7aWYoaWEpe3ZhciB4ZTtpZihpYSl7dmFyIHllPVwib25pbnB1dFwiaW4gZG9jdW1lbnQ7aWYoIXllKXt2YXIgemU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt6ZS5zZXRBdHRyaWJ1dGUoXCJvbmlucHV0XCIsXCJyZXR1cm47XCIpO3llPVwiZnVuY3Rpb25cIj09PXR5cGVvZiB6ZS5vbmlucHV0fXhlPXllfWVsc2UgeGU9ITE7d2U9eGUmJighZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw5PGRvY3VtZW50LmRvY3VtZW50TW9kZSl9ZnVuY3Rpb24gQWUoKXtwZSYmKHBlLmRldGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLEJlKSxxZT1wZT1udWxsKX1mdW5jdGlvbiBCZShhKXtpZihcInZhbHVlXCI9PT1hLnByb3BlcnR5TmFtZSYmdGUocWUpKXt2YXIgYj1bXTtuZShiLHFlLGEseGIoYSkpO0piKHJlLGIpfX1cbmZ1bmN0aW9uIENlKGEsYixjKXtcImZvY3VzaW5cIj09PWE/KEFlKCkscGU9YixxZT1jLHBlLmF0dGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLEJlKSk6XCJmb2N1c291dFwiPT09YSYmQWUoKX1mdW5jdGlvbiBEZShhKXtpZihcInNlbGVjdGlvbmNoYW5nZVwiPT09YXx8XCJrZXl1cFwiPT09YXx8XCJrZXlkb3duXCI9PT1hKXJldHVybiB0ZShxZSl9ZnVuY3Rpb24gRWUoYSxiKXtpZihcImNsaWNrXCI9PT1hKXJldHVybiB0ZShiKX1mdW5jdGlvbiBGZShhLGIpe2lmKFwiaW5wdXRcIj09PWF8fFwiY2hhbmdlXCI9PT1hKXJldHVybiB0ZShiKX1mdW5jdGlvbiBHZShhLGIpe3JldHVybiBhPT09YiYmKDAhPT1hfHwxL2E9PT0xL2IpfHxhIT09YSYmYiE9PWJ9dmFyIEhlPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBPYmplY3QuaXM/T2JqZWN0LmlzOkdlO1xuZnVuY3Rpb24gSWUoYSxiKXtpZihIZShhLGIpKXJldHVybiEwO2lmKFwib2JqZWN0XCIhPT10eXBlb2YgYXx8bnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYnx8bnVsbD09PWIpcmV0dXJuITE7dmFyIGM9T2JqZWN0LmtleXMoYSksZD1PYmplY3Qua2V5cyhiKTtpZihjLmxlbmd0aCE9PWQubGVuZ3RoKXJldHVybiExO2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF07aWYoIWphLmNhbGwoYixlKXx8IUhlKGFbZV0sYltlXSkpcmV0dXJuITF9cmV0dXJuITB9ZnVuY3Rpb24gSmUoYSl7Zm9yKDthJiZhLmZpcnN0Q2hpbGQ7KWE9YS5maXJzdENoaWxkO3JldHVybiBhfVxuZnVuY3Rpb24gS2UoYSxiKXt2YXIgYz1KZShhKTthPTA7Zm9yKHZhciBkO2M7KXtpZigzPT09Yy5ub2RlVHlwZSl7ZD1hK2MudGV4dENvbnRlbnQubGVuZ3RoO2lmKGE8PWImJmQ+PWIpcmV0dXJue25vZGU6YyxvZmZzZXQ6Yi1hfTthPWR9YTp7Zm9yKDtjOyl7aWYoYy5uZXh0U2libGluZyl7Yz1jLm5leHRTaWJsaW5nO2JyZWFrIGF9Yz1jLnBhcmVudE5vZGV9Yz12b2lkIDB9Yz1KZShjKX19ZnVuY3Rpb24gTGUoYSxiKXtyZXR1cm4gYSYmYj9hPT09Yj8hMDphJiYzPT09YS5ub2RlVHlwZT8hMTpiJiYzPT09Yi5ub2RlVHlwZT9MZShhLGIucGFyZW50Tm9kZSk6XCJjb250YWluc1wiaW4gYT9hLmNvbnRhaW5zKGIpOmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24/ISEoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSYxNik6ITE6ITF9XG5mdW5jdGlvbiBNZSgpe2Zvcih2YXIgYT13aW5kb3csYj1YYSgpO2IgaW5zdGFuY2VvZiBhLkhUTUxJRnJhbWVFbGVtZW50Oyl7dHJ5e3ZhciBjPVwic3RyaW5nXCI9PT10eXBlb2YgYi5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWZ9Y2F0Y2goZCl7Yz0hMX1pZihjKWE9Yi5jb250ZW50V2luZG93O2Vsc2UgYnJlYWs7Yj1YYShhLmRvY3VtZW50KX1yZXR1cm4gYn1mdW5jdGlvbiBOZShhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGImJihcImlucHV0XCI9PT1iJiYoXCJ0ZXh0XCI9PT1hLnR5cGV8fFwic2VhcmNoXCI9PT1hLnR5cGV8fFwidGVsXCI9PT1hLnR5cGV8fFwidXJsXCI9PT1hLnR5cGV8fFwicGFzc3dvcmRcIj09PWEudHlwZSl8fFwidGV4dGFyZWFcIj09PWJ8fFwidHJ1ZVwiPT09YS5jb250ZW50RWRpdGFibGUpfVxuZnVuY3Rpb24gT2UoYSl7dmFyIGI9TWUoKSxjPWEuZm9jdXNlZEVsZW0sZD1hLnNlbGVjdGlvblJhbmdlO2lmKGIhPT1jJiZjJiZjLm93bmVyRG9jdW1lbnQmJkxlKGMub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsYykpe2lmKG51bGwhPT1kJiZOZShjKSlpZihiPWQuc3RhcnQsYT1kLmVuZCx2b2lkIDA9PT1hJiYoYT1iKSxcInNlbGVjdGlvblN0YXJ0XCJpbiBjKWMuc2VsZWN0aW9uU3RhcnQ9YixjLnNlbGVjdGlvbkVuZD1NYXRoLm1pbihhLGMudmFsdWUubGVuZ3RoKTtlbHNlIGlmKGE9KGI9Yy5vd25lckRvY3VtZW50fHxkb2N1bWVudCkmJmIuZGVmYXVsdFZpZXd8fHdpbmRvdyxhLmdldFNlbGVjdGlvbil7YT1hLmdldFNlbGVjdGlvbigpO3ZhciBlPWMudGV4dENvbnRlbnQubGVuZ3RoLGY9TWF0aC5taW4oZC5zdGFydCxlKTtkPXZvaWQgMD09PWQuZW5kP2Y6TWF0aC5taW4oZC5lbmQsZSk7IWEuZXh0ZW5kJiZmPmQmJihlPWQsZD1mLGY9ZSk7ZT1LZShjLGYpO3ZhciBnPUtlKGMsXG5kKTtlJiZnJiYoMSE9PWEucmFuZ2VDb3VudHx8YS5hbmNob3JOb2RlIT09ZS5ub2RlfHxhLmFuY2hvck9mZnNldCE9PWUub2Zmc2V0fHxhLmZvY3VzTm9kZSE9PWcubm9kZXx8YS5mb2N1c09mZnNldCE9PWcub2Zmc2V0KSYmKGI9Yi5jcmVhdGVSYW5nZSgpLGIuc2V0U3RhcnQoZS5ub2RlLGUub2Zmc2V0KSxhLnJlbW92ZUFsbFJhbmdlcygpLGY+ZD8oYS5hZGRSYW5nZShiKSxhLmV4dGVuZChnLm5vZGUsZy5vZmZzZXQpKTooYi5zZXRFbmQoZy5ub2RlLGcub2Zmc2V0KSxhLmFkZFJhbmdlKGIpKSl9Yj1bXTtmb3IoYT1jO2E9YS5wYXJlbnROb2RlOykxPT09YS5ub2RlVHlwZSYmYi5wdXNoKHtlbGVtZW50OmEsbGVmdDphLnNjcm9sbExlZnQsdG9wOmEuc2Nyb2xsVG9wfSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGMuZm9jdXMmJmMuZm9jdXMoKTtmb3IoYz0wO2M8Yi5sZW5ndGg7YysrKWE9YltjXSxhLmVsZW1lbnQuc2Nyb2xsTGVmdD1hLmxlZnQsYS5lbGVtZW50LnNjcm9sbFRvcD1hLnRvcH19XG52YXIgUGU9aWEmJlwiZG9jdW1lbnRNb2RlXCJpbiBkb2N1bWVudCYmMTE+PWRvY3VtZW50LmRvY3VtZW50TW9kZSxRZT1udWxsLFJlPW51bGwsU2U9bnVsbCxUZT0hMTtcbmZ1bmN0aW9uIFVlKGEsYixjKXt2YXIgZD1jLndpbmRvdz09PWM/Yy5kb2N1bWVudDo5PT09Yy5ub2RlVHlwZT9jOmMub3duZXJEb2N1bWVudDtUZXx8bnVsbD09UWV8fFFlIT09WGEoZCl8fChkPVFlLFwic2VsZWN0aW9uU3RhcnRcImluIGQmJk5lKGQpP2Q9e3N0YXJ0OmQuc2VsZWN0aW9uU3RhcnQsZW5kOmQuc2VsZWN0aW9uRW5kfTooZD0oZC5vd25lckRvY3VtZW50JiZkLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXd8fHdpbmRvdykuZ2V0U2VsZWN0aW9uKCksZD17YW5jaG9yTm9kZTpkLmFuY2hvck5vZGUsYW5jaG9yT2Zmc2V0OmQuYW5jaG9yT2Zmc2V0LGZvY3VzTm9kZTpkLmZvY3VzTm9kZSxmb2N1c09mZnNldDpkLmZvY3VzT2Zmc2V0fSksU2UmJkllKFNlLGQpfHwoU2U9ZCxkPW9lKFJlLFwib25TZWxlY3RcIiksMDxkLmxlbmd0aCYmKGI9bmV3IHRkKFwib25TZWxlY3RcIixcInNlbGVjdFwiLG51bGwsYixjKSxhLnB1c2goe2V2ZW50OmIsbGlzdGVuZXJzOmR9KSxiLnRhcmdldD1RZSkpKX1cbmZ1bmN0aW9uIFZlKGEsYil7dmFyIGM9e307Y1thLnRvTG93ZXJDYXNlKCldPWIudG9Mb3dlckNhc2UoKTtjW1wiV2Via2l0XCIrYV09XCJ3ZWJraXRcIitiO2NbXCJNb3pcIithXT1cIm1velwiK2I7cmV0dXJuIGN9dmFyIFdlPXthbmltYXRpb25lbmQ6VmUoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvbkVuZFwiKSxhbmltYXRpb25pdGVyYXRpb246VmUoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvbkl0ZXJhdGlvblwiKSxhbmltYXRpb25zdGFydDpWZShcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uU3RhcnRcIiksdHJhbnNpdGlvbmVuZDpWZShcIlRyYW5zaXRpb25cIixcIlRyYW5zaXRpb25FbmRcIil9LFhlPXt9LFllPXt9O1xuaWEmJihZZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLFwiQW5pbWF0aW9uRXZlbnRcImluIHdpbmRvd3x8KGRlbGV0ZSBXZS5hbmltYXRpb25lbmQuYW5pbWF0aW9uLGRlbGV0ZSBXZS5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uLGRlbGV0ZSBXZS5hbmltYXRpb25zdGFydC5hbmltYXRpb24pLFwiVHJhbnNpdGlvbkV2ZW50XCJpbiB3aW5kb3d8fGRlbGV0ZSBXZS50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb24pO2Z1bmN0aW9uIFplKGEpe2lmKFhlW2FdKXJldHVybiBYZVthXTtpZighV2VbYV0pcmV0dXJuIGE7dmFyIGI9V2VbYV0sYztmb3IoYyBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoYykmJmMgaW4gWWUpcmV0dXJuIFhlW2FdPWJbY107cmV0dXJuIGF9dmFyICRlPVplKFwiYW5pbWF0aW9uZW5kXCIpLGFmPVplKFwiYW5pbWF0aW9uaXRlcmF0aW9uXCIpLGJmPVplKFwiYW5pbWF0aW9uc3RhcnRcIiksY2Y9WmUoXCJ0cmFuc2l0aW9uZW5kXCIpLGRmPW5ldyBNYXAsZWY9XCJhYm9ydCBhdXhDbGljayBjYW5jZWwgY2FuUGxheSBjYW5QbGF5VGhyb3VnaCBjbGljayBjbG9zZSBjb250ZXh0TWVudSBjb3B5IGN1dCBkcmFnIGRyYWdFbmQgZHJhZ0VudGVyIGRyYWdFeGl0IGRyYWdMZWF2ZSBkcmFnT3ZlciBkcmFnU3RhcnQgZHJvcCBkdXJhdGlvbkNoYW5nZSBlbXB0aWVkIGVuY3J5cHRlZCBlbmRlZCBlcnJvciBnb3RQb2ludGVyQ2FwdHVyZSBpbnB1dCBpbnZhbGlkIGtleURvd24ga2V5UHJlc3Mga2V5VXAgbG9hZCBsb2FkZWREYXRhIGxvYWRlZE1ldGFkYXRhIGxvYWRTdGFydCBsb3N0UG9pbnRlckNhcHR1cmUgbW91c2VEb3duIG1vdXNlTW92ZSBtb3VzZU91dCBtb3VzZU92ZXIgbW91c2VVcCBwYXN0ZSBwYXVzZSBwbGF5IHBsYXlpbmcgcG9pbnRlckNhbmNlbCBwb2ludGVyRG93biBwb2ludGVyTW92ZSBwb2ludGVyT3V0IHBvaW50ZXJPdmVyIHBvaW50ZXJVcCBwcm9ncmVzcyByYXRlQ2hhbmdlIHJlc2V0IHJlc2l6ZSBzZWVrZWQgc2Vla2luZyBzdGFsbGVkIHN1Ym1pdCBzdXNwZW5kIHRpbWVVcGRhdGUgdG91Y2hDYW5jZWwgdG91Y2hFbmQgdG91Y2hTdGFydCB2b2x1bWVDaGFuZ2Ugc2Nyb2xsIHRvZ2dsZSB0b3VjaE1vdmUgd2FpdGluZyB3aGVlbFwiLnNwbGl0KFwiIFwiKTtcbmZ1bmN0aW9uIGZmKGEsYil7ZGYuc2V0KGEsYik7ZmEoYixbYV0pfWZvcih2YXIgZ2Y9MDtnZjxlZi5sZW5ndGg7Z2YrKyl7dmFyIGhmPWVmW2dmXSxqZj1oZi50b0xvd2VyQ2FzZSgpLGtmPWhmWzBdLnRvVXBwZXJDYXNlKCkraGYuc2xpY2UoMSk7ZmYoamYsXCJvblwiK2tmKX1mZigkZSxcIm9uQW5pbWF0aW9uRW5kXCIpO2ZmKGFmLFwib25BbmltYXRpb25JdGVyYXRpb25cIik7ZmYoYmYsXCJvbkFuaW1hdGlvblN0YXJ0XCIpO2ZmKFwiZGJsY2xpY2tcIixcIm9uRG91YmxlQ2xpY2tcIik7ZmYoXCJmb2N1c2luXCIsXCJvbkZvY3VzXCIpO2ZmKFwiZm9jdXNvdXRcIixcIm9uQmx1clwiKTtmZihjZixcIm9uVHJhbnNpdGlvbkVuZFwiKTtoYShcIm9uTW91c2VFbnRlclwiLFtcIm1vdXNlb3V0XCIsXCJtb3VzZW92ZXJcIl0pO2hhKFwib25Nb3VzZUxlYXZlXCIsW1wibW91c2VvdXRcIixcIm1vdXNlb3ZlclwiXSk7aGEoXCJvblBvaW50ZXJFbnRlclwiLFtcInBvaW50ZXJvdXRcIixcInBvaW50ZXJvdmVyXCJdKTtcbmhhKFwib25Qb2ludGVyTGVhdmVcIixbXCJwb2ludGVyb3V0XCIsXCJwb2ludGVyb3ZlclwiXSk7ZmEoXCJvbkNoYW5nZVwiLFwiY2hhbmdlIGNsaWNrIGZvY3VzaW4gZm9jdXNvdXQgaW5wdXQga2V5ZG93biBrZXl1cCBzZWxlY3Rpb25jaGFuZ2VcIi5zcGxpdChcIiBcIikpO2ZhKFwib25TZWxlY3RcIixcImZvY3Vzb3V0IGNvbnRleHRtZW51IGRyYWdlbmQgZm9jdXNpbiBrZXlkb3duIGtleXVwIG1vdXNlZG93biBtb3VzZXVwIHNlbGVjdGlvbmNoYW5nZVwiLnNwbGl0KFwiIFwiKSk7ZmEoXCJvbkJlZm9yZUlucHV0XCIsW1wiY29tcG9zaXRpb25lbmRcIixcImtleXByZXNzXCIsXCJ0ZXh0SW5wdXRcIixcInBhc3RlXCJdKTtmYShcIm9uQ29tcG9zaXRpb25FbmRcIixcImNvbXBvc2l0aW9uZW5kIGZvY3Vzb3V0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duXCIuc3BsaXQoXCIgXCIpKTtmYShcIm9uQ29tcG9zaXRpb25TdGFydFwiLFwiY29tcG9zaXRpb25zdGFydCBmb2N1c291dCBrZXlkb3duIGtleXByZXNzIGtleXVwIG1vdXNlZG93blwiLnNwbGl0KFwiIFwiKSk7XG5mYShcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixcImNvbXBvc2l0aW9udXBkYXRlIGZvY3Vzb3V0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duXCIuc3BsaXQoXCIgXCIpKTt2YXIgbGY9XCJhYm9ydCBjYW5wbGF5IGNhbnBsYXl0aHJvdWdoIGR1cmF0aW9uY2hhbmdlIGVtcHRpZWQgZW5jcnlwdGVkIGVuZGVkIGVycm9yIGxvYWRlZGRhdGEgbG9hZGVkbWV0YWRhdGEgbG9hZHN0YXJ0IHBhdXNlIHBsYXkgcGxheWluZyBwcm9ncmVzcyByYXRlY2hhbmdlIHJlc2l6ZSBzZWVrZWQgc2Vla2luZyBzdGFsbGVkIHN1c3BlbmQgdGltZXVwZGF0ZSB2b2x1bWVjaGFuZ2Ugd2FpdGluZ1wiLnNwbGl0KFwiIFwiKSxtZj1uZXcgU2V0KFwiY2FuY2VsIGNsb3NlIGludmFsaWQgbG9hZCBzY3JvbGwgdG9nZ2xlXCIuc3BsaXQoXCIgXCIpLmNvbmNhdChsZikpO1xuZnVuY3Rpb24gbmYoYSxiLGMpe3ZhciBkPWEudHlwZXx8XCJ1bmtub3duLWV2ZW50XCI7YS5jdXJyZW50VGFyZ2V0PWM7VWIoZCxiLHZvaWQgMCxhKTthLmN1cnJlbnRUYXJnZXQ9bnVsbH1cbmZ1bmN0aW9uIHNlKGEsYil7Yj0wIT09KGImNCk7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPWFbY10sZT1kLmV2ZW50O2Q9ZC5saXN0ZW5lcnM7YTp7dmFyIGY9dm9pZCAwO2lmKGIpZm9yKHZhciBnPWQubGVuZ3RoLTE7MDw9ZztnLS0pe3ZhciBoPWRbZ10saz1oLmluc3RhbmNlLGw9aC5jdXJyZW50VGFyZ2V0O2g9aC5saXN0ZW5lcjtpZihrIT09ZiYmZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKWJyZWFrIGE7bmYoZSxoLGwpO2Y9a31lbHNlIGZvcihnPTA7ZzxkLmxlbmd0aDtnKyspe2g9ZFtnXTtrPWguaW5zdGFuY2U7bD1oLmN1cnJlbnRUYXJnZXQ7aD1oLmxpc3RlbmVyO2lmKGshPT1mJiZlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpYnJlYWsgYTtuZihlLGgsbCk7Zj1rfX19aWYoUWIpdGhyb3cgYT1SYixRYj0hMSxSYj1udWxsLGE7fVxuZnVuY3Rpb24gRChhLGIpe3ZhciBjPWJbb2ZdO3ZvaWQgMD09PWMmJihjPWJbb2ZdPW5ldyBTZXQpO3ZhciBkPWErXCJfX2J1YmJsZVwiO2MuaGFzKGQpfHwocGYoYixhLDIsITEpLGMuYWRkKGQpKX1mdW5jdGlvbiBxZihhLGIsYyl7dmFyIGQ9MDtiJiYoZHw9NCk7cGYoYyxhLGQsYil9dmFyIHJmPVwiX3JlYWN0TGlzdGVuaW5nXCIrTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7ZnVuY3Rpb24gc2YoYSl7aWYoIWFbcmZdKXthW3JmXT0hMDtkYS5mb3JFYWNoKGZ1bmN0aW9uKGIpe1wic2VsZWN0aW9uY2hhbmdlXCIhPT1iJiYobWYuaGFzKGIpfHxxZihiLCExLGEpLHFmKGIsITAsYSkpfSk7dmFyIGI9OT09PWEubm9kZVR5cGU/YTphLm93bmVyRG9jdW1lbnQ7bnVsbD09PWJ8fGJbcmZdfHwoYltyZl09ITAscWYoXCJzZWxlY3Rpb25jaGFuZ2VcIiwhMSxiKSl9fVxuZnVuY3Rpb24gcGYoYSxiLGMsZCl7c3dpdGNoKGpkKGIpKXtjYXNlIDE6dmFyIGU9ZWQ7YnJlYWs7Y2FzZSA0OmU9Z2Q7YnJlYWs7ZGVmYXVsdDplPWZkfWM9ZS5iaW5kKG51bGwsYixjLGEpO2U9dm9pZCAwOyFMYnx8XCJ0b3VjaHN0YXJ0XCIhPT1iJiZcInRvdWNobW92ZVwiIT09YiYmXCJ3aGVlbFwiIT09Ynx8KGU9ITApO2Q/dm9pZCAwIT09ZT9hLmFkZEV2ZW50TGlzdGVuZXIoYixjLHtjYXB0dXJlOiEwLHBhc3NpdmU6ZX0pOmEuYWRkRXZlbnRMaXN0ZW5lcihiLGMsITApOnZvaWQgMCE9PWU/YS5hZGRFdmVudExpc3RlbmVyKGIsYyx7cGFzc2l2ZTplfSk6YS5hZGRFdmVudExpc3RlbmVyKGIsYywhMSl9XG5mdW5jdGlvbiBoZChhLGIsYyxkLGUpe3ZhciBmPWQ7aWYoMD09PShiJjEpJiYwPT09KGImMikmJm51bGwhPT1kKWE6Zm9yKDs7KXtpZihudWxsPT09ZClyZXR1cm47dmFyIGc9ZC50YWc7aWYoMz09PWd8fDQ9PT1nKXt2YXIgaD1kLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKGg9PT1lfHw4PT09aC5ub2RlVHlwZSYmaC5wYXJlbnROb2RlPT09ZSlicmVhaztpZig0PT09Zylmb3IoZz1kLnJldHVybjtudWxsIT09Zzspe3ZhciBrPWcudGFnO2lmKDM9PT1rfHw0PT09aylpZihrPWcuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8saz09PWV8fDg9PT1rLm5vZGVUeXBlJiZrLnBhcmVudE5vZGU9PT1lKXJldHVybjtnPWcucmV0dXJufWZvcig7bnVsbCE9PWg7KXtnPVdjKGgpO2lmKG51bGw9PT1nKXJldHVybjtrPWcudGFnO2lmKDU9PT1rfHw2PT09ayl7ZD1mPWc7Y29udGludWUgYX1oPWgucGFyZW50Tm9kZX19ZD1kLnJldHVybn1KYihmdW5jdGlvbigpe3ZhciBkPWYsZT14YihjKSxnPVtdO1xuYTp7dmFyIGg9ZGYuZ2V0KGEpO2lmKHZvaWQgMCE9PWgpe3ZhciBrPXRkLG49YTtzd2l0Y2goYSl7Y2FzZSBcImtleXByZXNzXCI6aWYoMD09PW9kKGMpKWJyZWFrIGE7Y2FzZSBcImtleWRvd25cIjpjYXNlIFwia2V5dXBcIjprPVJkO2JyZWFrO2Nhc2UgXCJmb2N1c2luXCI6bj1cImZvY3VzXCI7az1GZDticmVhaztjYXNlIFwiZm9jdXNvdXRcIjpuPVwiYmx1clwiO2s9RmQ7YnJlYWs7Y2FzZSBcImJlZm9yZWJsdXJcIjpjYXNlIFwiYWZ0ZXJibHVyXCI6az1GZDticmVhaztjYXNlIFwiY2xpY2tcIjppZigyPT09Yy5idXR0b24pYnJlYWsgYTtjYXNlIFwiYXV4Y2xpY2tcIjpjYXNlIFwiZGJsY2xpY2tcIjpjYXNlIFwibW91c2Vkb3duXCI6Y2FzZSBcIm1vdXNlbW92ZVwiOmNhc2UgXCJtb3VzZXVwXCI6Y2FzZSBcIm1vdXNlb3V0XCI6Y2FzZSBcIm1vdXNlb3ZlclwiOmNhc2UgXCJjb250ZXh0bWVudVwiOms9QmQ7YnJlYWs7Y2FzZSBcImRyYWdcIjpjYXNlIFwiZHJhZ2VuZFwiOmNhc2UgXCJkcmFnZW50ZXJcIjpjYXNlIFwiZHJhZ2V4aXRcIjpjYXNlIFwiZHJhZ2xlYXZlXCI6Y2FzZSBcImRyYWdvdmVyXCI6Y2FzZSBcImRyYWdzdGFydFwiOmNhc2UgXCJkcm9wXCI6az1cbkRkO2JyZWFrO2Nhc2UgXCJ0b3VjaGNhbmNlbFwiOmNhc2UgXCJ0b3VjaGVuZFwiOmNhc2UgXCJ0b3VjaG1vdmVcIjpjYXNlIFwidG91Y2hzdGFydFwiOms9VmQ7YnJlYWs7Y2FzZSAkZTpjYXNlIGFmOmNhc2UgYmY6az1IZDticmVhaztjYXNlIGNmOms9WGQ7YnJlYWs7Y2FzZSBcInNjcm9sbFwiOms9dmQ7YnJlYWs7Y2FzZSBcIndoZWVsXCI6az1aZDticmVhaztjYXNlIFwiY29weVwiOmNhc2UgXCJjdXRcIjpjYXNlIFwicGFzdGVcIjprPUpkO2JyZWFrO2Nhc2UgXCJnb3Rwb2ludGVyY2FwdHVyZVwiOmNhc2UgXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjpjYXNlIFwicG9pbnRlcmNhbmNlbFwiOmNhc2UgXCJwb2ludGVyZG93blwiOmNhc2UgXCJwb2ludGVybW92ZVwiOmNhc2UgXCJwb2ludGVyb3V0XCI6Y2FzZSBcInBvaW50ZXJvdmVyXCI6Y2FzZSBcInBvaW50ZXJ1cFwiOms9VGR9dmFyIHQ9MCE9PShiJjQpLEo9IXQmJlwic2Nyb2xsXCI9PT1hLHg9dD9udWxsIT09aD9oK1wiQ2FwdHVyZVwiOm51bGw6aDt0PVtdO2Zvcih2YXIgdz1kLHU7bnVsbCE9PVxudzspe3U9dzt2YXIgRj11LnN0YXRlTm9kZTs1PT09dS50YWcmJm51bGwhPT1GJiYodT1GLG51bGwhPT14JiYoRj1LYih3LHgpLG51bGwhPUYmJnQucHVzaCh0Zih3LEYsdSkpKSk7aWYoSilicmVhazt3PXcucmV0dXJufTA8dC5sZW5ndGgmJihoPW5ldyBrKGgsbixudWxsLGMsZSksZy5wdXNoKHtldmVudDpoLGxpc3RlbmVyczp0fSkpfX1pZigwPT09KGImNykpe2E6e2g9XCJtb3VzZW92ZXJcIj09PWF8fFwicG9pbnRlcm92ZXJcIj09PWE7az1cIm1vdXNlb3V0XCI9PT1hfHxcInBvaW50ZXJvdXRcIj09PWE7aWYoaCYmYyE9PXdiJiYobj1jLnJlbGF0ZWRUYXJnZXR8fGMuZnJvbUVsZW1lbnQpJiYoV2Mobil8fG5bdWZdKSlicmVhayBhO2lmKGt8fGgpe2g9ZS53aW5kb3c9PT1lP2U6KGg9ZS5vd25lckRvY3VtZW50KT9oLmRlZmF1bHRWaWV3fHxoLnBhcmVudFdpbmRvdzp3aW5kb3c7aWYoayl7aWYobj1jLnJlbGF0ZWRUYXJnZXR8fGMudG9FbGVtZW50LGs9ZCxuPW4/V2Mobik6bnVsbCxudWxsIT09XG5uJiYoSj1WYihuKSxuIT09Snx8NSE9PW4udGFnJiY2IT09bi50YWcpKW49bnVsbH1lbHNlIGs9bnVsbCxuPWQ7aWYoayE9PW4pe3Q9QmQ7Rj1cIm9uTW91c2VMZWF2ZVwiO3g9XCJvbk1vdXNlRW50ZXJcIjt3PVwibW91c2VcIjtpZihcInBvaW50ZXJvdXRcIj09PWF8fFwicG9pbnRlcm92ZXJcIj09PWEpdD1UZCxGPVwib25Qb2ludGVyTGVhdmVcIix4PVwib25Qb2ludGVyRW50ZXJcIix3PVwicG9pbnRlclwiO0o9bnVsbD09az9oOnVlKGspO3U9bnVsbD09bj9oOnVlKG4pO2g9bmV3IHQoRix3K1wibGVhdmVcIixrLGMsZSk7aC50YXJnZXQ9SjtoLnJlbGF0ZWRUYXJnZXQ9dTtGPW51bGw7V2MoZSk9PT1kJiYodD1uZXcgdCh4LHcrXCJlbnRlclwiLG4sYyxlKSx0LnRhcmdldD11LHQucmVsYXRlZFRhcmdldD1KLEY9dCk7Sj1GO2lmKGsmJm4pYjp7dD1rO3g9bjt3PTA7Zm9yKHU9dDt1O3U9dmYodSkpdysrO3U9MDtmb3IoRj14O0Y7Rj12ZihGKSl1Kys7Zm9yKDswPHctdTspdD12Zih0KSx3LS07Zm9yKDswPHUtdzspeD1cbnZmKHgpLHUtLTtmb3IoO3ctLTspe2lmKHQ9PT14fHxudWxsIT09eCYmdD09PXguYWx0ZXJuYXRlKWJyZWFrIGI7dD12Zih0KTt4PXZmKHgpfXQ9bnVsbH1lbHNlIHQ9bnVsbDtudWxsIT09ayYmd2YoZyxoLGssdCwhMSk7bnVsbCE9PW4mJm51bGwhPT1KJiZ3ZihnLEosbix0LCEwKX19fWE6e2g9ZD91ZShkKTp3aW5kb3c7az1oLm5vZGVOYW1lJiZoLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoXCJzZWxlY3RcIj09PWt8fFwiaW5wdXRcIj09PWsmJlwiZmlsZVwiPT09aC50eXBlKXZhciBuYT12ZTtlbHNlIGlmKG1lKGgpKWlmKHdlKW5hPUZlO2Vsc2V7bmE9RGU7dmFyIHhhPUNlfWVsc2Uoaz1oLm5vZGVOYW1lKSYmXCJpbnB1dFwiPT09ay50b0xvd2VyQ2FzZSgpJiYoXCJjaGVja2JveFwiPT09aC50eXBlfHxcInJhZGlvXCI9PT1oLnR5cGUpJiYobmE9RWUpO2lmKG5hJiYobmE9bmEoYSxkKSkpe25lKGcsbmEsYyxlKTticmVhayBhfXhhJiZ4YShhLGgsZCk7XCJmb2N1c291dFwiPT09YSYmKHhhPWguX3dyYXBwZXJTdGF0ZSkmJlxueGEuY29udHJvbGxlZCYmXCJudW1iZXJcIj09PWgudHlwZSYmY2IoaCxcIm51bWJlclwiLGgudmFsdWUpfXhhPWQ/dWUoZCk6d2luZG93O3N3aXRjaChhKXtjYXNlIFwiZm9jdXNpblwiOmlmKG1lKHhhKXx8XCJ0cnVlXCI9PT14YS5jb250ZW50RWRpdGFibGUpUWU9eGEsUmU9ZCxTZT1udWxsO2JyZWFrO2Nhc2UgXCJmb2N1c291dFwiOlNlPVJlPVFlPW51bGw7YnJlYWs7Y2FzZSBcIm1vdXNlZG93blwiOlRlPSEwO2JyZWFrO2Nhc2UgXCJjb250ZXh0bWVudVwiOmNhc2UgXCJtb3VzZXVwXCI6Y2FzZSBcImRyYWdlbmRcIjpUZT0hMTtVZShnLGMsZSk7YnJlYWs7Y2FzZSBcInNlbGVjdGlvbmNoYW5nZVwiOmlmKFBlKWJyZWFrO2Nhc2UgXCJrZXlkb3duXCI6Y2FzZSBcImtleXVwXCI6VWUoZyxjLGUpfXZhciAkYTtpZihhZSliOntzd2l0Y2goYSl7Y2FzZSBcImNvbXBvc2l0aW9uc3RhcnRcIjp2YXIgYmE9XCJvbkNvbXBvc2l0aW9uU3RhcnRcIjticmVhayBiO2Nhc2UgXCJjb21wb3NpdGlvbmVuZFwiOmJhPVwib25Db21wb3NpdGlvbkVuZFwiO1xuYnJlYWsgYjtjYXNlIFwiY29tcG9zaXRpb251cGRhdGVcIjpiYT1cIm9uQ29tcG9zaXRpb25VcGRhdGVcIjticmVhayBifWJhPXZvaWQgMH1lbHNlIGllP2dlKGEsYykmJihiYT1cIm9uQ29tcG9zaXRpb25FbmRcIik6XCJrZXlkb3duXCI9PT1hJiYyMjk9PT1jLmtleUNvZGUmJihiYT1cIm9uQ29tcG9zaXRpb25TdGFydFwiKTtiYSYmKGRlJiZcImtvXCIhPT1jLmxvY2FsZSYmKGllfHxcIm9uQ29tcG9zaXRpb25TdGFydFwiIT09YmE/XCJvbkNvbXBvc2l0aW9uRW5kXCI9PT1iYSYmaWUmJigkYT1uZCgpKTooa2Q9ZSxsZD1cInZhbHVlXCJpbiBrZD9rZC52YWx1ZTprZC50ZXh0Q29udGVudCxpZT0hMCkpLHhhPW9lKGQsYmEpLDA8eGEubGVuZ3RoJiYoYmE9bmV3IExkKGJhLGEsbnVsbCxjLGUpLGcucHVzaCh7ZXZlbnQ6YmEsbGlzdGVuZXJzOnhhfSksJGE/YmEuZGF0YT0kYTooJGE9aGUoYyksbnVsbCE9PSRhJiYoYmEuZGF0YT0kYSkpKSk7aWYoJGE9Y2U/amUoYSxjKTprZShhLGMpKWQ9b2UoZCxcIm9uQmVmb3JlSW5wdXRcIiksXG4wPGQubGVuZ3RoJiYoZT1uZXcgTGQoXCJvbkJlZm9yZUlucHV0XCIsXCJiZWZvcmVpbnB1dFwiLG51bGwsYyxlKSxnLnB1c2goe2V2ZW50OmUsbGlzdGVuZXJzOmR9KSxlLmRhdGE9JGEpfXNlKGcsYil9KX1mdW5jdGlvbiB0ZihhLGIsYyl7cmV0dXJue2luc3RhbmNlOmEsbGlzdGVuZXI6YixjdXJyZW50VGFyZ2V0OmN9fWZ1bmN0aW9uIG9lKGEsYil7Zm9yKHZhciBjPWIrXCJDYXB0dXJlXCIsZD1bXTtudWxsIT09YTspe3ZhciBlPWEsZj1lLnN0YXRlTm9kZTs1PT09ZS50YWcmJm51bGwhPT1mJiYoZT1mLGY9S2IoYSxjKSxudWxsIT1mJiZkLnVuc2hpZnQodGYoYSxmLGUpKSxmPUtiKGEsYiksbnVsbCE9ZiYmZC5wdXNoKHRmKGEsZixlKSkpO2E9YS5yZXR1cm59cmV0dXJuIGR9ZnVuY3Rpb24gdmYoYSl7aWYobnVsbD09PWEpcmV0dXJuIG51bGw7ZG8gYT1hLnJldHVybjt3aGlsZShhJiY1IT09YS50YWcpO3JldHVybiBhP2E6bnVsbH1cbmZ1bmN0aW9uIHdmKGEsYixjLGQsZSl7Zm9yKHZhciBmPWIuX3JlYWN0TmFtZSxnPVtdO251bGwhPT1jJiZjIT09ZDspe3ZhciBoPWMsaz1oLmFsdGVybmF0ZSxsPWguc3RhdGVOb2RlO2lmKG51bGwhPT1rJiZrPT09ZClicmVhazs1PT09aC50YWcmJm51bGwhPT1sJiYoaD1sLGU/KGs9S2IoYyxmKSxudWxsIT1rJiZnLnVuc2hpZnQodGYoYyxrLGgpKSk6ZXx8KGs9S2IoYyxmKSxudWxsIT1rJiZnLnB1c2godGYoYyxrLGgpKSkpO2M9Yy5yZXR1cm59MCE9PWcubGVuZ3RoJiZhLnB1c2goe2V2ZW50OmIsbGlzdGVuZXJzOmd9KX12YXIgeGY9L1xcclxcbj8vZyx5Zj0vXFx1MDAwMHxcXHVGRkZEL2c7ZnVuY3Rpb24gemYoYSl7cmV0dXJuKFwic3RyaW5nXCI9PT10eXBlb2YgYT9hOlwiXCIrYSkucmVwbGFjZSh4ZixcIlxcblwiKS5yZXBsYWNlKHlmLFwiXCIpfWZ1bmN0aW9uIEFmKGEsYixjKXtiPXpmKGIpO2lmKHpmKGEpIT09YiYmYyl0aHJvdyBFcnJvcihwKDQyNSkpO31mdW5jdGlvbiBCZigpe31cbnZhciBDZj1udWxsLERmPW51bGw7ZnVuY3Rpb24gRWYoYSxiKXtyZXR1cm5cInRleHRhcmVhXCI9PT1hfHxcIm5vc2NyaXB0XCI9PT1hfHxcInN0cmluZ1wiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwibnVtYmVyXCI9PT10eXBlb2YgYi5jaGlsZHJlbnx8XCJvYmplY3RcIj09PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZudWxsIT09Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmbnVsbCE9Yi5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWx9XG52YXIgRmY9XCJmdW5jdGlvblwiPT09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDp2b2lkIDAsR2Y9XCJmdW5jdGlvblwiPT09dHlwZW9mIGNsZWFyVGltZW91dD9jbGVhclRpbWVvdXQ6dm9pZCAwLEhmPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBQcm9taXNlP1Byb21pc2U6dm9pZCAwLEpmPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBxdWV1ZU1pY3JvdGFzaz9xdWV1ZU1pY3JvdGFzazpcInVuZGVmaW5lZFwiIT09dHlwZW9mIEhmP2Z1bmN0aW9uKGEpe3JldHVybiBIZi5yZXNvbHZlKG51bGwpLnRoZW4oYSkuY2F0Y2goSWYpfTpGZjtmdW5jdGlvbiBJZihhKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgYTt9KX1cbmZ1bmN0aW9uIEtmKGEsYil7dmFyIGM9YixkPTA7ZG97dmFyIGU9Yy5uZXh0U2libGluZzthLnJlbW92ZUNoaWxkKGMpO2lmKGUmJjg9PT1lLm5vZGVUeXBlKWlmKGM9ZS5kYXRhLFwiLyRcIj09PWMpe2lmKDA9PT1kKXthLnJlbW92ZUNoaWxkKGUpO2JkKGIpO3JldHVybn1kLS19ZWxzZVwiJFwiIT09YyYmXCIkP1wiIT09YyYmXCIkIVwiIT09Y3x8ZCsrO2M9ZX13aGlsZShjKTtiZChiKX1mdW5jdGlvbiBMZihhKXtmb3IoO251bGwhPWE7YT1hLm5leHRTaWJsaW5nKXt2YXIgYj1hLm5vZGVUeXBlO2lmKDE9PT1ifHwzPT09YilicmVhaztpZig4PT09Yil7Yj1hLmRhdGE7aWYoXCIkXCI9PT1ifHxcIiQhXCI9PT1ifHxcIiQ/XCI9PT1iKWJyZWFrO2lmKFwiLyRcIj09PWIpcmV0dXJuIG51bGx9fXJldHVybiBhfVxuZnVuY3Rpb24gTWYoYSl7YT1hLnByZXZpb3VzU2libGluZztmb3IodmFyIGI9MDthOyl7aWYoOD09PWEubm9kZVR5cGUpe3ZhciBjPWEuZGF0YTtpZihcIiRcIj09PWN8fFwiJCFcIj09PWN8fFwiJD9cIj09PWMpe2lmKDA9PT1iKXJldHVybiBhO2ItLX1lbHNlXCIvJFwiPT09YyYmYisrfWE9YS5wcmV2aW91c1NpYmxpbmd9cmV0dXJuIG51bGx9dmFyIE5mPU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLE9mPVwiX19yZWFjdEZpYmVyJFwiK05mLFBmPVwiX19yZWFjdFByb3BzJFwiK05mLHVmPVwiX19yZWFjdENvbnRhaW5lciRcIitOZixvZj1cIl9fcmVhY3RFdmVudHMkXCIrTmYsUWY9XCJfX3JlYWN0TGlzdGVuZXJzJFwiK05mLFJmPVwiX19yZWFjdEhhbmRsZXMkXCIrTmY7XG5mdW5jdGlvbiBXYyhhKXt2YXIgYj1hW09mXTtpZihiKXJldHVybiBiO2Zvcih2YXIgYz1hLnBhcmVudE5vZGU7Yzspe2lmKGI9Y1t1Zl18fGNbT2ZdKXtjPWIuYWx0ZXJuYXRlO2lmKG51bGwhPT1iLmNoaWxkfHxudWxsIT09YyYmbnVsbCE9PWMuY2hpbGQpZm9yKGE9TWYoYSk7bnVsbCE9PWE7KXtpZihjPWFbT2ZdKXJldHVybiBjO2E9TWYoYSl9cmV0dXJuIGJ9YT1jO2M9YS5wYXJlbnROb2RlfXJldHVybiBudWxsfWZ1bmN0aW9uIENiKGEpe2E9YVtPZl18fGFbdWZdO3JldHVybiFhfHw1IT09YS50YWcmJjYhPT1hLnRhZyYmMTMhPT1hLnRhZyYmMyE9PWEudGFnP251bGw6YX1mdW5jdGlvbiB1ZShhKXtpZig1PT09YS50YWd8fDY9PT1hLnRhZylyZXR1cm4gYS5zdGF0ZU5vZGU7dGhyb3cgRXJyb3IocCgzMykpO31mdW5jdGlvbiBEYihhKXtyZXR1cm4gYVtQZl18fG51bGx9dmFyIFNmPVtdLFRmPS0xO2Z1bmN0aW9uIFVmKGEpe3JldHVybntjdXJyZW50OmF9fVxuZnVuY3Rpb24gRShhKXswPlRmfHwoYS5jdXJyZW50PVNmW1RmXSxTZltUZl09bnVsbCxUZi0tKX1mdW5jdGlvbiBHKGEsYil7VGYrKztTZltUZl09YS5jdXJyZW50O2EuY3VycmVudD1ifXZhciBWZj17fSxIPVVmKFZmKSxXZj1VZighMSksWGY9VmY7ZnVuY3Rpb24gWWYoYSxiKXt2YXIgYz1hLnR5cGUuY29udGV4dFR5cGVzO2lmKCFjKXJldHVybiBWZjt2YXIgZD1hLnN0YXRlTm9kZTtpZihkJiZkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1iKXJldHVybiBkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBlPXt9LGY7Zm9yKGYgaW4gYyllW2ZdPWJbZl07ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWIsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1lKTtyZXR1cm4gZX1cbmZ1bmN0aW9uIFpmKGEpe2E9YS5jaGlsZENvbnRleHRUeXBlcztyZXR1cm4gbnVsbCE9PWEmJnZvaWQgMCE9PWF9ZnVuY3Rpb24gJGYoKXtFKFdmKTtFKEgpfWZ1bmN0aW9uIGFnKGEsYixjKXtpZihILmN1cnJlbnQhPT1WZil0aHJvdyBFcnJvcihwKDE2OCkpO0coSCxiKTtHKFdmLGMpfWZ1bmN0aW9uIGJnKGEsYixjKXt2YXIgZD1hLnN0YXRlTm9kZTtiPWIuY2hpbGRDb250ZXh0VHlwZXM7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGQuZ2V0Q2hpbGRDb250ZXh0KXJldHVybiBjO2Q9ZC5nZXRDaGlsZENvbnRleHQoKTtmb3IodmFyIGUgaW4gZClpZighKGUgaW4gYikpdGhyb3cgRXJyb3IocCgxMDgsUmEoYSl8fFwiVW5rbm93blwiLGUpKTtyZXR1cm4gQSh7fSxjLGQpfVxuZnVuY3Rpb24gY2coYSl7YT0oYT1hLnN0YXRlTm9kZSkmJmEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHR8fFZmO1hmPUguY3VycmVudDtHKEgsYSk7RyhXZixXZi5jdXJyZW50KTtyZXR1cm4hMH1mdW5jdGlvbiBkZyhhLGIsYyl7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoIWQpdGhyb3cgRXJyb3IocCgxNjkpKTtjPyhhPWJnKGEsYixYZiksZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dD1hLEUoV2YpLEUoSCksRyhILGEpKTpFKFdmKTtHKFdmLGMpfXZhciBlZz1udWxsLGZnPSExLGdnPSExO2Z1bmN0aW9uIGhnKGEpe251bGw9PT1lZz9lZz1bYV06ZWcucHVzaChhKX1mdW5jdGlvbiBpZyhhKXtmZz0hMDtoZyhhKX1cbmZ1bmN0aW9uIGpnKCl7aWYoIWdnJiZudWxsIT09ZWcpe2dnPSEwO3ZhciBhPTAsYj1DO3RyeXt2YXIgYz1lZztmb3IoQz0xO2E8Yy5sZW5ndGg7YSsrKXt2YXIgZD1jW2FdO2RvIGQ9ZCghMCk7d2hpbGUobnVsbCE9PWQpfWVnPW51bGw7Zmc9ITF9Y2F0Y2goZSl7dGhyb3cgbnVsbCE9PWVnJiYoZWc9ZWcuc2xpY2UoYSsxKSksYWMoZmMsamcpLGU7fWZpbmFsbHl7Qz1iLGdnPSExfX1yZXR1cm4gbnVsbH12YXIga2c9W10sbGc9MCxtZz1udWxsLG5nPTAsb2c9W10scGc9MCxxZz1udWxsLHJnPTEsc2c9XCJcIjtmdW5jdGlvbiB0ZyhhLGIpe2tnW2xnKytdPW5nO2tnW2xnKytdPW1nO21nPWE7bmc9Yn1cbmZ1bmN0aW9uIHVnKGEsYixjKXtvZ1twZysrXT1yZztvZ1twZysrXT1zZztvZ1twZysrXT1xZztxZz1hO3ZhciBkPXJnO2E9c2c7dmFyIGU9MzItb2MoZCktMTtkJj1+KDE8PGUpO2MrPTE7dmFyIGY9MzItb2MoYikrZTtpZigzMDxmKXt2YXIgZz1lLWUlNTtmPShkJigxPDxnKS0xKS50b1N0cmluZygzMik7ZD4+PWc7ZS09ZztyZz0xPDwzMi1vYyhiKStlfGM8PGV8ZDtzZz1mK2F9ZWxzZSByZz0xPDxmfGM8PGV8ZCxzZz1hfWZ1bmN0aW9uIHZnKGEpe251bGwhPT1hLnJldHVybiYmKHRnKGEsMSksdWcoYSwxLDApKX1mdW5jdGlvbiB3ZyhhKXtmb3IoO2E9PT1tZzspbWc9a2dbLS1sZ10sa2dbbGddPW51bGwsbmc9a2dbLS1sZ10sa2dbbGddPW51bGw7Zm9yKDthPT09cWc7KXFnPW9nWy0tcGddLG9nW3BnXT1udWxsLHNnPW9nWy0tcGddLG9nW3BnXT1udWxsLHJnPW9nWy0tcGddLG9nW3BnXT1udWxsfXZhciB4Zz1udWxsLHlnPW51bGwsST0hMSx6Zz1udWxsO1xuZnVuY3Rpb24gQWcoYSxiKXt2YXIgYz1CZyg1LG51bGwsbnVsbCwwKTtjLmVsZW1lbnRUeXBlPVwiREVMRVRFRFwiO2Muc3RhdGVOb2RlPWI7Yy5yZXR1cm49YTtiPWEuZGVsZXRpb25zO251bGw9PT1iPyhhLmRlbGV0aW9ucz1bY10sYS5mbGFnc3w9MTYpOmIucHVzaChjKX1cbmZ1bmN0aW9uIENnKGEsYil7c3dpdGNoKGEudGFnKXtjYXNlIDU6dmFyIGM9YS50eXBlO2I9MSE9PWIubm9kZVR5cGV8fGMudG9Mb3dlckNhc2UoKSE9PWIubm9kZU5hbWUudG9Mb3dlckNhc2UoKT9udWxsOmI7cmV0dXJuIG51bGwhPT1iPyhhLnN0YXRlTm9kZT1iLHhnPWEseWc9TGYoYi5maXJzdENoaWxkKSwhMCk6ITE7Y2FzZSA2OnJldHVybiBiPVwiXCI9PT1hLnBlbmRpbmdQcm9wc3x8MyE9PWIubm9kZVR5cGU/bnVsbDpiLG51bGwhPT1iPyhhLnN0YXRlTm9kZT1iLHhnPWEseWc9bnVsbCwhMCk6ITE7Y2FzZSAxMzpyZXR1cm4gYj04IT09Yi5ub2RlVHlwZT9udWxsOmIsbnVsbCE9PWI/KGM9bnVsbCE9PXFnP3tpZDpyZyxvdmVyZmxvdzpzZ306bnVsbCxhLm1lbW9pemVkU3RhdGU9e2RlaHlkcmF0ZWQ6Yix0cmVlQ29udGV4dDpjLHJldHJ5TGFuZToxMDczNzQxODI0fSxjPUJnKDE4LG51bGwsbnVsbCwwKSxjLnN0YXRlTm9kZT1iLGMucmV0dXJuPWEsYS5jaGlsZD1jLHhnPWEseWc9XG5udWxsLCEwKTohMTtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBEZyhhKXtyZXR1cm4gMCE9PShhLm1vZGUmMSkmJjA9PT0oYS5mbGFncyYxMjgpfWZ1bmN0aW9uIEVnKGEpe2lmKEkpe3ZhciBiPXlnO2lmKGIpe3ZhciBjPWI7aWYoIUNnKGEsYikpe2lmKERnKGEpKXRocm93IEVycm9yKHAoNDE4KSk7Yj1MZihjLm5leHRTaWJsaW5nKTt2YXIgZD14ZztiJiZDZyhhLGIpP0FnKGQsYyk6KGEuZmxhZ3M9YS5mbGFncyYtNDA5N3wyLEk9ITEseGc9YSl9fWVsc2V7aWYoRGcoYSkpdGhyb3cgRXJyb3IocCg0MTgpKTthLmZsYWdzPWEuZmxhZ3MmLTQwOTd8MjtJPSExO3hnPWF9fX1mdW5jdGlvbiBGZyhhKXtmb3IoYT1hLnJldHVybjtudWxsIT09YSYmNSE9PWEudGFnJiYzIT09YS50YWcmJjEzIT09YS50YWc7KWE9YS5yZXR1cm47eGc9YX1cbmZ1bmN0aW9uIEdnKGEpe2lmKGEhPT14ZylyZXR1cm4hMTtpZighSSlyZXR1cm4gRmcoYSksST0hMCwhMTt2YXIgYjsoYj0zIT09YS50YWcpJiYhKGI9NSE9PWEudGFnKSYmKGI9YS50eXBlLGI9XCJoZWFkXCIhPT1iJiZcImJvZHlcIiE9PWImJiFFZihhLnR5cGUsYS5tZW1vaXplZFByb3BzKSk7aWYoYiYmKGI9eWcpKXtpZihEZyhhKSl0aHJvdyBIZygpLEVycm9yKHAoNDE4KSk7Zm9yKDtiOylBZyhhLGIpLGI9TGYoYi5uZXh0U2libGluZyl9RmcoYSk7aWYoMTM9PT1hLnRhZyl7YT1hLm1lbW9pemVkU3RhdGU7YT1udWxsIT09YT9hLmRlaHlkcmF0ZWQ6bnVsbDtpZighYSl0aHJvdyBFcnJvcihwKDMxNykpO2E6e2E9YS5uZXh0U2libGluZztmb3IoYj0wO2E7KXtpZig4PT09YS5ub2RlVHlwZSl7dmFyIGM9YS5kYXRhO2lmKFwiLyRcIj09PWMpe2lmKDA9PT1iKXt5Zz1MZihhLm5leHRTaWJsaW5nKTticmVhayBhfWItLX1lbHNlXCIkXCIhPT1jJiZcIiQhXCIhPT1jJiZcIiQ/XCIhPT1jfHxiKyt9YT1hLm5leHRTaWJsaW5nfXlnPVxubnVsbH19ZWxzZSB5Zz14Zz9MZihhLnN0YXRlTm9kZS5uZXh0U2libGluZyk6bnVsbDtyZXR1cm4hMH1mdW5jdGlvbiBIZygpe2Zvcih2YXIgYT15ZzthOylhPUxmKGEubmV4dFNpYmxpbmcpfWZ1bmN0aW9uIElnKCl7eWc9eGc9bnVsbDtJPSExfWZ1bmN0aW9uIEpnKGEpe251bGw9PT16Zz96Zz1bYV06emcucHVzaChhKX12YXIgS2c9dWEuUmVhY3RDdXJyZW50QmF0Y2hDb25maWc7XG5mdW5jdGlvbiBMZyhhLGIsYyl7YT1jLnJlZjtpZihudWxsIT09YSYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGEmJlwib2JqZWN0XCIhPT10eXBlb2YgYSl7aWYoYy5fb3duZXIpe2M9Yy5fb3duZXI7aWYoYyl7aWYoMSE9PWMudGFnKXRocm93IEVycm9yKHAoMzA5KSk7dmFyIGQ9Yy5zdGF0ZU5vZGV9aWYoIWQpdGhyb3cgRXJyb3IocCgxNDcsYSkpO3ZhciBlPWQsZj1cIlwiK2E7aWYobnVsbCE9PWImJm51bGwhPT1iLnJlZiYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGIucmVmJiZiLnJlZi5fc3RyaW5nUmVmPT09ZilyZXR1cm4gYi5yZWY7Yj1mdW5jdGlvbihhKXt2YXIgYj1lLnJlZnM7bnVsbD09PWE/ZGVsZXRlIGJbZl06YltmXT1hfTtiLl9zdHJpbmdSZWY9ZjtyZXR1cm4gYn1pZihcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgRXJyb3IocCgyODQpKTtpZighYy5fb3duZXIpdGhyb3cgRXJyb3IocCgyOTAsYSkpO31yZXR1cm4gYX1cbmZ1bmN0aW9uIE1nKGEsYil7YT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik7dGhyb3cgRXJyb3IocCgzMSxcIltvYmplY3QgT2JqZWN0XVwiPT09YT9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGIpLmpvaW4oXCIsIFwiKStcIn1cIjphKSk7fWZ1bmN0aW9uIE5nKGEpe3ZhciBiPWEuX2luaXQ7cmV0dXJuIGIoYS5fcGF5bG9hZCl9XG5mdW5jdGlvbiBPZyhhKXtmdW5jdGlvbiBiKGIsYyl7aWYoYSl7dmFyIGQ9Yi5kZWxldGlvbnM7bnVsbD09PWQ/KGIuZGVsZXRpb25zPVtjXSxiLmZsYWdzfD0xNik6ZC5wdXNoKGMpfX1mdW5jdGlvbiBjKGMsZCl7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKDtudWxsIT09ZDspYihjLGQpLGQ9ZC5zaWJsaW5nO3JldHVybiBudWxsfWZ1bmN0aW9uIGQoYSxiKXtmb3IoYT1uZXcgTWFwO251bGwhPT1iOyludWxsIT09Yi5rZXk/YS5zZXQoYi5rZXksYik6YS5zZXQoYi5pbmRleCxiKSxiPWIuc2libGluZztyZXR1cm4gYX1mdW5jdGlvbiBlKGEsYil7YT1QZyhhLGIpO2EuaW5kZXg9MDthLnNpYmxpbmc9bnVsbDtyZXR1cm4gYX1mdW5jdGlvbiBmKGIsYyxkKXtiLmluZGV4PWQ7aWYoIWEpcmV0dXJuIGIuZmxhZ3N8PTEwNDg1NzYsYztkPWIuYWx0ZXJuYXRlO2lmKG51bGwhPT1kKXJldHVybiBkPWQuaW5kZXgsZDxjPyhiLmZsYWdzfD0yLGMpOmQ7Yi5mbGFnc3w9MjtyZXR1cm4gY31mdW5jdGlvbiBnKGIpe2EmJlxubnVsbD09PWIuYWx0ZXJuYXRlJiYoYi5mbGFnc3w9Mik7cmV0dXJuIGJ9ZnVuY3Rpb24gaChhLGIsYyxkKXtpZihudWxsPT09Ynx8NiE9PWIudGFnKXJldHVybiBiPVFnKGMsYS5tb2RlLGQpLGIucmV0dXJuPWEsYjtiPWUoYixjKTtiLnJldHVybj1hO3JldHVybiBifWZ1bmN0aW9uIGsoYSxiLGMsZCl7dmFyIGY9Yy50eXBlO2lmKGY9PT15YSlyZXR1cm4gbShhLGIsYy5wcm9wcy5jaGlsZHJlbixkLGMua2V5KTtpZihudWxsIT09YiYmKGIuZWxlbWVudFR5cGU9PT1mfHxcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mJiZmLiQkdHlwZW9mPT09SGEmJk5nKGYpPT09Yi50eXBlKSlyZXR1cm4gZD1lKGIsYy5wcm9wcyksZC5yZWY9TGcoYSxiLGMpLGQucmV0dXJuPWEsZDtkPVJnKGMudHlwZSxjLmtleSxjLnByb3BzLG51bGwsYS5tb2RlLGQpO2QucmVmPUxnKGEsYixjKTtkLnJldHVybj1hO3JldHVybiBkfWZ1bmN0aW9uIGwoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDQhPT1iLnRhZ3x8XG5iLnN0YXRlTm9kZS5jb250YWluZXJJbmZvIT09Yy5jb250YWluZXJJbmZvfHxiLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiE9PWMuaW1wbGVtZW50YXRpb24pcmV0dXJuIGI9U2coYyxhLm1vZGUsZCksYi5yZXR1cm49YSxiO2I9ZShiLGMuY2hpbGRyZW58fFtdKTtiLnJldHVybj1hO3JldHVybiBifWZ1bmN0aW9uIG0oYSxiLGMsZCxmKXtpZihudWxsPT09Ynx8NyE9PWIudGFnKXJldHVybiBiPVRnKGMsYS5tb2RlLGQsZiksYi5yZXR1cm49YSxiO2I9ZShiLGMpO2IucmV0dXJuPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gcShhLGIsYyl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBiJiZcIlwiIT09Ynx8XCJudW1iZXJcIj09PXR5cGVvZiBiKXJldHVybiBiPVFnKFwiXCIrYixhLm1vZGUsYyksYi5yZXR1cm49YSxiO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYiYmbnVsbCE9PWIpe3N3aXRjaChiLiQkdHlwZW9mKXtjYXNlIHZhOnJldHVybiBjPVJnKGIudHlwZSxiLmtleSxiLnByb3BzLG51bGwsYS5tb2RlLGMpLFxuYy5yZWY9TGcoYSxudWxsLGIpLGMucmV0dXJuPWEsYztjYXNlIHdhOnJldHVybiBiPVNnKGIsYS5tb2RlLGMpLGIucmV0dXJuPWEsYjtjYXNlIEhhOnZhciBkPWIuX2luaXQ7cmV0dXJuIHEoYSxkKGIuX3BheWxvYWQpLGMpfWlmKGViKGIpfHxLYShiKSlyZXR1cm4gYj1UZyhiLGEubW9kZSxjLG51bGwpLGIucmV0dXJuPWEsYjtNZyhhLGIpfXJldHVybiBudWxsfWZ1bmN0aW9uIHIoYSxiLGMsZCl7dmFyIGU9bnVsbCE9PWI/Yi5rZXk6bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGMmJlwiXCIhPT1jfHxcIm51bWJlclwiPT09dHlwZW9mIGMpcmV0dXJuIG51bGwhPT1lP251bGw6aChhLGIsXCJcIitjLGQpO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYyYmbnVsbCE9PWMpe3N3aXRjaChjLiQkdHlwZW9mKXtjYXNlIHZhOnJldHVybiBjLmtleT09PWU/ayhhLGIsYyxkKTpudWxsO2Nhc2Ugd2E6cmV0dXJuIGMua2V5PT09ZT9sKGEsYixjLGQpOm51bGw7Y2FzZSBIYTpyZXR1cm4gZT1jLl9pbml0LHIoYSxcbmIsZShjLl9wYXlsb2FkKSxkKX1pZihlYihjKXx8S2EoYykpcmV0dXJuIG51bGwhPT1lP251bGw6bShhLGIsYyxkLG51bGwpO01nKGEsYyl9cmV0dXJuIG51bGx9ZnVuY3Rpb24geShhLGIsYyxkLGUpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgZCYmXCJcIiE9PWR8fFwibnVtYmVyXCI9PT10eXBlb2YgZClyZXR1cm4gYT1hLmdldChjKXx8bnVsbCxoKGIsYSxcIlwiK2QsZSk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBkJiZudWxsIT09ZCl7c3dpdGNoKGQuJCR0eXBlb2Ype2Nhc2UgdmE6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLGsoYixhLGQsZSk7Y2FzZSB3YTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsbChiLGEsZCxlKTtjYXNlIEhhOnZhciBmPWQuX2luaXQ7cmV0dXJuIHkoYSxiLGMsZihkLl9wYXlsb2FkKSxlKX1pZihlYihkKXx8S2EoZCkpcmV0dXJuIGE9YS5nZXQoYyl8fG51bGwsbShiLGEsZCxlLG51bGwpO01nKGIsZCl9cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBuKGUsZyxoLGspe2Zvcih2YXIgbD1udWxsLG09bnVsbCx1PWcsdz1nPTAseD1udWxsO251bGwhPT11JiZ3PGgubGVuZ3RoO3crKyl7dS5pbmRleD53Pyh4PXUsdT1udWxsKTp4PXUuc2libGluZzt2YXIgbj1yKGUsdSxoW3ddLGspO2lmKG51bGw9PT1uKXtudWxsPT09dSYmKHU9eCk7YnJlYWt9YSYmdSYmbnVsbD09PW4uYWx0ZXJuYXRlJiZiKGUsdSk7Zz1mKG4sZyx3KTtudWxsPT09bT9sPW46bS5zaWJsaW5nPW47bT1uO3U9eH1pZih3PT09aC5sZW5ndGgpcmV0dXJuIGMoZSx1KSxJJiZ0ZyhlLHcpLGw7aWYobnVsbD09PXUpe2Zvcig7dzxoLmxlbmd0aDt3KyspdT1xKGUsaFt3XSxrKSxudWxsIT09dSYmKGc9Zih1LGcsdyksbnVsbD09PW0/bD11Om0uc2libGluZz11LG09dSk7SSYmdGcoZSx3KTtyZXR1cm4gbH1mb3IodT1kKGUsdSk7dzxoLmxlbmd0aDt3KyspeD15KHUsZSx3LGhbd10sayksbnVsbCE9PXgmJihhJiZudWxsIT09eC5hbHRlcm5hdGUmJnUuZGVsZXRlKG51bGw9PT1cbngua2V5P3c6eC5rZXkpLGc9Zih4LGcsdyksbnVsbD09PW0/bD14Om0uc2libGluZz14LG09eCk7YSYmdS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JldHVybiBiKGUsYSl9KTtJJiZ0ZyhlLHcpO3JldHVybiBsfWZ1bmN0aW9uIHQoZSxnLGgsayl7dmFyIGw9S2EoaCk7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGwpdGhyb3cgRXJyb3IocCgxNTApKTtoPWwuY2FsbChoKTtpZihudWxsPT1oKXRocm93IEVycm9yKHAoMTUxKSk7Zm9yKHZhciB1PWw9bnVsbCxtPWcsdz1nPTAseD1udWxsLG49aC5uZXh0KCk7bnVsbCE9PW0mJiFuLmRvbmU7dysrLG49aC5uZXh0KCkpe20uaW5kZXg+dz8oeD1tLG09bnVsbCk6eD1tLnNpYmxpbmc7dmFyIHQ9cihlLG0sbi52YWx1ZSxrKTtpZihudWxsPT09dCl7bnVsbD09PW0mJihtPXgpO2JyZWFrfWEmJm0mJm51bGw9PT10LmFsdGVybmF0ZSYmYihlLG0pO2c9Zih0LGcsdyk7bnVsbD09PXU/bD10OnUuc2libGluZz10O3U9dDttPXh9aWYobi5kb25lKXJldHVybiBjKGUsXG5tKSxJJiZ0ZyhlLHcpLGw7aWYobnVsbD09PW0pe2Zvcig7IW4uZG9uZTt3Kyssbj1oLm5leHQoKSluPXEoZSxuLnZhbHVlLGspLG51bGwhPT1uJiYoZz1mKG4sZyx3KSxudWxsPT09dT9sPW46dS5zaWJsaW5nPW4sdT1uKTtJJiZ0ZyhlLHcpO3JldHVybiBsfWZvcihtPWQoZSxtKTshbi5kb25lO3crKyxuPWgubmV4dCgpKW49eShtLGUsdyxuLnZhbHVlLGspLG51bGwhPT1uJiYoYSYmbnVsbCE9PW4uYWx0ZXJuYXRlJiZtLmRlbGV0ZShudWxsPT09bi5rZXk/dzpuLmtleSksZz1mKG4sZyx3KSxudWxsPT09dT9sPW46dS5zaWJsaW5nPW4sdT1uKTthJiZtLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO0kmJnRnKGUsdyk7cmV0dXJuIGx9ZnVuY3Rpb24gSihhLGQsZixoKXtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mJiZmLnR5cGU9PT15YSYmbnVsbD09PWYua2V5JiYoZj1mLnByb3BzLmNoaWxkcmVuKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mKXtzd2l0Y2goZi4kJHR5cGVvZil7Y2FzZSB2YTphOntmb3IodmFyIGs9XG5mLmtleSxsPWQ7bnVsbCE9PWw7KXtpZihsLmtleT09PWspe2s9Zi50eXBlO2lmKGs9PT15YSl7aWYoNz09PWwudGFnKXtjKGEsbC5zaWJsaW5nKTtkPWUobCxmLnByb3BzLmNoaWxkcmVuKTtkLnJldHVybj1hO2E9ZDticmVhayBhfX1lbHNlIGlmKGwuZWxlbWVudFR5cGU9PT1rfHxcIm9iamVjdFwiPT09dHlwZW9mIGsmJm51bGwhPT1rJiZrLiQkdHlwZW9mPT09SGEmJk5nKGspPT09bC50eXBlKXtjKGEsbC5zaWJsaW5nKTtkPWUobCxmLnByb3BzKTtkLnJlZj1MZyhhLGwsZik7ZC5yZXR1cm49YTthPWQ7YnJlYWsgYX1jKGEsbCk7YnJlYWt9ZWxzZSBiKGEsbCk7bD1sLnNpYmxpbmd9Zi50eXBlPT09eWE/KGQ9VGcoZi5wcm9wcy5jaGlsZHJlbixhLm1vZGUsaCxmLmtleSksZC5yZXR1cm49YSxhPWQpOihoPVJnKGYudHlwZSxmLmtleSxmLnByb3BzLG51bGwsYS5tb2RlLGgpLGgucmVmPUxnKGEsZCxmKSxoLnJldHVybj1hLGE9aCl9cmV0dXJuIGcoYSk7Y2FzZSB3YTphOntmb3IobD1mLmtleTtudWxsIT09XG5kOyl7aWYoZC5rZXk9PT1sKWlmKDQ9PT1kLnRhZyYmZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbz09PWYuY29udGFpbmVySW5mbyYmZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb249PT1mLmltcGxlbWVudGF0aW9uKXtjKGEsZC5zaWJsaW5nKTtkPWUoZCxmLmNoaWxkcmVufHxbXSk7ZC5yZXR1cm49YTthPWQ7YnJlYWsgYX1lbHNle2MoYSxkKTticmVha31lbHNlIGIoYSxkKTtkPWQuc2libGluZ31kPVNnKGYsYS5tb2RlLGgpO2QucmV0dXJuPWE7YT1kfXJldHVybiBnKGEpO2Nhc2UgSGE6cmV0dXJuIGw9Zi5faW5pdCxKKGEsZCxsKGYuX3BheWxvYWQpLGgpfWlmKGViKGYpKXJldHVybiBuKGEsZCxmLGgpO2lmKEthKGYpKXJldHVybiB0KGEsZCxmLGgpO01nKGEsZil9cmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBmJiZcIlwiIT09Znx8XCJudW1iZXJcIj09PXR5cGVvZiBmPyhmPVwiXCIrZixudWxsIT09ZCYmNj09PWQudGFnPyhjKGEsZC5zaWJsaW5nKSxkPWUoZCxmKSxkLnJldHVybj1hLGE9ZCk6XG4oYyhhLGQpLGQ9UWcoZixhLm1vZGUsaCksZC5yZXR1cm49YSxhPWQpLGcoYSkpOmMoYSxkKX1yZXR1cm4gSn12YXIgVWc9T2coITApLFZnPU9nKCExKSxXZz1VZihudWxsKSxYZz1udWxsLFlnPW51bGwsWmc9bnVsbDtmdW5jdGlvbiAkZygpe1pnPVlnPVhnPW51bGx9ZnVuY3Rpb24gYWgoYSl7dmFyIGI9V2cuY3VycmVudDtFKFdnKTthLl9jdXJyZW50VmFsdWU9Yn1mdW5jdGlvbiBiaChhLGIsYyl7Zm9yKDtudWxsIT09YTspe3ZhciBkPWEuYWx0ZXJuYXRlOyhhLmNoaWxkTGFuZXMmYikhPT1iPyhhLmNoaWxkTGFuZXN8PWIsbnVsbCE9PWQmJihkLmNoaWxkTGFuZXN8PWIpKTpudWxsIT09ZCYmKGQuY2hpbGRMYW5lcyZiKSE9PWImJihkLmNoaWxkTGFuZXN8PWIpO2lmKGE9PT1jKWJyZWFrO2E9YS5yZXR1cm59fVxuZnVuY3Rpb24gY2goYSxiKXtYZz1hO1pnPVlnPW51bGw7YT1hLmRlcGVuZGVuY2llcztudWxsIT09YSYmbnVsbCE9PWEuZmlyc3RDb250ZXh0JiYoMCE9PShhLmxhbmVzJmIpJiYoZGg9ITApLGEuZmlyc3RDb250ZXh0PW51bGwpfWZ1bmN0aW9uIGVoKGEpe3ZhciBiPWEuX2N1cnJlbnRWYWx1ZTtpZihaZyE9PWEpaWYoYT17Y29udGV4dDphLG1lbW9pemVkVmFsdWU6YixuZXh0Om51bGx9LG51bGw9PT1ZZyl7aWYobnVsbD09PVhnKXRocm93IEVycm9yKHAoMzA4KSk7WWc9YTtYZy5kZXBlbmRlbmNpZXM9e2xhbmVzOjAsZmlyc3RDb250ZXh0OmF9fWVsc2UgWWc9WWcubmV4dD1hO3JldHVybiBifXZhciBmaD1udWxsO2Z1bmN0aW9uIGdoKGEpe251bGw9PT1maD9maD1bYV06ZmgucHVzaChhKX1cbmZ1bmN0aW9uIGhoKGEsYixjLGQpe3ZhciBlPWIuaW50ZXJsZWF2ZWQ7bnVsbD09PWU/KGMubmV4dD1jLGdoKGIpKTooYy5uZXh0PWUubmV4dCxlLm5leHQ9Yyk7Yi5pbnRlcmxlYXZlZD1jO3JldHVybiBpaChhLGQpfWZ1bmN0aW9uIGloKGEsYil7YS5sYW5lc3w9Yjt2YXIgYz1hLmFsdGVybmF0ZTtudWxsIT09YyYmKGMubGFuZXN8PWIpO2M9YTtmb3IoYT1hLnJldHVybjtudWxsIT09YTspYS5jaGlsZExhbmVzfD1iLGM9YS5hbHRlcm5hdGUsbnVsbCE9PWMmJihjLmNoaWxkTGFuZXN8PWIpLGM9YSxhPWEucmV0dXJuO3JldHVybiAzPT09Yy50YWc/Yy5zdGF0ZU5vZGU6bnVsbH12YXIgamg9ITE7ZnVuY3Rpb24ga2goYSl7YS51cGRhdGVRdWV1ZT17YmFzZVN0YXRlOmEubWVtb2l6ZWRTdGF0ZSxmaXJzdEJhc2VVcGRhdGU6bnVsbCxsYXN0QmFzZVVwZGF0ZTpudWxsLHNoYXJlZDp7cGVuZGluZzpudWxsLGludGVybGVhdmVkOm51bGwsbGFuZXM6MH0sZWZmZWN0czpudWxsfX1cbmZ1bmN0aW9uIGxoKGEsYil7YT1hLnVwZGF0ZVF1ZXVlO2IudXBkYXRlUXVldWU9PT1hJiYoYi51cGRhdGVRdWV1ZT17YmFzZVN0YXRlOmEuYmFzZVN0YXRlLGZpcnN0QmFzZVVwZGF0ZTphLmZpcnN0QmFzZVVwZGF0ZSxsYXN0QmFzZVVwZGF0ZTphLmxhc3RCYXNlVXBkYXRlLHNoYXJlZDphLnNoYXJlZCxlZmZlY3RzOmEuZWZmZWN0c30pfWZ1bmN0aW9uIG1oKGEsYil7cmV0dXJue2V2ZW50VGltZTphLGxhbmU6Yix0YWc6MCxwYXlsb2FkOm51bGwsY2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9fVxuZnVuY3Rpb24gbmgoYSxiLGMpe3ZhciBkPWEudXBkYXRlUXVldWU7aWYobnVsbD09PWQpcmV0dXJuIG51bGw7ZD1kLnNoYXJlZDtpZigwIT09KEsmMikpe3ZhciBlPWQucGVuZGluZztudWxsPT09ZT9iLm5leHQ9YjooYi5uZXh0PWUubmV4dCxlLm5leHQ9Yik7ZC5wZW5kaW5nPWI7cmV0dXJuIGloKGEsYyl9ZT1kLmludGVybGVhdmVkO251bGw9PT1lPyhiLm5leHQ9YixnaChkKSk6KGIubmV4dD1lLm5leHQsZS5uZXh0PWIpO2QuaW50ZXJsZWF2ZWQ9YjtyZXR1cm4gaWgoYSxjKX1mdW5jdGlvbiBvaChhLGIsYyl7Yj1iLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1iJiYoYj1iLnNoYXJlZCwwIT09KGMmNDE5NDI0MCkpKXt2YXIgZD1iLmxhbmVzO2QmPWEucGVuZGluZ0xhbmVzO2N8PWQ7Yi5sYW5lcz1jO0NjKGEsYyl9fVxuZnVuY3Rpb24gcGgoYSxiKXt2YXIgYz1hLnVwZGF0ZVF1ZXVlLGQ9YS5hbHRlcm5hdGU7aWYobnVsbCE9PWQmJihkPWQudXBkYXRlUXVldWUsYz09PWQpKXt2YXIgZT1udWxsLGY9bnVsbDtjPWMuZmlyc3RCYXNlVXBkYXRlO2lmKG51bGwhPT1jKXtkb3t2YXIgZz17ZXZlbnRUaW1lOmMuZXZlbnRUaW1lLGxhbmU6Yy5sYW5lLHRhZzpjLnRhZyxwYXlsb2FkOmMucGF5bG9hZCxjYWxsYmFjazpjLmNhbGxiYWNrLG5leHQ6bnVsbH07bnVsbD09PWY/ZT1mPWc6Zj1mLm5leHQ9ZztjPWMubmV4dH13aGlsZShudWxsIT09Yyk7bnVsbD09PWY/ZT1mPWI6Zj1mLm5leHQ9Yn1lbHNlIGU9Zj1iO2M9e2Jhc2VTdGF0ZTpkLmJhc2VTdGF0ZSxmaXJzdEJhc2VVcGRhdGU6ZSxsYXN0QmFzZVVwZGF0ZTpmLHNoYXJlZDpkLnNoYXJlZCxlZmZlY3RzOmQuZWZmZWN0c307YS51cGRhdGVRdWV1ZT1jO3JldHVybn1hPWMubGFzdEJhc2VVcGRhdGU7bnVsbD09PWE/Yy5maXJzdEJhc2VVcGRhdGU9YjphLm5leHQ9XG5iO2MubGFzdEJhc2VVcGRhdGU9Yn1cbmZ1bmN0aW9uIHFoKGEsYixjLGQpe3ZhciBlPWEudXBkYXRlUXVldWU7amg9ITE7dmFyIGY9ZS5maXJzdEJhc2VVcGRhdGUsZz1lLmxhc3RCYXNlVXBkYXRlLGg9ZS5zaGFyZWQucGVuZGluZztpZihudWxsIT09aCl7ZS5zaGFyZWQucGVuZGluZz1udWxsO3ZhciBrPWgsbD1rLm5leHQ7ay5uZXh0PW51bGw7bnVsbD09PWc/Zj1sOmcubmV4dD1sO2c9azt2YXIgbT1hLmFsdGVybmF0ZTtudWxsIT09bSYmKG09bS51cGRhdGVRdWV1ZSxoPW0ubGFzdEJhc2VVcGRhdGUsaCE9PWcmJihudWxsPT09aD9tLmZpcnN0QmFzZVVwZGF0ZT1sOmgubmV4dD1sLG0ubGFzdEJhc2VVcGRhdGU9aykpfWlmKG51bGwhPT1mKXt2YXIgcT1lLmJhc2VTdGF0ZTtnPTA7bT1sPWs9bnVsbDtoPWY7ZG97dmFyIHI9aC5sYW5lLHk9aC5ldmVudFRpbWU7aWYoKGQmcik9PT1yKXtudWxsIT09bSYmKG09bS5uZXh0PXtldmVudFRpbWU6eSxsYW5lOjAsdGFnOmgudGFnLHBheWxvYWQ6aC5wYXlsb2FkLGNhbGxiYWNrOmguY2FsbGJhY2ssXG5uZXh0Om51bGx9KTthOnt2YXIgbj1hLHQ9aDtyPWI7eT1jO3N3aXRjaCh0LnRhZyl7Y2FzZSAxOm49dC5wYXlsb2FkO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBuKXtxPW4uY2FsbCh5LHEscik7YnJlYWsgYX1xPW47YnJlYWsgYTtjYXNlIDM6bi5mbGFncz1uLmZsYWdzJi02NTUzN3wxMjg7Y2FzZSAwOm49dC5wYXlsb2FkO3I9XCJmdW5jdGlvblwiPT09dHlwZW9mIG4/bi5jYWxsKHkscSxyKTpuO2lmKG51bGw9PT1yfHx2b2lkIDA9PT1yKWJyZWFrIGE7cT1BKHt9LHEscik7YnJlYWsgYTtjYXNlIDI6amg9ITB9fW51bGwhPT1oLmNhbGxiYWNrJiYwIT09aC5sYW5lJiYoYS5mbGFnc3w9NjQscj1lLmVmZmVjdHMsbnVsbD09PXI/ZS5lZmZlY3RzPVtoXTpyLnB1c2goaCkpfWVsc2UgeT17ZXZlbnRUaW1lOnksbGFuZTpyLHRhZzpoLnRhZyxwYXlsb2FkOmgucGF5bG9hZCxjYWxsYmFjazpoLmNhbGxiYWNrLG5leHQ6bnVsbH0sbnVsbD09PW0/KGw9bT15LGs9cSk6bT1tLm5leHQ9eSxnfD1yO1xuaD1oLm5leHQ7aWYobnVsbD09PWgpaWYoaD1lLnNoYXJlZC5wZW5kaW5nLG51bGw9PT1oKWJyZWFrO2Vsc2Ugcj1oLGg9ci5uZXh0LHIubmV4dD1udWxsLGUubGFzdEJhc2VVcGRhdGU9cixlLnNoYXJlZC5wZW5kaW5nPW51bGx9d2hpbGUoMSk7bnVsbD09PW0mJihrPXEpO2UuYmFzZVN0YXRlPWs7ZS5maXJzdEJhc2VVcGRhdGU9bDtlLmxhc3RCYXNlVXBkYXRlPW07Yj1lLnNoYXJlZC5pbnRlcmxlYXZlZDtpZihudWxsIT09Yil7ZT1iO2RvIGd8PWUubGFuZSxlPWUubmV4dDt3aGlsZShlIT09Yil9ZWxzZSBudWxsPT09ZiYmKGUuc2hhcmVkLmxhbmVzPTApO3JofD1nO2EubGFuZXM9ZzthLm1lbW9pemVkU3RhdGU9cX19XG5mdW5jdGlvbiBzaChhLGIsYyl7YT1iLmVmZmVjdHM7Yi5lZmZlY3RzPW51bGw7aWYobnVsbCE9PWEpZm9yKGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGQ9YVtiXSxlPWQuY2FsbGJhY2s7aWYobnVsbCE9PWUpe2QuY2FsbGJhY2s9bnVsbDtkPWM7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGUpdGhyb3cgRXJyb3IocCgxOTEsZSkpO2UuY2FsbChkKX19fXZhciB0aD17fSx1aD1VZih0aCksdmg9VWYodGgpLHdoPVVmKHRoKTtmdW5jdGlvbiB4aChhKXtpZihhPT09dGgpdGhyb3cgRXJyb3IocCgxNzQpKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIHloKGEsYil7Ryh3aCxiKTtHKHZoLGEpO0codWgsdGgpO2E9Yi5ub2RlVHlwZTtzd2l0Y2goYSl7Y2FzZSA5OmNhc2UgMTE6Yj0oYj1iLmRvY3VtZW50RWxlbWVudCk/Yi5uYW1lc3BhY2VVUkk6bGIobnVsbCxcIlwiKTticmVhaztkZWZhdWx0OmE9OD09PWE/Yi5wYXJlbnROb2RlOmIsYj1hLm5hbWVzcGFjZVVSSXx8bnVsbCxhPWEudGFnTmFtZSxiPWxiKGIsYSl9RSh1aCk7Ryh1aCxiKX1mdW5jdGlvbiB6aCgpe0UodWgpO0UodmgpO0Uod2gpfWZ1bmN0aW9uIEFoKGEpe3hoKHdoLmN1cnJlbnQpO3ZhciBiPXhoKHVoLmN1cnJlbnQpO3ZhciBjPWxiKGIsYS50eXBlKTtiIT09YyYmKEcodmgsYSksRyh1aCxjKSl9ZnVuY3Rpb24gQmgoYSl7dmguY3VycmVudD09PWEmJihFKHVoKSxFKHZoKSl9dmFyIEw9VWYoMCk7XG5mdW5jdGlvbiBDaChhKXtmb3IodmFyIGI9YTtudWxsIT09Yjspe2lmKDEzPT09Yi50YWcpe3ZhciBjPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09YyYmKGM9Yy5kZWh5ZHJhdGVkLG51bGw9PT1jfHxcIiQ/XCI9PT1jLmRhdGF8fFwiJCFcIj09PWMuZGF0YSkpcmV0dXJuIGJ9ZWxzZSBpZigxOT09PWIudGFnJiZ2b2lkIDAhPT1iLm1lbW9pemVkUHJvcHMucmV2ZWFsT3JkZXIpe2lmKDAhPT0oYi5mbGFncyYxMjgpKXJldHVybiBifWVsc2UgaWYobnVsbCE9PWIuY2hpbGQpe2IuY2hpbGQucmV0dXJuPWI7Yj1iLmNoaWxkO2NvbnRpbnVlfWlmKGI9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWIuc2libGluZzspe2lmKG51bGw9PT1iLnJldHVybnx8Yi5yZXR1cm49PT1hKXJldHVybiBudWxsO2I9Yi5yZXR1cm59Yi5zaWJsaW5nLnJldHVybj1iLnJldHVybjtiPWIuc2libGluZ31yZXR1cm4gbnVsbH12YXIgRGg9W107XG5mdW5jdGlvbiBFaCgpe2Zvcih2YXIgYT0wO2E8RGgubGVuZ3RoO2ErKylEaFthXS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeT1udWxsO0RoLmxlbmd0aD0wfXZhciBGaD11YS5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLEdoPXVhLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLEhoPTAsTT1udWxsLE49bnVsbCxPPW51bGwsSWg9ITEsSmg9ITEsS2g9MCxMaD0wO2Z1bmN0aW9uIFAoKXt0aHJvdyBFcnJvcihwKDMyMSkpO31mdW5jdGlvbiBNaChhLGIpe2lmKG51bGw9PT1iKXJldHVybiExO2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGgmJmM8YS5sZW5ndGg7YysrKWlmKCFIZShhW2NdLGJbY10pKXJldHVybiExO3JldHVybiEwfVxuZnVuY3Rpb24gTmgoYSxiLGMsZCxlLGYpe0hoPWY7TT1iO2IubWVtb2l6ZWRTdGF0ZT1udWxsO2IudXBkYXRlUXVldWU9bnVsbDtiLmxhbmVzPTA7RmguY3VycmVudD1udWxsPT09YXx8bnVsbD09PWEubWVtb2l6ZWRTdGF0ZT9PaDpQaDthPWMoZCxlKTtpZihKaCl7Zj0wO2Rve0poPSExO0toPTA7aWYoMjU8PWYpdGhyb3cgRXJyb3IocCgzMDEpKTtmKz0xO089Tj1udWxsO2IudXBkYXRlUXVldWU9bnVsbDtGaC5jdXJyZW50PVFoO2E9YyhkLGUpfXdoaWxlKEpoKX1GaC5jdXJyZW50PVJoO2I9bnVsbCE9PU4mJm51bGwhPT1OLm5leHQ7SGg9MDtPPU49TT1udWxsO0loPSExO2lmKGIpdGhyb3cgRXJyb3IocCgzMDApKTtyZXR1cm4gYX1mdW5jdGlvbiBTaCgpe3ZhciBhPTAhPT1LaDtLaD0wO3JldHVybiBhfVxuZnVuY3Rpb24gVGgoKXt2YXIgYT17bWVtb2l6ZWRTdGF0ZTpudWxsLGJhc2VTdGF0ZTpudWxsLGJhc2VRdWV1ZTpudWxsLHF1ZXVlOm51bGwsbmV4dDpudWxsfTtudWxsPT09Tz9NLm1lbW9pemVkU3RhdGU9Tz1hOk89Ty5uZXh0PWE7cmV0dXJuIE99ZnVuY3Rpb24gVWgoKXtpZihudWxsPT09Til7dmFyIGE9TS5hbHRlcm5hdGU7YT1udWxsIT09YT9hLm1lbW9pemVkU3RhdGU6bnVsbH1lbHNlIGE9Ti5uZXh0O3ZhciBiPW51bGw9PT1PP00ubWVtb2l6ZWRTdGF0ZTpPLm5leHQ7aWYobnVsbCE9PWIpTz1iLE49YTtlbHNle2lmKG51bGw9PT1hKXRocm93IEVycm9yKHAoMzEwKSk7Tj1hO2E9e21lbW9pemVkU3RhdGU6Ti5tZW1vaXplZFN0YXRlLGJhc2VTdGF0ZTpOLmJhc2VTdGF0ZSxiYXNlUXVldWU6Ti5iYXNlUXVldWUscXVldWU6Ti5xdWV1ZSxuZXh0Om51bGx9O251bGw9PT1PP00ubWVtb2l6ZWRTdGF0ZT1PPWE6Tz1PLm5leHQ9YX1yZXR1cm4gT31cbmZ1bmN0aW9uIFZoKGEsYil7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGI/YihhKTpifVxuZnVuY3Rpb24gV2goYSl7dmFyIGI9VWgoKSxjPWIucXVldWU7aWYobnVsbD09PWMpdGhyb3cgRXJyb3IocCgzMTEpKTtjLmxhc3RSZW5kZXJlZFJlZHVjZXI9YTt2YXIgZD1OLGU9ZC5iYXNlUXVldWUsZj1jLnBlbmRpbmc7aWYobnVsbCE9PWYpe2lmKG51bGwhPT1lKXt2YXIgZz1lLm5leHQ7ZS5uZXh0PWYubmV4dDtmLm5leHQ9Z31kLmJhc2VRdWV1ZT1lPWY7Yy5wZW5kaW5nPW51bGx9aWYobnVsbCE9PWUpe2Y9ZS5uZXh0O2Q9ZC5iYXNlU3RhdGU7dmFyIGg9Zz1udWxsLGs9bnVsbCxsPWY7ZG97dmFyIG09bC5sYW5lO2lmKChIaCZtKT09PW0pbnVsbCE9PWsmJihrPWsubmV4dD17bGFuZTowLGFjdGlvbjpsLmFjdGlvbixoYXNFYWdlclN0YXRlOmwuaGFzRWFnZXJTdGF0ZSxlYWdlclN0YXRlOmwuZWFnZXJTdGF0ZSxuZXh0Om51bGx9KSxkPWwuaGFzRWFnZXJTdGF0ZT9sLmVhZ2VyU3RhdGU6YShkLGwuYWN0aW9uKTtlbHNle3ZhciBxPXtsYW5lOm0sYWN0aW9uOmwuYWN0aW9uLGhhc0VhZ2VyU3RhdGU6bC5oYXNFYWdlclN0YXRlLFxuZWFnZXJTdGF0ZTpsLmVhZ2VyU3RhdGUsbmV4dDpudWxsfTtudWxsPT09az8oaD1rPXEsZz1kKTprPWsubmV4dD1xO00ubGFuZXN8PW07cmh8PW19bD1sLm5leHR9d2hpbGUobnVsbCE9PWwmJmwhPT1mKTtudWxsPT09az9nPWQ6ay5uZXh0PWg7SGUoZCxiLm1lbW9pemVkU3RhdGUpfHwoZGg9ITApO2IubWVtb2l6ZWRTdGF0ZT1kO2IuYmFzZVN0YXRlPWc7Yi5iYXNlUXVldWU9aztjLmxhc3RSZW5kZXJlZFN0YXRlPWR9YT1jLmludGVybGVhdmVkO2lmKG51bGwhPT1hKXtlPWE7ZG8gZj1lLmxhbmUsTS5sYW5lc3w9ZixyaHw9ZixlPWUubmV4dDt3aGlsZShlIT09YSl9ZWxzZSBudWxsPT09ZSYmKGMubGFuZXM9MCk7cmV0dXJuW2IubWVtb2l6ZWRTdGF0ZSxjLmRpc3BhdGNoXX1cbmZ1bmN0aW9uIFhoKGEpe3ZhciBiPVVoKCksYz1iLnF1ZXVlO2lmKG51bGw9PT1jKXRocm93IEVycm9yKHAoMzExKSk7Yy5sYXN0UmVuZGVyZWRSZWR1Y2VyPWE7dmFyIGQ9Yy5kaXNwYXRjaCxlPWMucGVuZGluZyxmPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09ZSl7Yy5wZW5kaW5nPW51bGw7dmFyIGc9ZT1lLm5leHQ7ZG8gZj1hKGYsZy5hY3Rpb24pLGc9Zy5uZXh0O3doaWxlKGchPT1lKTtIZShmLGIubWVtb2l6ZWRTdGF0ZSl8fChkaD0hMCk7Yi5tZW1vaXplZFN0YXRlPWY7bnVsbD09PWIuYmFzZVF1ZXVlJiYoYi5iYXNlU3RhdGU9Zik7Yy5sYXN0UmVuZGVyZWRTdGF0ZT1mfXJldHVybltmLGRdfWZ1bmN0aW9uIFloKCl7fVxuZnVuY3Rpb24gWmgoYSxiKXt2YXIgYz1NLGQ9VWgoKSxlPWIoKSxmPSFIZShkLm1lbW9pemVkU3RhdGUsZSk7ZiYmKGQubWVtb2l6ZWRTdGF0ZT1lLGRoPSEwKTtkPWQucXVldWU7JGgoYWkuYmluZChudWxsLGMsZCxhKSxbYV0pO2lmKGQuZ2V0U25hcHNob3QhPT1ifHxmfHxudWxsIT09TyYmTy5tZW1vaXplZFN0YXRlLnRhZyYxKXtjLmZsYWdzfD0yMDQ4O2JpKDksY2kuYmluZChudWxsLGMsZCxlLGIpLHZvaWQgMCxudWxsKTtpZihudWxsPT09USl0aHJvdyBFcnJvcihwKDM0OSkpOzAhPT0oSGgmMzApfHxkaShjLGIsZSl9cmV0dXJuIGV9ZnVuY3Rpb24gZGkoYSxiLGMpe2EuZmxhZ3N8PTE2Mzg0O2E9e2dldFNuYXBzaG90OmIsdmFsdWU6Y307Yj1NLnVwZGF0ZVF1ZXVlO251bGw9PT1iPyhiPXtsYXN0RWZmZWN0Om51bGwsc3RvcmVzOm51bGx9LE0udXBkYXRlUXVldWU9YixiLnN0b3Jlcz1bYV0pOihjPWIuc3RvcmVzLG51bGw9PT1jP2Iuc3RvcmVzPVthXTpjLnB1c2goYSkpfVxuZnVuY3Rpb24gY2koYSxiLGMsZCl7Yi52YWx1ZT1jO2IuZ2V0U25hcHNob3Q9ZDtlaShiKSYmZmkoYSl9ZnVuY3Rpb24gYWkoYSxiLGMpe3JldHVybiBjKGZ1bmN0aW9uKCl7ZWkoYikmJmZpKGEpfSl9ZnVuY3Rpb24gZWkoYSl7dmFyIGI9YS5nZXRTbmFwc2hvdDthPWEudmFsdWU7dHJ5e3ZhciBjPWIoKTtyZXR1cm4hSGUoYSxjKX1jYXRjaChkKXtyZXR1cm4hMH19ZnVuY3Rpb24gZmkoYSl7dmFyIGI9aWgoYSwxKTtudWxsIT09YiYmZ2koYixhLDEsLTEpfVxuZnVuY3Rpb24gaGkoYSl7dmFyIGI9VGgoKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYSYmKGE9YSgpKTtiLm1lbW9pemVkU3RhdGU9Yi5iYXNlU3RhdGU9YTthPXtwZW5kaW5nOm51bGwsaW50ZXJsZWF2ZWQ6bnVsbCxsYW5lczowLGRpc3BhdGNoOm51bGwsbGFzdFJlbmRlcmVkUmVkdWNlcjpWaCxsYXN0UmVuZGVyZWRTdGF0ZTphfTtiLnF1ZXVlPWE7YT1hLmRpc3BhdGNoPWlpLmJpbmQobnVsbCxNLGEpO3JldHVybltiLm1lbW9pemVkU3RhdGUsYV19XG5mdW5jdGlvbiBiaShhLGIsYyxkKXthPXt0YWc6YSxjcmVhdGU6YixkZXN0cm95OmMsZGVwczpkLG5leHQ6bnVsbH07Yj1NLnVwZGF0ZVF1ZXVlO251bGw9PT1iPyhiPXtsYXN0RWZmZWN0Om51bGwsc3RvcmVzOm51bGx9LE0udXBkYXRlUXVldWU9YixiLmxhc3RFZmZlY3Q9YS5uZXh0PWEpOihjPWIubGFzdEVmZmVjdCxudWxsPT09Yz9iLmxhc3RFZmZlY3Q9YS5uZXh0PWE6KGQ9Yy5uZXh0LGMubmV4dD1hLGEubmV4dD1kLGIubGFzdEVmZmVjdD1hKSk7cmV0dXJuIGF9ZnVuY3Rpb24gamkoKXtyZXR1cm4gVWgoKS5tZW1vaXplZFN0YXRlfWZ1bmN0aW9uIGtpKGEsYixjLGQpe3ZhciBlPVRoKCk7TS5mbGFnc3w9YTtlLm1lbW9pemVkU3RhdGU9YmkoMXxiLGMsdm9pZCAwLHZvaWQgMD09PWQ/bnVsbDpkKX1cbmZ1bmN0aW9uIGxpKGEsYixjLGQpe3ZhciBlPVVoKCk7ZD12b2lkIDA9PT1kP251bGw6ZDt2YXIgZj12b2lkIDA7aWYobnVsbCE9PU4pe3ZhciBnPU4ubWVtb2l6ZWRTdGF0ZTtmPWcuZGVzdHJveTtpZihudWxsIT09ZCYmTWgoZCxnLmRlcHMpKXtlLm1lbW9pemVkU3RhdGU9YmkoYixjLGYsZCk7cmV0dXJufX1NLmZsYWdzfD1hO2UubWVtb2l6ZWRTdGF0ZT1iaSgxfGIsYyxmLGQpfWZ1bmN0aW9uIG1pKGEsYil7cmV0dXJuIGtpKDgzOTA2NTYsOCxhLGIpfWZ1bmN0aW9uICRoKGEsYil7cmV0dXJuIGxpKDIwNDgsOCxhLGIpfWZ1bmN0aW9uIG5pKGEsYil7cmV0dXJuIGxpKDQsMixhLGIpfWZ1bmN0aW9uIG9pKGEsYil7cmV0dXJuIGxpKDQsNCxhLGIpfVxuZnVuY3Rpb24gcGkoYSxiKXtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYilyZXR1cm4gYT1hKCksYihhKSxmdW5jdGlvbigpe2IobnVsbCl9O2lmKG51bGwhPT1iJiZ2b2lkIDAhPT1iKXJldHVybiBhPWEoKSxiLmN1cnJlbnQ9YSxmdW5jdGlvbigpe2IuY3VycmVudD1udWxsfX1mdW5jdGlvbiBxaShhLGIsYyl7Yz1udWxsIT09YyYmdm9pZCAwIT09Yz9jLmNvbmNhdChbYV0pOm51bGw7cmV0dXJuIGxpKDQsNCxwaS5iaW5kKG51bGwsYixhKSxjKX1mdW5jdGlvbiByaSgpe31mdW5jdGlvbiBzaShhLGIpe3ZhciBjPVVoKCk7Yj12b2lkIDA9PT1iP251bGw6Yjt2YXIgZD1jLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PWQmJm51bGwhPT1iJiZNaChiLGRbMV0pKXJldHVybiBkWzBdO2MubWVtb2l6ZWRTdGF0ZT1bYSxiXTtyZXR1cm4gYX1cbmZ1bmN0aW9uIHRpKGEsYil7dmFyIGM9VWgoKTtiPXZvaWQgMD09PWI/bnVsbDpiO3ZhciBkPWMubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09ZCYmbnVsbCE9PWImJk1oKGIsZFsxXSkpcmV0dXJuIGRbMF07YT1hKCk7Yy5tZW1vaXplZFN0YXRlPVthLGJdO3JldHVybiBhfWZ1bmN0aW9uIHVpKGEsYixjKXtpZigwPT09KEhoJjIxKSlyZXR1cm4gYS5iYXNlU3RhdGUmJihhLmJhc2VTdGF0ZT0hMSxkaD0hMCksYS5tZW1vaXplZFN0YXRlPWM7SGUoYyxiKXx8KGM9eWMoKSxNLmxhbmVzfD1jLHJofD1jLGEuYmFzZVN0YXRlPSEwKTtyZXR1cm4gYn1mdW5jdGlvbiB2aShhLGIpe3ZhciBjPUM7Qz0wIT09YyYmND5jP2M6NDthKCEwKTt2YXIgZD1HaC50cmFuc2l0aW9uO0doLnRyYW5zaXRpb249e307dHJ5e2EoITEpLGIoKX1maW5hbGx5e0M9YyxHaC50cmFuc2l0aW9uPWR9fWZ1bmN0aW9uIHdpKCl7cmV0dXJuIFVoKCkubWVtb2l6ZWRTdGF0ZX1cbmZ1bmN0aW9uIHhpKGEsYixjKXt2YXIgZD15aShhKTtjPXtsYW5lOmQsYWN0aW9uOmMsaGFzRWFnZXJTdGF0ZTohMSxlYWdlclN0YXRlOm51bGwsbmV4dDpudWxsfTtpZih6aShhKSlBaShiLGMpO2Vsc2UgaWYoYz1oaChhLGIsYyxkKSxudWxsIT09Yyl7dmFyIGU9UigpO2dpKGMsYSxkLGUpO0JpKGMsYixkKX19XG5mdW5jdGlvbiBpaShhLGIsYyl7dmFyIGQ9eWkoYSksZT17bGFuZTpkLGFjdGlvbjpjLGhhc0VhZ2VyU3RhdGU6ITEsZWFnZXJTdGF0ZTpudWxsLG5leHQ6bnVsbH07aWYoemkoYSkpQWkoYixlKTtlbHNle3ZhciBmPWEuYWx0ZXJuYXRlO2lmKDA9PT1hLmxhbmVzJiYobnVsbD09PWZ8fDA9PT1mLmxhbmVzKSYmKGY9Yi5sYXN0UmVuZGVyZWRSZWR1Y2VyLG51bGwhPT1mKSl0cnl7dmFyIGc9Yi5sYXN0UmVuZGVyZWRTdGF0ZSxoPWYoZyxjKTtlLmhhc0VhZ2VyU3RhdGU9ITA7ZS5lYWdlclN0YXRlPWg7aWYoSGUoaCxnKSl7dmFyIGs9Yi5pbnRlcmxlYXZlZDtudWxsPT09az8oZS5uZXh0PWUsZ2goYikpOihlLm5leHQ9ay5uZXh0LGsubmV4dD1lKTtiLmludGVybGVhdmVkPWU7cmV0dXJufX1jYXRjaChsKXt9ZmluYWxseXt9Yz1oaChhLGIsZSxkKTtudWxsIT09YyYmKGU9UigpLGdpKGMsYSxkLGUpLEJpKGMsYixkKSl9fVxuZnVuY3Rpb24gemkoYSl7dmFyIGI9YS5hbHRlcm5hdGU7cmV0dXJuIGE9PT1NfHxudWxsIT09YiYmYj09PU19ZnVuY3Rpb24gQWkoYSxiKXtKaD1JaD0hMDt2YXIgYz1hLnBlbmRpbmc7bnVsbD09PWM/Yi5uZXh0PWI6KGIubmV4dD1jLm5leHQsYy5uZXh0PWIpO2EucGVuZGluZz1ifWZ1bmN0aW9uIEJpKGEsYixjKXtpZigwIT09KGMmNDE5NDI0MCkpe3ZhciBkPWIubGFuZXM7ZCY9YS5wZW5kaW5nTGFuZXM7Y3w9ZDtiLmxhbmVzPWM7Q2MoYSxjKX19XG52YXIgUmg9e3JlYWRDb250ZXh0OmVoLHVzZUNhbGxiYWNrOlAsdXNlQ29udGV4dDpQLHVzZUVmZmVjdDpQLHVzZUltcGVyYXRpdmVIYW5kbGU6UCx1c2VJbnNlcnRpb25FZmZlY3Q6UCx1c2VMYXlvdXRFZmZlY3Q6UCx1c2VNZW1vOlAsdXNlUmVkdWNlcjpQLHVzZVJlZjpQLHVzZVN0YXRlOlAsdXNlRGVidWdWYWx1ZTpQLHVzZURlZmVycmVkVmFsdWU6UCx1c2VUcmFuc2l0aW9uOlAsdXNlTXV0YWJsZVNvdXJjZTpQLHVzZVN5bmNFeHRlcm5hbFN0b3JlOlAsdXNlSWQ6UCx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LE9oPXtyZWFkQ29udGV4dDplaCx1c2VDYWxsYmFjazpmdW5jdGlvbihhLGIpe1RoKCkubWVtb2l6ZWRTdGF0ZT1bYSx2b2lkIDA9PT1iP251bGw6Yl07cmV0dXJuIGF9LHVzZUNvbnRleHQ6ZWgsdXNlRWZmZWN0Om1pLHVzZUltcGVyYXRpdmVIYW5kbGU6ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbCE9PWMmJnZvaWQgMCE9PWM/Yy5jb25jYXQoW2FdKTpudWxsO3JldHVybiBraSg0MTk0MzA4LFxuNCxwaS5iaW5kKG51bGwsYixhKSxjKX0sdXNlTGF5b3V0RWZmZWN0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIGtpKDQxOTQzMDgsNCxhLGIpfSx1c2VJbnNlcnRpb25FZmZlY3Q6ZnVuY3Rpb24oYSxiKXtyZXR1cm4ga2koNCwyLGEsYil9LHVzZU1lbW86ZnVuY3Rpb24oYSxiKXt2YXIgYz1UaCgpO2I9dm9pZCAwPT09Yj9udWxsOmI7YT1hKCk7Yy5tZW1vaXplZFN0YXRlPVthLGJdO3JldHVybiBhfSx1c2VSZWR1Y2VyOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1UaCgpO2I9dm9pZCAwIT09Yz9jKGIpOmI7ZC5tZW1vaXplZFN0YXRlPWQuYmFzZVN0YXRlPWI7YT17cGVuZGluZzpudWxsLGludGVybGVhdmVkOm51bGwsbGFuZXM6MCxkaXNwYXRjaDpudWxsLGxhc3RSZW5kZXJlZFJlZHVjZXI6YSxsYXN0UmVuZGVyZWRTdGF0ZTpifTtkLnF1ZXVlPWE7YT1hLmRpc3BhdGNoPXhpLmJpbmQobnVsbCxNLGEpO3JldHVybltkLm1lbW9pemVkU3RhdGUsYV19LHVzZVJlZjpmdW5jdGlvbihhKXt2YXIgYj1cblRoKCk7YT17Y3VycmVudDphfTtyZXR1cm4gYi5tZW1vaXplZFN0YXRlPWF9LHVzZVN0YXRlOmhpLHVzZURlYnVnVmFsdWU6cmksdXNlRGVmZXJyZWRWYWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gVGgoKS5tZW1vaXplZFN0YXRlPWF9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXt2YXIgYT1oaSghMSksYj1hWzBdO2E9dmkuYmluZChudWxsLGFbMV0pO1RoKCkubWVtb2l6ZWRTdGF0ZT1hO3JldHVybltiLGFdfSx1c2VNdXRhYmxlU291cmNlOmZ1bmN0aW9uKCl7fSx1c2VTeW5jRXh0ZXJuYWxTdG9yZTpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9TSxlPVRoKCk7aWYoSSl7aWYodm9pZCAwPT09Yyl0aHJvdyBFcnJvcihwKDQwNykpO2M9YygpfWVsc2V7Yz1iKCk7aWYobnVsbD09PVEpdGhyb3cgRXJyb3IocCgzNDkpKTswIT09KEhoJjMwKXx8ZGkoZCxiLGMpfWUubWVtb2l6ZWRTdGF0ZT1jO3ZhciBmPXt2YWx1ZTpjLGdldFNuYXBzaG90OmJ9O2UucXVldWU9ZjttaShhaS5iaW5kKG51bGwsZCxcbmYsYSksW2FdKTtkLmZsYWdzfD0yMDQ4O2JpKDksY2kuYmluZChudWxsLGQsZixjLGIpLHZvaWQgMCxudWxsKTtyZXR1cm4gY30sdXNlSWQ6ZnVuY3Rpb24oKXt2YXIgYT1UaCgpLGI9US5pZGVudGlmaWVyUHJlZml4O2lmKEkpe3ZhciBjPXNnO3ZhciBkPXJnO2M9KGQmfigxPDwzMi1vYyhkKS0xKSkudG9TdHJpbmcoMzIpK2M7Yj1cIjpcIitiK1wiUlwiK2M7Yz1LaCsrOzA8YyYmKGIrPVwiSFwiK2MudG9TdHJpbmcoMzIpKTtiKz1cIjpcIn1lbHNlIGM9TGgrKyxiPVwiOlwiK2IrXCJyXCIrYy50b1N0cmluZygzMikrXCI6XCI7cmV0dXJuIGEubWVtb2l6ZWRTdGF0ZT1ifSx1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6ITF9LFBoPXtyZWFkQ29udGV4dDplaCx1c2VDYWxsYmFjazpzaSx1c2VDb250ZXh0OmVoLHVzZUVmZmVjdDokaCx1c2VJbXBlcmF0aXZlSGFuZGxlOnFpLHVzZUluc2VydGlvbkVmZmVjdDpuaSx1c2VMYXlvdXRFZmZlY3Q6b2ksdXNlTWVtbzp0aSx1c2VSZWR1Y2VyOldoLHVzZVJlZjpqaSx1c2VTdGF0ZTpmdW5jdGlvbigpe3JldHVybiBXaChWaCl9LFxudXNlRGVidWdWYWx1ZTpyaSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPVVoKCk7cmV0dXJuIHVpKGIsTi5tZW1vaXplZFN0YXRlLGEpfSx1c2VUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9V2goVmgpWzBdLGI9VWgoKS5tZW1vaXplZFN0YXRlO3JldHVyblthLGJdfSx1c2VNdXRhYmxlU291cmNlOlloLHVzZVN5bmNFeHRlcm5hbFN0b3JlOlpoLHVzZUlkOndpLHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjohMX0sUWg9e3JlYWRDb250ZXh0OmVoLHVzZUNhbGxiYWNrOnNpLHVzZUNvbnRleHQ6ZWgsdXNlRWZmZWN0OiRoLHVzZUltcGVyYXRpdmVIYW5kbGU6cWksdXNlSW5zZXJ0aW9uRWZmZWN0Om5pLHVzZUxheW91dEVmZmVjdDpvaSx1c2VNZW1vOnRpLHVzZVJlZHVjZXI6WGgsdXNlUmVmOmppLHVzZVN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuIFhoKFZoKX0sdXNlRGVidWdWYWx1ZTpyaSx1c2VEZWZlcnJlZFZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiPVVoKCk7cmV0dXJuIG51bGw9PT1cbk4/Yi5tZW1vaXplZFN0YXRlPWE6dWkoYixOLm1lbW9pemVkU3RhdGUsYSl9LHVzZVRyYW5zaXRpb246ZnVuY3Rpb24oKXt2YXIgYT1YaChWaClbMF0sYj1VaCgpLm1lbW9pemVkU3RhdGU7cmV0dXJuW2EsYl19LHVzZU11dGFibGVTb3VyY2U6WWgsdXNlU3luY0V4dGVybmFsU3RvcmU6WmgsdXNlSWQ6d2ksdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiExfTtmdW5jdGlvbiBDaShhLGIpe2lmKGEmJmEuZGVmYXVsdFByb3BzKXtiPUEoe30sYik7YT1hLmRlZmF1bHRQcm9wcztmb3IodmFyIGMgaW4gYSl2b2lkIDA9PT1iW2NdJiYoYltjXT1hW2NdKTtyZXR1cm4gYn1yZXR1cm4gYn1mdW5jdGlvbiBEaShhLGIsYyxkKXtiPWEubWVtb2l6ZWRTdGF0ZTtjPWMoZCxiKTtjPW51bGw9PT1jfHx2b2lkIDA9PT1jP2I6QSh7fSxiLGMpO2EubWVtb2l6ZWRTdGF0ZT1jOzA9PT1hLmxhbmVzJiYoYS51cGRhdGVRdWV1ZS5iYXNlU3RhdGU9Yyl9XG52YXIgRWk9e2lzTW91bnRlZDpmdW5jdGlvbihhKXtyZXR1cm4oYT1hLl9yZWFjdEludGVybmFscyk/VmIoYSk9PT1hOiExfSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oYSxiLGMpe2E9YS5fcmVhY3RJbnRlcm5hbHM7dmFyIGQ9UigpLGU9eWkoYSksZj1taChkLGUpO2YucGF5bG9hZD1iO3ZvaWQgMCE9PWMmJm51bGwhPT1jJiYoZi5jYWxsYmFjaz1jKTtiPW5oKGEsZixlKTtudWxsIT09YiYmKGdpKGIsYSxlLGQpLG9oKGIsYSxlKSl9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oYSxiLGMpe2E9YS5fcmVhY3RJbnRlcm5hbHM7dmFyIGQ9UigpLGU9eWkoYSksZj1taChkLGUpO2YudGFnPTE7Zi5wYXlsb2FkPWI7dm9pZCAwIT09YyYmbnVsbCE9PWMmJihmLmNhbGxiYWNrPWMpO2I9bmgoYSxmLGUpO251bGwhPT1iJiYoZ2koYixhLGUsZCksb2goYixhLGUpKX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKGEsYil7YT1hLl9yZWFjdEludGVybmFsczt2YXIgYz1SKCksZD1cbnlpKGEpLGU9bWgoYyxkKTtlLnRhZz0yO3ZvaWQgMCE9PWImJm51bGwhPT1iJiYoZS5jYWxsYmFjaz1iKTtiPW5oKGEsZSxkKTtudWxsIT09YiYmKGdpKGIsYSxkLGMpLG9oKGIsYSxkKSl9fTtmdW5jdGlvbiBGaShhLGIsYyxkLGUsZixnKXthPWEuc3RhdGVOb2RlO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLnNob3VsZENvbXBvbmVudFVwZGF0ZT9hLnNob3VsZENvbXBvbmVudFVwZGF0ZShkLGYsZyk6Yi5wcm90b3R5cGUmJmIucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50PyFJZShjLGQpfHwhSWUoZSxmKTohMH1cbmZ1bmN0aW9uIEdpKGEsYixjKXt2YXIgZD0hMSxlPVZmO3ZhciBmPWIuY29udGV4dFR5cGU7XCJvYmplY3RcIj09PXR5cGVvZiBmJiZudWxsIT09Zj9mPWVoKGYpOihlPVpmKGIpP1hmOkguY3VycmVudCxkPWIuY29udGV4dFR5cGVzLGY9KGQ9bnVsbCE9PWQmJnZvaWQgMCE9PWQpP1lmKGEsZSk6VmYpO2I9bmV3IGIoYyxmKTthLm1lbW9pemVkU3RhdGU9bnVsbCE9PWIuc3RhdGUmJnZvaWQgMCE9PWIuc3RhdGU/Yi5zdGF0ZTpudWxsO2IudXBkYXRlcj1FaTthLnN0YXRlTm9kZT1iO2IuX3JlYWN0SW50ZXJuYWxzPWE7ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1mKTtyZXR1cm4gYn1cbmZ1bmN0aW9uIEhpKGEsYixjLGQpe2E9Yi5zdGF0ZTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZiLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoYyxkKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmYi5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhjLGQpO2Iuc3RhdGUhPT1hJiZFaS5lbnF1ZXVlUmVwbGFjZVN0YXRlKGIsYi5zdGF0ZSxudWxsKX1cbmZ1bmN0aW9uIElpKGEsYixjLGQpe3ZhciBlPWEuc3RhdGVOb2RlO2UucHJvcHM9YztlLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZTtlLnJlZnM9e307a2goYSk7dmFyIGY9Yi5jb250ZXh0VHlwZTtcIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mP2UuY29udGV4dD1laChmKTooZj1aZihiKT9YZjpILmN1cnJlbnQsZS5jb250ZXh0PVlmKGEsZikpO2Uuc3RhdGU9YS5tZW1vaXplZFN0YXRlO2Y9Yi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XCJmdW5jdGlvblwiPT09dHlwZW9mIGYmJihEaShhLGIsZixjKSxlLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGIuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzfHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8XCJmdW5jdGlvblwiIT09dHlwZW9mIGUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGUuY29tcG9uZW50V2lsbE1vdW50fHwoYj1lLnN0YXRlLFxuXCJmdW5jdGlvblwiPT09dHlwZW9mIGUuY29tcG9uZW50V2lsbE1vdW50JiZlLmNvbXBvbmVudFdpbGxNb3VudCgpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJmUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpLGIhPT1lLnN0YXRlJiZFaS5lbnF1ZXVlUmVwbGFjZVN0YXRlKGUsZS5zdGF0ZSxudWxsKSxxaChhLGMsZSxkKSxlLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGUuY29tcG9uZW50RGlkTW91bnQmJihhLmZsYWdzfD00MTk0MzA4KX1mdW5jdGlvbiBKaShhLGIpe3RyeXt2YXIgYz1cIlwiLGQ9YjtkbyBjKz1QYShkKSxkPWQucmV0dXJuO3doaWxlKGQpO3ZhciBlPWN9Y2F0Y2goZil7ZT1cIlxcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6IFwiK2YubWVzc2FnZStcIlxcblwiK2Yuc3RhY2t9cmV0dXJue3ZhbHVlOmEsc291cmNlOmIsc3RhY2s6ZSxkaWdlc3Q6bnVsbH19XG5mdW5jdGlvbiBLaShhLGIsYyl7cmV0dXJue3ZhbHVlOmEsc291cmNlOm51bGwsc3RhY2s6bnVsbCE9Yz9jOm51bGwsZGlnZXN0Om51bGwhPWI/YjpudWxsfX1mdW5jdGlvbiBMaShhLGIpe3RyeXtjb25zb2xlLmVycm9yKGIudmFsdWUpfWNhdGNoKGMpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBjO30pfX12YXIgTWk9XCJmdW5jdGlvblwiPT09dHlwZW9mIFdlYWtNYXA/V2Vha01hcDpNYXA7ZnVuY3Rpb24gTmkoYSxiLGMpe2M9bWgoLTEsYyk7Yy50YWc9MztjLnBheWxvYWQ9e2VsZW1lbnQ6bnVsbH07dmFyIGQ9Yi52YWx1ZTtjLmNhbGxiYWNrPWZ1bmN0aW9uKCl7T2l8fChPaT0hMCxQaT1kKTtMaShhLGIpfTtyZXR1cm4gY31cbmZ1bmN0aW9uIFFpKGEsYixjKXtjPW1oKC0xLGMpO2MudGFnPTM7dmFyIGQ9YS50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZCl7dmFyIGU9Yi52YWx1ZTtjLnBheWxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gZChlKX07Yy5jYWxsYmFjaz1mdW5jdGlvbigpe0xpKGEsYil9fXZhciBmPWEuc3RhdGVOb2RlO251bGwhPT1mJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZi5jb21wb25lbnREaWRDYXRjaCYmKGMuY2FsbGJhY2s9ZnVuY3Rpb24oKXtMaShhLGIpO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBkJiYobnVsbD09PVJpP1JpPW5ldyBTZXQoW3RoaXNdKTpSaS5hZGQodGhpcykpO3ZhciBjPWIuc3RhY2s7dGhpcy5jb21wb25lbnREaWRDYXRjaChiLnZhbHVlLHtjb21wb25lbnRTdGFjazpudWxsIT09Yz9jOlwiXCJ9KX0pO3JldHVybiBjfVxuZnVuY3Rpb24gU2koYSxiLGMpe3ZhciBkPWEucGluZ0NhY2hlO2lmKG51bGw9PT1kKXtkPWEucGluZ0NhY2hlPW5ldyBNaTt2YXIgZT1uZXcgU2V0O2Quc2V0KGIsZSl9ZWxzZSBlPWQuZ2V0KGIpLHZvaWQgMD09PWUmJihlPW5ldyBTZXQsZC5zZXQoYixlKSk7ZS5oYXMoYyl8fChlLmFkZChjKSxhPVRpLmJpbmQobnVsbCxhLGIsYyksYi50aGVuKGEsYSkpfWZ1bmN0aW9uIFVpKGEpe2Rve3ZhciBiO2lmKGI9MTM9PT1hLnRhZyliPWEubWVtb2l6ZWRTdGF0ZSxiPW51bGwhPT1iP251bGwhPT1iLmRlaHlkcmF0ZWQ/ITA6ITE6ITA7aWYoYilyZXR1cm4gYTthPWEucmV0dXJufXdoaWxlKG51bGwhPT1hKTtyZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIFZpKGEsYixjLGQsZSl7aWYoMD09PShhLm1vZGUmMSkpcmV0dXJuIGE9PT1iP2EuZmxhZ3N8PTY1NTM2OihhLmZsYWdzfD0xMjgsYy5mbGFnc3w9MTMxMDcyLGMuZmxhZ3MmPS01MjgwNSwxPT09Yy50YWcmJihudWxsPT09Yy5hbHRlcm5hdGU/Yy50YWc9MTc6KGI9bWgoLTEsMSksYi50YWc9MixuaChjLGIsMSkpKSxjLmxhbmVzfD0xKSxhO2EuZmxhZ3N8PTY1NTM2O2EubGFuZXM9ZTtyZXR1cm4gYX12YXIgV2k9dWEuUmVhY3RDdXJyZW50T3duZXIsZGg9ITE7ZnVuY3Rpb24gWGkoYSxiLGMsZCl7Yi5jaGlsZD1udWxsPT09YT9WZyhiLG51bGwsYyxkKTpVZyhiLGEuY2hpbGQsYyxkKX1cbmZ1bmN0aW9uIFlpKGEsYixjLGQsZSl7Yz1jLnJlbmRlcjt2YXIgZj1iLnJlZjtjaChiLGUpO2Q9TmgoYSxiLGMsZCxmLGUpO2M9U2goKTtpZihudWxsIT09YSYmIWRoKXJldHVybiBiLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWUsYi5mbGFncyY9LTIwNTMsYS5sYW5lcyY9fmUsWmkoYSxiLGUpO0kmJmMmJnZnKGIpO2IuZmxhZ3N8PTE7WGkoYSxiLGQsZSk7cmV0dXJuIGIuY2hpbGR9XG5mdW5jdGlvbiAkaShhLGIsYyxkLGUpe2lmKG51bGw9PT1hKXt2YXIgZj1jLnR5cGU7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGYmJiFhaihmKSYmdm9pZCAwPT09Zi5kZWZhdWx0UHJvcHMmJm51bGw9PT1jLmNvbXBhcmUmJnZvaWQgMD09PWMuZGVmYXVsdFByb3BzKXJldHVybiBiLnRhZz0xNSxiLnR5cGU9ZixiaihhLGIsZixkLGUpO2E9UmcoYy50eXBlLG51bGwsZCxiLGIubW9kZSxlKTthLnJlZj1iLnJlZjthLnJldHVybj1iO3JldHVybiBiLmNoaWxkPWF9Zj1hLmNoaWxkO2lmKDA9PT0oYS5sYW5lcyZlKSl7dmFyIGc9Zi5tZW1vaXplZFByb3BzO2M9Yy5jb21wYXJlO2M9bnVsbCE9PWM/YzpJZTtpZihjKGcsZCkmJmEucmVmPT09Yi5yZWYpcmV0dXJuIFppKGEsYixlKX1iLmZsYWdzfD0xO2E9UGcoZixkKTthLnJlZj1iLnJlZjthLnJldHVybj1iO3JldHVybiBiLmNoaWxkPWF9XG5mdW5jdGlvbiBiaihhLGIsYyxkLGUpe2lmKG51bGwhPT1hKXt2YXIgZj1hLm1lbW9pemVkUHJvcHM7aWYoSWUoZixkKSYmYS5yZWY9PT1iLnJlZilpZihkaD0hMSxiLnBlbmRpbmdQcm9wcz1kPWYsMCE9PShhLmxhbmVzJmUpKTAhPT0oYS5mbGFncyYxMzEwNzIpJiYoZGg9ITApO2Vsc2UgcmV0dXJuIGIubGFuZXM9YS5sYW5lcyxaaShhLGIsZSl9cmV0dXJuIGNqKGEsYixjLGQsZSl9XG5mdW5jdGlvbiBkaihhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHMsZT1kLmNoaWxkcmVuLGY9bnVsbCE9PWE/YS5tZW1vaXplZFN0YXRlOm51bGw7aWYoXCJoaWRkZW5cIj09PWQubW9kZSlpZigwPT09KGIubW9kZSYxKSliLm1lbW9pemVkU3RhdGU9e2Jhc2VMYW5lczowLGNhY2hlUG9vbDpudWxsLHRyYW5zaXRpb25zOm51bGx9LEcoZWosZmopLGZqfD1jO2Vsc2V7aWYoMD09PShjJjEwNzM3NDE4MjQpKXJldHVybiBhPW51bGwhPT1mP2YuYmFzZUxhbmVzfGM6YyxiLmxhbmVzPWIuY2hpbGRMYW5lcz0xMDczNzQxODI0LGIubWVtb2l6ZWRTdGF0ZT17YmFzZUxhbmVzOmEsY2FjaGVQb29sOm51bGwsdHJhbnNpdGlvbnM6bnVsbH0sYi51cGRhdGVRdWV1ZT1udWxsLEcoZWosZmopLGZqfD1hLG51bGw7Yi5tZW1vaXplZFN0YXRlPXtiYXNlTGFuZXM6MCxjYWNoZVBvb2w6bnVsbCx0cmFuc2l0aW9uczpudWxsfTtkPW51bGwhPT1mP2YuYmFzZUxhbmVzOmM7Ryhlaixmaik7Zmp8PWR9ZWxzZSBudWxsIT09XG5mPyhkPWYuYmFzZUxhbmVzfGMsYi5tZW1vaXplZFN0YXRlPW51bGwpOmQ9YyxHKGVqLGZqKSxmanw9ZDtYaShhLGIsZSxjKTtyZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiBnaihhLGIpe3ZhciBjPWIucmVmO2lmKG51bGw9PT1hJiZudWxsIT09Y3x8bnVsbCE9PWEmJmEucmVmIT09YyliLmZsYWdzfD01MTIsYi5mbGFnc3w9MjA5NzE1Mn1mdW5jdGlvbiBjaihhLGIsYyxkLGUpe3ZhciBmPVpmKGMpP1hmOkguY3VycmVudDtmPVlmKGIsZik7Y2goYixlKTtjPU5oKGEsYixjLGQsZixlKTtkPVNoKCk7aWYobnVsbCE9PWEmJiFkaClyZXR1cm4gYi51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlLGIuZmxhZ3MmPS0yMDUzLGEubGFuZXMmPX5lLFppKGEsYixlKTtJJiZkJiZ2ZyhiKTtiLmZsYWdzfD0xO1hpKGEsYixjLGUpO3JldHVybiBiLmNoaWxkfVxuZnVuY3Rpb24gaGooYSxiLGMsZCxlKXtpZihaZihjKSl7dmFyIGY9ITA7Y2coYil9ZWxzZSBmPSExO2NoKGIsZSk7aWYobnVsbD09PWIuc3RhdGVOb2RlKWlqKGEsYiksR2koYixjLGQpLElpKGIsYyxkLGUpLGQ9ITA7ZWxzZSBpZihudWxsPT09YSl7dmFyIGc9Yi5zdGF0ZU5vZGUsaD1iLm1lbW9pemVkUHJvcHM7Zy5wcm9wcz1oO3ZhciBrPWcuY29udGV4dCxsPWMuY29udGV4dFR5cGU7XCJvYmplY3RcIj09PXR5cGVvZiBsJiZudWxsIT09bD9sPWVoKGwpOihsPVpmKGMpP1hmOkguY3VycmVudCxsPVlmKGIsbCkpO3ZhciBtPWMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLHE9XCJmdW5jdGlvblwiPT09dHlwZW9mIG18fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlO3F8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHxcbihoIT09ZHx8ayE9PWwpJiZIaShiLGcsZCxsKTtqaD0hMTt2YXIgcj1iLm1lbW9pemVkU3RhdGU7Zy5zdGF0ZT1yO3FoKGIsZCxnLGUpO2s9Yi5tZW1vaXplZFN0YXRlO2ghPT1kfHxyIT09a3x8V2YuY3VycmVudHx8amg/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBtJiYoRGkoYixjLG0sZCksaz1iLm1lbW9pemVkU3RhdGUpLChoPWpofHxGaShiLGMsaCxkLHIsayxsKSk/KHF8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudHx8KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxNb3VudCYmZy5jb21wb25lbnRXaWxsTW91bnQoKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JiZnLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50RGlkTW91bnQmJihiLmZsYWdzfD00MTk0MzA4KSk6XG4oXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50RGlkTW91bnQmJihiLmZsYWdzfD00MTk0MzA4KSxiLm1lbW9pemVkUHJvcHM9ZCxiLm1lbW9pemVkU3RhdGU9ayksZy5wcm9wcz1kLGcuc3RhdGU9ayxnLmNvbnRleHQ9bCxkPWgpOihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRNb3VudCYmKGIuZmxhZ3N8PTQxOTQzMDgpLGQ9ITEpfWVsc2V7Zz1iLnN0YXRlTm9kZTtsaChhLGIpO2g9Yi5tZW1vaXplZFByb3BzO2w9Yi50eXBlPT09Yi5lbGVtZW50VHlwZT9oOkNpKGIudHlwZSxoKTtnLnByb3BzPWw7cT1iLnBlbmRpbmdQcm9wcztyPWcuY29udGV4dDtrPWMuY29udGV4dFR5cGU7XCJvYmplY3RcIj09PXR5cGVvZiBrJiZudWxsIT09az9rPWVoKGspOihrPVpmKGMpP1hmOkguY3VycmVudCxrPVlmKGIsaykpO3ZhciB5PWMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOyhtPVwiZnVuY3Rpb25cIj09PXR5cGVvZiB5fHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSl8fFxuXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHN8fChoIT09cXx8ciE9PWspJiZIaShiLGcsZCxrKTtqaD0hMTtyPWIubWVtb2l6ZWRTdGF0ZTtnLnN0YXRlPXI7cWgoYixkLGcsZSk7dmFyIG49Yi5tZW1vaXplZFN0YXRlO2ghPT1xfHxyIT09bnx8V2YuY3VycmVudHx8amg/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiB5JiYoRGkoYixjLHksZCksbj1iLm1lbW9pemVkU3RhdGUpLChsPWpofHxGaShiLGMsbCxkLHIsbixrKXx8ITEpPyhtfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFVwZGF0ZXx8KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGUmJmcuY29tcG9uZW50V2lsbFVwZGF0ZShkLG4sayksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUmJlxuZy5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZShkLG4saykpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZSYmKGIuZmxhZ3N8PTQpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlJiYoYi5mbGFnc3w9MTAyNCkpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJnI9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD00KSxcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmcj09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZmxhZ3N8PTEwMjQpLGIubWVtb2l6ZWRQcm9wcz1kLGIubWVtb2l6ZWRTdGF0ZT1uKSxnLnByb3BzPWQsZy5zdGF0ZT1uLGcuY29udGV4dD1rLGQ9bCk6KFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmcj09PVxuYS5tZW1vaXplZFN0YXRlfHwoYi5mbGFnc3w9NCksXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGV8fGg9PT1hLm1lbW9pemVkUHJvcHMmJnI9PT1hLm1lbW9pemVkU3RhdGV8fChiLmZsYWdzfD0xMDI0KSxkPSExKX1yZXR1cm4gamooYSxiLGMsZCxmLGUpfVxuZnVuY3Rpb24gamooYSxiLGMsZCxlLGYpe2dqKGEsYik7dmFyIGc9MCE9PShiLmZsYWdzJjEyOCk7aWYoIWQmJiFnKXJldHVybiBlJiZkZyhiLGMsITEpLFppKGEsYixmKTtkPWIuc3RhdGVOb2RlO1dpLmN1cnJlbnQ9Yjt2YXIgaD1nJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I/bnVsbDpkLnJlbmRlcigpO2IuZmxhZ3N8PTE7bnVsbCE9PWEmJmc/KGIuY2hpbGQ9VWcoYixhLmNoaWxkLG51bGwsZiksYi5jaGlsZD1VZyhiLG51bGwsaCxmKSk6WGkoYSxiLGgsZik7Yi5tZW1vaXplZFN0YXRlPWQuc3RhdGU7ZSYmZGcoYixjLCEwKTtyZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiBraihhKXt2YXIgYj1hLnN0YXRlTm9kZTtiLnBlbmRpbmdDb250ZXh0P2FnKGEsYi5wZW5kaW5nQ29udGV4dCxiLnBlbmRpbmdDb250ZXh0IT09Yi5jb250ZXh0KTpiLmNvbnRleHQmJmFnKGEsYi5jb250ZXh0LCExKTt5aChhLGIuY29udGFpbmVySW5mbyl9XG5mdW5jdGlvbiBsaihhLGIsYyxkLGUpe0lnKCk7SmcoZSk7Yi5mbGFnc3w9MjU2O1hpKGEsYixjLGQpO3JldHVybiBiLmNoaWxkfXZhciBtaj17ZGVoeWRyYXRlZDpudWxsLHRyZWVDb250ZXh0Om51bGwscmV0cnlMYW5lOjB9O2Z1bmN0aW9uIG5qKGEpe3JldHVybntiYXNlTGFuZXM6YSxjYWNoZVBvb2w6bnVsbCx0cmFuc2l0aW9uczpudWxsfX1cbmZ1bmN0aW9uIG9qKGEsYixjKXt2YXIgZD1iLnBlbmRpbmdQcm9wcyxlPUwuY3VycmVudCxmPSExLGc9MCE9PShiLmZsYWdzJjEyOCksaDsoaD1nKXx8KGg9bnVsbCE9PWEmJm51bGw9PT1hLm1lbW9pemVkU3RhdGU/ITE6MCE9PShlJjIpKTtpZihoKWY9ITAsYi5mbGFncyY9LTEyOTtlbHNlIGlmKG51bGw9PT1hfHxudWxsIT09YS5tZW1vaXplZFN0YXRlKWV8PTE7RyhMLGUmMSk7aWYobnVsbD09PWEpe0VnKGIpO2E9Yi5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1hJiYoYT1hLmRlaHlkcmF0ZWQsbnVsbCE9PWEpKXJldHVybiAwPT09KGIubW9kZSYxKT9iLmxhbmVzPTE6XCIkIVwiPT09YS5kYXRhP2IubGFuZXM9ODpiLmxhbmVzPTEwNzM3NDE4MjQsbnVsbDtnPWQuY2hpbGRyZW47YT1kLmZhbGxiYWNrO3JldHVybiBmPyhkPWIubW9kZSxmPWIuY2hpbGQsZz17bW9kZTpcImhpZGRlblwiLGNoaWxkcmVuOmd9LDA9PT0oZCYxKSYmbnVsbCE9PWY/KGYuY2hpbGRMYW5lcz0wLGYucGVuZGluZ1Byb3BzPVxuZyk6Zj1waihnLGQsMCxudWxsKSxhPVRnKGEsZCxjLG51bGwpLGYucmV0dXJuPWIsYS5yZXR1cm49YixmLnNpYmxpbmc9YSxiLmNoaWxkPWYsYi5jaGlsZC5tZW1vaXplZFN0YXRlPW5qKGMpLGIubWVtb2l6ZWRTdGF0ZT1taixhKTpxaihiLGcpfWU9YS5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1lJiYoaD1lLmRlaHlkcmF0ZWQsbnVsbCE9PWgpKXJldHVybiByaihhLGIsZyxkLGgsZSxjKTtpZihmKXtmPWQuZmFsbGJhY2s7Zz1iLm1vZGU7ZT1hLmNoaWxkO2g9ZS5zaWJsaW5nO3ZhciBrPXttb2RlOlwiaGlkZGVuXCIsY2hpbGRyZW46ZC5jaGlsZHJlbn07MD09PShnJjEpJiZiLmNoaWxkIT09ZT8oZD1iLmNoaWxkLGQuY2hpbGRMYW5lcz0wLGQucGVuZGluZ1Byb3BzPWssYi5kZWxldGlvbnM9bnVsbCk6KGQ9UGcoZSxrKSxkLnN1YnRyZWVGbGFncz1lLnN1YnRyZWVGbGFncyYxNDY4MDA2NCk7bnVsbCE9PWg/Zj1QZyhoLGYpOihmPVRnKGYsZyxjLG51bGwpLGYuZmxhZ3N8PTIpO2YucmV0dXJuPVxuYjtkLnJldHVybj1iO2Quc2libGluZz1mO2IuY2hpbGQ9ZDtkPWY7Zj1iLmNoaWxkO2c9YS5jaGlsZC5tZW1vaXplZFN0YXRlO2c9bnVsbD09PWc/bmooYyk6e2Jhc2VMYW5lczpnLmJhc2VMYW5lc3xjLGNhY2hlUG9vbDpudWxsLHRyYW5zaXRpb25zOmcudHJhbnNpdGlvbnN9O2YubWVtb2l6ZWRTdGF0ZT1nO2YuY2hpbGRMYW5lcz1hLmNoaWxkTGFuZXMmfmM7Yi5tZW1vaXplZFN0YXRlPW1qO3JldHVybiBkfWY9YS5jaGlsZDthPWYuc2libGluZztkPVBnKGYse21vZGU6XCJ2aXNpYmxlXCIsY2hpbGRyZW46ZC5jaGlsZHJlbn0pOzA9PT0oYi5tb2RlJjEpJiYoZC5sYW5lcz1jKTtkLnJldHVybj1iO2Quc2libGluZz1udWxsO251bGwhPT1hJiYoYz1iLmRlbGV0aW9ucyxudWxsPT09Yz8oYi5kZWxldGlvbnM9W2FdLGIuZmxhZ3N8PTE2KTpjLnB1c2goYSkpO2IuY2hpbGQ9ZDtiLm1lbW9pemVkU3RhdGU9bnVsbDtyZXR1cm4gZH1cbmZ1bmN0aW9uIHFqKGEsYil7Yj1waih7bW9kZTpcInZpc2libGVcIixjaGlsZHJlbjpifSxhLm1vZGUsMCxudWxsKTtiLnJldHVybj1hO3JldHVybiBhLmNoaWxkPWJ9ZnVuY3Rpb24gc2ooYSxiLGMsZCl7bnVsbCE9PWQmJkpnKGQpO1VnKGIsYS5jaGlsZCxudWxsLGMpO2E9cWooYixiLnBlbmRpbmdQcm9wcy5jaGlsZHJlbik7YS5mbGFnc3w9MjtiLm1lbW9pemVkU3RhdGU9bnVsbDtyZXR1cm4gYX1cbmZ1bmN0aW9uIHJqKGEsYixjLGQsZSxmLGcpe2lmKGMpe2lmKGIuZmxhZ3MmMjU2KXJldHVybiBiLmZsYWdzJj0tMjU3LGQ9S2koRXJyb3IocCg0MjIpKSksc2ooYSxiLGcsZCk7aWYobnVsbCE9PWIubWVtb2l6ZWRTdGF0ZSlyZXR1cm4gYi5jaGlsZD1hLmNoaWxkLGIuZmxhZ3N8PTEyOCxudWxsO2Y9ZC5mYWxsYmFjaztlPWIubW9kZTtkPXBqKHttb2RlOlwidmlzaWJsZVwiLGNoaWxkcmVuOmQuY2hpbGRyZW59LGUsMCxudWxsKTtmPVRnKGYsZSxnLG51bGwpO2YuZmxhZ3N8PTI7ZC5yZXR1cm49YjtmLnJldHVybj1iO2Quc2libGluZz1mO2IuY2hpbGQ9ZDswIT09KGIubW9kZSYxKSYmVWcoYixhLmNoaWxkLG51bGwsZyk7Yi5jaGlsZC5tZW1vaXplZFN0YXRlPW5qKGcpO2IubWVtb2l6ZWRTdGF0ZT1tajtyZXR1cm4gZn1pZigwPT09KGIubW9kZSYxKSlyZXR1cm4gc2ooYSxiLGcsbnVsbCk7aWYoXCIkIVwiPT09ZS5kYXRhKXtkPWUubmV4dFNpYmxpbmcmJmUubmV4dFNpYmxpbmcuZGF0YXNldDtcbmlmKGQpdmFyIGg9ZC5kZ3N0O2Q9aDtmPUVycm9yKHAoNDE5KSk7ZD1LaShmLGQsdm9pZCAwKTtyZXR1cm4gc2ooYSxiLGcsZCl9aD0wIT09KGcmYS5jaGlsZExhbmVzKTtpZihkaHx8aCl7ZD1RO2lmKG51bGwhPT1kKXtzd2l0Y2goZyYtZyl7Y2FzZSA0OmU9MjticmVhaztjYXNlIDE2OmU9ODticmVhaztjYXNlIDY0OmNhc2UgMTI4OmNhc2UgMjU2OmNhc2UgNTEyOmNhc2UgMTAyNDpjYXNlIDIwNDg6Y2FzZSA0MDk2OmNhc2UgODE5MjpjYXNlIDE2Mzg0OmNhc2UgMzI3Njg6Y2FzZSA2NTUzNjpjYXNlIDEzMTA3MjpjYXNlIDI2MjE0NDpjYXNlIDUyNDI4ODpjYXNlIDEwNDg1NzY6Y2FzZSAyMDk3MTUyOmNhc2UgNDE5NDMwNDpjYXNlIDgzODg2MDg6Y2FzZSAxNjc3NzIxNjpjYXNlIDMzNTU0NDMyOmNhc2UgNjcxMDg4NjQ6ZT0zMjticmVhaztjYXNlIDUzNjg3MDkxMjplPTI2ODQzNTQ1NjticmVhaztkZWZhdWx0OmU9MH1lPTAhPT0oZSYoZC5zdXNwZW5kZWRMYW5lc3xnKSk/MDplO1xuMCE9PWUmJmUhPT1mLnJldHJ5TGFuZSYmKGYucmV0cnlMYW5lPWUsaWgoYSxlKSxnaShkLGEsZSwtMSkpfXRqKCk7ZD1LaShFcnJvcihwKDQyMSkpKTtyZXR1cm4gc2ooYSxiLGcsZCl9aWYoXCIkP1wiPT09ZS5kYXRhKXJldHVybiBiLmZsYWdzfD0xMjgsYi5jaGlsZD1hLmNoaWxkLGI9dWouYmluZChudWxsLGEpLGUuX3JlYWN0UmV0cnk9YixudWxsO2E9Zi50cmVlQ29udGV4dDt5Zz1MZihlLm5leHRTaWJsaW5nKTt4Zz1iO0k9ITA7emc9bnVsbDtudWxsIT09YSYmKG9nW3BnKytdPXJnLG9nW3BnKytdPXNnLG9nW3BnKytdPXFnLHJnPWEuaWQsc2c9YS5vdmVyZmxvdyxxZz1iKTtiPXFqKGIsZC5jaGlsZHJlbik7Yi5mbGFnc3w9NDA5NjtyZXR1cm4gYn1mdW5jdGlvbiB2aihhLGIsYyl7YS5sYW5lc3w9Yjt2YXIgZD1hLmFsdGVybmF0ZTtudWxsIT09ZCYmKGQubGFuZXN8PWIpO2JoKGEucmV0dXJuLGIsYyl9XG5mdW5jdGlvbiB3aihhLGIsYyxkLGUpe3ZhciBmPWEubWVtb2l6ZWRTdGF0ZTtudWxsPT09Zj9hLm1lbW9pemVkU3RhdGU9e2lzQmFja3dhcmRzOmIscmVuZGVyaW5nOm51bGwscmVuZGVyaW5nU3RhcnRUaW1lOjAsbGFzdDpkLHRhaWw6Yyx0YWlsTW9kZTplfTooZi5pc0JhY2t3YXJkcz1iLGYucmVuZGVyaW5nPW51bGwsZi5yZW5kZXJpbmdTdGFydFRpbWU9MCxmLmxhc3Q9ZCxmLnRhaWw9YyxmLnRhaWxNb2RlPWUpfVxuZnVuY3Rpb24geGooYSxiLGMpe3ZhciBkPWIucGVuZGluZ1Byb3BzLGU9ZC5yZXZlYWxPcmRlcixmPWQudGFpbDtYaShhLGIsZC5jaGlsZHJlbixjKTtkPUwuY3VycmVudDtpZigwIT09KGQmMikpZD1kJjF8MixiLmZsYWdzfD0xMjg7ZWxzZXtpZihudWxsIT09YSYmMCE9PShhLmZsYWdzJjEyOCkpYTpmb3IoYT1iLmNoaWxkO251bGwhPT1hOyl7aWYoMTM9PT1hLnRhZyludWxsIT09YS5tZW1vaXplZFN0YXRlJiZ2aihhLGMsYik7ZWxzZSBpZigxOT09PWEudGFnKXZqKGEsYyxiKTtlbHNlIGlmKG51bGwhPT1hLmNoaWxkKXthLmNoaWxkLnJldHVybj1hO2E9YS5jaGlsZDtjb250aW51ZX1pZihhPT09YilicmVhayBhO2Zvcig7bnVsbD09PWEuc2libGluZzspe2lmKG51bGw9PT1hLnJldHVybnx8YS5yZXR1cm49PT1iKWJyZWFrIGE7YT1hLnJldHVybn1hLnNpYmxpbmcucmV0dXJuPWEucmV0dXJuO2E9YS5zaWJsaW5nfWQmPTF9RyhMLGQpO2lmKDA9PT0oYi5tb2RlJjEpKWIubWVtb2l6ZWRTdGF0ZT1cbm51bGw7ZWxzZSBzd2l0Y2goZSl7Y2FzZSBcImZvcndhcmRzXCI6Yz1iLmNoaWxkO2ZvcihlPW51bGw7bnVsbCE9PWM7KWE9Yy5hbHRlcm5hdGUsbnVsbCE9PWEmJm51bGw9PT1DaChhKSYmKGU9YyksYz1jLnNpYmxpbmc7Yz1lO251bGw9PT1jPyhlPWIuY2hpbGQsYi5jaGlsZD1udWxsKTooZT1jLnNpYmxpbmcsYy5zaWJsaW5nPW51bGwpO3dqKGIsITEsZSxjLGYpO2JyZWFrO2Nhc2UgXCJiYWNrd2FyZHNcIjpjPW51bGw7ZT1iLmNoaWxkO2ZvcihiLmNoaWxkPW51bGw7bnVsbCE9PWU7KXthPWUuYWx0ZXJuYXRlO2lmKG51bGwhPT1hJiZudWxsPT09Q2goYSkpe2IuY2hpbGQ9ZTticmVha31hPWUuc2libGluZztlLnNpYmxpbmc9YztjPWU7ZT1hfXdqKGIsITAsYyxudWxsLGYpO2JyZWFrO2Nhc2UgXCJ0b2dldGhlclwiOndqKGIsITEsbnVsbCxudWxsLHZvaWQgMCk7YnJlYWs7ZGVmYXVsdDpiLm1lbW9pemVkU3RhdGU9bnVsbH1yZXR1cm4gYi5jaGlsZH1cbmZ1bmN0aW9uIGlqKGEsYil7MD09PShiLm1vZGUmMSkmJm51bGwhPT1hJiYoYS5hbHRlcm5hdGU9bnVsbCxiLmFsdGVybmF0ZT1udWxsLGIuZmxhZ3N8PTIpfWZ1bmN0aW9uIFppKGEsYixjKXtudWxsIT09YSYmKGIuZGVwZW5kZW5jaWVzPWEuZGVwZW5kZW5jaWVzKTtyaHw9Yi5sYW5lcztpZigwPT09KGMmYi5jaGlsZExhbmVzKSlyZXR1cm4gbnVsbDtpZihudWxsIT09YSYmYi5jaGlsZCE9PWEuY2hpbGQpdGhyb3cgRXJyb3IocCgxNTMpKTtpZihudWxsIT09Yi5jaGlsZCl7YT1iLmNoaWxkO2M9UGcoYSxhLnBlbmRpbmdQcm9wcyk7Yi5jaGlsZD1jO2ZvcihjLnJldHVybj1iO251bGwhPT1hLnNpYmxpbmc7KWE9YS5zaWJsaW5nLGM9Yy5zaWJsaW5nPVBnKGEsYS5wZW5kaW5nUHJvcHMpLGMucmV0dXJuPWI7Yy5zaWJsaW5nPW51bGx9cmV0dXJuIGIuY2hpbGR9XG5mdW5jdGlvbiB5aihhLGIsYyl7c3dpdGNoKGIudGFnKXtjYXNlIDM6a2ooYik7SWcoKTticmVhaztjYXNlIDU6QWgoYik7YnJlYWs7Y2FzZSAxOlpmKGIudHlwZSkmJmNnKGIpO2JyZWFrO2Nhc2UgNDp5aChiLGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO2JyZWFrO2Nhc2UgMTA6dmFyIGQ9Yi50eXBlLl9jb250ZXh0LGU9Yi5tZW1vaXplZFByb3BzLnZhbHVlO0coV2csZC5fY3VycmVudFZhbHVlKTtkLl9jdXJyZW50VmFsdWU9ZTticmVhaztjYXNlIDEzOmQ9Yi5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1kKXtpZihudWxsIT09ZC5kZWh5ZHJhdGVkKXJldHVybiBHKEwsTC5jdXJyZW50JjEpLGIuZmxhZ3N8PTEyOCxudWxsO2lmKDAhPT0oYyZiLmNoaWxkLmNoaWxkTGFuZXMpKXJldHVybiBvaihhLGIsYyk7RyhMLEwuY3VycmVudCYxKTthPVppKGEsYixjKTtyZXR1cm4gbnVsbCE9PWE/YS5zaWJsaW5nOm51bGx9RyhMLEwuY3VycmVudCYxKTticmVhaztjYXNlIDE5OmQ9MCE9PShjJlxuYi5jaGlsZExhbmVzKTtpZigwIT09KGEuZmxhZ3MmMTI4KSl7aWYoZClyZXR1cm4geGooYSxiLGMpO2IuZmxhZ3N8PTEyOH1lPWIubWVtb2l6ZWRTdGF0ZTtudWxsIT09ZSYmKGUucmVuZGVyaW5nPW51bGwsZS50YWlsPW51bGwsZS5sYXN0RWZmZWN0PW51bGwpO0coTCxMLmN1cnJlbnQpO2lmKGQpYnJlYWs7ZWxzZSByZXR1cm4gbnVsbDtjYXNlIDIyOmNhc2UgMjM6cmV0dXJuIGIubGFuZXM9MCxkaihhLGIsYyl9cmV0dXJuIFppKGEsYixjKX12YXIgemosQWosQmosQ2o7XG56aj1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1iLmNoaWxkO251bGwhPT1jOyl7aWYoNT09PWMudGFnfHw2PT09Yy50YWcpYS5hcHBlbmRDaGlsZChjLnN0YXRlTm9kZSk7ZWxzZSBpZig0IT09Yy50YWcmJm51bGwhPT1jLmNoaWxkKXtjLmNoaWxkLnJldHVybj1jO2M9Yy5jaGlsZDtjb250aW51ZX1pZihjPT09YilicmVhaztmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Yy5yZXR1cm58fGMucmV0dXJuPT09YilyZXR1cm47Yz1jLnJldHVybn1jLnNpYmxpbmcucmV0dXJuPWMucmV0dXJuO2M9Yy5zaWJsaW5nfX07QWo9ZnVuY3Rpb24oKXt9O1xuQmo9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9YS5tZW1vaXplZFByb3BzO2lmKGUhPT1kKXthPWIuc3RhdGVOb2RlO3hoKHVoLmN1cnJlbnQpO3ZhciBmPW51bGw7c3dpdGNoKGMpe2Nhc2UgXCJpbnB1dFwiOmU9WWEoYSxlKTtkPVlhKGEsZCk7Zj1bXTticmVhaztjYXNlIFwic2VsZWN0XCI6ZT1BKHt9LGUse3ZhbHVlOnZvaWQgMH0pO2Q9QSh7fSxkLHt2YWx1ZTp2b2lkIDB9KTtmPVtdO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmU9Z2IoYSxlKTtkPWdiKGEsZCk7Zj1bXTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBlLm9uQ2xpY2smJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLm9uQ2xpY2smJihhLm9uY2xpY2s9QmYpfXViKGMsZCk7dmFyIGc7Yz1udWxsO2ZvcihsIGluIGUpaWYoIWQuaGFzT3duUHJvcGVydHkobCkmJmUuaGFzT3duUHJvcGVydHkobCkmJm51bGwhPWVbbF0paWYoXCJzdHlsZVwiPT09bCl7dmFyIGg9ZVtsXTtmb3IoZyBpbiBoKWguaGFzT3duUHJvcGVydHkoZykmJlxuKGN8fChjPXt9KSxjW2ddPVwiXCIpfWVsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1sJiZcImNoaWxkcmVuXCIhPT1sJiZcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09bCYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWwmJlwiYXV0b0ZvY3VzXCIhPT1sJiYoZWEuaGFzT3duUHJvcGVydHkobCk/Znx8KGY9W10pOihmPWZ8fFtdKS5wdXNoKGwsbnVsbCkpO2ZvcihsIGluIGQpe3ZhciBrPWRbbF07aD1udWxsIT1lP2VbbF06dm9pZCAwO2lmKGQuaGFzT3duUHJvcGVydHkobCkmJmshPT1oJiYobnVsbCE9a3x8bnVsbCE9aCkpaWYoXCJzdHlsZVwiPT09bClpZihoKXtmb3IoZyBpbiBoKSFoLmhhc093blByb3BlcnR5KGcpfHxrJiZrLmhhc093blByb3BlcnR5KGcpfHwoY3x8KGM9e30pLGNbZ109XCJcIik7Zm9yKGcgaW4gaylrLmhhc093blByb3BlcnR5KGcpJiZoW2ddIT09a1tnXSYmKGN8fChjPXt9KSxjW2ddPWtbZ10pfWVsc2UgY3x8KGZ8fChmPVtdKSxmLnB1c2gobCxcbmMpKSxjPWs7ZWxzZVwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWw/KGs9az9rLl9faHRtbDp2b2lkIDAsaD1oP2guX19odG1sOnZvaWQgMCxudWxsIT1rJiZoIT09ayYmKGY9Znx8W10pLnB1c2gobCxrKSk6XCJjaGlsZHJlblwiPT09bD9cInN0cmluZ1wiIT09dHlwZW9mIGsmJlwibnVtYmVyXCIhPT10eXBlb2Yga3x8KGY9Znx8W10pLnB1c2gobCxcIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1sJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09bCYmKGVhLmhhc093blByb3BlcnR5KGwpPyhudWxsIT1rJiZcIm9uU2Nyb2xsXCI9PT1sJiZEKFwic2Nyb2xsXCIsYSksZnx8aD09PWt8fChmPVtdKSk6KGY9Znx8W10pLnB1c2gobCxrKSl9YyYmKGY9Znx8W10pLnB1c2goXCJzdHlsZVwiLGMpO3ZhciBsPWY7aWYoYi51cGRhdGVRdWV1ZT1sKWIuZmxhZ3N8PTR9fTtDaj1mdW5jdGlvbihhLGIsYyxkKXtjIT09ZCYmKGIuZmxhZ3N8PTQpfTtcbmZ1bmN0aW9uIERqKGEsYil7aWYoIUkpc3dpdGNoKGEudGFpbE1vZGUpe2Nhc2UgXCJoaWRkZW5cIjpiPWEudGFpbDtmb3IodmFyIGM9bnVsbDtudWxsIT09YjspbnVsbCE9PWIuYWx0ZXJuYXRlJiYoYz1iKSxiPWIuc2libGluZztudWxsPT09Yz9hLnRhaWw9bnVsbDpjLnNpYmxpbmc9bnVsbDticmVhaztjYXNlIFwiY29sbGFwc2VkXCI6Yz1hLnRhaWw7Zm9yKHZhciBkPW51bGw7bnVsbCE9PWM7KW51bGwhPT1jLmFsdGVybmF0ZSYmKGQ9YyksYz1jLnNpYmxpbmc7bnVsbD09PWQ/Ynx8bnVsbD09PWEudGFpbD9hLnRhaWw9bnVsbDphLnRhaWwuc2libGluZz1udWxsOmQuc2libGluZz1udWxsfX1cbmZ1bmN0aW9uIFMoYSl7dmFyIGI9bnVsbCE9PWEuYWx0ZXJuYXRlJiZhLmFsdGVybmF0ZS5jaGlsZD09PWEuY2hpbGQsYz0wLGQ9MDtpZihiKWZvcih2YXIgZT1hLmNoaWxkO251bGwhPT1lOyljfD1lLmxhbmVzfGUuY2hpbGRMYW5lcyxkfD1lLnN1YnRyZWVGbGFncyYxNDY4MDA2NCxkfD1lLmZsYWdzJjE0NjgwMDY0LGUucmV0dXJuPWEsZT1lLnNpYmxpbmc7ZWxzZSBmb3IoZT1hLmNoaWxkO251bGwhPT1lOyljfD1lLmxhbmVzfGUuY2hpbGRMYW5lcyxkfD1lLnN1YnRyZWVGbGFncyxkfD1lLmZsYWdzLGUucmV0dXJuPWEsZT1lLnNpYmxpbmc7YS5zdWJ0cmVlRmxhZ3N8PWQ7YS5jaGlsZExhbmVzPWM7cmV0dXJuIGJ9XG5mdW5jdGlvbiBFaihhLGIsYyl7dmFyIGQ9Yi5wZW5kaW5nUHJvcHM7d2coYik7c3dpdGNoKGIudGFnKXtjYXNlIDI6Y2FzZSAxNjpjYXNlIDE1OmNhc2UgMDpjYXNlIDExOmNhc2UgNzpjYXNlIDg6Y2FzZSAxMjpjYXNlIDk6Y2FzZSAxNDpyZXR1cm4gUyhiKSxudWxsO2Nhc2UgMTpyZXR1cm4gWmYoYi50eXBlKSYmJGYoKSxTKGIpLG51bGw7Y2FzZSAzOmQ9Yi5zdGF0ZU5vZGU7emgoKTtFKFdmKTtFKEgpO0VoKCk7ZC5wZW5kaW5nQ29udGV4dCYmKGQuY29udGV4dD1kLnBlbmRpbmdDb250ZXh0LGQucGVuZGluZ0NvbnRleHQ9bnVsbCk7aWYobnVsbD09PWF8fG51bGw9PT1hLmNoaWxkKUdnKGIpP2IuZmxhZ3N8PTQ6bnVsbD09PWF8fGEubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQmJjA9PT0oYi5mbGFncyYyNTYpfHwoYi5mbGFnc3w9MTAyNCxudWxsIT09emcmJihGaih6Zyksemc9bnVsbCkpO0FqKGEsYik7UyhiKTtyZXR1cm4gbnVsbDtjYXNlIDU6QmgoYik7dmFyIGU9eGgod2guY3VycmVudCk7XG5jPWIudHlwZTtpZihudWxsIT09YSYmbnVsbCE9Yi5zdGF0ZU5vZGUpQmooYSxiLGMsZCxlKSxhLnJlZiE9PWIucmVmJiYoYi5mbGFnc3w9NTEyLGIuZmxhZ3N8PTIwOTcxNTIpO2Vsc2V7aWYoIWQpe2lmKG51bGw9PT1iLnN0YXRlTm9kZSl0aHJvdyBFcnJvcihwKDE2NikpO1MoYik7cmV0dXJuIG51bGx9YT14aCh1aC5jdXJyZW50KTtpZihHZyhiKSl7ZD1iLnN0YXRlTm9kZTtjPWIudHlwZTt2YXIgZj1iLm1lbW9pemVkUHJvcHM7ZFtPZl09YjtkW1BmXT1mO2E9MCE9PShiLm1vZGUmMSk7c3dpdGNoKGMpe2Nhc2UgXCJkaWFsb2dcIjpEKFwiY2FuY2VsXCIsZCk7RChcImNsb3NlXCIsZCk7YnJlYWs7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwiZW1iZWRcIjpEKFwibG9hZFwiLGQpO2JyZWFrO2Nhc2UgXCJ2aWRlb1wiOmNhc2UgXCJhdWRpb1wiOmZvcihlPTA7ZTxsZi5sZW5ndGg7ZSsrKUQobGZbZV0sZCk7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOkQoXCJlcnJvclwiLGQpO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpjYXNlIFwibGlua1wiOkQoXCJlcnJvclwiLFxuZCk7RChcImxvYWRcIixkKTticmVhaztjYXNlIFwiZGV0YWlsc1wiOkQoXCJ0b2dnbGVcIixkKTticmVhaztjYXNlIFwiaW5wdXRcIjpaYShkLGYpO0QoXCJpbnZhbGlkXCIsZCk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmQuX3dyYXBwZXJTdGF0ZT17d2FzTXVsdGlwbGU6ISFmLm11bHRpcGxlfTtEKFwiaW52YWxpZFwiLGQpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmhiKGQsZiksRChcImludmFsaWRcIixkKX11YihjLGYpO2U9bnVsbDtmb3IodmFyIGcgaW4gZilpZihmLmhhc093blByb3BlcnR5KGcpKXt2YXIgaD1mW2ddO1wiY2hpbGRyZW5cIj09PWc/XCJzdHJpbmdcIj09PXR5cGVvZiBoP2QudGV4dENvbnRlbnQhPT1oJiYoITAhPT1mLnN1cHByZXNzSHlkcmF0aW9uV2FybmluZyYmQWYoZC50ZXh0Q29udGVudCxoLGEpLGU9W1wiY2hpbGRyZW5cIixoXSk6XCJudW1iZXJcIj09PXR5cGVvZiBoJiZkLnRleHRDb250ZW50IT09XCJcIitoJiYoITAhPT1mLnN1cHByZXNzSHlkcmF0aW9uV2FybmluZyYmQWYoZC50ZXh0Q29udGVudCxcbmgsYSksZT1bXCJjaGlsZHJlblwiLFwiXCIraF0pOmVhLmhhc093blByb3BlcnR5KGcpJiZudWxsIT1oJiZcIm9uU2Nyb2xsXCI9PT1nJiZEKFwic2Nyb2xsXCIsZCl9c3dpdGNoKGMpe2Nhc2UgXCJpbnB1dFwiOlZhKGQpO2RiKGQsZiwhMCk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmEoZCk7amIoZCk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJvcHRpb25cIjpicmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLm9uQ2xpY2smJihkLm9uY2xpY2s9QmYpfWQ9ZTtiLnVwZGF0ZVF1ZXVlPWQ7bnVsbCE9PWQmJihiLmZsYWdzfD00KX1lbHNle2c9OT09PWUubm9kZVR5cGU/ZTplLm93bmVyRG9jdW1lbnQ7XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PT1hJiYoYT1rYihjKSk7XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PT1hP1wic2NyaXB0XCI9PT1jPyhhPWcuY3JlYXRlRWxlbWVudChcImRpdlwiKSxhLmlubmVySFRNTD1cIjxzY3JpcHQ+XFx4M2Mvc2NyaXB0PlwiLGE9YS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpKTpcblwic3RyaW5nXCI9PT10eXBlb2YgZC5pcz9hPWcuY3JlYXRlRWxlbWVudChjLHtpczpkLmlzfSk6KGE9Zy5jcmVhdGVFbGVtZW50KGMpLFwic2VsZWN0XCI9PT1jJiYoZz1hLGQubXVsdGlwbGU/Zy5tdWx0aXBsZT0hMDpkLnNpemUmJihnLnNpemU9ZC5zaXplKSkpOmE9Zy5jcmVhdGVFbGVtZW50TlMoYSxjKTthW09mXT1iO2FbUGZdPWQ7emooYSxiLCExLCExKTtiLnN0YXRlTm9kZT1hO2E6e2c9dmIoYyxkKTtzd2l0Y2goYyl7Y2FzZSBcImRpYWxvZ1wiOkQoXCJjYW5jZWxcIixhKTtEKFwiY2xvc2VcIixhKTtlPWQ7YnJlYWs7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpjYXNlIFwiZW1iZWRcIjpEKFwibG9hZFwiLGEpO2U9ZDticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IoZT0wO2U8bGYubGVuZ3RoO2UrKylEKGxmW2VdLGEpO2U9ZDticmVhaztjYXNlIFwic291cmNlXCI6RChcImVycm9yXCIsYSk7ZT1kO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpjYXNlIFwibGlua1wiOkQoXCJlcnJvclwiLFxuYSk7RChcImxvYWRcIixhKTtlPWQ7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpEKFwidG9nZ2xlXCIsYSk7ZT1kO2JyZWFrO2Nhc2UgXCJpbnB1dFwiOlphKGEsZCk7ZT1ZYShhLGQpO0QoXCJpbnZhbGlkXCIsYSk7YnJlYWs7Y2FzZSBcIm9wdGlvblwiOmU9ZDticmVhaztjYXNlIFwic2VsZWN0XCI6YS5fd3JhcHBlclN0YXRlPXt3YXNNdWx0aXBsZTohIWQubXVsdGlwbGV9O2U9QSh7fSxkLHt2YWx1ZTp2b2lkIDB9KTtEKFwiaW52YWxpZFwiLGEpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmhiKGEsZCk7ZT1nYihhLGQpO0QoXCJpbnZhbGlkXCIsYSk7YnJlYWs7ZGVmYXVsdDplPWR9dWIoYyxlKTtoPWU7Zm9yKGYgaW4gaClpZihoLmhhc093blByb3BlcnR5KGYpKXt2YXIgaz1oW2ZdO1wic3R5bGVcIj09PWY/c2IoYSxrKTpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1mPyhrPWs/ay5fX2h0bWw6dm9pZCAwLG51bGwhPWsmJm5iKGEsaykpOlwiY2hpbGRyZW5cIj09PWY/XCJzdHJpbmdcIj09PXR5cGVvZiBrPyhcInRleHRhcmVhXCIhPT1cbmN8fFwiXCIhPT1rKSYmb2IoYSxrKTpcIm51bWJlclwiPT09dHlwZW9mIGsmJm9iKGEsXCJcIitrKTpcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09ZiYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWYmJlwiYXV0b0ZvY3VzXCIhPT1mJiYoZWEuaGFzT3duUHJvcGVydHkoZik/bnVsbCE9ayYmXCJvblNjcm9sbFwiPT09ZiYmRChcInNjcm9sbFwiLGEpOm51bGwhPWsmJnRhKGEsZixrLGcpKX1zd2l0Y2goYyl7Y2FzZSBcImlucHV0XCI6VmEoYSk7ZGIoYSxkLCExKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpWYShhKTtqYihhKTticmVhaztjYXNlIFwib3B0aW9uXCI6bnVsbCE9ZC52YWx1ZSYmYS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLFwiXCIrU2EoZC52YWx1ZSkpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjphLm11bHRpcGxlPSEhZC5tdWx0aXBsZTtmPWQudmFsdWU7bnVsbCE9Zj9mYihhLCEhZC5tdWx0aXBsZSxmLCExKTpudWxsIT1kLmRlZmF1bHRWYWx1ZSYmZmIoYSwhIWQubXVsdGlwbGUsZC5kZWZhdWx0VmFsdWUsXG4hMCk7YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCI9PT10eXBlb2YgZS5vbkNsaWNrJiYoYS5vbmNsaWNrPUJmKX1zd2l0Y2goYyl7Y2FzZSBcImJ1dHRvblwiOmNhc2UgXCJpbnB1dFwiOmNhc2UgXCJzZWxlY3RcIjpjYXNlIFwidGV4dGFyZWFcIjpkPSEhZC5hdXRvRm9jdXM7YnJlYWsgYTtjYXNlIFwiaW1nXCI6ZD0hMDticmVhayBhO2RlZmF1bHQ6ZD0hMX19ZCYmKGIuZmxhZ3N8PTQpfW51bGwhPT1iLnJlZiYmKGIuZmxhZ3N8PTUxMixiLmZsYWdzfD0yMDk3MTUyKX1TKGIpO3JldHVybiBudWxsO2Nhc2UgNjppZihhJiZudWxsIT1iLnN0YXRlTm9kZSlDaihhLGIsYS5tZW1vaXplZFByb3BzLGQpO2Vsc2V7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBkJiZudWxsPT09Yi5zdGF0ZU5vZGUpdGhyb3cgRXJyb3IocCgxNjYpKTtjPXhoKHdoLmN1cnJlbnQpO3hoKHVoLmN1cnJlbnQpO2lmKEdnKGIpKXtkPWIuc3RhdGVOb2RlO2M9Yi5tZW1vaXplZFByb3BzO2RbT2ZdPWI7aWYoZj1kLm5vZGVWYWx1ZSE9PWMpaWYoYT1cbnhnLG51bGwhPT1hKXN3aXRjaChhLnRhZyl7Y2FzZSAzOkFmKGQubm9kZVZhbHVlLGMsMCE9PShhLm1vZGUmMSkpO2JyZWFrO2Nhc2UgNTohMCE9PWEubWVtb2l6ZWRQcm9wcy5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcmJkFmKGQubm9kZVZhbHVlLGMsMCE9PShhLm1vZGUmMSkpfWYmJihiLmZsYWdzfD00KX1lbHNlIGQ9KDk9PT1jLm5vZGVUeXBlP2M6Yy5vd25lckRvY3VtZW50KS5jcmVhdGVUZXh0Tm9kZShkKSxkW09mXT1iLGIuc3RhdGVOb2RlPWR9UyhiKTtyZXR1cm4gbnVsbDtjYXNlIDEzOkUoTCk7ZD1iLm1lbW9pemVkU3RhdGU7aWYobnVsbD09PWF8fG51bGwhPT1hLm1lbW9pemVkU3RhdGUmJm51bGwhPT1hLm1lbW9pemVkU3RhdGUuZGVoeWRyYXRlZCl7aWYoSSYmbnVsbCE9PXlnJiYwIT09KGIubW9kZSYxKSYmMD09PShiLmZsYWdzJjEyOCkpSGcoKSxJZygpLGIuZmxhZ3N8PTk4NTYwLGY9ITE7ZWxzZSBpZihmPUdnKGIpLG51bGwhPT1kJiZudWxsIT09ZC5kZWh5ZHJhdGVkKXtpZihudWxsPT09XG5hKXtpZighZil0aHJvdyBFcnJvcihwKDMxOCkpO2Y9Yi5tZW1vaXplZFN0YXRlO2Y9bnVsbCE9PWY/Zi5kZWh5ZHJhdGVkOm51bGw7aWYoIWYpdGhyb3cgRXJyb3IocCgzMTcpKTtmW09mXT1ifWVsc2UgSWcoKSwwPT09KGIuZmxhZ3MmMTI4KSYmKGIubWVtb2l6ZWRTdGF0ZT1udWxsKSxiLmZsYWdzfD00O1MoYik7Zj0hMX1lbHNlIG51bGwhPT16ZyYmKEZqKHpnKSx6Zz1udWxsKSxmPSEwO2lmKCFmKXJldHVybiBiLmZsYWdzJjY1NTM2P2I6bnVsbH1pZigwIT09KGIuZmxhZ3MmMTI4KSlyZXR1cm4gYi5sYW5lcz1jLGI7ZD1udWxsIT09ZDtkIT09KG51bGwhPT1hJiZudWxsIT09YS5tZW1vaXplZFN0YXRlKSYmZCYmKGIuY2hpbGQuZmxhZ3N8PTgxOTIsMCE9PShiLm1vZGUmMSkmJihudWxsPT09YXx8MCE9PShMLmN1cnJlbnQmMSk/MD09PVQmJihUPTMpOnRqKCkpKTtudWxsIT09Yi51cGRhdGVRdWV1ZSYmKGIuZmxhZ3N8PTQpO1MoYik7cmV0dXJuIG51bGw7Y2FzZSA0OnJldHVybiB6aCgpLFxuQWooYSxiKSxudWxsPT09YSYmc2YoYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyksUyhiKSxudWxsO2Nhc2UgMTA6cmV0dXJuIGFoKGIudHlwZS5fY29udGV4dCksUyhiKSxudWxsO2Nhc2UgMTc6cmV0dXJuIFpmKGIudHlwZSkmJiRmKCksUyhiKSxudWxsO2Nhc2UgMTk6RShMKTtmPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsPT09ZilyZXR1cm4gUyhiKSxudWxsO2Q9MCE9PShiLmZsYWdzJjEyOCk7Zz1mLnJlbmRlcmluZztpZihudWxsPT09ZylpZihkKURqKGYsITEpO2Vsc2V7aWYoMCE9PVR8fG51bGwhPT1hJiYwIT09KGEuZmxhZ3MmMTI4KSlmb3IoYT1iLmNoaWxkO251bGwhPT1hOyl7Zz1DaChhKTtpZihudWxsIT09Zyl7Yi5mbGFnc3w9MTI4O0RqKGYsITEpO2Q9Zy51cGRhdGVRdWV1ZTtudWxsIT09ZCYmKGIudXBkYXRlUXVldWU9ZCxiLmZsYWdzfD00KTtiLnN1YnRyZWVGbGFncz0wO2Q9Yztmb3IoYz1iLmNoaWxkO251bGwhPT1jOylmPWMsYT1kLGYuZmxhZ3MmPTE0NjgwMDY2LFxuZz1mLmFsdGVybmF0ZSxudWxsPT09Zz8oZi5jaGlsZExhbmVzPTAsZi5sYW5lcz1hLGYuY2hpbGQ9bnVsbCxmLnN1YnRyZWVGbGFncz0wLGYubWVtb2l6ZWRQcm9wcz1udWxsLGYubWVtb2l6ZWRTdGF0ZT1udWxsLGYudXBkYXRlUXVldWU9bnVsbCxmLmRlcGVuZGVuY2llcz1udWxsLGYuc3RhdGVOb2RlPW51bGwpOihmLmNoaWxkTGFuZXM9Zy5jaGlsZExhbmVzLGYubGFuZXM9Zy5sYW5lcyxmLmNoaWxkPWcuY2hpbGQsZi5zdWJ0cmVlRmxhZ3M9MCxmLmRlbGV0aW9ucz1udWxsLGYubWVtb2l6ZWRQcm9wcz1nLm1lbW9pemVkUHJvcHMsZi5tZW1vaXplZFN0YXRlPWcubWVtb2l6ZWRTdGF0ZSxmLnVwZGF0ZVF1ZXVlPWcudXBkYXRlUXVldWUsZi50eXBlPWcudHlwZSxhPWcuZGVwZW5kZW5jaWVzLGYuZGVwZW5kZW5jaWVzPW51bGw9PT1hP251bGw6e2xhbmVzOmEubGFuZXMsZmlyc3RDb250ZXh0OmEuZmlyc3RDb250ZXh0fSksYz1jLnNpYmxpbmc7RyhMLEwuY3VycmVudCYxfDIpO3JldHVybiBiLmNoaWxkfWE9XG5hLnNpYmxpbmd9bnVsbCE9PWYudGFpbCYmQigpPkdqJiYoYi5mbGFnc3w9MTI4LGQ9ITAsRGooZiwhMSksYi5sYW5lcz00MTk0MzA0KX1lbHNle2lmKCFkKWlmKGE9Q2goZyksbnVsbCE9PWEpe2lmKGIuZmxhZ3N8PTEyOCxkPSEwLGM9YS51cGRhdGVRdWV1ZSxudWxsIT09YyYmKGIudXBkYXRlUXVldWU9YyxiLmZsYWdzfD00KSxEaihmLCEwKSxudWxsPT09Zi50YWlsJiZcImhpZGRlblwiPT09Zi50YWlsTW9kZSYmIWcuYWx0ZXJuYXRlJiYhSSlyZXR1cm4gUyhiKSxudWxsfWVsc2UgMipCKCktZi5yZW5kZXJpbmdTdGFydFRpbWU+R2omJjEwNzM3NDE4MjQhPT1jJiYoYi5mbGFnc3w9MTI4LGQ9ITAsRGooZiwhMSksYi5sYW5lcz00MTk0MzA0KTtmLmlzQmFja3dhcmRzPyhnLnNpYmxpbmc9Yi5jaGlsZCxiLmNoaWxkPWcpOihjPWYubGFzdCxudWxsIT09Yz9jLnNpYmxpbmc9ZzpiLmNoaWxkPWcsZi5sYXN0PWcpfWlmKG51bGwhPT1mLnRhaWwpcmV0dXJuIGI9Zi50YWlsLGYucmVuZGVyaW5nPVxuYixmLnRhaWw9Yi5zaWJsaW5nLGYucmVuZGVyaW5nU3RhcnRUaW1lPUIoKSxiLnNpYmxpbmc9bnVsbCxjPUwuY3VycmVudCxHKEwsZD9jJjF8MjpjJjEpLGI7UyhiKTtyZXR1cm4gbnVsbDtjYXNlIDIyOmNhc2UgMjM6cmV0dXJuIEhqKCksZD1udWxsIT09Yi5tZW1vaXplZFN0YXRlLG51bGwhPT1hJiZudWxsIT09YS5tZW1vaXplZFN0YXRlIT09ZCYmKGIuZmxhZ3N8PTgxOTIpLGQmJjAhPT0oYi5tb2RlJjEpPzAhPT0oZmomMTA3Mzc0MTgyNCkmJihTKGIpLGIuc3VidHJlZUZsYWdzJjYmJihiLmZsYWdzfD04MTkyKSk6UyhiKSxudWxsO2Nhc2UgMjQ6cmV0dXJuIG51bGw7Y2FzZSAyNTpyZXR1cm4gbnVsbH10aHJvdyBFcnJvcihwKDE1NixiLnRhZykpO31cbmZ1bmN0aW9uIElqKGEsYil7d2coYik7c3dpdGNoKGIudGFnKXtjYXNlIDE6cmV0dXJuIFpmKGIudHlwZSkmJiRmKCksYT1iLmZsYWdzLGEmNjU1MzY/KGIuZmxhZ3M9YSYtNjU1Mzd8MTI4LGIpOm51bGw7Y2FzZSAzOnJldHVybiB6aCgpLEUoV2YpLEUoSCksRWgoKSxhPWIuZmxhZ3MsMCE9PShhJjY1NTM2KSYmMD09PShhJjEyOCk/KGIuZmxhZ3M9YSYtNjU1Mzd8MTI4LGIpOm51bGw7Y2FzZSA1OnJldHVybiBCaChiKSxudWxsO2Nhc2UgMTM6RShMKTthPWIubWVtb2l6ZWRTdGF0ZTtpZihudWxsIT09YSYmbnVsbCE9PWEuZGVoeWRyYXRlZCl7aWYobnVsbD09PWIuYWx0ZXJuYXRlKXRocm93IEVycm9yKHAoMzQwKSk7SWcoKX1hPWIuZmxhZ3M7cmV0dXJuIGEmNjU1MzY/KGIuZmxhZ3M9YSYtNjU1Mzd8MTI4LGIpOm51bGw7Y2FzZSAxOTpyZXR1cm4gRShMKSxudWxsO2Nhc2UgNDpyZXR1cm4gemgoKSxudWxsO2Nhc2UgMTA6cmV0dXJuIGFoKGIudHlwZS5fY29udGV4dCksbnVsbDtjYXNlIDIyOmNhc2UgMjM6cmV0dXJuIEhqKCksXG5udWxsO2Nhc2UgMjQ6cmV0dXJuIG51bGw7ZGVmYXVsdDpyZXR1cm4gbnVsbH19dmFyIEpqPSExLFU9ITEsS2o9XCJmdW5jdGlvblwiPT09dHlwZW9mIFdlYWtTZXQ/V2Vha1NldDpTZXQsVj1udWxsO2Z1bmN0aW9uIExqKGEsYil7dmFyIGM9YS5yZWY7aWYobnVsbCE9PWMpaWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGMpdHJ5e2MobnVsbCl9Y2F0Y2goZCl7VyhhLGIsZCl9ZWxzZSBjLmN1cnJlbnQ9bnVsbH1mdW5jdGlvbiBNaihhLGIsYyl7dHJ5e2MoKX1jYXRjaChkKXtXKGEsYixkKX19dmFyIE5qPSExO1xuZnVuY3Rpb24gT2ooYSxiKXtDZj1kZDthPU1lKCk7aWYoTmUoYSkpe2lmKFwic2VsZWN0aW9uU3RhcnRcImluIGEpdmFyIGM9e3N0YXJ0OmEuc2VsZWN0aW9uU3RhcnQsZW5kOmEuc2VsZWN0aW9uRW5kfTtlbHNlIGE6e2M9KGM9YS5vd25lckRvY3VtZW50KSYmYy5kZWZhdWx0Vmlld3x8d2luZG93O3ZhciBkPWMuZ2V0U2VsZWN0aW9uJiZjLmdldFNlbGVjdGlvbigpO2lmKGQmJjAhPT1kLnJhbmdlQ291bnQpe2M9ZC5hbmNob3JOb2RlO3ZhciBlPWQuYW5jaG9yT2Zmc2V0LGY9ZC5mb2N1c05vZGU7ZD1kLmZvY3VzT2Zmc2V0O3RyeXtjLm5vZGVUeXBlLGYubm9kZVR5cGV9Y2F0Y2goRil7Yz1udWxsO2JyZWFrIGF9dmFyIGc9MCxoPS0xLGs9LTEsbD0wLG09MCxxPWEscj1udWxsO2I6Zm9yKDs7KXtmb3IodmFyIHk7Oyl7cSE9PWN8fDAhPT1lJiYzIT09cS5ub2RlVHlwZXx8KGg9ZytlKTtxIT09Znx8MCE9PWQmJjMhPT1xLm5vZGVUeXBlfHwoaz1nK2QpOzM9PT1xLm5vZGVUeXBlJiYoZys9XG5xLm5vZGVWYWx1ZS5sZW5ndGgpO2lmKG51bGw9PT0oeT1xLmZpcnN0Q2hpbGQpKWJyZWFrO3I9cTtxPXl9Zm9yKDs7KXtpZihxPT09YSlicmVhayBiO3I9PT1jJiYrK2w9PT1lJiYoaD1nKTtyPT09ZiYmKyttPT09ZCYmKGs9Zyk7aWYobnVsbCE9PSh5PXEubmV4dFNpYmxpbmcpKWJyZWFrO3E9cjtyPXEucGFyZW50Tm9kZX1xPXl9Yz0tMT09PWh8fC0xPT09az9udWxsOntzdGFydDpoLGVuZDprfX1lbHNlIGM9bnVsbH1jPWN8fHtzdGFydDowLGVuZDowfX1lbHNlIGM9bnVsbDtEZj17Zm9jdXNlZEVsZW06YSxzZWxlY3Rpb25SYW5nZTpjfTtkZD0hMTtmb3IoVj1iO251bGwhPT1WOylpZihiPVYsYT1iLmNoaWxkLDAhPT0oYi5zdWJ0cmVlRmxhZ3MmMTAyOCkmJm51bGwhPT1hKWEucmV0dXJuPWIsVj1hO2Vsc2UgZm9yKDtudWxsIT09Vjspe2I9Vjt0cnl7dmFyIG49Yi5hbHRlcm5hdGU7aWYoMCE9PShiLmZsYWdzJjEwMjQpKXN3aXRjaChiLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpicmVhaztcbmNhc2UgMTppZihudWxsIT09bil7dmFyIHQ9bi5tZW1vaXplZFByb3BzLEo9bi5tZW1vaXplZFN0YXRlLHg9Yi5zdGF0ZU5vZGUsdz14LmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKGIuZWxlbWVudFR5cGU9PT1iLnR5cGU/dDpDaShiLnR5cGUsdCksSik7eC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZT13fWJyZWFrO2Nhc2UgMzp2YXIgdT1iLnN0YXRlTm9kZS5jb250YWluZXJJbmZvOzE9PT11Lm5vZGVUeXBlP3UudGV4dENvbnRlbnQ9XCJcIjo5PT09dS5ub2RlVHlwZSYmdS5kb2N1bWVudEVsZW1lbnQmJnUucmVtb3ZlQ2hpbGQodS5kb2N1bWVudEVsZW1lbnQpO2JyZWFrO2Nhc2UgNTpjYXNlIDY6Y2FzZSA0OmNhc2UgMTc6YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihwKDE2MykpO319Y2F0Y2goRil7VyhiLGIucmV0dXJuLEYpfWE9Yi5zaWJsaW5nO2lmKG51bGwhPT1hKXthLnJldHVybj1iLnJldHVybjtWPWE7YnJlYWt9Vj1iLnJldHVybn1uPU5qO05qPSExO3JldHVybiBufVxuZnVuY3Rpb24gUGooYSxiLGMpe3ZhciBkPWIudXBkYXRlUXVldWU7ZD1udWxsIT09ZD9kLmxhc3RFZmZlY3Q6bnVsbDtpZihudWxsIT09ZCl7dmFyIGU9ZD1kLm5leHQ7ZG97aWYoKGUudGFnJmEpPT09YSl7dmFyIGY9ZS5kZXN0cm95O2UuZGVzdHJveT12b2lkIDA7dm9pZCAwIT09ZiYmTWooYixjLGYpfWU9ZS5uZXh0fXdoaWxlKGUhPT1kKX19ZnVuY3Rpb24gUWooYSxiKXtiPWIudXBkYXRlUXVldWU7Yj1udWxsIT09Yj9iLmxhc3RFZmZlY3Q6bnVsbDtpZihudWxsIT09Yil7dmFyIGM9Yj1iLm5leHQ7ZG97aWYoKGMudGFnJmEpPT09YSl7dmFyIGQ9Yy5jcmVhdGU7Yy5kZXN0cm95PWQoKX1jPWMubmV4dH13aGlsZShjIT09Yil9fWZ1bmN0aW9uIFJqKGEpe3ZhciBiPWEucmVmO2lmKG51bGwhPT1iKXt2YXIgYz1hLnN0YXRlTm9kZTtzd2l0Y2goYS50YWcpe2Nhc2UgNTphPWM7YnJlYWs7ZGVmYXVsdDphPWN9XCJmdW5jdGlvblwiPT09dHlwZW9mIGI/YihhKTpiLmN1cnJlbnQ9YX19XG5mdW5jdGlvbiBTaihhKXt2YXIgYj1hLmFsdGVybmF0ZTtudWxsIT09YiYmKGEuYWx0ZXJuYXRlPW51bGwsU2ooYikpO2EuY2hpbGQ9bnVsbDthLmRlbGV0aW9ucz1udWxsO2Euc2libGluZz1udWxsOzU9PT1hLnRhZyYmKGI9YS5zdGF0ZU5vZGUsbnVsbCE9PWImJihkZWxldGUgYltPZl0sZGVsZXRlIGJbUGZdLGRlbGV0ZSBiW29mXSxkZWxldGUgYltRZl0sZGVsZXRlIGJbUmZdKSk7YS5zdGF0ZU5vZGU9bnVsbDthLnJldHVybj1udWxsO2EuZGVwZW5kZW5jaWVzPW51bGw7YS5tZW1vaXplZFByb3BzPW51bGw7YS5tZW1vaXplZFN0YXRlPW51bGw7YS5wZW5kaW5nUHJvcHM9bnVsbDthLnN0YXRlTm9kZT1udWxsO2EudXBkYXRlUXVldWU9bnVsbH1mdW5jdGlvbiBUaihhKXtyZXR1cm4gNT09PWEudGFnfHwzPT09YS50YWd8fDQ9PT1hLnRhZ31cbmZ1bmN0aW9uIFVqKGEpe2E6Zm9yKDs7KXtmb3IoO251bGw9PT1hLnNpYmxpbmc7KXtpZihudWxsPT09YS5yZXR1cm58fFRqKGEucmV0dXJuKSlyZXR1cm4gbnVsbDthPWEucmV0dXJufWEuc2libGluZy5yZXR1cm49YS5yZXR1cm47Zm9yKGE9YS5zaWJsaW5nOzUhPT1hLnRhZyYmNiE9PWEudGFnJiYxOCE9PWEudGFnOyl7aWYoYS5mbGFncyYyKWNvbnRpbnVlIGE7aWYobnVsbD09PWEuY2hpbGR8fDQ9PT1hLnRhZyljb250aW51ZSBhO2Vsc2UgYS5jaGlsZC5yZXR1cm49YSxhPWEuY2hpbGR9aWYoIShhLmZsYWdzJjIpKXJldHVybiBhLnN0YXRlTm9kZX19XG5mdW5jdGlvbiBWaihhLGIsYyl7dmFyIGQ9YS50YWc7aWYoNT09PWR8fDY9PT1kKWE9YS5zdGF0ZU5vZGUsYj84PT09Yy5ub2RlVHlwZT9jLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsYik6Yy5pbnNlcnRCZWZvcmUoYSxiKTooOD09PWMubm9kZVR5cGU/KGI9Yy5wYXJlbnROb2RlLGIuaW5zZXJ0QmVmb3JlKGEsYykpOihiPWMsYi5hcHBlbmRDaGlsZChhKSksYz1jLl9yZWFjdFJvb3RDb250YWluZXIsbnVsbCE9PWMmJnZvaWQgMCE9PWN8fG51bGwhPT1iLm9uY2xpY2t8fChiLm9uY2xpY2s9QmYpKTtlbHNlIGlmKDQhPT1kJiYoYT1hLmNoaWxkLG51bGwhPT1hKSlmb3IoVmooYSxiLGMpLGE9YS5zaWJsaW5nO251bGwhPT1hOylWaihhLGIsYyksYT1hLnNpYmxpbmd9XG5mdW5jdGlvbiBXaihhLGIsYyl7dmFyIGQ9YS50YWc7aWYoNT09PWR8fDY9PT1kKWE9YS5zdGF0ZU5vZGUsYj9jLmluc2VydEJlZm9yZShhLGIpOmMuYXBwZW5kQ2hpbGQoYSk7ZWxzZSBpZig0IT09ZCYmKGE9YS5jaGlsZCxudWxsIT09YSkpZm9yKFdqKGEsYixjKSxhPWEuc2libGluZztudWxsIT09YTspV2ooYSxiLGMpLGE9YS5zaWJsaW5nfXZhciBYPW51bGwsWGo9ITE7ZnVuY3Rpb24gWWooYSxiLGMpe2ZvcihjPWMuY2hpbGQ7bnVsbCE9PWM7KVpqKGEsYixjKSxjPWMuc2libGluZ31cbmZ1bmN0aW9uIFpqKGEsYixjKXtpZihsYyYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGxjLm9uQ29tbWl0RmliZXJVbm1vdW50KXRyeXtsYy5vbkNvbW1pdEZpYmVyVW5tb3VudChrYyxjKX1jYXRjaChoKXt9c3dpdGNoKGMudGFnKXtjYXNlIDU6VXx8TGooYyxiKTtjYXNlIDY6dmFyIGQ9WCxlPVhqO1g9bnVsbDtZaihhLGIsYyk7WD1kO1hqPWU7bnVsbCE9PVgmJihYaj8oYT1YLGM9Yy5zdGF0ZU5vZGUsOD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpOmEucmVtb3ZlQ2hpbGQoYykpOlgucmVtb3ZlQ2hpbGQoYy5zdGF0ZU5vZGUpKTticmVhaztjYXNlIDE4Om51bGwhPT1YJiYoWGo/KGE9WCxjPWMuc3RhdGVOb2RlLDg9PT1hLm5vZGVUeXBlP0tmKGEucGFyZW50Tm9kZSxjKToxPT09YS5ub2RlVHlwZSYmS2YoYSxjKSxiZChhKSk6S2YoWCxjLnN0YXRlTm9kZSkpO2JyZWFrO2Nhc2UgNDpkPVg7ZT1YajtYPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87WGo9ITA7XG5ZaihhLGIsYyk7WD1kO1hqPWU7YnJlYWs7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OmlmKCFVJiYoZD1jLnVwZGF0ZVF1ZXVlLG51bGwhPT1kJiYoZD1kLmxhc3RFZmZlY3QsbnVsbCE9PWQpKSl7ZT1kPWQubmV4dDtkb3t2YXIgZj1lLGc9Zi5kZXN0cm95O2Y9Zi50YWc7dm9pZCAwIT09ZyYmKDAhPT0oZiYyKT9NaihjLGIsZyk6MCE9PShmJjQpJiZNaihjLGIsZykpO2U9ZS5uZXh0fXdoaWxlKGUhPT1kKX1ZaihhLGIsYyk7YnJlYWs7Y2FzZSAxOmlmKCFVJiYoTGooYyxiKSxkPWMuc3RhdGVOb2RlLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudFdpbGxVbm1vdW50KSl0cnl7ZC5wcm9wcz1jLm1lbW9pemVkUHJvcHMsZC5zdGF0ZT1jLm1lbW9pemVkU3RhdGUsZC5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKGgpe1coYyxiLGgpfVlqKGEsYixjKTticmVhaztjYXNlIDIxOllqKGEsYixjKTticmVhaztjYXNlIDIyOmMubW9kZSYxPyhVPShkPVUpfHxudWxsIT09XG5jLm1lbW9pemVkU3RhdGUsWWooYSxiLGMpLFU9ZCk6WWooYSxiLGMpO2JyZWFrO2RlZmF1bHQ6WWooYSxiLGMpfX1mdW5jdGlvbiBhayhhKXt2YXIgYj1hLnVwZGF0ZVF1ZXVlO2lmKG51bGwhPT1iKXthLnVwZGF0ZVF1ZXVlPW51bGw7dmFyIGM9YS5zdGF0ZU5vZGU7bnVsbD09PWMmJihjPWEuc3RhdGVOb2RlPW5ldyBLaik7Yi5mb3JFYWNoKGZ1bmN0aW9uKGIpe3ZhciBkPWJrLmJpbmQobnVsbCxhLGIpO2MuaGFzKGIpfHwoYy5hZGQoYiksYi50aGVuKGQsZCkpfSl9fVxuZnVuY3Rpb24gY2soYSxiKXt2YXIgYz1iLmRlbGV0aW9ucztpZihudWxsIT09Yylmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTt0cnl7dmFyIGY9YSxnPWIsaD1nO2E6Zm9yKDtudWxsIT09aDspe3N3aXRjaChoLnRhZyl7Y2FzZSA1Olg9aC5zdGF0ZU5vZGU7WGo9ITE7YnJlYWsgYTtjYXNlIDM6WD1oLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1hqPSEwO2JyZWFrIGE7Y2FzZSA0Olg9aC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztYaj0hMDticmVhayBhfWg9aC5yZXR1cm59aWYobnVsbD09PVgpdGhyb3cgRXJyb3IocCgxNjApKTtaaihmLGcsZSk7WD1udWxsO1hqPSExO3ZhciBrPWUuYWx0ZXJuYXRlO251bGwhPT1rJiYoay5yZXR1cm49bnVsbCk7ZS5yZXR1cm49bnVsbH1jYXRjaChsKXtXKGUsYixsKX19aWYoYi5zdWJ0cmVlRmxhZ3MmMTI4NTQpZm9yKGI9Yi5jaGlsZDtudWxsIT09YjspZGsoYixhKSxiPWIuc2libGluZ31cbmZ1bmN0aW9uIGRrKGEsYil7dmFyIGM9YS5hbHRlcm5hdGUsZD1hLmZsYWdzO3N3aXRjaChhLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNDpjYXNlIDE1OmNrKGIsYSk7ZWsoYSk7aWYoZCY0KXt0cnl7UGooMyxhLGEucmV0dXJuKSxRaigzLGEpfWNhdGNoKHQpe1coYSxhLnJldHVybix0KX10cnl7UGooNSxhLGEucmV0dXJuKX1jYXRjaCh0KXtXKGEsYS5yZXR1cm4sdCl9fWJyZWFrO2Nhc2UgMTpjayhiLGEpO2VrKGEpO2QmNTEyJiZudWxsIT09YyYmTGooYyxjLnJldHVybik7YnJlYWs7Y2FzZSA1OmNrKGIsYSk7ZWsoYSk7ZCY1MTImJm51bGwhPT1jJiZMaihjLGMucmV0dXJuKTtpZihhLmZsYWdzJjMyKXt2YXIgZT1hLnN0YXRlTm9kZTt0cnl7b2IoZSxcIlwiKX1jYXRjaCh0KXtXKGEsYS5yZXR1cm4sdCl9fWlmKGQmNCYmKGU9YS5zdGF0ZU5vZGUsbnVsbCE9ZSkpe3ZhciBmPWEubWVtb2l6ZWRQcm9wcyxnPW51bGwhPT1jP2MubWVtb2l6ZWRQcm9wczpmLGg9YS50eXBlLGs9YS51cGRhdGVRdWV1ZTtcbmEudXBkYXRlUXVldWU9bnVsbDtpZihudWxsIT09ayl0cnl7XCJpbnB1dFwiPT09aCYmXCJyYWRpb1wiPT09Zi50eXBlJiZudWxsIT1mLm5hbWUmJmFiKGUsZik7dmIoaCxnKTt2YXIgbD12YihoLGYpO2ZvcihnPTA7ZzxrLmxlbmd0aDtnKz0yKXt2YXIgbT1rW2ddLHE9a1tnKzFdO1wic3R5bGVcIj09PW0/c2IoZSxxKTpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1tP25iKGUscSk6XCJjaGlsZHJlblwiPT09bT9vYihlLHEpOnRhKGUsbSxxLGwpfXN3aXRjaChoKXtjYXNlIFwiaW5wdXRcIjpiYihlLGYpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmliKGUsZik7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOnZhciByPWUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU9ISFmLm11bHRpcGxlO3ZhciB5PWYudmFsdWU7bnVsbCE9eT9mYihlLCEhZi5tdWx0aXBsZSx5LCExKTpyIT09ISFmLm11bHRpcGxlJiYobnVsbCE9Zi5kZWZhdWx0VmFsdWU/ZmIoZSwhIWYubXVsdGlwbGUsXG5mLmRlZmF1bHRWYWx1ZSwhMCk6ZmIoZSwhIWYubXVsdGlwbGUsZi5tdWx0aXBsZT9bXTpcIlwiLCExKSl9ZVtQZl09Zn1jYXRjaCh0KXtXKGEsYS5yZXR1cm4sdCl9fWJyZWFrO2Nhc2UgNjpjayhiLGEpO2VrKGEpO2lmKGQmNCl7aWYobnVsbD09PWEuc3RhdGVOb2RlKXRocm93IEVycm9yKHAoMTYyKSk7ZT1hLnN0YXRlTm9kZTtmPWEubWVtb2l6ZWRQcm9wczt0cnl7ZS5ub2RlVmFsdWU9Zn1jYXRjaCh0KXtXKGEsYS5yZXR1cm4sdCl9fWJyZWFrO2Nhc2UgMzpjayhiLGEpO2VrKGEpO2lmKGQmNCYmbnVsbCE9PWMmJmMubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpdHJ5e2JkKGIuY29udGFpbmVySW5mbyl9Y2F0Y2godCl7VyhhLGEucmV0dXJuLHQpfWJyZWFrO2Nhc2UgNDpjayhiLGEpO2VrKGEpO2JyZWFrO2Nhc2UgMTM6Y2soYixhKTtlayhhKTtlPWEuY2hpbGQ7ZS5mbGFncyY4MTkyJiYoZj1udWxsIT09ZS5tZW1vaXplZFN0YXRlLGUuc3RhdGVOb2RlLmlzSGlkZGVuPWYsIWZ8fFxubnVsbCE9PWUuYWx0ZXJuYXRlJiZudWxsIT09ZS5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZXx8KGZrPUIoKSkpO2QmNCYmYWsoYSk7YnJlYWs7Y2FzZSAyMjptPW51bGwhPT1jJiZudWxsIT09Yy5tZW1vaXplZFN0YXRlO2EubW9kZSYxPyhVPShsPVUpfHxtLGNrKGIsYSksVT1sKTpjayhiLGEpO2VrKGEpO2lmKGQmODE5Mil7bD1udWxsIT09YS5tZW1vaXplZFN0YXRlO2lmKChhLnN0YXRlTm9kZS5pc0hpZGRlbj1sKSYmIW0mJjAhPT0oYS5tb2RlJjEpKWZvcihWPWEsbT1hLmNoaWxkO251bGwhPT1tOyl7Zm9yKHE9Vj1tO251bGwhPT1WOyl7cj1WO3k9ci5jaGlsZDtzd2l0Y2goci50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTQ6Y2FzZSAxNTpQaig0LHIsci5yZXR1cm4pO2JyZWFrO2Nhc2UgMTpMaihyLHIucmV0dXJuKTt2YXIgbj1yLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2Ygbi5jb21wb25lbnRXaWxsVW5tb3VudCl7ZD1yO2M9ci5yZXR1cm47dHJ5e2I9ZCxuLnByb3BzPVxuYi5tZW1vaXplZFByb3BzLG4uc3RhdGU9Yi5tZW1vaXplZFN0YXRlLG4uY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaCh0KXtXKGQsYyx0KX19YnJlYWs7Y2FzZSA1OkxqKHIsci5yZXR1cm4pO2JyZWFrO2Nhc2UgMjI6aWYobnVsbCE9PXIubWVtb2l6ZWRTdGF0ZSl7Z2socSk7Y29udGludWV9fW51bGwhPT15Pyh5LnJldHVybj1yLFY9eSk6Z2socSl9bT1tLnNpYmxpbmd9YTpmb3IobT1udWxsLHE9YTs7KXtpZig1PT09cS50YWcpe2lmKG51bGw9PT1tKXttPXE7dHJ5e2U9cS5zdGF0ZU5vZGUsbD8oZj1lLnN0eWxlLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBmLnNldFByb3BlcnR5P2Yuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsXCJub25lXCIsXCJpbXBvcnRhbnRcIik6Zi5kaXNwbGF5PVwibm9uZVwiKTooaD1xLnN0YXRlTm9kZSxrPXEubWVtb2l6ZWRQcm9wcy5zdHlsZSxnPXZvaWQgMCE9PWsmJm51bGwhPT1rJiZrLmhhc093blByb3BlcnR5KFwiZGlzcGxheVwiKT9rLmRpc3BsYXk6bnVsbCxoLnN0eWxlLmRpc3BsYXk9XG5yYihcImRpc3BsYXlcIixnKSl9Y2F0Y2godCl7VyhhLGEucmV0dXJuLHQpfX19ZWxzZSBpZig2PT09cS50YWcpe2lmKG51bGw9PT1tKXRyeXtxLnN0YXRlTm9kZS5ub2RlVmFsdWU9bD9cIlwiOnEubWVtb2l6ZWRQcm9wc31jYXRjaCh0KXtXKGEsYS5yZXR1cm4sdCl9fWVsc2UgaWYoKDIyIT09cS50YWcmJjIzIT09cS50YWd8fG51bGw9PT1xLm1lbW9pemVkU3RhdGV8fHE9PT1hKSYmbnVsbCE9PXEuY2hpbGQpe3EuY2hpbGQucmV0dXJuPXE7cT1xLmNoaWxkO2NvbnRpbnVlfWlmKHE9PT1hKWJyZWFrIGE7Zm9yKDtudWxsPT09cS5zaWJsaW5nOyl7aWYobnVsbD09PXEucmV0dXJufHxxLnJldHVybj09PWEpYnJlYWsgYTttPT09cSYmKG09bnVsbCk7cT1xLnJldHVybn1tPT09cSYmKG09bnVsbCk7cS5zaWJsaW5nLnJldHVybj1xLnJldHVybjtxPXEuc2libGluZ319YnJlYWs7Y2FzZSAxOTpjayhiLGEpO2VrKGEpO2QmNCYmYWsoYSk7YnJlYWs7Y2FzZSAyMTpicmVhaztkZWZhdWx0OmNrKGIsXG5hKSxlayhhKX19ZnVuY3Rpb24gZWsoYSl7dmFyIGI9YS5mbGFncztpZihiJjIpe3RyeXthOntmb3IodmFyIGM9YS5yZXR1cm47bnVsbCE9PWM7KXtpZihUaihjKSl7dmFyIGQ9YzticmVhayBhfWM9Yy5yZXR1cm59dGhyb3cgRXJyb3IocCgxNjApKTt9c3dpdGNoKGQudGFnKXtjYXNlIDU6dmFyIGU9ZC5zdGF0ZU5vZGU7ZC5mbGFncyYzMiYmKG9iKGUsXCJcIiksZC5mbGFncyY9LTMzKTt2YXIgZj1VaihhKTtXaihhLGYsZSk7YnJlYWs7Y2FzZSAzOmNhc2UgNDp2YXIgZz1kLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLGg9VWooYSk7VmooYSxoLGcpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IocCgxNjEpKTt9fWNhdGNoKGspe1coYSxhLnJldHVybixrKX1hLmZsYWdzJj0tM31iJjQwOTYmJihhLmZsYWdzJj0tNDA5Nyl9ZnVuY3Rpb24gaGsoYSxiLGMpe1Y9YTtpayhhLGIsYyl9XG5mdW5jdGlvbiBpayhhLGIsYyl7Zm9yKHZhciBkPTAhPT0oYS5tb2RlJjEpO251bGwhPT1WOyl7dmFyIGU9VixmPWUuY2hpbGQ7aWYoMjI9PT1lLnRhZyYmZCl7dmFyIGc9bnVsbCE9PWUubWVtb2l6ZWRTdGF0ZXx8Smo7aWYoIWcpe3ZhciBoPWUuYWx0ZXJuYXRlLGs9bnVsbCE9PWgmJm51bGwhPT1oLm1lbW9pemVkU3RhdGV8fFU7aD1Kajt2YXIgbD1VO0pqPWc7aWYoKFU9aykmJiFsKWZvcihWPWU7bnVsbCE9PVY7KWc9VixrPWcuY2hpbGQsMjI9PT1nLnRhZyYmbnVsbCE9PWcubWVtb2l6ZWRTdGF0ZT9qayhlKTpudWxsIT09az8oay5yZXR1cm49ZyxWPWspOmprKGUpO2Zvcig7bnVsbCE9PWY7KVY9ZixpayhmLGIsYyksZj1mLnNpYmxpbmc7Vj1lO0pqPWg7VT1sfWtrKGEsYixjKX1lbHNlIDAhPT0oZS5zdWJ0cmVlRmxhZ3MmODc3MikmJm51bGwhPT1mPyhmLnJldHVybj1lLFY9Zik6a2soYSxiLGMpfX1cbmZ1bmN0aW9uIGtrKGEpe2Zvcig7bnVsbCE9PVY7KXt2YXIgYj1WO2lmKDAhPT0oYi5mbGFncyY4NzcyKSl7dmFyIGM9Yi5hbHRlcm5hdGU7dHJ5e2lmKDAhPT0oYi5mbGFncyY4NzcyKSlzd2l0Y2goYi50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6VXx8UWooNSxiKTticmVhaztjYXNlIDE6dmFyIGQ9Yi5zdGF0ZU5vZGU7aWYoYi5mbGFncyY0JiYhVSlpZihudWxsPT09YylkLmNvbXBvbmVudERpZE1vdW50KCk7ZWxzZXt2YXIgZT1iLmVsZW1lbnRUeXBlPT09Yi50eXBlP2MubWVtb2l6ZWRQcm9wczpDaShiLnR5cGUsYy5tZW1vaXplZFByb3BzKTtkLmNvbXBvbmVudERpZFVwZGF0ZShlLGMubWVtb2l6ZWRTdGF0ZSxkLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKX12YXIgZj1iLnVwZGF0ZVF1ZXVlO251bGwhPT1mJiZzaChiLGYsZCk7YnJlYWs7Y2FzZSAzOnZhciBnPWIudXBkYXRlUXVldWU7aWYobnVsbCE9PWcpe2M9bnVsbDtpZihudWxsIT09Yi5jaGlsZClzd2l0Y2goYi5jaGlsZC50YWcpe2Nhc2UgNTpjPVxuYi5jaGlsZC5zdGF0ZU5vZGU7YnJlYWs7Y2FzZSAxOmM9Yi5jaGlsZC5zdGF0ZU5vZGV9c2goYixnLGMpfWJyZWFrO2Nhc2UgNTp2YXIgaD1iLnN0YXRlTm9kZTtpZihudWxsPT09YyYmYi5mbGFncyY0KXtjPWg7dmFyIGs9Yi5tZW1vaXplZFByb3BzO3N3aXRjaChiLnR5cGUpe2Nhc2UgXCJidXR0b25cIjpjYXNlIFwiaW5wdXRcIjpjYXNlIFwic2VsZWN0XCI6Y2FzZSBcInRleHRhcmVhXCI6ay5hdXRvRm9jdXMmJmMuZm9jdXMoKTticmVhaztjYXNlIFwiaW1nXCI6ay5zcmMmJihjLnNyYz1rLnNyYyl9fWJyZWFrO2Nhc2UgNjpicmVhaztjYXNlIDQ6YnJlYWs7Y2FzZSAxMjpicmVhaztjYXNlIDEzOmlmKG51bGw9PT1iLm1lbW9pemVkU3RhdGUpe3ZhciBsPWIuYWx0ZXJuYXRlO2lmKG51bGwhPT1sKXt2YXIgbT1sLm1lbW9pemVkU3RhdGU7aWYobnVsbCE9PW0pe3ZhciBxPW0uZGVoeWRyYXRlZDtudWxsIT09cSYmYmQocSl9fX1icmVhaztjYXNlIDE5OmNhc2UgMTc6Y2FzZSAyMTpjYXNlIDIyOmNhc2UgMjM6Y2FzZSAyNTpicmVhaztcbmRlZmF1bHQ6dGhyb3cgRXJyb3IocCgxNjMpKTt9VXx8Yi5mbGFncyY1MTImJlJqKGIpfWNhdGNoKHIpe1coYixiLnJldHVybixyKX19aWYoYj09PWEpe1Y9bnVsbDticmVha31jPWIuc2libGluZztpZihudWxsIT09Yyl7Yy5yZXR1cm49Yi5yZXR1cm47Vj1jO2JyZWFrfVY9Yi5yZXR1cm59fWZ1bmN0aW9uIGdrKGEpe2Zvcig7bnVsbCE9PVY7KXt2YXIgYj1WO2lmKGI9PT1hKXtWPW51bGw7YnJlYWt9dmFyIGM9Yi5zaWJsaW5nO2lmKG51bGwhPT1jKXtjLnJldHVybj1iLnJldHVybjtWPWM7YnJlYWt9Vj1iLnJldHVybn19XG5mdW5jdGlvbiBqayhhKXtmb3IoO251bGwhPT1WOyl7dmFyIGI9Vjt0cnl7c3dpdGNoKGIudGFnKXtjYXNlIDA6Y2FzZSAxMTpjYXNlIDE1OnZhciBjPWIucmV0dXJuO3RyeXtRaig0LGIpfWNhdGNoKGspe1coYixjLGspfWJyZWFrO2Nhc2UgMTp2YXIgZD1iLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnREaWRNb3VudCl7dmFyIGU9Yi5yZXR1cm47dHJ5e2QuY29tcG9uZW50RGlkTW91bnQoKX1jYXRjaChrKXtXKGIsZSxrKX19dmFyIGY9Yi5yZXR1cm47dHJ5e1JqKGIpfWNhdGNoKGspe1coYixmLGspfWJyZWFrO2Nhc2UgNTp2YXIgZz1iLnJldHVybjt0cnl7UmooYil9Y2F0Y2goayl7VyhiLGcsayl9fX1jYXRjaChrKXtXKGIsYi5yZXR1cm4sayl9aWYoYj09PWEpe1Y9bnVsbDticmVha312YXIgaD1iLnNpYmxpbmc7aWYobnVsbCE9PWgpe2gucmV0dXJuPWIucmV0dXJuO1Y9aDticmVha31WPWIucmV0dXJufX1cbnZhciBsaz1NYXRoLmNlaWwsbWs9dWEuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixuaz11YS5SZWFjdEN1cnJlbnRPd25lcixvaz11YS5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxLPTAsUT1udWxsLFk9bnVsbCxaPTAsZmo9MCxlaj1VZigwKSxUPTAscGs9bnVsbCxyaD0wLHFrPTAscms9MCxzaz1udWxsLHRrPW51bGwsZms9MCxHaj1JbmZpbml0eSx1az1udWxsLE9pPSExLFBpPW51bGwsUmk9bnVsbCx2az0hMSx3az1udWxsLHhrPTAseWs9MCx6az1udWxsLEFrPS0xLEJrPTA7ZnVuY3Rpb24gUigpe3JldHVybiAwIT09KEsmNik/QigpOi0xIT09QWs/QWs6QWs9QigpfVxuZnVuY3Rpb24geWkoYSl7aWYoMD09PShhLm1vZGUmMSkpcmV0dXJuIDE7aWYoMCE9PShLJjIpJiYwIT09WilyZXR1cm4gWiYtWjtpZihudWxsIT09S2cudHJhbnNpdGlvbilyZXR1cm4gMD09PUJrJiYoQms9eWMoKSksQms7YT1DO2lmKDAhPT1hKXJldHVybiBhO2E9d2luZG93LmV2ZW50O2E9dm9pZCAwPT09YT8xNjpqZChhLnR5cGUpO3JldHVybiBhfWZ1bmN0aW9uIGdpKGEsYixjLGQpe2lmKDUwPHlrKXRocm93IHlrPTAsems9bnVsbCxFcnJvcihwKDE4NSkpO0FjKGEsYyxkKTtpZigwPT09KEsmMil8fGEhPT1RKWE9PT1RJiYoMD09PShLJjIpJiYocWt8PWMpLDQ9PT1UJiZDayhhLFopKSxEayhhLGQpLDE9PT1jJiYwPT09SyYmMD09PShiLm1vZGUmMSkmJihHaj1CKCkrNTAwLGZnJiZqZygpKX1cbmZ1bmN0aW9uIERrKGEsYil7dmFyIGM9YS5jYWxsYmFja05vZGU7d2MoYSxiKTt2YXIgZD11YyhhLGE9PT1RP1o6MCk7aWYoMD09PWQpbnVsbCE9PWMmJmJjKGMpLGEuY2FsbGJhY2tOb2RlPW51bGwsYS5jYWxsYmFja1ByaW9yaXR5PTA7ZWxzZSBpZihiPWQmLWQsYS5jYWxsYmFja1ByaW9yaXR5IT09Yil7bnVsbCE9YyYmYmMoYyk7aWYoMT09PWIpMD09PWEudGFnP2lnKEVrLmJpbmQobnVsbCxhKSk6aGcoRWsuYmluZChudWxsLGEpKSxKZihmdW5jdGlvbigpezA9PT0oSyY2KSYmamcoKX0pLGM9bnVsbDtlbHNle3N3aXRjaChEYyhkKSl7Y2FzZSAxOmM9ZmM7YnJlYWs7Y2FzZSA0OmM9Z2M7YnJlYWs7Y2FzZSAxNjpjPWhjO2JyZWFrO2Nhc2UgNTM2ODcwOTEyOmM9amM7YnJlYWs7ZGVmYXVsdDpjPWhjfWM9RmsoYyxHay5iaW5kKG51bGwsYSkpfWEuY2FsbGJhY2tQcmlvcml0eT1iO2EuY2FsbGJhY2tOb2RlPWN9fVxuZnVuY3Rpb24gR2soYSxiKXtBaz0tMTtCaz0wO2lmKDAhPT0oSyY2KSl0aHJvdyBFcnJvcihwKDMyNykpO3ZhciBjPWEuY2FsbGJhY2tOb2RlO2lmKEhrKCkmJmEuY2FsbGJhY2tOb2RlIT09YylyZXR1cm4gbnVsbDt2YXIgZD11YyhhLGE9PT1RP1o6MCk7aWYoMD09PWQpcmV0dXJuIG51bGw7aWYoMCE9PShkJjMwKXx8MCE9PShkJmEuZXhwaXJlZExhbmVzKXx8YiliPUlrKGEsZCk7ZWxzZXtiPWQ7dmFyIGU9SztLfD0yO3ZhciBmPUprKCk7aWYoUSE9PWF8fFohPT1iKXVrPW51bGwsR2o9QigpKzUwMCxLayhhLGIpO2RvIHRyeXtMaygpO2JyZWFrfWNhdGNoKGgpe01rKGEsaCl9d2hpbGUoMSk7JGcoKTttay5jdXJyZW50PWY7Sz1lO251bGwhPT1ZP2I9MDooUT1udWxsLFo9MCxiPVQpfWlmKDAhPT1iKXsyPT09YiYmKGU9eGMoYSksMCE9PWUmJihkPWUsYj1OayhhLGUpKSk7aWYoMT09PWIpdGhyb3cgYz1wayxLayhhLDApLENrKGEsZCksRGsoYSxCKCkpLGM7aWYoNj09PWIpQ2soYSxkKTtcbmVsc2V7ZT1hLmN1cnJlbnQuYWx0ZXJuYXRlO2lmKDA9PT0oZCYzMCkmJiFPayhlKSYmKGI9SWsoYSxkKSwyPT09YiYmKGY9eGMoYSksMCE9PWYmJihkPWYsYj1OayhhLGYpKSksMT09PWIpKXRocm93IGM9cGssS2soYSwwKSxDayhhLGQpLERrKGEsQigpKSxjO2EuZmluaXNoZWRXb3JrPWU7YS5maW5pc2hlZExhbmVzPWQ7c3dpdGNoKGIpe2Nhc2UgMDpjYXNlIDE6dGhyb3cgRXJyb3IocCgzNDUpKTtjYXNlIDI6UGsoYSx0ayx1ayk7YnJlYWs7Y2FzZSAzOkNrKGEsZCk7aWYoKGQmMTMwMDIzNDI0KT09PWQmJihiPWZrKzUwMC1CKCksMTA8Yikpe2lmKDAhPT11YyhhLDApKWJyZWFrO2U9YS5zdXNwZW5kZWRMYW5lcztpZigoZSZkKSE9PWQpe1IoKTthLnBpbmdlZExhbmVzfD1hLnN1c3BlbmRlZExhbmVzJmU7YnJlYWt9YS50aW1lb3V0SGFuZGxlPUZmKFBrLmJpbmQobnVsbCxhLHRrLHVrKSxiKTticmVha31QayhhLHRrLHVrKTticmVhaztjYXNlIDQ6Q2soYSxkKTtpZigoZCY0MTk0MjQwKT09PVxuZClicmVhaztiPWEuZXZlbnRUaW1lcztmb3IoZT0tMTswPGQ7KXt2YXIgZz0zMS1vYyhkKTtmPTE8PGc7Zz1iW2ddO2c+ZSYmKGU9Zyk7ZCY9fmZ9ZD1lO2Q9QigpLWQ7ZD0oMTIwPmQ/MTIwOjQ4MD5kPzQ4MDoxMDgwPmQ/MTA4MDoxOTIwPmQ/MTkyMDozRTM+ZD8zRTM6NDMyMD5kPzQzMjA6MTk2MCpsayhkLzE5NjApKS1kO2lmKDEwPGQpe2EudGltZW91dEhhbmRsZT1GZihQay5iaW5kKG51bGwsYSx0ayx1ayksZCk7YnJlYWt9UGsoYSx0ayx1ayk7YnJlYWs7Y2FzZSA1OlBrKGEsdGssdWspO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IocCgzMjkpKTt9fX1EayhhLEIoKSk7cmV0dXJuIGEuY2FsbGJhY2tOb2RlPT09Yz9Hay5iaW5kKG51bGwsYSk6bnVsbH1cbmZ1bmN0aW9uIE5rKGEsYil7dmFyIGM9c2s7YS5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkJiYoS2soYSxiKS5mbGFnc3w9MjU2KTthPUlrKGEsYik7MiE9PWEmJihiPXRrLHRrPWMsbnVsbCE9PWImJkZqKGIpKTtyZXR1cm4gYX1mdW5jdGlvbiBGaihhKXtudWxsPT09dGs/dGs9YTp0ay5wdXNoLmFwcGx5KHRrLGEpfVxuZnVuY3Rpb24gT2soYSl7Zm9yKHZhciBiPWE7Oyl7aWYoYi5mbGFncyYxNjM4NCl7dmFyIGM9Yi51cGRhdGVRdWV1ZTtpZihudWxsIT09YyYmKGM9Yy5zdG9yZXMsbnVsbCE9PWMpKWZvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdLGY9ZS5nZXRTbmFwc2hvdDtlPWUudmFsdWU7dHJ5e2lmKCFIZShmKCksZSkpcmV0dXJuITF9Y2F0Y2goZyl7cmV0dXJuITF9fX1jPWIuY2hpbGQ7aWYoYi5zdWJ0cmVlRmxhZ3MmMTYzODQmJm51bGwhPT1jKWMucmV0dXJuPWIsYj1jO2Vsc2V7aWYoYj09PWEpYnJlYWs7Zm9yKDtudWxsPT09Yi5zaWJsaW5nOyl7aWYobnVsbD09PWIucmV0dXJufHxiLnJldHVybj09PWEpcmV0dXJuITA7Yj1iLnJldHVybn1iLnNpYmxpbmcucmV0dXJuPWIucmV0dXJuO2I9Yi5zaWJsaW5nfX1yZXR1cm4hMH1cbmZ1bmN0aW9uIENrKGEsYil7YiY9fnJrO2ImPX5xazthLnN1c3BlbmRlZExhbmVzfD1iO2EucGluZ2VkTGFuZXMmPX5iO2ZvcihhPWEuZXhwaXJhdGlvblRpbWVzOzA8Yjspe3ZhciBjPTMxLW9jKGIpLGQ9MTw8YzthW2NdPS0xO2ImPX5kfX1mdW5jdGlvbiBFayhhKXtpZigwIT09KEsmNikpdGhyb3cgRXJyb3IocCgzMjcpKTtIaygpO3ZhciBiPXVjKGEsMCk7aWYoMD09PShiJjEpKXJldHVybiBEayhhLEIoKSksbnVsbDt2YXIgYz1JayhhLGIpO2lmKDAhPT1hLnRhZyYmMj09PWMpe3ZhciBkPXhjKGEpOzAhPT1kJiYoYj1kLGM9TmsoYSxkKSl9aWYoMT09PWMpdGhyb3cgYz1wayxLayhhLDApLENrKGEsYiksRGsoYSxCKCkpLGM7aWYoNj09PWMpdGhyb3cgRXJyb3IocCgzNDUpKTthLmZpbmlzaGVkV29yaz1hLmN1cnJlbnQuYWx0ZXJuYXRlO2EuZmluaXNoZWRMYW5lcz1iO1BrKGEsdGssdWspO0RrKGEsQigpKTtyZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIFFrKGEsYil7dmFyIGM9SztLfD0xO3RyeXtyZXR1cm4gYShiKX1maW5hbGx5e0s9YywwPT09SyYmKEdqPUIoKSs1MDAsZmcmJmpnKCkpfX1mdW5jdGlvbiBSayhhKXtudWxsIT09d2smJjA9PT13ay50YWcmJjA9PT0oSyY2KSYmSGsoKTt2YXIgYj1LO0t8PTE7dmFyIGM9b2sudHJhbnNpdGlvbixkPUM7dHJ5e2lmKG9rLnRyYW5zaXRpb249bnVsbCxDPTEsYSlyZXR1cm4gYSgpfWZpbmFsbHl7Qz1kLG9rLnRyYW5zaXRpb249YyxLPWIsMD09PShLJjYpJiZqZygpfX1mdW5jdGlvbiBIaigpe2ZqPWVqLmN1cnJlbnQ7RShlail9XG5mdW5jdGlvbiBLayhhLGIpe2EuZmluaXNoZWRXb3JrPW51bGw7YS5maW5pc2hlZExhbmVzPTA7dmFyIGM9YS50aW1lb3V0SGFuZGxlOy0xIT09YyYmKGEudGltZW91dEhhbmRsZT0tMSxHZihjKSk7aWYobnVsbCE9PVkpZm9yKGM9WS5yZXR1cm47bnVsbCE9PWM7KXt2YXIgZD1jO3dnKGQpO3N3aXRjaChkLnRhZyl7Y2FzZSAxOmQ9ZC50eXBlLmNoaWxkQ29udGV4dFR5cGVzO251bGwhPT1kJiZ2b2lkIDAhPT1kJiYkZigpO2JyZWFrO2Nhc2UgMzp6aCgpO0UoV2YpO0UoSCk7RWgoKTticmVhaztjYXNlIDU6QmgoZCk7YnJlYWs7Y2FzZSA0OnpoKCk7YnJlYWs7Y2FzZSAxMzpFKEwpO2JyZWFrO2Nhc2UgMTk6RShMKTticmVhaztjYXNlIDEwOmFoKGQudHlwZS5fY29udGV4dCk7YnJlYWs7Y2FzZSAyMjpjYXNlIDIzOkhqKCl9Yz1jLnJldHVybn1RPWE7WT1hPVBnKGEuY3VycmVudCxudWxsKTtaPWZqPWI7VD0wO3BrPW51bGw7cms9cWs9cmg9MDt0az1zaz1udWxsO2lmKG51bGwhPT1maCl7Zm9yKGI9XG4wO2I8ZmgubGVuZ3RoO2IrKylpZihjPWZoW2JdLGQ9Yy5pbnRlcmxlYXZlZCxudWxsIT09ZCl7Yy5pbnRlcmxlYXZlZD1udWxsO3ZhciBlPWQubmV4dCxmPWMucGVuZGluZztpZihudWxsIT09Zil7dmFyIGc9Zi5uZXh0O2YubmV4dD1lO2QubmV4dD1nfWMucGVuZGluZz1kfWZoPW51bGx9cmV0dXJuIGF9XG5mdW5jdGlvbiBNayhhLGIpe2Rve3ZhciBjPVk7dHJ5eyRnKCk7RmguY3VycmVudD1SaDtpZihJaCl7Zm9yKHZhciBkPU0ubWVtb2l6ZWRTdGF0ZTtudWxsIT09ZDspe3ZhciBlPWQucXVldWU7bnVsbCE9PWUmJihlLnBlbmRpbmc9bnVsbCk7ZD1kLm5leHR9SWg9ITF9SGg9MDtPPU49TT1udWxsO0poPSExO0toPTA7bmsuY3VycmVudD1udWxsO2lmKG51bGw9PT1jfHxudWxsPT09Yy5yZXR1cm4pe1Q9MTtwaz1iO1k9bnVsbDticmVha31hOnt2YXIgZj1hLGc9Yy5yZXR1cm4saD1jLGs9YjtiPVo7aC5mbGFnc3w9MzI3Njg7aWYobnVsbCE9PWsmJlwib2JqZWN0XCI9PT10eXBlb2YgayYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGsudGhlbil7dmFyIGw9ayxtPWgscT1tLnRhZztpZigwPT09KG0ubW9kZSYxKSYmKDA9PT1xfHwxMT09PXF8fDE1PT09cSkpe3ZhciByPW0uYWx0ZXJuYXRlO3I/KG0udXBkYXRlUXVldWU9ci51cGRhdGVRdWV1ZSxtLm1lbW9pemVkU3RhdGU9ci5tZW1vaXplZFN0YXRlLFxubS5sYW5lcz1yLmxhbmVzKToobS51cGRhdGVRdWV1ZT1udWxsLG0ubWVtb2l6ZWRTdGF0ZT1udWxsKX12YXIgeT1VaShnKTtpZihudWxsIT09eSl7eS5mbGFncyY9LTI1NztWaSh5LGcsaCxmLGIpO3kubW9kZSYxJiZTaShmLGwsYik7Yj15O2s9bDt2YXIgbj1iLnVwZGF0ZVF1ZXVlO2lmKG51bGw9PT1uKXt2YXIgdD1uZXcgU2V0O3QuYWRkKGspO2IudXBkYXRlUXVldWU9dH1lbHNlIG4uYWRkKGspO2JyZWFrIGF9ZWxzZXtpZigwPT09KGImMSkpe1NpKGYsbCxiKTt0aigpO2JyZWFrIGF9az1FcnJvcihwKDQyNikpfX1lbHNlIGlmKEkmJmgubW9kZSYxKXt2YXIgSj1VaShnKTtpZihudWxsIT09Sil7MD09PShKLmZsYWdzJjY1NTM2KSYmKEouZmxhZ3N8PTI1Nik7VmkoSixnLGgsZixiKTtKZyhKaShrLGgpKTticmVhayBhfX1mPWs9SmkoayxoKTs0IT09VCYmKFQ9Mik7bnVsbD09PXNrP3NrPVtmXTpzay5wdXNoKGYpO2Y9Zztkb3tzd2l0Y2goZi50YWcpe2Nhc2UgMzpmLmZsYWdzfD02NTUzNjtcbmImPS1iO2YubGFuZXN8PWI7dmFyIHg9TmkoZixrLGIpO3BoKGYseCk7YnJlYWsgYTtjYXNlIDE6aD1rO3ZhciB3PWYudHlwZSx1PWYuc3RhdGVOb2RlO2lmKDA9PT0oZi5mbGFncyYxMjgpJiYoXCJmdW5jdGlvblwiPT09dHlwZW9mIHcuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yfHxudWxsIT09dSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIHUuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09Uml8fCFSaS5oYXModSkpKSl7Zi5mbGFnc3w9NjU1MzY7YiY9LWI7Zi5sYW5lc3w9Yjt2YXIgRj1RaShmLGgsYik7cGgoZixGKTticmVhayBhfX1mPWYucmV0dXJufXdoaWxlKG51bGwhPT1mKX1TayhjKX1jYXRjaChuYSl7Yj1uYTtZPT09YyYmbnVsbCE9PWMmJihZPWM9Yy5yZXR1cm4pO2NvbnRpbnVlfWJyZWFrfXdoaWxlKDEpfWZ1bmN0aW9uIEprKCl7dmFyIGE9bWsuY3VycmVudDttay5jdXJyZW50PVJoO3JldHVybiBudWxsPT09YT9SaDphfVxuZnVuY3Rpb24gdGooKXtpZigwPT09VHx8Mz09PVR8fDI9PT1UKVQ9NDtudWxsPT09UXx8MD09PShyaCYyNjg0MzU0NTUpJiYwPT09KHFrJjI2ODQzNTQ1NSl8fENrKFEsWil9ZnVuY3Rpb24gSWsoYSxiKXt2YXIgYz1LO0t8PTI7dmFyIGQ9SmsoKTtpZihRIT09YXx8WiE9PWIpdWs9bnVsbCxLayhhLGIpO2RvIHRyeXtUaygpO2JyZWFrfWNhdGNoKGUpe01rKGEsZSl9d2hpbGUoMSk7JGcoKTtLPWM7bWsuY3VycmVudD1kO2lmKG51bGwhPT1ZKXRocm93IEVycm9yKHAoMjYxKSk7UT1udWxsO1o9MDtyZXR1cm4gVH1mdW5jdGlvbiBUaygpe2Zvcig7bnVsbCE9PVk7KVVrKFkpfWZ1bmN0aW9uIExrKCl7Zm9yKDtudWxsIT09WSYmIWNjKCk7KVVrKFkpfWZ1bmN0aW9uIFVrKGEpe3ZhciBiPVZrKGEuYWx0ZXJuYXRlLGEsZmopO2EubWVtb2l6ZWRQcm9wcz1hLnBlbmRpbmdQcm9wcztudWxsPT09Yj9TayhhKTpZPWI7bmsuY3VycmVudD1udWxsfVxuZnVuY3Rpb24gU2soYSl7dmFyIGI9YTtkb3t2YXIgYz1iLmFsdGVybmF0ZTthPWIucmV0dXJuO2lmKDA9PT0oYi5mbGFncyYzMjc2OCkpe2lmKGM9RWooYyxiLGZqKSxudWxsIT09Yyl7WT1jO3JldHVybn19ZWxzZXtjPUlqKGMsYik7aWYobnVsbCE9PWMpe2MuZmxhZ3MmPTMyNzY3O1k9YztyZXR1cm59aWYobnVsbCE9PWEpYS5mbGFnc3w9MzI3NjgsYS5zdWJ0cmVlRmxhZ3M9MCxhLmRlbGV0aW9ucz1udWxsO2Vsc2V7VD02O1k9bnVsbDtyZXR1cm59fWI9Yi5zaWJsaW5nO2lmKG51bGwhPT1iKXtZPWI7cmV0dXJufVk9Yj1hfXdoaWxlKG51bGwhPT1iKTswPT09VCYmKFQ9NSl9ZnVuY3Rpb24gUGsoYSxiLGMpe3ZhciBkPUMsZT1vay50cmFuc2l0aW9uO3RyeXtvay50cmFuc2l0aW9uPW51bGwsQz0xLFdrKGEsYixjLGQpfWZpbmFsbHl7b2sudHJhbnNpdGlvbj1lLEM9ZH1yZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIFdrKGEsYixjLGQpe2RvIEhrKCk7d2hpbGUobnVsbCE9PXdrKTtpZigwIT09KEsmNikpdGhyb3cgRXJyb3IocCgzMjcpKTtjPWEuZmluaXNoZWRXb3JrO3ZhciBlPWEuZmluaXNoZWRMYW5lcztpZihudWxsPT09YylyZXR1cm4gbnVsbDthLmZpbmlzaGVkV29yaz1udWxsO2EuZmluaXNoZWRMYW5lcz0wO2lmKGM9PT1hLmN1cnJlbnQpdGhyb3cgRXJyb3IocCgxNzcpKTthLmNhbGxiYWNrTm9kZT1udWxsO2EuY2FsbGJhY2tQcmlvcml0eT0wO3ZhciBmPWMubGFuZXN8Yy5jaGlsZExhbmVzO0JjKGEsZik7YT09PVEmJihZPVE9bnVsbCxaPTApOzA9PT0oYy5zdWJ0cmVlRmxhZ3MmMjA2NCkmJjA9PT0oYy5mbGFncyYyMDY0KXx8dmt8fCh2az0hMCxGayhoYyxmdW5jdGlvbigpe0hrKCk7cmV0dXJuIG51bGx9KSk7Zj0wIT09KGMuZmxhZ3MmMTU5OTApO2lmKDAhPT0oYy5zdWJ0cmVlRmxhZ3MmMTU5OTApfHxmKXtmPW9rLnRyYW5zaXRpb247b2sudHJhbnNpdGlvbj1udWxsO1xudmFyIGc9QztDPTE7dmFyIGg9SztLfD00O25rLmN1cnJlbnQ9bnVsbDtPaihhLGMpO2RrKGMsYSk7T2UoRGYpO2RkPSEhQ2Y7RGY9Q2Y9bnVsbDthLmN1cnJlbnQ9YztoayhjLGEsZSk7ZGMoKTtLPWg7Qz1nO29rLnRyYW5zaXRpb249Zn1lbHNlIGEuY3VycmVudD1jO3ZrJiYodms9ITEsd2s9YSx4az1lKTtmPWEucGVuZGluZ0xhbmVzOzA9PT1mJiYoUmk9bnVsbCk7bWMoYy5zdGF0ZU5vZGUsZCk7RGsoYSxCKCkpO2lmKG51bGwhPT1iKWZvcihkPWEub25SZWNvdmVyYWJsZUVycm9yLGM9MDtjPGIubGVuZ3RoO2MrKyllPWJbY10sZChlLnZhbHVlLHtjb21wb25lbnRTdGFjazplLnN0YWNrLGRpZ2VzdDplLmRpZ2VzdH0pO2lmKE9pKXRocm93IE9pPSExLGE9UGksUGk9bnVsbCxhOzAhPT0oeGsmMSkmJjAhPT1hLnRhZyYmSGsoKTtmPWEucGVuZGluZ0xhbmVzOzAhPT0oZiYxKT9hPT09ems/eWsrKzooeWs9MCx6az1hKTp5az0wO2pnKCk7cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBIaygpe2lmKG51bGwhPT13ayl7dmFyIGE9RGMoeGspLGI9b2sudHJhbnNpdGlvbixjPUM7dHJ5e29rLnRyYW5zaXRpb249bnVsbDtDPTE2PmE/MTY6YTtpZihudWxsPT09d2spdmFyIGQ9ITE7ZWxzZXthPXdrO3drPW51bGw7eGs9MDtpZigwIT09KEsmNikpdGhyb3cgRXJyb3IocCgzMzEpKTt2YXIgZT1LO0t8PTQ7Zm9yKFY9YS5jdXJyZW50O251bGwhPT1WOyl7dmFyIGY9VixnPWYuY2hpbGQ7aWYoMCE9PShWLmZsYWdzJjE2KSl7dmFyIGg9Zi5kZWxldGlvbnM7aWYobnVsbCE9PWgpe2Zvcih2YXIgaz0wO2s8aC5sZW5ndGg7aysrKXt2YXIgbD1oW2tdO2ZvcihWPWw7bnVsbCE9PVY7KXt2YXIgbT1WO3N3aXRjaChtLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpQaig4LG0sZil9dmFyIHE9bS5jaGlsZDtpZihudWxsIT09cSlxLnJldHVybj1tLFY9cTtlbHNlIGZvcig7bnVsbCE9PVY7KXttPVY7dmFyIHI9bS5zaWJsaW5nLHk9bS5yZXR1cm47U2oobSk7aWYobT09PVxubCl7Vj1udWxsO2JyZWFrfWlmKG51bGwhPT1yKXtyLnJldHVybj15O1Y9cjticmVha31WPXl9fX12YXIgbj1mLmFsdGVybmF0ZTtpZihudWxsIT09bil7dmFyIHQ9bi5jaGlsZDtpZihudWxsIT09dCl7bi5jaGlsZD1udWxsO2Rve3ZhciBKPXQuc2libGluZzt0LnNpYmxpbmc9bnVsbDt0PUp9d2hpbGUobnVsbCE9PXQpfX1WPWZ9fWlmKDAhPT0oZi5zdWJ0cmVlRmxhZ3MmMjA2NCkmJm51bGwhPT1nKWcucmV0dXJuPWYsVj1nO2Vsc2UgYjpmb3IoO251bGwhPT1WOyl7Zj1WO2lmKDAhPT0oZi5mbGFncyYyMDQ4KSlzd2l0Y2goZi50YWcpe2Nhc2UgMDpjYXNlIDExOmNhc2UgMTU6UGooOSxmLGYucmV0dXJuKX12YXIgeD1mLnNpYmxpbmc7aWYobnVsbCE9PXgpe3gucmV0dXJuPWYucmV0dXJuO1Y9eDticmVhayBifVY9Zi5yZXR1cm59fXZhciB3PWEuY3VycmVudDtmb3IoVj13O251bGwhPT1WOyl7Zz1WO3ZhciB1PWcuY2hpbGQ7aWYoMCE9PShnLnN1YnRyZWVGbGFncyYyMDY0KSYmbnVsbCE9PVxudSl1LnJldHVybj1nLFY9dTtlbHNlIGI6Zm9yKGc9dztudWxsIT09Vjspe2g9VjtpZigwIT09KGguZmxhZ3MmMjA0OCkpdHJ5e3N3aXRjaChoLnRhZyl7Y2FzZSAwOmNhc2UgMTE6Y2FzZSAxNTpRaig5LGgpfX1jYXRjaChuYSl7VyhoLGgucmV0dXJuLG5hKX1pZihoPT09Zyl7Vj1udWxsO2JyZWFrIGJ9dmFyIEY9aC5zaWJsaW5nO2lmKG51bGwhPT1GKXtGLnJldHVybj1oLnJldHVybjtWPUY7YnJlYWsgYn1WPWgucmV0dXJufX1LPWU7amcoKTtpZihsYyYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGxjLm9uUG9zdENvbW1pdEZpYmVyUm9vdCl0cnl7bGMub25Qb3N0Q29tbWl0RmliZXJSb290KGtjLGEpfWNhdGNoKG5hKXt9ZD0hMH1yZXR1cm4gZH1maW5hbGx5e0M9Yyxvay50cmFuc2l0aW9uPWJ9fXJldHVybiExfWZ1bmN0aW9uIFhrKGEsYixjKXtiPUppKGMsYik7Yj1OaShhLGIsMSk7YT1uaChhLGIsMSk7Yj1SKCk7bnVsbCE9PWEmJihBYyhhLDEsYiksRGsoYSxiKSl9XG5mdW5jdGlvbiBXKGEsYixjKXtpZigzPT09YS50YWcpWGsoYSxhLGMpO2Vsc2UgZm9yKDtudWxsIT09Yjspe2lmKDM9PT1iLnRhZyl7WGsoYixhLGMpO2JyZWFrfWVsc2UgaWYoMT09PWIudGFnKXt2YXIgZD1iLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcnx8XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50RGlkQ2F0Y2gmJihudWxsPT09Uml8fCFSaS5oYXMoZCkpKXthPUppKGMsYSk7YT1RaShiLGEsMSk7Yj1uaChiLGEsMSk7YT1SKCk7bnVsbCE9PWImJihBYyhiLDEsYSksRGsoYixhKSk7YnJlYWt9fWI9Yi5yZXR1cm59fVxuZnVuY3Rpb24gVGkoYSxiLGMpe3ZhciBkPWEucGluZ0NhY2hlO251bGwhPT1kJiZkLmRlbGV0ZShiKTtiPVIoKTthLnBpbmdlZExhbmVzfD1hLnN1c3BlbmRlZExhbmVzJmM7UT09PWEmJihaJmMpPT09YyYmKDQ9PT1UfHwzPT09VCYmKFomMTMwMDIzNDI0KT09PVomJjUwMD5CKCktZms/S2soYSwwKTpya3w9Yyk7RGsoYSxiKX1mdW5jdGlvbiBZayhhLGIpezA9PT1iJiYoMD09PShhLm1vZGUmMSk/Yj0xOihiPXNjLHNjPDw9MSwwPT09KHNjJjEzMDAyMzQyNCkmJihzYz00MTk0MzA0KSkpO3ZhciBjPVIoKTthPWloKGEsYik7bnVsbCE9PWEmJihBYyhhLGIsYyksRGsoYSxjKSl9ZnVuY3Rpb24gdWooYSl7dmFyIGI9YS5tZW1vaXplZFN0YXRlLGM9MDtudWxsIT09YiYmKGM9Yi5yZXRyeUxhbmUpO1lrKGEsYyl9XG5mdW5jdGlvbiBiayhhLGIpe3ZhciBjPTA7c3dpdGNoKGEudGFnKXtjYXNlIDEzOnZhciBkPWEuc3RhdGVOb2RlO3ZhciBlPWEubWVtb2l6ZWRTdGF0ZTtudWxsIT09ZSYmKGM9ZS5yZXRyeUxhbmUpO2JyZWFrO2Nhc2UgMTk6ZD1hLnN0YXRlTm9kZTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKHAoMzE0KSk7fW51bGwhPT1kJiZkLmRlbGV0ZShiKTtZayhhLGMpfXZhciBWaztcblZrPWZ1bmN0aW9uKGEsYixjKXtpZihudWxsIT09YSlpZihhLm1lbW9pemVkUHJvcHMhPT1iLnBlbmRpbmdQcm9wc3x8V2YuY3VycmVudClkaD0hMDtlbHNle2lmKDA9PT0oYS5sYW5lcyZjKSYmMD09PShiLmZsYWdzJjEyOCkpcmV0dXJuIGRoPSExLHlqKGEsYixjKTtkaD0wIT09KGEuZmxhZ3MmMTMxMDcyKT8hMDohMX1lbHNlIGRoPSExLEkmJjAhPT0oYi5mbGFncyYxMDQ4NTc2KSYmdWcoYixuZyxiLmluZGV4KTtiLmxhbmVzPTA7c3dpdGNoKGIudGFnKXtjYXNlIDI6dmFyIGQ9Yi50eXBlO2lqKGEsYik7YT1iLnBlbmRpbmdQcm9wczt2YXIgZT1ZZihiLEguY3VycmVudCk7Y2goYixjKTtlPU5oKG51bGwsYixkLGEsZSxjKTt2YXIgZj1TaCgpO2IuZmxhZ3N8PTE7XCJvYmplY3RcIj09PXR5cGVvZiBlJiZudWxsIT09ZSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGUucmVuZGVyJiZ2b2lkIDA9PT1lLiQkdHlwZW9mPyhiLnRhZz0xLGIubWVtb2l6ZWRTdGF0ZT1udWxsLGIudXBkYXRlUXVldWU9XG5udWxsLFpmKGQpPyhmPSEwLGNnKGIpKTpmPSExLGIubWVtb2l6ZWRTdGF0ZT1udWxsIT09ZS5zdGF0ZSYmdm9pZCAwIT09ZS5zdGF0ZT9lLnN0YXRlOm51bGwsa2goYiksZS51cGRhdGVyPUVpLGIuc3RhdGVOb2RlPWUsZS5fcmVhY3RJbnRlcm5hbHM9YixJaShiLGQsYSxjKSxiPWpqKG51bGwsYixkLCEwLGYsYykpOihiLnRhZz0wLEkmJmYmJnZnKGIpLFhpKG51bGwsYixlLGMpLGI9Yi5jaGlsZCk7cmV0dXJuIGI7Y2FzZSAxNjpkPWIuZWxlbWVudFR5cGU7YTp7aWooYSxiKTthPWIucGVuZGluZ1Byb3BzO2U9ZC5faW5pdDtkPWUoZC5fcGF5bG9hZCk7Yi50eXBlPWQ7ZT1iLnRhZz1aayhkKTthPUNpKGQsYSk7c3dpdGNoKGUpe2Nhc2UgMDpiPWNqKG51bGwsYixkLGEsYyk7YnJlYWsgYTtjYXNlIDE6Yj1oaihudWxsLGIsZCxhLGMpO2JyZWFrIGE7Y2FzZSAxMTpiPVlpKG51bGwsYixkLGEsYyk7YnJlYWsgYTtjYXNlIDE0OmI9JGkobnVsbCxiLGQsQ2koZC50eXBlLGEpLGMpO2JyZWFrIGF9dGhyb3cgRXJyb3IocCgzMDYsXG5kLFwiXCIpKTt9cmV0dXJuIGI7Y2FzZSAwOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpDaShkLGUpLGNqKGEsYixkLGUsYyk7Y2FzZSAxOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpDaShkLGUpLGhqKGEsYixkLGUsYyk7Y2FzZSAzOmE6e2tqKGIpO2lmKG51bGw9PT1hKXRocm93IEVycm9yKHAoMzg3KSk7ZD1iLnBlbmRpbmdQcm9wcztmPWIubWVtb2l6ZWRTdGF0ZTtlPWYuZWxlbWVudDtsaChhLGIpO3FoKGIsZCxudWxsLGMpO3ZhciBnPWIubWVtb2l6ZWRTdGF0ZTtkPWcuZWxlbWVudDtpZihmLmlzRGVoeWRyYXRlZClpZihmPXtlbGVtZW50OmQsaXNEZWh5ZHJhdGVkOiExLGNhY2hlOmcuY2FjaGUscGVuZGluZ1N1c3BlbnNlQm91bmRhcmllczpnLnBlbmRpbmdTdXNwZW5zZUJvdW5kYXJpZXMsdHJhbnNpdGlvbnM6Zy50cmFuc2l0aW9uc30sYi51cGRhdGVRdWV1ZS5iYXNlU3RhdGU9XG5mLGIubWVtb2l6ZWRTdGF0ZT1mLGIuZmxhZ3MmMjU2KXtlPUppKEVycm9yKHAoNDIzKSksYik7Yj1saihhLGIsZCxjLGUpO2JyZWFrIGF9ZWxzZSBpZihkIT09ZSl7ZT1KaShFcnJvcihwKDQyNCkpLGIpO2I9bGooYSxiLGQsYyxlKTticmVhayBhfWVsc2UgZm9yKHlnPUxmKGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8uZmlyc3RDaGlsZCkseGc9YixJPSEwLHpnPW51bGwsYz1WZyhiLG51bGwsZCxjKSxiLmNoaWxkPWM7YzspYy5mbGFncz1jLmZsYWdzJi0zfDQwOTYsYz1jLnNpYmxpbmc7ZWxzZXtJZygpO2lmKGQ9PT1lKXtiPVppKGEsYixjKTticmVhayBhfVhpKGEsYixkLGMpfWI9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDU6cmV0dXJuIEFoKGIpLG51bGw9PT1hJiZFZyhiKSxkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGY9bnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOm51bGwsZz1lLmNoaWxkcmVuLEVmKGQsZSk/Zz1udWxsOm51bGwhPT1mJiZFZihkLGYpJiYoYi5mbGFnc3w9MzIpLFxuZ2ooYSxiKSxYaShhLGIsZyxjKSxiLmNoaWxkO2Nhc2UgNjpyZXR1cm4gbnVsbD09PWEmJkVnKGIpLG51bGw7Y2FzZSAxMzpyZXR1cm4gb2ooYSxiLGMpO2Nhc2UgNDpyZXR1cm4geWgoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxkPWIucGVuZGluZ1Byb3BzLG51bGw9PT1hP2IuY2hpbGQ9VWcoYixudWxsLGQsYyk6WGkoYSxiLGQsYyksYi5jaGlsZDtjYXNlIDExOnJldHVybiBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGU9Yi5lbGVtZW50VHlwZT09PWQ/ZTpDaShkLGUpLFlpKGEsYixkLGUsYyk7Y2FzZSA3OnJldHVybiBYaShhLGIsYi5wZW5kaW5nUHJvcHMsYyksYi5jaGlsZDtjYXNlIDg6cmV0dXJuIFhpKGEsYixiLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixjKSxiLmNoaWxkO2Nhc2UgMTI6cmV0dXJuIFhpKGEsYixiLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixjKSxiLmNoaWxkO2Nhc2UgMTA6YTp7ZD1iLnR5cGUuX2NvbnRleHQ7ZT1iLnBlbmRpbmdQcm9wcztmPWIubWVtb2l6ZWRQcm9wcztcbmc9ZS52YWx1ZTtHKFdnLGQuX2N1cnJlbnRWYWx1ZSk7ZC5fY3VycmVudFZhbHVlPWc7aWYobnVsbCE9PWYpaWYoSGUoZi52YWx1ZSxnKSl7aWYoZi5jaGlsZHJlbj09PWUuY2hpbGRyZW4mJiFXZi5jdXJyZW50KXtiPVppKGEsYixjKTticmVhayBhfX1lbHNlIGZvcihmPWIuY2hpbGQsbnVsbCE9PWYmJihmLnJldHVybj1iKTtudWxsIT09Zjspe3ZhciBoPWYuZGVwZW5kZW5jaWVzO2lmKG51bGwhPT1oKXtnPWYuY2hpbGQ7Zm9yKHZhciBrPWguZmlyc3RDb250ZXh0O251bGwhPT1rOyl7aWYoay5jb250ZXh0PT09ZCl7aWYoMT09PWYudGFnKXtrPW1oKC0xLGMmLWMpO2sudGFnPTI7dmFyIGw9Zi51cGRhdGVRdWV1ZTtpZihudWxsIT09bCl7bD1sLnNoYXJlZDt2YXIgbT1sLnBlbmRpbmc7bnVsbD09PW0/ay5uZXh0PWs6KGsubmV4dD1tLm5leHQsbS5uZXh0PWspO2wucGVuZGluZz1rfX1mLmxhbmVzfD1jO2s9Zi5hbHRlcm5hdGU7bnVsbCE9PWsmJihrLmxhbmVzfD1jKTtiaChmLnJldHVybixcbmMsYik7aC5sYW5lc3w9YzticmVha31rPWsubmV4dH19ZWxzZSBpZigxMD09PWYudGFnKWc9Zi50eXBlPT09Yi50eXBlP251bGw6Zi5jaGlsZDtlbHNlIGlmKDE4PT09Zi50YWcpe2c9Zi5yZXR1cm47aWYobnVsbD09PWcpdGhyb3cgRXJyb3IocCgzNDEpKTtnLmxhbmVzfD1jO2g9Zy5hbHRlcm5hdGU7bnVsbCE9PWgmJihoLmxhbmVzfD1jKTtiaChnLGMsYik7Zz1mLnNpYmxpbmd9ZWxzZSBnPWYuY2hpbGQ7aWYobnVsbCE9PWcpZy5yZXR1cm49ZjtlbHNlIGZvcihnPWY7bnVsbCE9PWc7KXtpZihnPT09Yil7Zz1udWxsO2JyZWFrfWY9Zy5zaWJsaW5nO2lmKG51bGwhPT1mKXtmLnJldHVybj1nLnJldHVybjtnPWY7YnJlYWt9Zz1nLnJldHVybn1mPWd9WGkoYSxiLGUuY2hpbGRyZW4sYyk7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgOTpyZXR1cm4gZT1iLnR5cGUsZD1iLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixjaChiLGMpLGU9ZWgoZSksZD1kKGUpLGIuZmxhZ3N8PTEsWGkoYSxiLGQsYyksXG5iLmNoaWxkO2Nhc2UgMTQ6cmV0dXJuIGQ9Yi50eXBlLGU9Q2koZCxiLnBlbmRpbmdQcm9wcyksZT1DaShkLnR5cGUsZSksJGkoYSxiLGQsZSxjKTtjYXNlIDE1OnJldHVybiBiaihhLGIsYi50eXBlLGIucGVuZGluZ1Byb3BzLGMpO2Nhc2UgMTc6cmV0dXJuIGQ9Yi50eXBlLGU9Yi5wZW5kaW5nUHJvcHMsZT1iLmVsZW1lbnRUeXBlPT09ZD9lOkNpKGQsZSksaWooYSxiKSxiLnRhZz0xLFpmKGQpPyhhPSEwLGNnKGIpKTphPSExLGNoKGIsYyksR2koYixkLGUpLElpKGIsZCxlLGMpLGpqKG51bGwsYixkLCEwLGEsYyk7Y2FzZSAxOTpyZXR1cm4geGooYSxiLGMpO2Nhc2UgMjI6cmV0dXJuIGRqKGEsYixjKX10aHJvdyBFcnJvcihwKDE1NixiLnRhZykpO307ZnVuY3Rpb24gRmsoYSxiKXtyZXR1cm4gYWMoYSxiKX1cbmZ1bmN0aW9uICRrKGEsYixjLGQpe3RoaXMudGFnPWE7dGhpcy5rZXk9Yzt0aGlzLnNpYmxpbmc9dGhpcy5jaGlsZD10aGlzLnJldHVybj10aGlzLnN0YXRlTm9kZT10aGlzLnR5cGU9dGhpcy5lbGVtZW50VHlwZT1udWxsO3RoaXMuaW5kZXg9MDt0aGlzLnJlZj1udWxsO3RoaXMucGVuZGluZ1Byb3BzPWI7dGhpcy5kZXBlbmRlbmNpZXM9dGhpcy5tZW1vaXplZFN0YXRlPXRoaXMudXBkYXRlUXVldWU9dGhpcy5tZW1vaXplZFByb3BzPW51bGw7dGhpcy5tb2RlPWQ7dGhpcy5zdWJ0cmVlRmxhZ3M9dGhpcy5mbGFncz0wO3RoaXMuZGVsZXRpb25zPW51bGw7dGhpcy5jaGlsZExhbmVzPXRoaXMubGFuZXM9MDt0aGlzLmFsdGVybmF0ZT1udWxsfWZ1bmN0aW9uIEJnKGEsYixjLGQpe3JldHVybiBuZXcgJGsoYSxiLGMsZCl9ZnVuY3Rpb24gYWooYSl7YT1hLnByb3RvdHlwZTtyZXR1cm4hKCFhfHwhYS5pc1JlYWN0Q29tcG9uZW50KX1cbmZ1bmN0aW9uIFprKGEpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBhKXJldHVybiBhaihhKT8xOjA7aWYodm9pZCAwIT09YSYmbnVsbCE9PWEpe2E9YS4kJHR5cGVvZjtpZihhPT09RGEpcmV0dXJuIDExO2lmKGE9PT1HYSlyZXR1cm4gMTR9cmV0dXJuIDJ9XG5mdW5jdGlvbiBQZyhhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlO251bGw9PT1jPyhjPUJnKGEudGFnLGIsYS5rZXksYS5tb2RlKSxjLmVsZW1lbnRUeXBlPWEuZWxlbWVudFR5cGUsYy50eXBlPWEudHlwZSxjLnN0YXRlTm9kZT1hLnN0YXRlTm9kZSxjLmFsdGVybmF0ZT1hLGEuYWx0ZXJuYXRlPWMpOihjLnBlbmRpbmdQcm9wcz1iLGMudHlwZT1hLnR5cGUsYy5mbGFncz0wLGMuc3VidHJlZUZsYWdzPTAsYy5kZWxldGlvbnM9bnVsbCk7Yy5mbGFncz1hLmZsYWdzJjE0NjgwMDY0O2MuY2hpbGRMYW5lcz1hLmNoaWxkTGFuZXM7Yy5sYW5lcz1hLmxhbmVzO2MuY2hpbGQ9YS5jaGlsZDtjLm1lbW9pemVkUHJvcHM9YS5tZW1vaXplZFByb3BzO2MubWVtb2l6ZWRTdGF0ZT1hLm1lbW9pemVkU3RhdGU7Yy51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlO2I9YS5kZXBlbmRlbmNpZXM7Yy5kZXBlbmRlbmNpZXM9bnVsbD09PWI/bnVsbDp7bGFuZXM6Yi5sYW5lcyxmaXJzdENvbnRleHQ6Yi5maXJzdENvbnRleHR9O1xuYy5zaWJsaW5nPWEuc2libGluZztjLmluZGV4PWEuaW5kZXg7Yy5yZWY9YS5yZWY7cmV0dXJuIGN9XG5mdW5jdGlvbiBSZyhhLGIsYyxkLGUsZil7dmFyIGc9MjtkPWE7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGEpYWooYSkmJihnPTEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKWc9NTtlbHNlIGE6c3dpdGNoKGEpe2Nhc2UgeWE6cmV0dXJuIFRnKGMuY2hpbGRyZW4sZSxmLGIpO2Nhc2UgemE6Zz04O2V8PTg7YnJlYWs7Y2FzZSBBYTpyZXR1cm4gYT1CZygxMixjLGIsZXwyKSxhLmVsZW1lbnRUeXBlPUFhLGEubGFuZXM9ZixhO2Nhc2UgRWE6cmV0dXJuIGE9QmcoMTMsYyxiLGUpLGEuZWxlbWVudFR5cGU9RWEsYS5sYW5lcz1mLGE7Y2FzZSBGYTpyZXR1cm4gYT1CZygxOSxjLGIsZSksYS5lbGVtZW50VHlwZT1GYSxhLmxhbmVzPWYsYTtjYXNlIElhOnJldHVybiBwaihjLGUsZixiKTtkZWZhdWx0OmlmKFwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEpc3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2UgQmE6Zz0xMDticmVhayBhO2Nhc2UgQ2E6Zz05O2JyZWFrIGE7Y2FzZSBEYTpnPTExO1xuYnJlYWsgYTtjYXNlIEdhOmc9MTQ7YnJlYWsgYTtjYXNlIEhhOmc9MTY7ZD1udWxsO2JyZWFrIGF9dGhyb3cgRXJyb3IocCgxMzAsbnVsbD09YT9hOnR5cGVvZiBhLFwiXCIpKTt9Yj1CZyhnLGMsYixlKTtiLmVsZW1lbnRUeXBlPWE7Yi50eXBlPWQ7Yi5sYW5lcz1mO3JldHVybiBifWZ1bmN0aW9uIFRnKGEsYixjLGQpe2E9QmcoNyxhLGQsYik7YS5sYW5lcz1jO3JldHVybiBhfWZ1bmN0aW9uIHBqKGEsYixjLGQpe2E9QmcoMjIsYSxkLGIpO2EuZWxlbWVudFR5cGU9SWE7YS5sYW5lcz1jO2Euc3RhdGVOb2RlPXtpc0hpZGRlbjohMX07cmV0dXJuIGF9ZnVuY3Rpb24gUWcoYSxiLGMpe2E9QmcoNixhLG51bGwsYik7YS5sYW5lcz1jO3JldHVybiBhfVxuZnVuY3Rpb24gU2coYSxiLGMpe2I9QmcoNCxudWxsIT09YS5jaGlsZHJlbj9hLmNoaWxkcmVuOltdLGEua2V5LGIpO2IubGFuZXM9YztiLnN0YXRlTm9kZT17Y29udGFpbmVySW5mbzphLmNvbnRhaW5lckluZm8scGVuZGluZ0NoaWxkcmVuOm51bGwsaW1wbGVtZW50YXRpb246YS5pbXBsZW1lbnRhdGlvbn07cmV0dXJuIGJ9XG5mdW5jdGlvbiBhbChhLGIsYyxkLGUpe3RoaXMudGFnPWI7dGhpcy5jb250YWluZXJJbmZvPWE7dGhpcy5maW5pc2hlZFdvcms9dGhpcy5waW5nQ2FjaGU9dGhpcy5jdXJyZW50PXRoaXMucGVuZGluZ0NoaWxkcmVuPW51bGw7dGhpcy50aW1lb3V0SGFuZGxlPS0xO3RoaXMuY2FsbGJhY2tOb2RlPXRoaXMucGVuZGluZ0NvbnRleHQ9dGhpcy5jb250ZXh0PW51bGw7dGhpcy5jYWxsYmFja1ByaW9yaXR5PTA7dGhpcy5ldmVudFRpbWVzPXpjKDApO3RoaXMuZXhwaXJhdGlvblRpbWVzPXpjKC0xKTt0aGlzLmVudGFuZ2xlZExhbmVzPXRoaXMuZmluaXNoZWRMYW5lcz10aGlzLm11dGFibGVSZWFkTGFuZXM9dGhpcy5leHBpcmVkTGFuZXM9dGhpcy5waW5nZWRMYW5lcz10aGlzLnN1c3BlbmRlZExhbmVzPXRoaXMucGVuZGluZ0xhbmVzPTA7dGhpcy5lbnRhbmdsZW1lbnRzPXpjKDApO3RoaXMuaWRlbnRpZmllclByZWZpeD1kO3RoaXMub25SZWNvdmVyYWJsZUVycm9yPWU7dGhpcy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhPVxubnVsbH1mdW5jdGlvbiBibChhLGIsYyxkLGUsZixnLGgsayl7YT1uZXcgYWwoYSxiLGMsaCxrKTsxPT09Yj8oYj0xLCEwPT09ZiYmKGJ8PTgpKTpiPTA7Zj1CZygzLG51bGwsbnVsbCxiKTthLmN1cnJlbnQ9ZjtmLnN0YXRlTm9kZT1hO2YubWVtb2l6ZWRTdGF0ZT17ZWxlbWVudDpkLGlzRGVoeWRyYXRlZDpjLGNhY2hlOm51bGwsdHJhbnNpdGlvbnM6bnVsbCxwZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzOm51bGx9O2toKGYpO3JldHVybiBhfWZ1bmN0aW9uIGNsKGEsYixjKXt2YXIgZD0zPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106bnVsbDtyZXR1cm57JCR0eXBlb2Y6d2Esa2V5Om51bGw9PWQ/bnVsbDpcIlwiK2QsY2hpbGRyZW46YSxjb250YWluZXJJbmZvOmIsaW1wbGVtZW50YXRpb246Y319XG5mdW5jdGlvbiBkbChhKXtpZighYSlyZXR1cm4gVmY7YT1hLl9yZWFjdEludGVybmFsczthOntpZihWYihhKSE9PWF8fDEhPT1hLnRhZyl0aHJvdyBFcnJvcihwKDE3MCkpO3ZhciBiPWE7ZG97c3dpdGNoKGIudGFnKXtjYXNlIDM6Yj1iLnN0YXRlTm9kZS5jb250ZXh0O2JyZWFrIGE7Y2FzZSAxOmlmKFpmKGIudHlwZSkpe2I9Yi5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7YnJlYWsgYX19Yj1iLnJldHVybn13aGlsZShudWxsIT09Yik7dGhyb3cgRXJyb3IocCgxNzEpKTt9aWYoMT09PWEudGFnKXt2YXIgYz1hLnR5cGU7aWYoWmYoYykpcmV0dXJuIGJnKGEsYyxiKX1yZXR1cm4gYn1cbmZ1bmN0aW9uIGVsKGEsYixjLGQsZSxmLGcsaCxrKXthPWJsKGMsZCwhMCxhLGUsZixnLGgsayk7YS5jb250ZXh0PWRsKG51bGwpO2M9YS5jdXJyZW50O2Q9UigpO2U9eWkoYyk7Zj1taChkLGUpO2YuY2FsbGJhY2s9dm9pZCAwIT09YiYmbnVsbCE9PWI/YjpudWxsO25oKGMsZixlKTthLmN1cnJlbnQubGFuZXM9ZTtBYyhhLGUsZCk7RGsoYSxkKTtyZXR1cm4gYX1mdW5jdGlvbiBmbChhLGIsYyxkKXt2YXIgZT1iLmN1cnJlbnQsZj1SKCksZz15aShlKTtjPWRsKGMpO251bGw9PT1iLmNvbnRleHQ/Yi5jb250ZXh0PWM6Yi5wZW5kaW5nQ29udGV4dD1jO2I9bWgoZixnKTtiLnBheWxvYWQ9e2VsZW1lbnQ6YX07ZD12b2lkIDA9PT1kP251bGw6ZDtudWxsIT09ZCYmKGIuY2FsbGJhY2s9ZCk7YT1uaChlLGIsZyk7bnVsbCE9PWEmJihnaShhLGUsZyxmKSxvaChhLGUsZykpO3JldHVybiBnfVxuZnVuY3Rpb24gZ2woYSl7YT1hLmN1cnJlbnQ7aWYoIWEuY2hpbGQpcmV0dXJuIG51bGw7c3dpdGNoKGEuY2hpbGQudGFnKXtjYXNlIDU6cmV0dXJuIGEuY2hpbGQuc3RhdGVOb2RlO2RlZmF1bHQ6cmV0dXJuIGEuY2hpbGQuc3RhdGVOb2RlfX1mdW5jdGlvbiBobChhLGIpe2E9YS5tZW1vaXplZFN0YXRlO2lmKG51bGwhPT1hJiZudWxsIT09YS5kZWh5ZHJhdGVkKXt2YXIgYz1hLnJldHJ5TGFuZTthLnJldHJ5TGFuZT0wIT09YyYmYzxiP2M6Yn19ZnVuY3Rpb24gaWwoYSxiKXtobChhLGIpOyhhPWEuYWx0ZXJuYXRlKSYmaGwoYSxiKX1mdW5jdGlvbiBqbCgpe3JldHVybiBudWxsfXZhciBrbD1cImZ1bmN0aW9uXCI9PT10eXBlb2YgcmVwb3J0RXJyb3I/cmVwb3J0RXJyb3I6ZnVuY3Rpb24oYSl7Y29uc29sZS5lcnJvcihhKX07ZnVuY3Rpb24gbGwoYSl7dGhpcy5faW50ZXJuYWxSb290PWF9XG5tbC5wcm90b3R5cGUucmVuZGVyPWxsLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5faW50ZXJuYWxSb290O2lmKG51bGw9PT1iKXRocm93IEVycm9yKHAoNDA5KSk7ZmwoYSxiLG51bGwsbnVsbCl9O21sLnByb3RvdHlwZS51bm1vdW50PWxsLnByb3RvdHlwZS51bm1vdW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5faW50ZXJuYWxSb290O2lmKG51bGwhPT1hKXt0aGlzLl9pbnRlcm5hbFJvb3Q9bnVsbDt2YXIgYj1hLmNvbnRhaW5lckluZm87UmsoZnVuY3Rpb24oKXtmbChudWxsLGEsbnVsbCxudWxsKX0pO2JbdWZdPW51bGx9fTtmdW5jdGlvbiBtbChhKXt0aGlzLl9pbnRlcm5hbFJvb3Q9YX1cbm1sLnByb3RvdHlwZS51bnN0YWJsZV9zY2hlZHVsZUh5ZHJhdGlvbj1mdW5jdGlvbihhKXtpZihhKXt2YXIgYj1IYygpO2E9e2Jsb2NrZWRPbjpudWxsLHRhcmdldDphLHByaW9yaXR5OmJ9O2Zvcih2YXIgYz0wO2M8UWMubGVuZ3RoJiYwIT09YiYmYjxRY1tjXS5wcmlvcml0eTtjKyspO1FjLnNwbGljZShjLDAsYSk7MD09PWMmJlZjKGEpfX07ZnVuY3Rpb24gbmwoYSl7cmV0dXJuISghYXx8MSE9PWEubm9kZVR5cGUmJjkhPT1hLm5vZGVUeXBlJiYxMSE9PWEubm9kZVR5cGUpfWZ1bmN0aW9uIG9sKGEpe3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlJiY5IT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlJiYoOCE9PWEubm9kZVR5cGV8fFwiIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlIFwiIT09YS5ub2RlVmFsdWUpKX1mdW5jdGlvbiBwbCgpe31cbmZ1bmN0aW9uIHFsKGEsYixjLGQsZSl7aWYoZSl7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGQpe3ZhciBmPWQ7ZD1mdW5jdGlvbigpe3ZhciBhPWdsKGcpO2YuY2FsbChhKX19dmFyIGc9ZWwoYixkLGEsMCxudWxsLCExLCExLFwiXCIscGwpO2EuX3JlYWN0Um9vdENvbnRhaW5lcj1nO2FbdWZdPWcuY3VycmVudDtzZig4PT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGU6YSk7UmsoKTtyZXR1cm4gZ31mb3IoO2U9YS5sYXN0Q2hpbGQ7KWEucmVtb3ZlQ2hpbGQoZSk7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGQpe3ZhciBoPWQ7ZD1mdW5jdGlvbigpe3ZhciBhPWdsKGspO2guY2FsbChhKX19dmFyIGs9YmwoYSwwLCExLG51bGwsbnVsbCwhMSwhMSxcIlwiLHBsKTthLl9yZWFjdFJvb3RDb250YWluZXI9azthW3VmXT1rLmN1cnJlbnQ7c2YoOD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmEpO1JrKGZ1bmN0aW9uKCl7ZmwoYixrLGMsZCl9KTtyZXR1cm4ga31cbmZ1bmN0aW9uIHJsKGEsYixjLGQsZSl7dmFyIGY9Yy5fcmVhY3RSb290Q29udGFpbmVyO2lmKGYpe3ZhciBnPWY7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGUpe3ZhciBoPWU7ZT1mdW5jdGlvbigpe3ZhciBhPWdsKGcpO2guY2FsbChhKX19ZmwoYixnLGEsZSl9ZWxzZSBnPXFsKGMsYixhLGUsZCk7cmV0dXJuIGdsKGcpfUVjPWZ1bmN0aW9uKGEpe3N3aXRjaChhLnRhZyl7Y2FzZSAzOnZhciBiPWEuc3RhdGVOb2RlO2lmKGIuY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCl7dmFyIGM9dGMoYi5wZW5kaW5nTGFuZXMpOzAhPT1jJiYoQ2MoYixjfDEpLERrKGIsQigpKSwwPT09KEsmNikmJihHaj1CKCkrNTAwLGpnKCkpKX1icmVhaztjYXNlIDEzOlJrKGZ1bmN0aW9uKCl7dmFyIGI9aWgoYSwxKTtpZihudWxsIT09Yil7dmFyIGM9UigpO2dpKGIsYSwxLGMpfX0pLGlsKGEsMSl9fTtcbkZjPWZ1bmN0aW9uKGEpe2lmKDEzPT09YS50YWcpe3ZhciBiPWloKGEsMTM0MjE3NzI4KTtpZihudWxsIT09Yil7dmFyIGM9UigpO2dpKGIsYSwxMzQyMTc3MjgsYyl9aWwoYSwxMzQyMTc3MjgpfX07R2M9ZnVuY3Rpb24oYSl7aWYoMTM9PT1hLnRhZyl7dmFyIGI9eWkoYSksYz1paChhLGIpO2lmKG51bGwhPT1jKXt2YXIgZD1SKCk7Z2koYyxhLGIsZCl9aWwoYSxiKX19O0hjPWZ1bmN0aW9uKCl7cmV0dXJuIEN9O0ljPWZ1bmN0aW9uKGEsYil7dmFyIGM9Qzt0cnl7cmV0dXJuIEM9YSxiKCl9ZmluYWxseXtDPWN9fTtcbnliPWZ1bmN0aW9uKGEsYixjKXtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6YmIoYSxjKTtiPWMubmFtZTtpZihcInJhZGlvXCI9PT1jLnR5cGUmJm51bGwhPWIpe2ZvcihjPWE7Yy5wYXJlbnROb2RlOyljPWMucGFyZW50Tm9kZTtjPWMucXVlcnlTZWxlY3RvckFsbChcImlucHV0W25hbWU9XCIrSlNPTi5zdHJpbmdpZnkoXCJcIitiKSsnXVt0eXBlPVwicmFkaW9cIl0nKTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKXt2YXIgZD1jW2JdO2lmKGQhPT1hJiZkLmZvcm09PT1hLmZvcm0pe3ZhciBlPURiKGQpO2lmKCFlKXRocm93IEVycm9yKHAoOTApKTtXYShkKTtiYihkLGUpfX19YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6aWIoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6Yj1jLnZhbHVlLG51bGwhPWImJmZiKGEsISFjLm11bHRpcGxlLGIsITEpfX07R2I9UWs7SGI9Ums7XG52YXIgc2w9e3VzaW5nQ2xpZW50RW50cnlQb2ludDohMSxFdmVudHM6W0NiLHVlLERiLEViLEZiLFFrXX0sdGw9e2ZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOldjLGJ1bmRsZVR5cGU6MCx2ZXJzaW9uOlwiMTguMy4xXCIscmVuZGVyZXJQYWNrYWdlTmFtZTpcInJlYWN0LWRvbVwifTtcbnZhciB1bD17YnVuZGxlVHlwZTp0bC5idW5kbGVUeXBlLHZlcnNpb246dGwudmVyc2lvbixyZW5kZXJlclBhY2thZ2VOYW1lOnRsLnJlbmRlcmVyUGFja2FnZU5hbWUscmVuZGVyZXJDb25maWc6dGwucmVuZGVyZXJDb25maWcsb3ZlcnJpZGVIb29rU3RhdGU6bnVsbCxvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGg6bnVsbCxvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg6bnVsbCxvdmVycmlkZVByb3BzOm51bGwsb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg6bnVsbCxvdmVycmlkZVByb3BzUmVuYW1lUGF0aDpudWxsLHNldEVycm9ySGFuZGxlcjpudWxsLHNldFN1c3BlbnNlSGFuZGxlcjpudWxsLHNjaGVkdWxlVXBkYXRlOm51bGwsY3VycmVudERpc3BhdGNoZXJSZWY6dWEuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjpmdW5jdGlvbihhKXthPVpiKGEpO3JldHVybiBudWxsPT09YT9udWxsOmEuc3RhdGVOb2RlfSxmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTp0bC5maW5kRmliZXJCeUhvc3RJbnN0YW5jZXx8XG5qbCxmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2g6bnVsbCxzY2hlZHVsZVJlZnJlc2g6bnVsbCxzY2hlZHVsZVJvb3Q6bnVsbCxzZXRSZWZyZXNoSGFuZGxlcjpudWxsLGdldEN1cnJlbnRGaWJlcjpudWxsLHJlY29uY2lsZXJWZXJzaW9uOlwiMTguMy4xLW5leHQtZjEzMzhmODA4MC0yMDI0MDQyNlwifTtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyl7dmFyIHZsPV9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztpZighdmwuaXNEaXNhYmxlZCYmdmwuc3VwcG9ydHNGaWJlcil0cnl7a2M9dmwuaW5qZWN0KHVsKSxsYz12bH1jYXRjaChhKXt9fWV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ9c2w7XG5leHBvcnRzLmNyZWF0ZVBvcnRhbD1mdW5jdGlvbihhLGIpe3ZhciBjPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsO2lmKCFubChiKSl0aHJvdyBFcnJvcihwKDIwMCkpO3JldHVybiBjbChhLGIsbnVsbCxjKX07ZXhwb3J0cy5jcmVhdGVSb290PWZ1bmN0aW9uKGEsYil7aWYoIW5sKGEpKXRocm93IEVycm9yKHAoMjk5KSk7dmFyIGM9ITEsZD1cIlwiLGU9a2w7bnVsbCE9PWImJnZvaWQgMCE9PWImJighMD09PWIudW5zdGFibGVfc3RyaWN0TW9kZSYmKGM9ITApLHZvaWQgMCE9PWIuaWRlbnRpZmllclByZWZpeCYmKGQ9Yi5pZGVudGlmaWVyUHJlZml4KSx2b2lkIDAhPT1iLm9uUmVjb3ZlcmFibGVFcnJvciYmKGU9Yi5vblJlY292ZXJhYmxlRXJyb3IpKTtiPWJsKGEsMSwhMSxudWxsLG51bGwsYywhMSxkLGUpO2FbdWZdPWIuY3VycmVudDtzZig4PT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGU6YSk7cmV0dXJuIG5ldyBsbChiKX07XG5leHBvcnRzLmZpbmRET01Ob2RlPWZ1bmN0aW9uKGEpe2lmKG51bGw9PWEpcmV0dXJuIG51bGw7aWYoMT09PWEubm9kZVR5cGUpcmV0dXJuIGE7dmFyIGI9YS5fcmVhY3RJbnRlcm5hbHM7aWYodm9pZCAwPT09Yil7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGEucmVuZGVyKXRocm93IEVycm9yKHAoMTg4KSk7YT1PYmplY3Qua2V5cyhhKS5qb2luKFwiLFwiKTt0aHJvdyBFcnJvcihwKDI2OCxhKSk7fWE9WmIoYik7YT1udWxsPT09YT9udWxsOmEuc3RhdGVOb2RlO3JldHVybiBhfTtleHBvcnRzLmZsdXNoU3luYz1mdW5jdGlvbihhKXtyZXR1cm4gUmsoYSl9O2V4cG9ydHMuaHlkcmF0ZT1mdW5jdGlvbihhLGIsYyl7aWYoIW9sKGIpKXRocm93IEVycm9yKHAoMjAwKSk7cmV0dXJuIHJsKG51bGwsYSxiLCEwLGMpfTtcbmV4cG9ydHMuaHlkcmF0ZVJvb3Q9ZnVuY3Rpb24oYSxiLGMpe2lmKCFubChhKSl0aHJvdyBFcnJvcihwKDQwNSkpO3ZhciBkPW51bGwhPWMmJmMuaHlkcmF0ZWRTb3VyY2VzfHxudWxsLGU9ITEsZj1cIlwiLGc9a2w7bnVsbCE9PWMmJnZvaWQgMCE9PWMmJighMD09PWMudW5zdGFibGVfc3RyaWN0TW9kZSYmKGU9ITApLHZvaWQgMCE9PWMuaWRlbnRpZmllclByZWZpeCYmKGY9Yy5pZGVudGlmaWVyUHJlZml4KSx2b2lkIDAhPT1jLm9uUmVjb3ZlcmFibGVFcnJvciYmKGc9Yy5vblJlY292ZXJhYmxlRXJyb3IpKTtiPWVsKGIsbnVsbCxhLDEsbnVsbCE9Yz9jOm51bGwsZSwhMSxmLGcpO2FbdWZdPWIuY3VycmVudDtzZihhKTtpZihkKWZvcihhPTA7YTxkLmxlbmd0aDthKyspYz1kW2FdLGU9Yy5fZ2V0VmVyc2lvbixlPWUoYy5fc291cmNlKSxudWxsPT1iLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE/Yi5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhPVtjLGVdOmIubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YS5wdXNoKGMsXG5lKTtyZXR1cm4gbmV3IG1sKGIpfTtleHBvcnRzLnJlbmRlcj1mdW5jdGlvbihhLGIsYyl7aWYoIW9sKGIpKXRocm93IEVycm9yKHAoMjAwKSk7cmV0dXJuIHJsKG51bGwsYSxiLCExLGMpfTtleHBvcnRzLnVubW91bnRDb21wb25lbnRBdE5vZGU9ZnVuY3Rpb24oYSl7aWYoIW9sKGEpKXRocm93IEVycm9yKHAoNDApKTtyZXR1cm4gYS5fcmVhY3RSb290Q29udGFpbmVyPyhSayhmdW5jdGlvbigpe3JsKG51bGwsbnVsbCxhLCExLGZ1bmN0aW9uKCl7YS5fcmVhY3RSb290Q29udGFpbmVyPW51bGw7YVt1Zl09bnVsbH0pfSksITApOiExfTtleHBvcnRzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzPVFrO1xuZXhwb3J0cy51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcj1mdW5jdGlvbihhLGIsYyxkKXtpZighb2woYykpdGhyb3cgRXJyb3IocCgyMDApKTtpZihudWxsPT1hfHx2b2lkIDA9PT1hLl9yZWFjdEludGVybmFscyl0aHJvdyBFcnJvcihwKDM4KSk7cmV0dXJuIHJsKGEsYixjLCExLGQpfTtleHBvcnRzLnZlcnNpb249XCIxOC4zLjEtbmV4dC1mMTMzOGY4MDgwLTIwMjQwNDI2XCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///551\n')},338:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar m = __webpack_require__(961);\nif (true) {\n  exports.createRoot = m.createRoot;\n  exports.hydrateRoot = m.hydrateRoot;\n} else { var i; }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsbUJBQU8sQ0FBQyxHQUFXO0FBQzNCLElBQUksSUFBcUM7QUFDekMsRUFBRSxrQkFBa0I7QUFDcEIsRUFBRSxtQkFBbUI7QUFDckIsRUFBRSxLQUFLLFVBa0JOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnRzcC1zdHJlYW0tdmlld2VyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9jbGllbnQuanM/MTFiMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBtID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBleHBvcnRzLmNyZWF0ZVJvb3QgPSBtLmNyZWF0ZVJvb3Q7XG4gIGV4cG9ydHMuaHlkcmF0ZVJvb3QgPSBtLmh5ZHJhdGVSb290O1xufSBlbHNlIHtcbiAgdmFyIGkgPSBtLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICBleHBvcnRzLmNyZWF0ZVJvb3QgPSBmdW5jdGlvbihjLCBvKSB7XG4gICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbS5jcmVhdGVSb290KGMsIG8pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpLnVzaW5nQ2xpZW50RW50cnlQb2ludCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5oeWRyYXRlUm9vdCA9IGZ1bmN0aW9uKGMsIGgsIG8pIHtcbiAgICBpLnVzaW5nQ2xpZW50RW50cnlQb2ludCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtLmh5ZHJhdGVSb290KGMsIGgsIG8pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpLnVzaW5nQ2xpZW50RW50cnlQb2ludCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///338\n")},961:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (false) {}\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (true) {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = __webpack_require__(551);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYxLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFTMUM7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEVBQUUseUNBQTZEO0FBQy9ELEVBQUUsS0FBSyxFQUVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnRzcC1zdHJlYW0tdmlld2VyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcz84YmM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///961\n")},20:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar f=__webpack_require__(540),k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2EsTUFBTSxtQkFBTyxDQUFDLEdBQU8sNktBQTZLO0FBQy9NLGtCQUFrQixVQUFVLGVBQWUscUJBQXFCLDZCQUE2QiwwQkFBMEIsMERBQTBELDRFQUE0RSxPQUFPLHdEQUF3RCxnQkFBZ0IsR0FBRyxXQUFXLEdBQUcsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL3J0c3Atc3RyZWFtLXZpZXdlci8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanM/ZDMxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7dmFyIGY9cmVxdWlyZShcInJlYWN0XCIpLGs9U3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksbD1TeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksbT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LG49Zi5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcixwPXtrZXk6ITAscmVmOiEwLF9fc2VsZjohMCxfX3NvdXJjZTohMH07XG5mdW5jdGlvbiBxKGMsYSxnKXt2YXIgYixkPXt9LGU9bnVsbCxoPW51bGw7dm9pZCAwIT09ZyYmKGU9XCJcIitnKTt2b2lkIDAhPT1hLmtleSYmKGU9XCJcIithLmtleSk7dm9pZCAwIT09YS5yZWYmJihoPWEucmVmKTtmb3IoYiBpbiBhKW0uY2FsbChhLGIpJiYhcC5oYXNPd25Qcm9wZXJ0eShiKSYmKGRbYl09YVtiXSk7aWYoYyYmYy5kZWZhdWx0UHJvcHMpZm9yKGIgaW4gYT1jLmRlZmF1bHRQcm9wcyxhKXZvaWQgMD09PWRbYl0mJihkW2JdPWFbYl0pO3JldHVybnskJHR5cGVvZjprLHR5cGU6YyxrZXk6ZSxyZWY6aCxwcm9wczpkLF9vd25lcjpuLmN1cnJlbnR9fWV4cG9ydHMuRnJhZ21lbnQ9bDtleHBvcnRzLmpzeD1xO2V4cG9ydHMuanN4cz1xO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20\n')},287:(__unused_webpack_module,exports)=>{"use strict";eval('/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar l=Symbol.for("react.element"),n=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),q=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z=Symbol.iterator;function A(a){if(null===a||"object"!==typeof a)return null;a=z&&a[z]||a["@@iterator"];return"function"===typeof a?a:null}\nvar B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};\nE.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;\nH.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};\nfunction M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}\nfunction N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\\/+/g;function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}\nfunction R(a,b,e,d,c){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=""===d?"."+Q(h,0):d,I(c)?(e="",null!=a&&(e=a.replace(P,"$&/")+"/"),R(c,b,e,"",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?"":(""+c.key).replace(P,"$&/")+"/")+a)),b.push(c)),1;h=0;d=""===d?".":d+":";if(I(a))for(var g=0;g<a.length;g++){k=\na[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if("object"===k)throw b=String(a),Error("Objects are not valid as a React child (found: "+("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}\nfunction S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,"","",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}\nvar U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};function X(){throw Error("act(...) is not supported in production builds of React.");}\nexports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};exports.Component=E;exports.Fragment=p;exports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;\nexports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;exports.act=X;\nexports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);\nfor(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};\nexports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=X;exports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};\nexports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};exports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};\nexports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};exports.useTransition=function(){return U.current.useTransition()};exports.version="18.3.1";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhLHFXQUFxVyxjQUFjLDZDQUE2QywyQkFBMkI7QUFDeGMsT0FBTyxxQkFBcUIsU0FBUyxnQ0FBZ0MsaUNBQWlDLDhCQUE4QixzQkFBc0Isa0JBQWtCLGFBQWEsZUFBZSxZQUFZLGtCQUFrQjtBQUN0TyxtQ0FBbUMsNExBQTRMLG1EQUFtRCxvQ0FBb0MsdURBQXVELGNBQWMsd0JBQXdCLGtCQUFrQixhQUFhLGVBQWUsWUFBWSxrQkFBa0I7QUFDL2QsZ0JBQWdCLGlCQUFpQiwwQkFBMEIseURBQXlELGFBQWEsSUFBSTtBQUNySSxrQkFBa0IsVUFBVSxlQUFlLDRIQUE0SCx5QkFBeUIsc0JBQXNCLGFBQWEsdUJBQXVCLElBQUksd0JBQXdCLGFBQWEsNEVBQTRFLE9BQU87QUFDdFgsZ0JBQWdCLE9BQU8sc0VBQXNFLGNBQWMsb0RBQW9ELG1CQUFtQixPQUFPLG1CQUFtQix3Q0FBd0MsWUFBWSxFQUFFLGFBQWEsZ0JBQWdCO0FBQy9SLHNCQUFzQixlQUFlLHlDQUF5QyxTQUFTLGlCQUFpQixlQUFlLGlDQUFpQyxNQUFNLGlDQUFpQyxvQkFBb0IsbUhBQW1ILFNBQVMsMkdBQTJHLElBQUksbUJBQW1CLG9CQUFvQixXQUFXLEtBQUs7QUFDcmYsS0FBSyxlQUFlLGdCQUFnQix5REFBeUQsbUJBQW1CLHdDQUF3Qyx5SUFBeUksOEJBQThCLGtGQUFrRjtBQUNqWixrQkFBa0Isb0JBQW9CLGFBQWEsd0JBQXdCLHVCQUF1QixFQUFFLFNBQVMsY0FBYyxtQkFBbUIsZ0JBQWdCLE1BQU0sbUJBQW1CLHlEQUF5RCxhQUFhLHlEQUF5RCxFQUFFLDBDQUEwQywwQ0FBMEM7QUFDNVksT0FBTyxhQUFhLElBQUksZ0JBQWdCLElBQUksd0VBQXdFLGFBQWE7QUFDakksZ0JBQWdCLEVBQUUsOEJBQThCLGVBQWUsd0JBQXdCLElBQUksbUJBQW1CLFFBQVEsZUFBZSxJQUFJLEVBQUUsU0FBUyxxQkFBcUIsdUJBQXVCLFNBQVMsTUFBTSxrQkFBa0IsOEZBQThGLFdBQVcsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcscUJBQXFCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCO0FBQ2pjLDBEQUEwRCxHQUFHLFdBQVc7QUFDeEUsb0JBQW9CLGlCQUFpQiw0SEFBNEgsVUFBVSxxQ0FBcUMsWUFBWSxzQ0FBc0MsNkJBQTZCLHlEQUF5RCx5RkFBeUYseUJBQXlCLHNCQUFzQixhQUFhO0FBQzdlLFlBQVksSUFBSSx3QkFBd0IsYUFBYSxPQUFPLHNEQUFzRCxxQkFBcUIsYUFBYSxHQUFHLDRIQUE0SCxZQUFZLHVCQUF1QixxQkFBcUIscUJBQXFCLEdBQUcscUJBQXFCLGFBQWEscUJBQXFCLFNBQVMsVUFBVSxpQkFBaUIsWUFBWSxPQUFPO0FBQ2pkLGtCQUFrQixhQUFhLE9BQU8sc0JBQXNCLHNCQUFzQixHQUFHLFlBQVksYUFBYSxPQUFPLHFCQUFxQixxQkFBcUIsV0FBVyxZQUFZLGVBQWUsT0FBTyw4Q0FBOEMsdUJBQXVCLGFBQWEsbUJBQW1CLGdCQUFnQixJQUFJLElBQUksUUFBUSxpQkFBaUIsb0JBQW9CLEdBQUcsbUJBQW1CLGVBQWUsbUNBQW1DLGtCQUFrQixhQUFhO0FBQzdkLHFCQUFxQixjQUFjLHdCQUF3QixhQUFhLHNDQUFzQyxpQkFBaUIsZUFBZSxpQ0FBaUMsYUFBYSxZQUFZLDBCQUEwQiwyQkFBMkIsaUJBQWlCLDZDQUE2QywwQkFBMEIsZUFBZSwwQ0FBMEMsdUJBQXVCLGVBQWU7QUFDcGIsZUFBZSxlQUFlLCtCQUErQixrQkFBa0IsaUJBQWlCLG9DQUFvQyxjQUFjLGFBQWEsNEJBQTRCLGdCQUFnQixhQUFhLDhCQUE4Qiw0QkFBNEIsaUJBQWlCLDhDQUE4QyxxQkFBcUIsWUFBWSxrQ0FBa0MsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3J0c3Atc3RyZWFtLXZpZXdlci8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanM/YmUyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7dmFyIGw9U3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksbj1TeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLHA9U3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLHE9U3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLHI9U3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLHQ9U3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLHU9U3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksdj1TeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksdz1TeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIikseD1TeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSx5PVN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLHo9U3ltYm9sLml0ZXJhdG9yO2Z1bmN0aW9uIEEoYSl7aWYobnVsbD09PWF8fFwib2JqZWN0XCIhPT10eXBlb2YgYSlyZXR1cm4gbnVsbDthPXomJmFbel18fGFbXCJAQGl0ZXJhdG9yXCJdO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2E6bnVsbH1cbnZhciBCPXtpc01vdW50ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oKXt9fSxDPU9iamVjdC5hc3NpZ24sRD17fTtmdW5jdGlvbiBFKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPUQ7dGhpcy51cGRhdGVyPWV8fEJ9RS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fTtcbkUucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGEsYil7aWYoXCJvYmplY3RcIiE9PXR5cGVvZiBhJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSYmbnVsbCE9YSl0aHJvdyBFcnJvcihcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiKTt0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsYSxiLFwic2V0U3RhdGVcIil9O0UucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyxhLFwiZm9yY2VVcGRhdGVcIil9O2Z1bmN0aW9uIEYoKXt9Ri5wcm90b3R5cGU9RS5wcm90b3R5cGU7ZnVuY3Rpb24gRyhhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1EO3RoaXMudXBkYXRlcj1lfHxCfXZhciBIPUcucHJvdG90eXBlPW5ldyBGO1xuSC5jb25zdHJ1Y3Rvcj1HO0MoSCxFLnByb3RvdHlwZSk7SC5pc1B1cmVSZWFjdENvbXBvbmVudD0hMDt2YXIgST1BcnJheS5pc0FycmF5LEo9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxLPXtjdXJyZW50Om51bGx9LEw9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIE0oYSxiLGUpe3ZhciBkLGM9e30saz1udWxsLGg9bnVsbDtpZihudWxsIT1iKWZvcihkIGluIHZvaWQgMCE9PWIucmVmJiYoaD1iLnJlZiksdm9pZCAwIT09Yi5rZXkmJihrPVwiXCIrYi5rZXkpLGIpSi5jYWxsKGIsZCkmJiFMLmhhc093blByb3BlcnR5KGQpJiYoY1tkXT1iW2RdKTt2YXIgZz1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWcpYy5jaGlsZHJlbj1lO2Vsc2UgaWYoMTxnKXtmb3IodmFyIGY9QXJyYXkoZyksbT0wO208ZzttKyspZlttXT1hcmd1bWVudHNbbSsyXTtjLmNoaWxkcmVuPWZ9aWYoYSYmYS5kZWZhdWx0UHJvcHMpZm9yKGQgaW4gZz1hLmRlZmF1bHRQcm9wcyxnKXZvaWQgMD09PWNbZF0mJihjW2RdPWdbZF0pO3JldHVybnskJHR5cGVvZjpsLHR5cGU6YSxrZXk6ayxyZWY6aCxwcm9wczpjLF9vd25lcjpLLmN1cnJlbnR9fVxuZnVuY3Rpb24gTihhLGIpe3JldHVybnskJHR5cGVvZjpsLHR5cGU6YS50eXBlLGtleTpiLHJlZjphLnJlZixwcm9wczphLnByb3BzLF9vd25lcjphLl9vd25lcn19ZnVuY3Rpb24gTyhhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09bH1mdW5jdGlvbiBlc2NhcGUoYSl7dmFyIGI9e1wiPVwiOlwiPTBcIixcIjpcIjpcIj0yXCJ9O3JldHVyblwiJFwiK2EucmVwbGFjZSgvWz06XS9nLGZ1bmN0aW9uKGEpe3JldHVybiBiW2FdfSl9dmFyIFA9L1xcLysvZztmdW5jdGlvbiBRKGEsYil7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmbnVsbCE9YS5rZXk/ZXNjYXBlKFwiXCIrYS5rZXkpOmIudG9TdHJpbmcoMzYpfVxuZnVuY3Rpb24gUihhLGIsZSxkLGMpe3ZhciBrPXR5cGVvZiBhO2lmKFwidW5kZWZpbmVkXCI9PT1rfHxcImJvb2xlYW5cIj09PWspYT1udWxsO3ZhciBoPSExO2lmKG51bGw9PT1hKWg9ITA7ZWxzZSBzd2l0Y2goayl7Y2FzZSBcInN0cmluZ1wiOmNhc2UgXCJudW1iZXJcIjpoPSEwO2JyZWFrO2Nhc2UgXCJvYmplY3RcIjpzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSBsOmNhc2UgbjpoPSEwfX1pZihoKXJldHVybiBoPWEsYz1jKGgpLGE9XCJcIj09PWQ/XCIuXCIrUShoLDApOmQsSShjKT8oZT1cIlwiLG51bGwhPWEmJihlPWEucmVwbGFjZShQLFwiJCYvXCIpK1wiL1wiKSxSKGMsYixlLFwiXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGF9KSk6bnVsbCE9YyYmKE8oYykmJihjPU4oYyxlKyghYy5rZXl8fGgmJmgua2V5PT09Yy5rZXk/XCJcIjooXCJcIitjLmtleSkucmVwbGFjZShQLFwiJCYvXCIpK1wiL1wiKSthKSksYi5wdXNoKGMpKSwxO2g9MDtkPVwiXCI9PT1kP1wiLlwiOmQrXCI6XCI7aWYoSShhKSlmb3IodmFyIGc9MDtnPGEubGVuZ3RoO2crKyl7az1cbmFbZ107dmFyIGY9ZCtRKGssZyk7aCs9UihrLGIsZSxmLGMpfWVsc2UgaWYoZj1BKGEpLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBmKWZvcihhPWYuY2FsbChhKSxnPTA7IShrPWEubmV4dCgpKS5kb25lOylrPWsudmFsdWUsZj1kK1EoayxnKyspLGgrPVIoayxiLGUsZixjKTtlbHNlIGlmKFwib2JqZWN0XCI9PT1rKXRocm93IGI9U3RyaW5nKGEpLEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIisoXCJbb2JqZWN0IE9iamVjdF1cIj09PWI/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhhKS5qb2luKFwiLCBcIikrXCJ9XCI6YikrXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIpO3JldHVybiBofVxuZnVuY3Rpb24gUyhhLGIsZSl7aWYobnVsbD09YSlyZXR1cm4gYTt2YXIgZD1bXSxjPTA7UihhLGQsXCJcIixcIlwiLGZ1bmN0aW9uKGEpe3JldHVybiBiLmNhbGwoZSxhLGMrKyl9KTtyZXR1cm4gZH1mdW5jdGlvbiBUKGEpe2lmKC0xPT09YS5fc3RhdHVzKXt2YXIgYj1hLl9yZXN1bHQ7Yj1iKCk7Yi50aGVuKGZ1bmN0aW9uKGIpe2lmKDA9PT1hLl9zdGF0dXN8fC0xPT09YS5fc3RhdHVzKWEuX3N0YXR1cz0xLGEuX3Jlc3VsdD1ifSxmdW5jdGlvbihiKXtpZigwPT09YS5fc3RhdHVzfHwtMT09PWEuX3N0YXR1cylhLl9zdGF0dXM9MixhLl9yZXN1bHQ9Yn0pOy0xPT09YS5fc3RhdHVzJiYoYS5fc3RhdHVzPTAsYS5fcmVzdWx0PWIpfWlmKDE9PT1hLl9zdGF0dXMpcmV0dXJuIGEuX3Jlc3VsdC5kZWZhdWx0O3Rocm93IGEuX3Jlc3VsdDt9XG52YXIgVT17Y3VycmVudDpudWxsfSxWPXt0cmFuc2l0aW9uOm51bGx9LFc9e1JlYWN0Q3VycmVudERpc3BhdGNoZXI6VSxSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzpWLFJlYWN0Q3VycmVudE93bmVyOkt9O2Z1bmN0aW9uIFgoKXt0aHJvdyBFcnJvcihcImFjdCguLi4pIGlzIG5vdCBzdXBwb3J0ZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMgb2YgUmVhY3QuXCIpO31cbmV4cG9ydHMuQ2hpbGRyZW49e21hcDpTLGZvckVhY2g6ZnVuY3Rpb24oYSxiLGUpe1MoYSxmdW5jdGlvbigpe2IuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxlKX0sY291bnQ6ZnVuY3Rpb24oYSl7dmFyIGI9MDtTKGEsZnVuY3Rpb24oKXtiKyt9KTtyZXR1cm4gYn0sdG9BcnJheTpmdW5jdGlvbihhKXtyZXR1cm4gUyhhLGZ1bmN0aW9uKGEpe3JldHVybiBhfSl8fFtdfSxvbmx5OmZ1bmN0aW9uKGEpe2lmKCFPKGEpKXRocm93IEVycm9yKFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIpO3JldHVybiBhfX07ZXhwb3J0cy5Db21wb25lbnQ9RTtleHBvcnRzLkZyYWdtZW50PXA7ZXhwb3J0cy5Qcm9maWxlcj1yO2V4cG9ydHMuUHVyZUNvbXBvbmVudD1HO2V4cG9ydHMuU3RyaWN0TW9kZT1xO2V4cG9ydHMuU3VzcGVuc2U9dztcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ9VztleHBvcnRzLmFjdD1YO1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQ9ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PT1hfHx2b2lkIDA9PT1hKXRocm93IEVycm9yKFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIrYStcIi5cIik7dmFyIGQ9Qyh7fSxhLnByb3BzKSxjPWEua2V5LGs9YS5yZWYsaD1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGs9Yi5yZWYsaD1LLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoYz1cIlwiK2Iua2V5KTtpZihhLnR5cGUmJmEudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGc9YS50eXBlLmRlZmF1bHRQcm9wcztmb3IoZiBpbiBiKUouY2FsbChiLGYpJiYhTC5oYXNPd25Qcm9wZXJ0eShmKSYmKGRbZl09dm9pZCAwPT09YltmXSYmdm9pZCAwIT09Zz9nW2ZdOmJbZl0pfXZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZilkLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGYpe2c9QXJyYXkoZik7XG5mb3IodmFyIG09MDttPGY7bSsrKWdbbV09YXJndW1lbnRzW20rMl07ZC5jaGlsZHJlbj1nfXJldHVybnskJHR5cGVvZjpsLHR5cGU6YS50eXBlLGtleTpjLHJlZjprLHByb3BzOmQsX293bmVyOmh9fTtleHBvcnRzLmNyZWF0ZUNvbnRleHQ9ZnVuY3Rpb24oYSl7YT17JCR0eXBlb2Y6dSxfY3VycmVudFZhbHVlOmEsX2N1cnJlbnRWYWx1ZTI6YSxfdGhyZWFkQ291bnQ6MCxQcm92aWRlcjpudWxsLENvbnN1bWVyOm51bGwsX2RlZmF1bHRWYWx1ZTpudWxsLF9nbG9iYWxOYW1lOm51bGx9O2EuUHJvdmlkZXI9eyQkdHlwZW9mOnQsX2NvbnRleHQ6YX07cmV0dXJuIGEuQ29uc3VtZXI9YX07ZXhwb3J0cy5jcmVhdGVFbGVtZW50PU07ZXhwb3J0cy5jcmVhdGVGYWN0b3J5PWZ1bmN0aW9uKGEpe3ZhciBiPU0uYmluZChudWxsLGEpO2IudHlwZT1hO3JldHVybiBifTtleHBvcnRzLmNyZWF0ZVJlZj1mdW5jdGlvbigpe3JldHVybntjdXJyZW50Om51bGx9fTtcbmV4cG9ydHMuZm9yd2FyZFJlZj1mdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6dixyZW5kZXI6YX19O2V4cG9ydHMuaXNWYWxpZEVsZW1lbnQ9TztleHBvcnRzLmxhenk9ZnVuY3Rpb24oYSl7cmV0dXJueyQkdHlwZW9mOnksX3BheWxvYWQ6e19zdGF0dXM6LTEsX3Jlc3VsdDphfSxfaW5pdDpUfX07ZXhwb3J0cy5tZW1vPWZ1bmN0aW9uKGEsYil7cmV0dXJueyQkdHlwZW9mOngsdHlwZTphLGNvbXBhcmU6dm9pZCAwPT09Yj9udWxsOmJ9fTtleHBvcnRzLnN0YXJ0VHJhbnNpdGlvbj1mdW5jdGlvbihhKXt2YXIgYj1WLnRyYW5zaXRpb247Vi50cmFuc2l0aW9uPXt9O3RyeXthKCl9ZmluYWxseXtWLnRyYW5zaXRpb249Yn19O2V4cG9ydHMudW5zdGFibGVfYWN0PVg7ZXhwb3J0cy51c2VDYWxsYmFjaz1mdW5jdGlvbihhLGIpe3JldHVybiBVLmN1cnJlbnQudXNlQ2FsbGJhY2soYSxiKX07ZXhwb3J0cy51c2VDb250ZXh0PWZ1bmN0aW9uKGEpe3JldHVybiBVLmN1cnJlbnQudXNlQ29udGV4dChhKX07XG5leHBvcnRzLnVzZURlYnVnVmFsdWU9ZnVuY3Rpb24oKXt9O2V4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZT1mdW5jdGlvbihhKXtyZXR1cm4gVS5jdXJyZW50LnVzZURlZmVycmVkVmFsdWUoYSl9O2V4cG9ydHMudXNlRWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFUuY3VycmVudC51c2VFZmZlY3QoYSxiKX07ZXhwb3J0cy51c2VJZD1mdW5jdGlvbigpe3JldHVybiBVLmN1cnJlbnQudXNlSWQoKX07ZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlPWZ1bmN0aW9uKGEsYixlKXtyZXR1cm4gVS5jdXJyZW50LnVzZUltcGVyYXRpdmVIYW5kbGUoYSxiLGUpfTtleHBvcnRzLnVzZUluc2VydGlvbkVmZmVjdD1mdW5jdGlvbihhLGIpe3JldHVybiBVLmN1cnJlbnQudXNlSW5zZXJ0aW9uRWZmZWN0KGEsYil9O2V4cG9ydHMudXNlTGF5b3V0RWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFUuY3VycmVudC51c2VMYXlvdXRFZmZlY3QoYSxiKX07XG5leHBvcnRzLnVzZU1lbW89ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVS5jdXJyZW50LnVzZU1lbW8oYSxiKX07ZXhwb3J0cy51c2VSZWR1Y2VyPWZ1bmN0aW9uKGEsYixlKXtyZXR1cm4gVS5jdXJyZW50LnVzZVJlZHVjZXIoYSxiLGUpfTtleHBvcnRzLnVzZVJlZj1mdW5jdGlvbihhKXtyZXR1cm4gVS5jdXJyZW50LnVzZVJlZihhKX07ZXhwb3J0cy51c2VTdGF0ZT1mdW5jdGlvbihhKXtyZXR1cm4gVS5jdXJyZW50LnVzZVN0YXRlKGEpfTtleHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlPWZ1bmN0aW9uKGEsYixlKXtyZXR1cm4gVS5jdXJyZW50LnVzZVN5bmNFeHRlcm5hbFN0b3JlKGEsYixlKX07ZXhwb3J0cy51c2VUcmFuc2l0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIFUuY3VycmVudC51c2VUcmFuc2l0aW9uKCl9O2V4cG9ydHMudmVyc2lvbj1cIjE4LjMuMVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///287\n')},540:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(287);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBeUQ7QUFDM0QsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ydHNwLXN0cmVhbS12aWV3ZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanM/YWI1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///540\n")},848:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(20);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx3Q0FBcUU7QUFDdkUsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ydHNwLXN0cmVhbS12aWV3ZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanM/OWNhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///848\n")},463:(__unused_webpack_module,exports)=>{"use strict";eval('/**\n * @license React\n * scheduler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nfunction f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}\nfunction g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}var r=[],t=[],u=1,v=null,y=3,z=!1,A=!1,B=!1,D="function"===typeof setTimeout?setTimeout:null,E="function"===typeof clearTimeout?clearTimeout:null,F="undefined"!==typeof setImmediate?setImmediate:null;\n"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t)}}function H(a){B=!1;G(a);if(!A)if(null!==h(r))A=!0,I(J);else{var b=h(t);null!==b&&K(H,b.startTime-a)}}\nfunction J(a,b){A=!1;B&&(B=!1,E(L),L=-1);z=!0;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if("function"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?v.callback=e:v===h(r)&&k(r);G(b)}else k(r);v=h(r)}if(null!==v)var w=!0;else{var m=h(t);null!==m&&K(H,m.startTime-b);w=!1}return w}finally{v=null,y=c,z=!1}}var N=!1,O=null,L=-1,P=5,Q=-1;\nfunction M(){return exports.unstable_now()-Q<P?!1:!0}function R(){if(null!==O){var a=exports.unstable_now();Q=a;var b=!0;try{b=O(!0,a)}finally{b?S():(N=!1,O=null)}}else N=!1}var S;if("function"===typeof F)S=function(){F(R)};else if("undefined"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null)}}else S=function(){D(R,0)};function I(a){O=a;N||(N=!0,S())}function K(a,b){L=D(function(){a(exports.unstable_now())},b)}\nexports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){A||z||(A=!0,I(J))};\nexports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<a?Math.floor(1E3/a):5};exports.unstable_getCurrentPriorityLevel=function(){return y};exports.unstable_getFirstCallbackNode=function(){return h(r)};exports.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y}var c=y;y=b;try{return a()}finally{y=c}};exports.unstable_pauseExecution=function(){};\nexports.unstable_requestPaint=function(){};exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=y;y=a;try{return b()}finally{y=c}};\nexports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=!0,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=!0,I(J)));return a};\nexports.unstable_shouldYield=M;exports.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c}}};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhLGdCQUFnQixlQUFlLFVBQVUsT0FBTyxJQUFJLEVBQUUscUJBQXFCLDhCQUE4QixjQUFjLGNBQWMsOEJBQThCLGNBQWMsNEJBQTRCLHFCQUFxQixVQUFVLE9BQU8saUNBQWlDLElBQUksRUFBRSxvQ0FBb0Msa0VBQWtFLHdDQUF3QyxjQUFjO0FBQ25jLGdCQUFnQiw4QkFBOEIseUJBQXlCLHVFQUF1RSxrQkFBa0Isb0JBQW9CLFlBQVksZ0JBQWdCLEtBQUsscUJBQXFCLG9CQUFvQixZQUFZLGtCQUFrQjtBQUM1Uiw0S0FBNEssY0FBYyxlQUFlLFNBQVMsRUFBRSwwQkFBMEIsZ0VBQWdFLFdBQVcsUUFBUSxjQUFjLEtBQUssS0FBSywrQkFBK0IsS0FBSyxXQUFXO0FBQ3hZLGdCQUFnQixLQUFLLG9CQUFvQixLQUFLLFFBQVEsSUFBSSxLQUFLLFdBQVcsMkNBQTJDLEVBQUUsaUJBQWlCLDBCQUEwQixnQkFBZ0Isa0JBQWtCLDZCQUE2Qix5QkFBeUIsa0RBQWtELEtBQUssVUFBVSxPQUFPLHFCQUFxQixLQUFLLFdBQVcsNkJBQTZCLEtBQUssU0FBUyxRQUFRLGlCQUFpQjtBQUMzYSxhQUFhLHdDQUF3QyxhQUFhLGFBQWEsNkJBQTZCLElBQUksU0FBUyxJQUFJLFVBQVUsUUFBUSxxQkFBcUIsVUFBVSxNQUFNLHNDQUFzQyxNQUFNLDZDQUE2QyxtQ0FBbUMsb0JBQW9CLGFBQWEscUJBQXFCLGtCQUFrQixRQUFRLGNBQWMsSUFBSSxjQUFjLGdCQUFnQixlQUFlLDBCQUEwQjtBQUN6ZCw2QkFBNkIsR0FBRyxrQ0FBa0MsR0FBRyw0QkFBNEIsR0FBRywrQkFBK0IsR0FBRywwQkFBMEIsTUFBTSxxQ0FBcUMsR0FBRywrQkFBK0IsYUFBYSxpQkFBaUIsa0NBQWtDLFlBQVk7QUFDelQsK0JBQStCLGFBQWEsdUtBQXVLLHdDQUF3QyxZQUFZLFVBQVUscUNBQXFDLFlBQVksYUFBYSxxQkFBcUIsYUFBYSxVQUFVLDZCQUE2QixNQUFNLFlBQVksUUFBUSxJQUFJLElBQUksV0FBVyxRQUFRLE1BQU0sK0JBQStCO0FBQ2xmLDZCQUE2QixjQUFjLGdDQUFnQyxlQUFlLFVBQVUseUNBQXlDLFlBQVksUUFBUSxJQUFJLElBQUksV0FBVyxRQUFRO0FBQzVMLGlDQUFpQyxpQkFBaUIsNkJBQTZCLCtFQUErRSxVQUFVLGdCQUFnQixNQUFNLGFBQWEsTUFBTSxvQkFBb0IsTUFBTSxhQUFhLE1BQU0sY0FBYyxNQUFNLEdBQUcsNkVBQTZFLHlIQUF5SDtBQUMzZCw0QkFBNEIsR0FBRyw2QkFBNkIsYUFBYSxRQUFRLGtCQUFrQixRQUFRLElBQUksSUFBSSwrQkFBK0IsUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL3J0c3Atc3RyZWFtLXZpZXdlci8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcz9mYjA3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHNjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7ZnVuY3Rpb24gZihhLGIpe3ZhciBjPWEubGVuZ3RoO2EucHVzaChiKTthOmZvcig7MDxjOyl7dmFyIGQ9Yy0xPj4+MSxlPWFbZF07aWYoMDxnKGUsYikpYVtkXT1iLGFbY109ZSxjPWQ7ZWxzZSBicmVhayBhfX1mdW5jdGlvbiBoKGEpe3JldHVybiAwPT09YS5sZW5ndGg/bnVsbDphWzBdfWZ1bmN0aW9uIGsoYSl7aWYoMD09PWEubGVuZ3RoKXJldHVybiBudWxsO3ZhciBiPWFbMF0sYz1hLnBvcCgpO2lmKGMhPT1iKXthWzBdPWM7YTpmb3IodmFyIGQ9MCxlPWEubGVuZ3RoLHc9ZT4+PjE7ZDx3Oyl7dmFyIG09MiooZCsxKS0xLEM9YVttXSxuPW0rMSx4PWFbbl07aWYoMD5nKEMsYykpbjxlJiYwPmcoeCxDKT8oYVtkXT14LGFbbl09YyxkPW4pOihhW2RdPUMsYVttXT1jLGQ9bSk7ZWxzZSBpZihuPGUmJjA+Zyh4LGMpKWFbZF09eCxhW25dPWMsZD1uO2Vsc2UgYnJlYWsgYX19cmV0dXJuIGJ9XG5mdW5jdGlvbiBnKGEsYil7dmFyIGM9YS5zb3J0SW5kZXgtYi5zb3J0SW5kZXg7cmV0dXJuIDAhPT1jP2M6YS5pZC1iLmlkfWlmKFwib2JqZWN0XCI9PT10eXBlb2YgcGVyZm9ybWFuY2UmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBwZXJmb3JtYW5jZS5ub3cpe3ZhciBsPXBlcmZvcm1hbmNlO2V4cG9ydHMudW5zdGFibGVfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIGwubm93KCl9fWVsc2V7dmFyIHA9RGF0ZSxxPXAubm93KCk7ZXhwb3J0cy51bnN0YWJsZV9ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gcC5ub3coKS1xfX12YXIgcj1bXSx0PVtdLHU9MSx2PW51bGwseT0zLHo9ITEsQT0hMSxCPSExLEQ9XCJmdW5jdGlvblwiPT09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDpudWxsLEU9XCJmdW5jdGlvblwiPT09dHlwZW9mIGNsZWFyVGltZW91dD9jbGVhclRpbWVvdXQ6bnVsbCxGPVwidW5kZWZpbmVkXCIhPT10eXBlb2Ygc2V0SW1tZWRpYXRlP3NldEltbWVkaWF0ZTpudWxsO1xuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBuYXZpZ2F0b3ImJnZvaWQgMCE9PW5hdmlnYXRvci5zY2hlZHVsaW5nJiZ2b2lkIDAhPT1uYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZyYmbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcuYmluZChuYXZpZ2F0b3Iuc2NoZWR1bGluZyk7ZnVuY3Rpb24gRyhhKXtmb3IodmFyIGI9aCh0KTtudWxsIT09Yjspe2lmKG51bGw9PT1iLmNhbGxiYWNrKWsodCk7ZWxzZSBpZihiLnN0YXJ0VGltZTw9YSlrKHQpLGIuc29ydEluZGV4PWIuZXhwaXJhdGlvblRpbWUsZihyLGIpO2Vsc2UgYnJlYWs7Yj1oKHQpfX1mdW5jdGlvbiBIKGEpe0I9ITE7RyhhKTtpZighQSlpZihudWxsIT09aChyKSlBPSEwLEkoSik7ZWxzZXt2YXIgYj1oKHQpO251bGwhPT1iJiZLKEgsYi5zdGFydFRpbWUtYSl9fVxuZnVuY3Rpb24gSihhLGIpe0E9ITE7QiYmKEI9ITEsRShMKSxMPS0xKTt6PSEwO3ZhciBjPXk7dHJ5e0coYik7Zm9yKHY9aChyKTtudWxsIT09diYmKCEodi5leHBpcmF0aW9uVGltZT5iKXx8YSYmIU0oKSk7KXt2YXIgZD12LmNhbGxiYWNrO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkKXt2LmNhbGxiYWNrPW51bGw7eT12LnByaW9yaXR5TGV2ZWw7dmFyIGU9ZCh2LmV4cGlyYXRpb25UaW1lPD1iKTtiPWV4cG9ydHMudW5zdGFibGVfbm93KCk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGU/di5jYWxsYmFjaz1lOnY9PT1oKHIpJiZrKHIpO0coYil9ZWxzZSBrKHIpO3Y9aChyKX1pZihudWxsIT09dil2YXIgdz0hMDtlbHNle3ZhciBtPWgodCk7bnVsbCE9PW0mJksoSCxtLnN0YXJ0VGltZS1iKTt3PSExfXJldHVybiB3fWZpbmFsbHl7dj1udWxsLHk9Yyx6PSExfX12YXIgTj0hMSxPPW51bGwsTD0tMSxQPTUsUT0tMTtcbmZ1bmN0aW9uIE0oKXtyZXR1cm4gZXhwb3J0cy51bnN0YWJsZV9ub3coKS1RPFA/ITE6ITB9ZnVuY3Rpb24gUigpe2lmKG51bGwhPT1PKXt2YXIgYT1leHBvcnRzLnVuc3RhYmxlX25vdygpO1E9YTt2YXIgYj0hMDt0cnl7Yj1PKCEwLGEpfWZpbmFsbHl7Yj9TKCk6KE49ITEsTz1udWxsKX19ZWxzZSBOPSExfXZhciBTO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBGKVM9ZnVuY3Rpb24oKXtGKFIpfTtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgTWVzc2FnZUNoYW5uZWwpe3ZhciBUPW5ldyBNZXNzYWdlQ2hhbm5lbCxVPVQucG9ydDI7VC5wb3J0MS5vbm1lc3NhZ2U9UjtTPWZ1bmN0aW9uKCl7VS5wb3N0TWVzc2FnZShudWxsKX19ZWxzZSBTPWZ1bmN0aW9uKCl7RChSLDApfTtmdW5jdGlvbiBJKGEpe089YTtOfHwoTj0hMCxTKCkpfWZ1bmN0aW9uIEsoYSxiKXtMPUQoZnVuY3Rpb24oKXthKGV4cG9ydHMudW5zdGFibGVfbm93KCkpfSxiKX1cbmV4cG9ydHMudW5zdGFibGVfSWRsZVByaW9yaXR5PTU7ZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eT0xO2V4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHk9NDtleHBvcnRzLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5PTM7ZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmc9bnVsbDtleHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5PTI7ZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjaz1mdW5jdGlvbihhKXthLmNhbGxiYWNrPW51bGx9O2V4cG9ydHMudW5zdGFibGVfY29udGludWVFeGVjdXRpb249ZnVuY3Rpb24oKXtBfHx6fHwoQT0hMCxJKEopKX07XG5leHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlPWZ1bmN0aW9uKGEpezA+YXx8MTI1PGE/Y29uc29sZS5lcnJvcihcImZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCBmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZFwiKTpQPTA8YT9NYXRoLmZsb29yKDFFMy9hKTo1fTtleHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsPWZ1bmN0aW9uKCl7cmV0dXJuIHl9O2V4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gaChyKX07ZXhwb3J0cy51bnN0YWJsZV9uZXh0PWZ1bmN0aW9uKGEpe3N3aXRjaCh5KXtjYXNlIDE6Y2FzZSAyOmNhc2UgMzp2YXIgYj0zO2JyZWFrO2RlZmF1bHQ6Yj15fXZhciBjPXk7eT1iO3RyeXtyZXR1cm4gYSgpfWZpbmFsbHl7eT1jfX07ZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbj1mdW5jdGlvbigpe307XG5leHBvcnRzLnVuc3RhYmxlX3JlcXVlc3RQYWludD1mdW5jdGlvbigpe307ZXhwb3J0cy51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHk9ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYSl7Y2FzZSAxOmNhc2UgMjpjYXNlIDM6Y2FzZSA0OmNhc2UgNTpicmVhaztkZWZhdWx0OmE9M312YXIgYz15O3k9YTt0cnl7cmV0dXJuIGIoKX1maW5hbGx5e3k9Y319O1xuZXhwb3J0cy51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1leHBvcnRzLnVuc3RhYmxlX25vdygpO1wib2JqZWN0XCI9PT10eXBlb2YgYyYmbnVsbCE9PWM/KGM9Yy5kZWxheSxjPVwibnVtYmVyXCI9PT10eXBlb2YgYyYmMDxjP2QrYzpkKTpjPWQ7c3dpdGNoKGEpe2Nhc2UgMTp2YXIgZT0tMTticmVhaztjYXNlIDI6ZT0yNTA7YnJlYWs7Y2FzZSA1OmU9MTA3Mzc0MTgyMzticmVhaztjYXNlIDQ6ZT0xRTQ7YnJlYWs7ZGVmYXVsdDplPTVFM31lPWMrZTthPXtpZDp1KyssY2FsbGJhY2s6Yixwcmlvcml0eUxldmVsOmEsc3RhcnRUaW1lOmMsZXhwaXJhdGlvblRpbWU6ZSxzb3J0SW5kZXg6LTF9O2M+ZD8oYS5zb3J0SW5kZXg9YyxmKHQsYSksbnVsbD09PWgocikmJmE9PT1oKHQpJiYoQj8oRShMKSxMPS0xKTpCPSEwLEsoSCxjLWQpKSk6KGEuc29ydEluZGV4PWUsZihyLGEpLEF8fHp8fChBPSEwLEkoSikpKTtyZXR1cm4gYX07XG5leHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkPU07ZXhwb3J0cy51bnN0YWJsZV93cmFwQ2FsbGJhY2s9ZnVuY3Rpb24oYSl7dmFyIGI9eTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYz15O3k9Yjt0cnl7cmV0dXJuIGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbmFsbHl7eT1jfX19O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///463\n')},982:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(463);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBNkQ7QUFDL0QsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ydHNwLXN0cmVhbS12aWV3ZXIvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzPzQwMjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///982\n")},176:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.initRTSPStreamPanel = initRTSPStreamPanel;\nconst jsx_runtime_1 = __webpack_require__(848);\nconst react_1 = __webpack_require__(540);\nconst hls_js_1 = __importStar(__webpack_require__(473));\nconst client_1 = __webpack_require__(338);\nfunction RTSPStreamPanel({ context }) {\n    const [streamUrl, setStreamUrl] = (0, react_1.useState)("http://localhost:8888/stream/index.m3u8");\n    const [isConnected, setIsConnected] = (0, react_1.useState)(false);\n    const [error, setError] = (0, react_1.useState)(null);\n    const [renderDone, setRenderDone] = (0, react_1.useState)();\n    const videoRef = (0, react_1.useRef)(null);\n    const hlsRef = (0, react_1.useRef)(null);\n    // Setup render handler\n    (0, react_1.useLayoutEffect)(() => {\n        context.onRender = (_, done) => {\n            setRenderDone(() => done);\n        };\n        // We don\'t need to watch any specific ROS topics for RTSP streaming\n        // But we still need a render handler to keep the panel active\n    }, [context]);\n    // invoke the done callback once the render is complete\n    (0, react_1.useEffect)(() => {\n        renderDone?.();\n    }, [renderDone]);\n    // Convert an RTSP URL to the equivalent HLS URL served by rtsp-simple-server\n    const rtspToHls = (url) => {\n        try {\n            const u = new URL(url);\n            // Use same hostname, default HLS port 8888, and same path with /index.m3u8 suffix\n            const host = u.hostname || "localhost";\n            const path = u.pathname.replace(/^\\/+/, "");\n            const hlsPath = path.length > 0 ? `${path}/index.m3u8` : "index.m3u8";\n            return `http://${host}:8888/${hlsPath}`;\n        }\n        catch {\n            return url;\n        }\n    };\n    // Simple stream connection (supports HLS via hls.js and native formats)\n    const connectToStream = async () => {\n        try {\n            setError(null);\n            setIsConnected(false);\n            if (!videoRef.current) {\n                throw new Error("Video element not available");\n            }\n            const video = videoRef.current;\n            // Cleanup any existing HLS instance before re-connecting\n            if (hlsRef.current) {\n                hlsRef.current.destroy();\n                hlsRef.current = null;\n            }\n            // Normalize URL: if RTSP, translate to HLS\n            const normalizedUrl = /^rtsp(s)?:\\/\\//i.test(streamUrl) ? rtspToHls(streamUrl) : streamUrl;\n            console.log(`Connecting to: ${normalizedUrl}`);\n            // Reset the element before attaching a new source\n            video.pause();\n            video.removeAttribute("src");\n            video.load();\n            video.onloadstart = () => {\n                console.log("Starting to load stream...");\n            };\n            video.oncanplay = () => {\n                setIsConnected(true);\n                console.log("Stream ready to play");\n            };\n            video.onloadedmetadata = () => {\n                console.log(`Video loaded: ${video.videoWidth}x${video.videoHeight}`);\n            };\n            video.onerror = () => {\n                let errorMsg = "Failed to load stream";\n                if (video.error) {\n                    switch (video.error.code) {\n                        case video.error.MEDIA_ERR_ABORTED:\n                            errorMsg = "Stream loading aborted";\n                            break;\n                        case video.error.MEDIA_ERR_NETWORK:\n                            errorMsg = "Network error - check URL and connectivity";\n                            break;\n                        case video.error.MEDIA_ERR_DECODE:\n                            errorMsg = "Cannot decode stream - unsupported format";\n                            break;\n                        case video.error.MEDIA_ERR_SRC_NOT_SUPPORTED:\n                            errorMsg = "Stream format not supported by browser";\n                            break;\n                        default:\n                            errorMsg = `Media error code: ${video.error.code}`;\n                    }\n                }\n                setError(errorMsg);\n                setIsConnected(false);\n            };\n            const isHls = /\\.m3u8(\\?.*)?$/i.test(normalizedUrl);\n            if (isHls) {\n                if (hls_js_1.default.isSupported()) {\n                    const hls = new hls_js_1.default({\n                        // Favor low latency if configured that way server-side\n                        lowLatencyMode: true,\n                        // Allow cross-origin fetches (server should send CORS headers)\n                        // debug: true,\n                    });\n                    hlsRef.current = hls;\n                    hls.on(hls_js_1.Events.ERROR, (_evt, data) => {\n                        if (data?.fatal) {\n                            switch (data.type) {\n                                case hls_js_1.ErrorTypes.NETWORK_ERROR:\n                                    setError("HLS network error - check server and CORS");\n                                    hls.startLoad();\n                                    break;\n                                case hls_js_1.ErrorTypes.MEDIA_ERROR:\n                                    setError("HLS media error - attempting recovery");\n                                    hls.recoverMediaError();\n                                    break;\n                                default:\n                                    setError("Fatal HLS error");\n                                    hls.destroy();\n                                    hlsRef.current = null;\n                            }\n                            setIsConnected(false);\n                        }\n                    });\n                    hls.loadSource(normalizedUrl);\n                    hls.attachMedia(video);\n                }\n                else if (video.canPlayType("application/vnd.apple.mpegurl")) {\n                    // Safari (and some environments) can play HLS natively\n                    video.src = normalizedUrl;\n                    video.load();\n                }\n                else {\n                    setError("HLS not supported in this environment");\n                    setIsConnected(false);\n                    return;\n                }\n            }\n            else {\n                // Non-HLS: try direct\n                video.src = normalizedUrl;\n                video.load();\n            }\n            // Try autoplay immediately; if it fails, try again on canplay\n            const tryPlay = async () => {\n                try {\n                    await video.play();\n                    setError(null);\n                }\n                catch (err) {\n                    console.warn("Auto-play failed:", err);\n                    setError(`Auto-play failed: ${err instanceof Error ? err.message : String(err)}. Click play button manually.`);\n                }\n            };\n            void tryPlay();\n            const handleCanPlay = () => void tryPlay();\n            video.addEventListener("canplay", handleCanPlay, { once: true });\n        }\n        catch (err) {\n            console.error("Connection error:", err);\n            setError(`Connection error: ${err instanceof Error ? err.message : String(err)}`);\n            setIsConnected(false);\n        }\n    };\n    const disconnectFromStream = () => {\n        if (videoRef.current) {\n            videoRef.current.pause();\n            videoRef.current.removeAttribute("src");\n            videoRef.current.load();\n        }\n        if (hlsRef.current) {\n            hlsRef.current.destroy();\n            hlsRef.current = null;\n        }\n        setIsConnected(false);\n        setError(null);\n    };\n    return ((0, jsx_runtime_1.jsxs)("div", { style: { padding: "1rem", height: "100%", display: "flex", flexDirection: "column" }, children: [(0, jsx_runtime_1.jsx)("h2", { children: "Video Stream Viewer" }), (0, jsx_runtime_1.jsxs)("div", { style: { marginBottom: "1rem" }, children: [(0, jsx_runtime_1.jsx)("label", { htmlFor: "stream-url", style: { display: "block", marginBottom: "0.5rem" }, children: "Stream URL:" }), (0, jsx_runtime_1.jsxs)("div", { style: { display: "flex", gap: "0.5rem" }, children: [(0, jsx_runtime_1.jsx)("input", { id: "stream-url", type: "text", value: streamUrl, onChange: (e) => setStreamUrl(e.target.value), placeholder: "http://localhost:8888/stream/index.m3u8", style: {\n                                    flex: 1,\n                                    padding: "0.5rem",\n                                    border: "1px solid #ccc",\n                                    borderRadius: "4px",\n                                }, disabled: isConnected }), (0, jsx_runtime_1.jsx)("button", { onClick: isConnected ? disconnectFromStream : connectToStream, style: {\n                                    padding: "0.5rem 1rem",\n                                    backgroundColor: isConnected ? "#dc3545" : "#007bff",\n                                    color: "white",\n                                    border: "none",\n                                    borderRadius: "4px",\n                                    cursor: "pointer",\n                                }, children: isConnected ? "Disconnect" : "Connect" })] }), (0, jsx_runtime_1.jsxs)("div", { style: { fontSize: "0.8rem", color: "#666", marginTop: "0.25rem" }, children: ["Supports: HLS (.m3u8 via hls.js), MP4, WebM, MJPEG streams. If you have an RTSP URL, it will be auto-converted to HLS as ", (0, jsx_runtime_1.jsx)("code", { children: "http://host:8888/your_path/index.m3u8" }), "."] })] }), (0, jsx_runtime_1.jsxs)("div", { style: { marginBottom: "1rem" }, children: [(0, jsx_runtime_1.jsx)("span", { style: {\n                            display: "inline-block",\n                            padding: "0.25rem 0.5rem",\n                            borderRadius: "4px",\n                            fontSize: "0.8rem",\n                            backgroundColor: isConnected ? "#28a745" : error ? "#dc3545" : "#6c757d",\n                            color: "white",\n                        }, children: isConnected ? "Connected" : error ? "Error" : "Disconnected" }), error && ((0, jsx_runtime_1.jsx)("div", { style: { color: "#dc3545", fontSize: "0.9rem", marginTop: "0.25rem" }, children: error }))] }), (0, jsx_runtime_1.jsxs)("div", { style: { flex: 1, minHeight: "300px", backgroundColor: "#000", borderRadius: "4px", position: "relative" }, children: [(0, jsx_runtime_1.jsx)("video", { ref: videoRef, style: {\n                            width: "100%",\n                            height: "100%",\n                            objectFit: "contain",\n                        }, controls: true, muted: true, playsInline: true, crossOrigin: "anonymous" }), !isConnected && !error && ((0, jsx_runtime_1.jsxs)("div", { style: {\n                            position: "absolute",\n                            top: "50%",\n                            left: "50%",\n                            transform: "translate(-50%, -50%)",\n                            color: "white",\n                            textAlign: "center",\n                        }, children: [(0, jsx_runtime_1.jsx)("p", { children: "Enter RTSP URL and click Connect to view stream" }), (0, jsx_runtime_1.jsxs)("p", { style: { fontSize: "0.8rem", opacity: 0.7 }, children: ["Note: Direct RTSP playback may not work in all browsers.", (0, jsx_runtime_1.jsx)("br", {}), "For production use, consider using WebRTC or HLS/DASH conversion."] })] }))] }), isConnected && videoRef.current && ((0, jsx_runtime_1.jsxs)("div", { style: { marginTop: "1rem", fontSize: "0.9rem", color: "#666" }, children: [(0, jsx_runtime_1.jsxs)("div", { children: ["Resolution: ", videoRef.current.videoWidth, "x", videoRef.current.videoHeight] }), (0, jsx_runtime_1.jsxs)("div", { children: ["URL: ", streamUrl] }), (0, jsx_runtime_1.jsx)("div", { children: "Status: Connected and playing" })] }))] }));\n}\nfunction initRTSPStreamPanel(context) {\n    const root = (0, client_1.createRoot)(context.panelElement);\n    root.render((0, jsx_runtime_1.jsx)(RTSPStreamPanel, { context: context }));\n    // Return a function to run when the panel is removed\n    return () => {\n        root.unmount();\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc2LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQixzQkFBc0IsbUJBQU8sQ0FBQyxHQUFtQjtBQUNqRCxnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFPO0FBQy9CLDhCQUE4QixtQkFBTyxDQUFDLEdBQVE7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsR0FBa0I7QUFDM0MsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQsNkJBQTZCLEtBQUssUUFBUSxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUIsR0FBRyxrQkFBa0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpREFBaUQ7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsWUFBWTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsaURBQWlEO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVMsMkVBQTJFLDRDQUE0QyxpQ0FBaUMsb0NBQW9DLFNBQVMsc0JBQXNCLCtDQUErQyxnQ0FBZ0MsMENBQTBDLDJCQUEyQixvQ0FBb0MsU0FBUyxnQ0FBZ0MsK0NBQStDO0FBQ2ppQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUIsc0NBQXNDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvREFBb0QsSUFBSSxvQ0FBb0MsU0FBUyx5REFBeUQsMktBQTJLLG1EQUFtRCxTQUFTLElBQUksb0NBQW9DLFNBQVMsc0JBQXNCLDhDQUE4QztBQUMzaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBFQUEwRSw2Q0FBNkMsU0FBUyw0REFBNEQsbUJBQW1CLEtBQUssb0NBQW9DLFNBQVMsaUdBQWlHLCtDQUErQztBQUMxYTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEVBQTRFLCtEQUErRDtBQUNwSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkNBQTJDLDZEQUE2RCxrQ0FBa0MsU0FBUyxrQ0FBa0Msd0dBQXdHLHlFQUF5RSxJQUFJLEtBQUssd0VBQXdFLFNBQVMsc0RBQXNELDhDQUE4Qyw0RkFBNEYsb0NBQW9DLGdDQUFnQyxtQ0FBbUMsMkNBQTJDLElBQUksS0FBSztBQUNwekI7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGtCQUFrQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcnRzcC1zdHJlYW0tdmlld2VyLy4vc3JjL1JUU1BTdHJlYW1QYW5lbC50c3g/ODhjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbml0UlRTUFN0cmVhbVBhbmVsID0gaW5pdFJUU1BTdHJlYW1QYW5lbDtcbmNvbnN0IGpzeF9ydW50aW1lXzEgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgaGxzX2pzXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImhscy5qc1wiKSk7XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCJyZWFjdC1kb20vY2xpZW50XCIpO1xuZnVuY3Rpb24gUlRTUFN0cmVhbVBhbmVsKHsgY29udGV4dCB9KSB7XG4gICAgY29uc3QgW3N0cmVhbVVybCwgc2V0U3RyZWFtVXJsXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShcImh0dHA6Ly9sb2NhbGhvc3Q6ODg4OC9zdHJlYW0vaW5kZXgubTN1OFwiKTtcbiAgICBjb25zdCBbaXNDb25uZWN0ZWQsIHNldElzQ29ubmVjdGVkXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkobnVsbCk7XG4gICAgY29uc3QgW3JlbmRlckRvbmUsIHNldFJlbmRlckRvbmVdID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKCk7XG4gICAgY29uc3QgdmlkZW9SZWYgPSAoMCwgcmVhY3RfMS51c2VSZWYpKG51bGwpO1xuICAgIGNvbnN0IGhsc1JlZiA9ICgwLCByZWFjdF8xLnVzZVJlZikobnVsbCk7XG4gICAgLy8gU2V0dXAgcmVuZGVyIGhhbmRsZXJcbiAgICAoMCwgcmVhY3RfMS51c2VMYXlvdXRFZmZlY3QpKCgpID0+IHtcbiAgICAgICAgY29udGV4dC5vblJlbmRlciA9IChfLCBkb25lKSA9PiB7XG4gICAgICAgICAgICBzZXRSZW5kZXJEb25lKCgpID0+IGRvbmUpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHdhdGNoIGFueSBzcGVjaWZpYyBST1MgdG9waWNzIGZvciBSVFNQIHN0cmVhbWluZ1xuICAgICAgICAvLyBCdXQgd2Ugc3RpbGwgbmVlZCBhIHJlbmRlciBoYW5kbGVyIHRvIGtlZXAgdGhlIHBhbmVsIGFjdGl2ZVxuICAgIH0sIFtjb250ZXh0XSk7XG4gICAgLy8gaW52b2tlIHRoZSBkb25lIGNhbGxiYWNrIG9uY2UgdGhlIHJlbmRlciBpcyBjb21wbGV0ZVxuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgICAgICByZW5kZXJEb25lPy4oKTtcbiAgICB9LCBbcmVuZGVyRG9uZV0pO1xuICAgIC8vIENvbnZlcnQgYW4gUlRTUCBVUkwgdG8gdGhlIGVxdWl2YWxlbnQgSExTIFVSTCBzZXJ2ZWQgYnkgcnRzcC1zaW1wbGUtc2VydmVyXG4gICAgY29uc3QgcnRzcFRvSGxzID0gKHVybCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdSA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgICAgIC8vIFVzZSBzYW1lIGhvc3RuYW1lLCBkZWZhdWx0IEhMUyBwb3J0IDg4ODgsIGFuZCBzYW1lIHBhdGggd2l0aCAvaW5kZXgubTN1OCBzdWZmaXhcbiAgICAgICAgICAgIGNvbnN0IGhvc3QgPSB1Lmhvc3RuYW1lIHx8IFwibG9jYWxob3N0XCI7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gdS5wYXRobmFtZS5yZXBsYWNlKC9eXFwvKy8sIFwiXCIpO1xuICAgICAgICAgICAgY29uc3QgaGxzUGF0aCA9IHBhdGgubGVuZ3RoID4gMCA/IGAke3BhdGh9L2luZGV4Lm0zdThgIDogXCJpbmRleC5tM3U4XCI7XG4gICAgICAgICAgICByZXR1cm4gYGh0dHA6Ly8ke2hvc3R9Ojg4ODgvJHtobHNQYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gU2ltcGxlIHN0cmVhbSBjb25uZWN0aW9uIChzdXBwb3J0cyBITFMgdmlhIGhscy5qcyBhbmQgbmF0aXZlIGZvcm1hdHMpXG4gICAgY29uc3QgY29ubmVjdFRvU3RyZWFtID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XG4gICAgICAgICAgICBpZiAoIXZpZGVvUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWRlbyBlbGVtZW50IG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2aWRlbyA9IHZpZGVvUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAvLyBDbGVhbnVwIGFueSBleGlzdGluZyBITFMgaW5zdGFuY2UgYmVmb3JlIHJlLWNvbm5lY3RpbmdcbiAgICAgICAgICAgIGlmIChobHNSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGhsc1JlZi5jdXJyZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBobHNSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgVVJMOiBpZiBSVFNQLCB0cmFuc2xhdGUgdG8gSExTXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkVXJsID0gL15ydHNwKHMpPzpcXC9cXC8vaS50ZXN0KHN0cmVhbVVybCkgPyBydHNwVG9IbHMoc3RyZWFtVXJsKSA6IHN0cmVhbVVybDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDb25uZWN0aW5nIHRvOiAke25vcm1hbGl6ZWRVcmx9YCk7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZWxlbWVudCBiZWZvcmUgYXR0YWNoaW5nIGEgbmV3IHNvdXJjZVxuICAgICAgICAgICAgdmlkZW8ucGF1c2UoKTtcbiAgICAgICAgICAgIHZpZGVvLnJlbW92ZUF0dHJpYnV0ZShcInNyY1wiKTtcbiAgICAgICAgICAgIHZpZGVvLmxvYWQoKTtcbiAgICAgICAgICAgIHZpZGVvLm9ubG9hZHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3RhcnRpbmcgdG8gbG9hZCBzdHJlYW0uLi5cIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmlkZW8ub25jYW5wbGF5ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3RyZWFtIHJlYWR5IHRvIHBsYXlcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmlkZW8ub25sb2FkZWRtZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVmlkZW8gbG9hZGVkOiAke3ZpZGVvLnZpZGVvV2lkdGh9eCR7dmlkZW8udmlkZW9IZWlnaHR9YCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmlkZW8ub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JNc2cgPSBcIkZhaWxlZCB0byBsb2FkIHN0cmVhbVwiO1xuICAgICAgICAgICAgICAgIGlmICh2aWRlby5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZpZGVvLmVycm9yLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdmlkZW8uZXJyb3IuTUVESUFfRVJSX0FCT1JURUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNc2cgPSBcIlN0cmVhbSBsb2FkaW5nIGFib3J0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdmlkZW8uZXJyb3IuTUVESUFfRVJSX05FVFdPUks6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNc2cgPSBcIk5ldHdvcmsgZXJyb3IgLSBjaGVjayBVUkwgYW5kIGNvbm5lY3Rpdml0eVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB2aWRlby5lcnJvci5NRURJQV9FUlJfREVDT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTXNnID0gXCJDYW5ub3QgZGVjb2RlIHN0cmVhbSAtIHVuc3VwcG9ydGVkIGZvcm1hdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB2aWRlby5lcnJvci5NRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURUQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNc2cgPSBcIlN0cmVhbSBmb3JtYXQgbm90IHN1cHBvcnRlZCBieSBicm93c2VyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTXNnID0gYE1lZGlhIGVycm9yIGNvZGU6ICR7dmlkZW8uZXJyb3IuY29kZX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldEVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgICAgICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaXNIbHMgPSAvXFwubTN1OChcXD8uKik/JC9pLnRlc3Qobm9ybWFsaXplZFVybCk7XG4gICAgICAgICAgICBpZiAoaXNIbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGxzX2pzXzEuZGVmYXVsdC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhscyA9IG5ldyBobHNfanNfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhdm9yIGxvdyBsYXRlbmN5IGlmIGNvbmZpZ3VyZWQgdGhhdCB3YXkgc2VydmVyLXNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd0xhdGVuY3lNb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgY3Jvc3Mtb3JpZ2luIGZldGNoZXMgKHNlcnZlciBzaG91bGQgc2VuZCBDT1JTIGhlYWRlcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWJ1ZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGhsc1JlZi5jdXJyZW50ID0gaGxzO1xuICAgICAgICAgICAgICAgICAgICBobHMub24oaGxzX2pzXzEuRXZlbnRzLkVSUk9SLCAoX2V2dCwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGE/LmZhdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBobHNfanNfMS5FcnJvclR5cGVzLk5FVFdPUktfRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcihcIkhMUyBuZXR3b3JrIGVycm9yIC0gY2hlY2sgc2VydmVyIGFuZCBDT1JTXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGxzLnN0YXJ0TG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaGxzX2pzXzEuRXJyb3JUeXBlcy5NRURJQV9FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKFwiSExTIG1lZGlhIGVycm9yIC0gYXR0ZW1wdGluZyByZWNvdmVyeVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhscy5yZWNvdmVyTWVkaWFFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcihcIkZhdGFsIEhMUyBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhscy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBobHNSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGhscy5sb2FkU291cmNlKG5vcm1hbGl6ZWRVcmwpO1xuICAgICAgICAgICAgICAgICAgICBobHMuYXR0YWNoTWVkaWEodmlkZW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2aWRlby5jYW5QbGF5VHlwZShcImFwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVndXJsXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSAoYW5kIHNvbWUgZW52aXJvbm1lbnRzKSBjYW4gcGxheSBITFMgbmF0aXZlbHlcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uc3JjID0gbm9ybWFsaXplZFVybDtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8ubG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoXCJITFMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb24tSExTOiB0cnkgZGlyZWN0XG4gICAgICAgICAgICAgICAgdmlkZW8uc3JjID0gbm9ybWFsaXplZFVybDtcbiAgICAgICAgICAgICAgICB2aWRlby5sb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUcnkgYXV0b3BsYXkgaW1tZWRpYXRlbHk7IGlmIGl0IGZhaWxzLCB0cnkgYWdhaW4gb24gY2FucGxheVxuICAgICAgICAgICAgY29uc3QgdHJ5UGxheSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB2aWRlby5wbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkF1dG8tcGxheSBmYWlsZWQ6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHNldEVycm9yKGBBdXRvLXBsYXkgZmFpbGVkOiAke2VyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBTdHJpbmcoZXJyKX0uIENsaWNrIHBsYXkgYnV0dG9uIG1hbnVhbGx5LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2b2lkIHRyeVBsYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNhblBsYXkgPSAoKSA9PiB2b2lkIHRyeVBsYXkoKTtcbiAgICAgICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIGhhbmRsZUNhblBsYXksIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ29ubmVjdGlvbiBlcnJvcjpcIiwgZXJyKTtcbiAgICAgICAgICAgIHNldEVycm9yKGBDb25uZWN0aW9uIGVycm9yOiAke2VyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBTdHJpbmcoZXJyKX1gKTtcbiAgICAgICAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZGlzY29ubmVjdEZyb21TdHJlYW0gPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aWRlb1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICB2aWRlb1JlZi5jdXJyZW50LnBhdXNlKCk7XG4gICAgICAgICAgICB2aWRlb1JlZi5jdXJyZW50LnJlbW92ZUF0dHJpYnV0ZShcInNyY1wiKTtcbiAgICAgICAgICAgIHZpZGVvUmVmLmN1cnJlbnQubG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChobHNSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaGxzUmVmLmN1cnJlbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgaGxzUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNldElzQ29ubmVjdGVkKGZhbHNlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgc3R5bGU6IHsgcGFkZGluZzogXCIxcmVtXCIsIGhlaWdodDogXCIxMDAlXCIsIGRpc3BsYXk6IFwiZmxleFwiLCBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImgyXCIsIHsgY2hpbGRyZW46IFwiVmlkZW8gU3RyZWFtIFZpZXdlclwiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IHN0eWxlOiB7IG1hcmdpbkJvdHRvbTogXCIxcmVtXCIgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwibGFiZWxcIiwgeyBodG1sRm9yOiBcInN0cmVhbS11cmxcIiwgc3R5bGU6IHsgZGlzcGxheTogXCJibG9ja1wiLCBtYXJnaW5Cb3R0b206IFwiMC41cmVtXCIgfSwgY2hpbGRyZW46IFwiU3RyZWFtIFVSTDpcIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBzdHlsZTogeyBkaXNwbGF5OiBcImZsZXhcIiwgZ2FwOiBcIjAuNXJlbVwiIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImlucHV0XCIsIHsgaWQ6IFwic3RyZWFtLXVybFwiLCB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHN0cmVhbVVybCwgb25DaGFuZ2U6IChlKSA9PiBzZXRTdHJlYW1VcmwoZS50YXJnZXQudmFsdWUpLCBwbGFjZWhvbGRlcjogXCJodHRwOi8vbG9jYWxob3N0Ojg4ODgvc3RyZWFtL2luZGV4Lm0zdThcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsZXg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjAuNXJlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjY2NjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiNHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGRpc2FibGVkOiBpc0Nvbm5lY3RlZCB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImJ1dHRvblwiLCB7IG9uQ2xpY2s6IGlzQ29ubmVjdGVkID8gZGlzY29ubmVjdEZyb21TdHJlYW0gOiBjb25uZWN0VG9TdHJlYW0sIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjAuNXJlbSAxcmVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGlzQ29ubmVjdGVkID8gXCIjZGMzNTQ1XCIgOiBcIiMwMDdiZmZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjRweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGlzQ29ubmVjdGVkID8gXCJEaXNjb25uZWN0XCIgOiBcIkNvbm5lY3RcIiB9KV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgc3R5bGU6IHsgZm9udFNpemU6IFwiMC44cmVtXCIsIGNvbG9yOiBcIiM2NjZcIiwgbWFyZ2luVG9wOiBcIjAuMjVyZW1cIiB9LCBjaGlsZHJlbjogW1wiU3VwcG9ydHM6IEhMUyAoLm0zdTggdmlhIGhscy5qcyksIE1QNCwgV2ViTSwgTUpQRUcgc3RyZWFtcy4gSWYgeW91IGhhdmUgYW4gUlRTUCBVUkwsIGl0IHdpbGwgYmUgYXV0by1jb252ZXJ0ZWQgdG8gSExTIGFzIFwiLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiY29kZVwiLCB7IGNoaWxkcmVuOiBcImh0dHA6Ly9ob3N0Ojg4ODgveW91cl9wYXRoL2luZGV4Lm0zdThcIiB9KSwgXCIuXCJdIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBzdHlsZTogeyBtYXJnaW5Cb3R0b206IFwiMXJlbVwiIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInNwYW5cIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogXCIwLjI1cmVtIDAuNXJlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI0cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogXCIwLjhyZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGlzQ29ubmVjdGVkID8gXCIjMjhhNzQ1XCIgOiBlcnJvciA/IFwiI2RjMzU0NVwiIDogXCIjNmM3NTdkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBpc0Nvbm5lY3RlZCA/IFwiQ29ubmVjdGVkXCIgOiBlcnJvciA/IFwiRXJyb3JcIiA6IFwiRGlzY29ubmVjdGVkXCIgfSksIGVycm9yICYmICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiZGl2XCIsIHsgc3R5bGU6IHsgY29sb3I6IFwiI2RjMzU0NVwiLCBmb250U2l6ZTogXCIwLjlyZW1cIiwgbWFyZ2luVG9wOiBcIjAuMjVyZW1cIiB9LCBjaGlsZHJlbjogZXJyb3IgfSkpXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBzdHlsZTogeyBmbGV4OiAxLCBtaW5IZWlnaHQ6IFwiMzAwcHhcIiwgYmFja2dyb3VuZENvbG9yOiBcIiMwMDBcIiwgYm9yZGVyUmFkaXVzOiBcIjRweFwiLCBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInZpZGVvXCIsIHsgcmVmOiB2aWRlb1JlZiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RGaXQ6IFwiY29udGFpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29udHJvbHM6IHRydWUsIG11dGVkOiB0cnVlLCBwbGF5c0lubGluZTogdHJ1ZSwgY3Jvc3NPcmlnaW46IFwiYW5vbnltb3VzXCIgfSksICFpc0Nvbm5lY3RlZCAmJiAhZXJyb3IgJiYgKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCI1MCVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIjUwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTUwJSwgLTUwJSlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInBcIiwgeyBjaGlsZHJlbjogXCJFbnRlciBSVFNQIFVSTCBhbmQgY2xpY2sgQ29ubmVjdCB0byB2aWV3IHN0cmVhbVwiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcInBcIiwgeyBzdHlsZTogeyBmb250U2l6ZTogXCIwLjhyZW1cIiwgb3BhY2l0eTogMC43IH0sIGNoaWxkcmVuOiBbXCJOb3RlOiBEaXJlY3QgUlRTUCBwbGF5YmFjayBtYXkgbm90IHdvcmsgaW4gYWxsIGJyb3dzZXJzLlwiLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiYnJcIiwge30pLCBcIkZvciBwcm9kdWN0aW9uIHVzZSwgY29uc2lkZXIgdXNpbmcgV2ViUlRDIG9yIEhMUy9EQVNIIGNvbnZlcnNpb24uXCJdIH0pXSB9KSldIH0pLCBpc0Nvbm5lY3RlZCAmJiB2aWRlb1JlZi5jdXJyZW50ICYmICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IHN0eWxlOiB7IG1hcmdpblRvcDogXCIxcmVtXCIsIGZvbnRTaXplOiBcIjAuOXJlbVwiLCBjb2xvcjogXCIjNjY2XCIgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IGNoaWxkcmVuOiBbXCJSZXNvbHV0aW9uOiBcIiwgdmlkZW9SZWYuY3VycmVudC52aWRlb1dpZHRoLCBcInhcIiwgdmlkZW9SZWYuY3VycmVudC52aWRlb0hlaWdodF0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2hpbGRyZW46IFtcIlVSTDogXCIsIHN0cmVhbVVybF0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJkaXZcIiwgeyBjaGlsZHJlbjogXCJTdGF0dXM6IENvbm5lY3RlZCBhbmQgcGxheWluZ1wiIH0pXSB9KSldIH0pKTtcbn1cbmZ1bmN0aW9uIGluaXRSVFNQU3RyZWFtUGFuZWwoY29udGV4dCkge1xuICAgIGNvbnN0IHJvb3QgPSAoMCwgY2xpZW50XzEuY3JlYXRlUm9vdCkoY29udGV4dC5wYW5lbEVsZW1lbnQpO1xuICAgIHJvb3QucmVuZGVyKCgwLCBqc3hfcnVudGltZV8xLmpzeCkoUlRTUFN0cmVhbVBhbmVsLCB7IGNvbnRleHQ6IGNvbnRleHQgfSkpO1xuICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSBwYW5lbCBpcyByZW1vdmVkXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcm9vdC51bm1vdW50KCk7XG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///176\n')},729:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.activate = activate;\nconst RTSPStreamPanel_1 = __webpack_require__(176);\nfunction activate(extensionContext) {\n    extensionContext.registerPanel({ name: "rtsp-stream-viewer", initPanel: RTSPStreamPanel_1.initRTSPStreamPanel });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQiwwQkFBMEIsbUJBQU8sQ0FBQyxHQUFtQjtBQUNyRDtBQUNBLHFDQUFxQyw4RUFBOEU7QUFDbkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ydHNwLXN0cmVhbS12aWV3ZXIvLi9zcmMvaW5kZXgudHM/MzNiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWN0aXZhdGUgPSBhY3RpdmF0ZTtcbmNvbnN0IFJUU1BTdHJlYW1QYW5lbF8xID0gcmVxdWlyZShcIi4vUlRTUFN0cmVhbVBhbmVsXCIpO1xuZnVuY3Rpb24gYWN0aXZhdGUoZXh0ZW5zaW9uQ29udGV4dCkge1xuICAgIGV4dGVuc2lvbkNvbnRleHQucmVnaXN0ZXJQYW5lbCh7IG5hbWU6IFwicnRzcC1zdHJlYW0tdmlld2VyXCIsIGluaXRQYW5lbDogUlRTUFN0cmVhbVBhbmVsXzEuaW5pdFJUU1BTdHJlYW1QYW5lbCB9KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///729\n')}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var t=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g].call(t.exports,t,t.exports,__webpack_require__),t.exports}var __webpack_exports__=__webpack_require__(729);module.exports=__webpack_exports__})();