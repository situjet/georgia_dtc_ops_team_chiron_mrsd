#!/usr/bin/env python3
"""
MAVLink UDP proxy / forwarder.

Purpose:
  Allow QGroundControl (remote operator host) to connect to an onboard MAVLink endpoint
  over a shared network by forwarding packets bidirectionally between two UDP endpoints.

Default topology (as requested):
  - Onboard computer (this machine) IP: 10.3.1.32
  - Operator platform running QGroundControl: 10.3.1.96
  - Typical autopilot broadcast/ listening port: 14550 (can vary)
  - We'll listen to the onboard autopilot on --autopilot (e.g. udp:0.0.0.0:14550) and
    create an outbound link to QGC at udpout:10.3.1.96:14550 by default.

Features:
  * Uses pymavlink mavutil.mavlink_connection
  * Separate receiver thread for each side, forwarding raw MAVLink packets (frame-level)
  * Heartbeat watchdog (optional) prints status
  * Graceful shutdown via SIGINT / SIGTERM

Usage examples:
  On the onboard machine (10.3.1.32):
    ./mavlink_proxy.py \
        --autopilot udp:0.0.0.0:14550 \
        --qgc 10.3.1.96 \
        --qgc-port 14550

  If autopilot is accessible via TCP (rare here but possible):
    ./mavlink_proxy.py --autopilot tcp:127.0.0.1:5760 --qgc 10.3.1.96

  Show help:
    ./mavlink_proxy.py -h

Limitations:
  * This is a simple best-effort forwarder; it does not de-duplicate multi-client streams.
  * If you already launch mavlink-router or mavproxy you may not need this.

Author: Copilot autogenerated
"""
import argparse
import os
import queue
import signal
import sys
import threading
import time
from typing import Optional
import socket

from pymavlink import mavutil

STOP_EVENT = threading.Event()


def _make_connection(endpoint: str, source_system: int = 255, source_component: int = 0, baud: int = 115200):
    """Create a mavlink connection for UDP/TCP or serial.

    endpoint examples:
      udp:0.0.0.0:14550
      udpout:10.3.1.96:14550
      tcp:127.0.0.1:5760
      /dev/ttyACM0 (serial)
    """
    return mavutil.mavlink_connection(
        endpoint,
        source_system=source_system,
        source_component=source_component,
        autoreconnect=True,
        baud=baud,
        robust_parsing=True,
    )


def forward_loop(name: str, src, dst, stats, idle_timeout: float = 0.0, debug_first: bool = False):
    """Continuously read raw MAVLink packets from src and write to dst.

    We use recv_msg to parse; then send the raw original packet bytes so
    framing is preserved. (msg.get_msgbuf())
    """
    last_any = time.time()
    while not STOP_EVENT.is_set():
        try:
            msg = src.recv_msg()
        except Exception as e:  # noqa
            continue
        if msg is None:
            if idle_timeout and (time.time() - last_any) > idle_timeout:
                print(f"[{name}] idle for {idle_timeout}s", flush=True)
                last_any = time.time()
            continue
        last_any = time.time()
        try:
            buf = msg.get_msgbuf()
            if buf:
                if msg.get_type() == 'HEARTBEAT':
                    stats['hb'] = stats.get('hb', 0) + 1
                    if debug_first and stats['hb'] == 1:
                        print(f"[{name}] First HEARTBEAT sysid={msg.get_srcSystem()} compid={msg.get_srcComponent()}")
                # dst can be a mavutil connection or a tuple ('rawudp', socket, (host,port))
                try:
                    if isinstance(dst, tuple) and dst and dst[0] == 'rawudp':
                        _sock = dst[1]
                        _addr = dst[2]
                        _sock.sendto(buf, _addr)
                    else:
                        # pymavlink connections expose write() on the connection object
                        # (dst.mav.write is not available for UDP/serial link objects)
                        dst.write(buf)
                    stats['fwd'] += 1
                except Exception:
                    stats['err'] += 1
        except Exception as e:  # noqa
            stats['err'] += 1


def heartbeat_monitor(link, name: str, stats):
    last_hb = 0.0
    while not STOP_EVENT.is_set():
        msg = link.recv_match(type='HEARTBEAT', blocking=False)
        if msg:
            last_hb = time.time()
            stats['hb'] = stats.get('hb', 0) + 1
        if time.time() - last_hb > 5:
            # Print every 5s if no heartbeat yet
            print(f"[{name}] waiting for HEARTBEAT... (fwd={stats.get('fwd',0)})", flush=True)
            last_hb = time.time()
        time.sleep(1.0)


def parse_args():
    p = argparse.ArgumentParser(description="Simple MAVLink UDP/TCP proxy")
    p.add_argument('--autopilot', default='udp:0.0.0.0:14550', help='Endpoint string to connect/listen to autopilot (e.g., udp:0.0.0.0:14550)')
    p.add_argument('--qgc', default='10.3.1.96', help='QGroundControl host to forward to')
    p.add_argument('--qgc-port', type=int, default=14550, help='Port QGroundControl listens on (default 14550)')
    p.add_argument('--bind-qgc-port', type=int, default=0, help='Optional local (source) port for GCS connection (0 = ephemeral)')
    p.add_argument('--source-system', type=int, default=255)
    p.add_argument('--source-component', type=int, default=0)
    p.add_argument('--print-stats', action='store_true', help='Periodically print forwarding counters')
    p.add_argument('--stats-interval', type=float, default=10.0)
    p.add_argument('--autopilot-baud', type=int, default=115200, help='Baud rate if autopilot endpoint is a serial device (e.g., /dev/ttyACM0)')
    p.add_argument('--debug-first', action='store_true', help='Print diagnostic info on first received HEARTBEAT in each direction')
    return p.parse_args()


def main():
    args = parse_args()

    # Build endpoint strings for GCS outbound link
    # pymavlink uses form udpout:host:port[:source_port]
    use_raw_udp = False
    if args.bind_qgc_port:
        # We'll create our own UDP socket bound to the requested local port and sendto() QGC.
        use_raw_udp = True
        gcs_host = args.qgc
        gcs_addr = (gcs_host, args.qgc_port)
        raw_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        raw_sock.bind(('0.0.0.0', args.bind_qgc_port))
        raw_sock.setblocking(False)
        gcs_link = ('rawudp', raw_sock, gcs_addr)  # type: ignore
        print(f"Forwarding to QGC (raw UDP) {gcs_host}:{args.qgc_port} from local port {args.bind_qgc_port}")
    else:
        gcs_endpoint = f"udpout:{args.qgc}:{args.qgc_port}"
        print(f"Forwarding to QGC at {gcs_endpoint}")
        gcs_link = _make_connection(gcs_endpoint, args.source_system, args.source_component)

    print(f"Connecting to autopilot via {args.autopilot}")
    autopilot_link = _make_connection(args.autopilot, args.source_system, args.source_component, baud=args.autopilot_baud)

    stats_a2g = {'fwd': 0, 'err': 0}
    stats_g2a = {'fwd': 0, 'err': 0}

    t1 = threading.Thread(target=forward_loop, args=('A->G', autopilot_link, gcs_link, stats_a2g, 0.0, args.debug_first), daemon=True)
    t2 = threading.Thread(target=forward_loop, args=('G->A', gcs_link, autopilot_link, stats_g2a, 0.0, args.debug_first), daemon=True)
    t1.start(); t2.start()

    def handle_sig(sig, frame):  # noqa
        print('Shutting down...')
        STOP_EVENT.set()
    signal.signal(signal.SIGINT, handle_sig)
    signal.signal(signal.SIGTERM, handle_sig)

    last_print = time.time()
    try:
        while not STOP_EVENT.is_set():
            time.sleep(0.5)
            if args.print_stats and (time.time() - last_print) > args.stats_interval:
                print(f"Stats: A->G fwd={stats_a2g['fwd']} hb={stats_a2g.get('hb',0)} err={stats_a2g['err']} | G->A fwd={stats_g2a['fwd']} hb={stats_g2a.get('hb',0)} err={stats_g2a['err']}")
                last_print = time.time()
    finally:
        STOP_EVENT.set()
        t1.join(timeout=1.0)
        t2.join(timeout=1.0)
        autopilot_link.close()
        if use_raw_udp:
            try:
                raw_sock.close()  # type: ignore
            except Exception:
                pass
        else:
            gcs_link.close()
        print('Proxy terminated.')


if __name__ == '__main__':
    main()
