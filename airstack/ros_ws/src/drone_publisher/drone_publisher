#!/usr/bin/env python3
import socket
import time
from typing import Tuple

import rclpy
from rclpy.node import Node
from rcl_interfaces.msg import ParameterDescriptor, ParameterType
from rclpy.serialization import serialize_message

from std_msgs.msg import Header
from sensor_msgs.msg import Image, NavSatFix
from dtc_network_msgs.msg import HumanDataMsg


class HumanDataTX(Node):
    """
    TX bridge (drone side, fuse mode only):
    - Subscribes to /camera/image_raw (Image) and /navsatfix5 (NavSatFix).
    - Builds HumanDataMsg with image + GPS + metadata.
    - Validates it.
    - Serializes and sends via UDP to the ground radio.
    """

    def __init__(self):
        super().__init__('human_data_tx')

        # ---------- Parameters ----------
        self.declare_parameter('camera_topic', '/camera/image_raw',
            ParameterDescriptor(type=ParameterType.PARAMETER_STRING))
        self.declare_parameter('gps_topic', '/navsatfix5',
            ParameterDescriptor(type=ParameterType.PARAMETER_STRING))
        self.declare_parameter('system_name', 'uav1',
            ParameterDescriptor(type=ParameterType.PARAMETER_STRING))
        self.declare_parameter('frame_id', 'camera_optical_frame',
            ParameterDescriptor(type=ParameterType.PARAMETER_STRING))
        self.declare_parameter('fps', 0,  # 0 = unlimited
            ParameterDescriptor(type=ParameterType.PARAMETER_INTEGER))

        self.declare_parameter('udp_ip', '192.168.50.106',
            ParameterDescriptor(type=ParameterType.PARAMETER_STRING))
        self.declare_parameter('udp_port', 5005,
            ParameterDescriptor(type=ParameterType.PARAMETER_INTEGER))
        self.declare_parameter('chunk_size', 1200,
            ParameterDescriptor(type=ParameterType.PARAMETER_INTEGER))
        self.declare_parameter('chunk_sleep_ms', 0,
            ParameterDescriptor(type=ParameterType.PARAMETER_INTEGER))

        # ---------- Get params ----------
        self.camera_topic = self.get_parameter('camera_topic').value
        self.gps_topic = self.get_parameter('gps_topic').value
        self.system_name = self.get_parameter('system_name').value
        self.frame_id = self.get_parameter('frame_id').value
        self.fps = int(self.get_parameter('fps').value)

        self.udp_ip = self.get_parameter('udp_ip').value
        self.udp_port = int(self.get_parameter('udp_port').value)
        self.chunk_size = int(self.get_parameter('chunk_size').value)
        self.chunk_sleep = max(0, int(self.get_parameter('chunk_sleep_ms').value)) / 1000.0

        # ---------- UDP socket ----------
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1 << 20)
        except Exception:
            pass

        # ---------- Throttle state ----------
        self._last_send_time_sec = 0.0
        self._min_period = (1.0 / self.fps) if self.fps > 0 else 0.0

        # ---------- Subscriptions ----------
        self.last_gps: NavSatFix | None = None
        self.create_subscription(NavSatFix, self.gps_topic, self._gps_cb, 10)
        self.create_subscription(Image, self.camera_topic, self._image_cb, 10)

        self.get_logger().info(
            f"[TX fuse] cam={self.camera_topic} gps={self.gps_topic} -> UDP {self.udp_ip}:{self.udp_port} "
            f"(fps={self.fps if self.fps>0 else 'unlimited'}, chunk={self.chunk_size})"
        )

    # ---------- Validation ----------
    def _valid_human_data(self, m) -> Tuple[bool, str]:
        if not getattr(m, 'system', ''):
            return False, "system is empty"
        gps = getattr(m, 'gps_data', None)
        if gps is None:
            return False, "gps_data is None"
        if not (-90.0 <= gps.latitude <= 90.0 and -180.0 <= gps.longitude <= 180.0):
            return False, "gps lat/lon out of range"
        has_raw = bool(m.raw_images)
        has_comp = bool(m.compressed_images)
        if not (has_raw ^ has_comp):
            return False, "must have exactly one of raw_images or compressed_images"
        if has_raw:
            img = m.raw_images[0]
            if img.height == 0 or img.width == 0 or not img.encoding or len(img.data) == 0:
                return False, "raw image invalid (shape/encoding/data)"
        if m.header.stamp.sec == 0 and m.header.stamp.nanosec == 0:
            return False, "header.stamp is zero"
        return True, ""

    # ---------- Callbacks ----------
    def _gps_cb(self, msg: NavSatFix):
        self.last_gps = msg

    def _image_cb(self, img: Image):
        if self.last_gps is None:
            return

        # throttle
        if self._min_period > 0.0:
            now_sec = self.get_clock().now().nanoseconds / 1e9
            if (now_sec - self._last_send_time_sec) < self._min_period:
                return
            self._last_send_time_sec = now_sec

        # build HumanDataMsg
        now = self.get_clock().now().to_msg()
        hd = HumanDataMsg()
        hd.header = Header(stamp=now, frame_id=(img.header.frame_id or self.frame_id))
        hd.stamp = now
        hd.system = self.system_name
        hd.gps_data = self.last_gps
        hd.raw_images = [img]
        hd.compressed_images = []

        ok, why = self._valid_human_data(hd)
        if not ok:
            self.get_logger().warn(f"Not sending invalid HumanDataMsg: {why}")
            return

        self._send_bytes(hd)

    # ---------- UDP send ----------
    def _send_bytes(self, ros_msg):
        try:
            blob = serialize_message(ros_msg)
            self.sock.sendto(b'__start__', (self.udp_ip, self.udp_port))
            for i in range(0, len(blob), self.chunk_size):
                self.sock.sendto(blob[i:i+self.chunk_size], (self.udp_ip, self.udp_port))
                if self.chunk_sleep > 0:
                    time.sleep(self.chunk_sleep)
            self.sock.sendto(b'__end__', (self.udp_ip, self.udp_port))
        except Exception as e:
            self.get_logger().error(f"UDP send error: {e}")


def main(args=None):
    rclpy.init(args=args)
    node = HumanDataTX()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        try:
            node.sock.close()
        except Exception:
            pass
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
